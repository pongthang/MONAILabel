(self["webpackChunk"] = self["webpackChunk"] || []).push([[420],{

/***/ 93952:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const CORNERSTONE_COLOR_LUT = [
    [0, 0, 0, 0],
    [221, 84, 84, 255],
    [77, 228, 121, 255],
    [166, 70, 235, 255],
    [189, 180, 116, 255],
    [109, 182, 196, 255],
    [204, 101, 157, 255],
    [123, 211, 94, 255],
    [93, 87, 218, 255],
    [225, 128, 80, 255],
    [73, 232, 172, 255],
    [181, 119, 186, 255],
    [176, 193, 112, 255],
    [105, 153, 200, 255],
    [208, 97, 120, 255],
    [90, 215, 101, 255],
    [135, 83, 222, 255],
    [229, 178, 76, 255],
    [122, 183, 181, 255],
    [190, 115, 171, 255],
    [149, 197, 108, 255],
    [100, 118, 205, 255],
    [212, 108, 93, 255],
    [86, 219, 141, 255],
    [183, 79, 226, 255],
    [233, 233, 72, 255],
    [118, 167, 187, 255],
    [194, 111, 146, 255],
    [116, 201, 104, 255],
    [115, 96, 209, 255],
    [216, 147, 89, 255],
    [82, 223, 188, 255],
    [230, 75, 224, 255],
    [163, 184, 121, 255],
    [114, 143, 191, 255],
    [198, 107, 114, 255],
    [99, 206, 122, 255],
    [153, 92, 213, 255],
    [220, 192, 85, 255],
    [78, 215, 227, 255],
    [234, 71, 173, 255],
    [141, 188, 117, 255],
    [110, 113, 195, 255],
    [202, 128, 103, 255],
    [95, 210, 157, 255],
    [195, 88, 217, 255],
    [206, 224, 81, 255],
    [74, 166, 231, 255],
    [185, 120, 139, 255],
    [113, 192, 113, 255],
    [133, 106, 199, 255],
    [207, 162, 98, 255],
    [91, 214, 198, 255],
    [221, 84, 198, 255],
    [159, 228, 77, 255],
    [70, 111, 235, 255],
    [189, 119, 116, 255],
    [109, 196, 138, 255],
    [165, 101, 204, 255],
    [211, 201, 94, 255],
    [87, 191, 218, 255],
    [225, 80, 153, 255],
    [106, 232, 73, 255],
    [124, 119, 186, 255],
    [193, 142, 112, 255],
    [105, 200, 168, 255],
    [203, 97, 208, 255],
    [184, 215, 90, 255],
    [83, 147, 222, 255],
    [229, 76, 101, 255],
    [122, 183, 130, 255],
    [146, 115, 190, 255],
    [197, 171, 108, 255],
    [100, 205, 205, 255],
    [212, 93, 177, 255],
    [141, 219, 86, 255],
    [79, 97, 226, 255],
    [233, 99, 72, 255],
    [118, 187, 150, 255],
    [173, 111, 194, 255],
    [197, 201, 104, 255],
    [96, 171, 209, 255],
    [216, 89, 137, 255],
    [94, 223, 82, 255],
    [107, 75, 230, 255],
    [184, 153, 121, 255],
    [114, 191, 175, 255],
    [198, 107, 191, 255],
    [166, 206, 99, 255],
    [92, 132, 213, 255],
    [220, 85, 91, 255],
    [78, 227, 115, 255],
    [159, 71, 234, 255],
    [188, 176, 117, 255],
    [110, 185, 195, 255],
    [202, 103, 161, 255],
    [129, 210, 95, 255],
    [88, 88, 217, 255],
    [224, 123, 81, 255],
    [74, 231, 166, 255],
    [177, 120, 185, 255],
    [179, 192, 113, 255],
    [106, 156, 199, 255],
    [207, 98, 125, 255],
    [91, 214, 96, 255],
    [130, 84, 221, 255],
    [228, 171, 77, 255],
    [70, 235, 221, 255],
    [189, 116, 174, 255],
    [153, 196, 109, 255],
    [101, 123, 204, 255],
    [211, 104, 94, 255],
    [87, 218, 136, 255],
    [177, 80, 225, 255],
    [232, 225, 73, 255],
    [119, 169, 186, 255],
    [193, 112, 149, 255],
    [121, 200, 105, 255],
    [111, 97, 208, 255],
    [215, 142, 90, 255],
    [83, 222, 181, 255],
    [229, 76, 229, 255],
    [165, 183, 122, 255],
    [115, 146, 190, 255],
    [197, 108, 119, 255],
    [100, 205, 118, 255],
    [148, 93, 212, 255],
    [219, 186, 86, 255],
    [79, 220, 226, 255],
    [233, 72, 179, 255],
    [144, 187, 118, 255],
    [111, 118, 194, 255],
    [201, 124, 104, 255],
    [96, 209, 153, 255],
    [189, 89, 216, 255],
    [211, 223, 82, 255],
    [75, 172, 230, 255],
    [184, 121, 142, 255],
    [117, 191, 114, 255],
    [130, 107, 198, 255],
    [206, 157, 99, 255],
    [92, 213, 193, 255],
    [220, 85, 203, 255],
    [165, 227, 78, 255],
    [71, 118, 234, 255],
    [188, 117, 117, 255],
    [110, 195, 135, 255],
    [161, 103, 202, 255],
    [210, 195, 95, 255],
    [88, 195, 217, 255],
    [224, 81, 158, 255],
    [113, 231, 74, 255],
    [123, 120, 185, 255],
    [192, 139, 113, 255],
    [106, 199, 164, 255],
    [198, 98, 207, 255],
    [188, 214, 91, 255],
    [84, 153, 221, 255],
    [228, 77, 108, 255],
    [70, 235, 84, 255],
    [143, 116, 189, 255],
    [196, 167, 109, 255],
    [101, 204, 199, 255],
    [211, 94, 182, 255],
    [147, 218, 87, 255],
    [80, 104, 225, 255],
    [232, 93, 73, 255],
    [119, 186, 147, 255],
    [170, 112, 193, 255],
    [200, 200, 105, 255],
    [97, 175, 208, 255],
    [215, 90, 142, 255],
    [100, 222, 83, 255],
    [101, 76, 229, 255],
    [183, 150, 122, 255],
    [115, 190, 171, 255],
    [197, 108, 194, 255],
    [170, 205, 100, 255],
    [93, 138, 212, 255],
    [219, 86, 97, 255],
    [79, 226, 110, 255],
    [153, 72, 233, 255],
    [187, 173, 118, 255],
    [111, 187, 194, 255],
    [201, 104, 165, 255],
    [134, 209, 96, 255],
    [89, 95, 216, 255],
    [223, 117, 82, 255],
    [75, 230, 159, 255],
    [174, 121, 184, 255],
    [182, 191, 114, 255],
    [107, 160, 198, 255],
    [206, 99, 130, 255],
    [92, 213, 92, 255],
    [124, 85, 220, 255],
    [227, 165, 78, 255],
    [71, 234, 214, 255],
    [188, 117, 176, 255],
    [156, 195, 110, 255],
    [103, 128, 202, 255],
    [210, 100, 95, 255],
    [88, 217, 131, 255],
    [170, 81, 224, 255],
    [231, 218, 74, 255],
    [120, 172, 185, 255],
    [192, 113, 153, 255],
    [125, 199, 106, 255],
    [107, 98, 207, 255],
    [214, 137, 91, 255],
    [84, 221, 175, 255],
    [222, 77, 228, 255],
    [194, 235, 70, 255],
    [116, 149, 189, 255],
    [196, 109, 123, 255],
    [101, 204, 114, 255],
    [143, 94, 211, 255],
    [218, 180, 87, 255],
    [80, 225, 225, 255],
    [232, 73, 186, 255],
    [147, 186, 119, 255],
    [112, 122, 193, 255],
    [200, 121, 105, 255],
    [97, 208, 148, 255],
    [184, 90, 215, 255],
    [216, 222, 83, 255],
    [76, 178, 229, 255],
    [183, 122, 145, 255],
    [121, 190, 115, 255],
    [126, 108, 197, 255],
    [205, 153, 100, 255],
    [93, 212, 187, 255],
    [219, 86, 208, 255],
    [171, 226, 79, 255],
    [72, 126, 233, 255],
    [187, 118, 121, 255],
    [111, 194, 132, 255],
    [157, 104, 201, 255],
    [209, 190, 96, 255],
    [89, 200, 216, 255],
    [223, 82, 164, 255],
    [120, 230, 75, 255],
    [121, 121, 184, 255],
    [191, 136, 114, 255],
    [107, 198, 160, 255],
    [192, 99, 206, 255],
    [193, 213, 92, 255],
    [85, 158, 220, 255],
    [227, 78, 115, 255],
    [71, 234, 78, 255],
    [141, 117, 188, 255],
    [195, 163, 110, 255],
    [103, 202, 194, 255],
    [210, 95, 186, 255],
    [153, 217, 88, 255],
    [81, 111, 224, 255],
];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CORNERSTONE_COLOR_LUT);


/***/ }),

/***/ 94430:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ MouseCursor),
/* harmony export */   i: () => (/* binding */ standardCursorNames)
/* harmony export */ });
const DEFINED_CURSORS = Symbol('DefinedCursors');
const STANDARD_CURSORS = new Set([
    'alias',
    'all-scroll',
    'auto',
    'cell',
    'col-resize',
    'context-menu',
    'copy',
    'crosshair',
    'default',
    'e-resize',
    'ew-resize',
    'grab',
    'grabbing',
    'help',
    'move',
    'ne-resize',
    'nesw-resize',
    'no-drop',
    'none',
    'not-allowed',
    'n-resize',
    'ns-resize',
    'nw-resize',
    'nwse-resize',
    'pointer',
    'progress',
    'row-resize',
    'se-resize',
    's-resize',
    'sw-resize',
    'text',
    'vertical-text',
    'wait',
    'w-resize',
    'zoom-in',
    'zoom-out',
]);
class MouseCursor {
    constructor(name, fallback) {
        this.name = name + '';
        this.fallback = fallback;
    }
    getName() {
        return this.name + '';
    }
    addFallbackStyleProperty(style) {
        const { fallback } = this;
        if (fallback instanceof MouseCursor) {
            return `${style}, ${fallback.getStyleProperty()}`;
        }
        return style + '';
    }
    getStyleProperty() {
        return this.addFallbackStyleProperty(this.name) + '';
    }
    static getDefinedCursor(name) {
        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
        let mouseCursor = definedCursors.get(name);
        if (mouseCursor instanceof MouseCursor) {
            return mouseCursor;
        }
        if (STANDARD_CURSORS.has(name)) {
            mouseCursor = new MouseCursor(name);
            definedCursors.set(name, mouseCursor);
            return mouseCursor;
        }
    }
    static setDefinedCursor(name, cursor) {
        if (cursor instanceof MouseCursor) {
            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
            definedCursors.set(name, cursor);
            return true;
        }
        return false;
    }
}
function getDefinedCursors(context, symbol) {
    let definedCursors = context[symbol];
    if (!(definedCursors instanceof Map)) {
        definedCursors = new Map();
        Object.defineProperty(context, symbol, { value: definedCursors });
    }
    return definedCursors;
}
const standardCursorNames = STANDARD_CURSORS.values();



/***/ }),

/***/ 7001:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hideElementCursor: () => (/* binding */ hideElementCursor),
/* harmony export */   initElementCursor: () => (/* binding */ initElementCursor),
/* harmony export */   resetElementCursor: () => (/* binding */ resetElementCursor),
/* harmony export */   setElementCursor: () => (/* binding */ _setElementCursor)
/* harmony export */ });
/* harmony import */ var _MouseCursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94430);

const ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');
function initElementCursor(element, cursor) {
    _getElementCursors(element)[0] = cursor;
    _setElementCursor(element, cursor);
}
function _setElementCursor(element, cursor) {
    const cursors = _getElementCursors(element);
    cursors[1] = cursors[0];
    cursors[0] = cursor;
    element.style.cursor = (cursor instanceof _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
        ? cursor
        : _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getDefinedCursor('auto')).getStyleProperty();
}
function resetElementCursor(element) {
    _setElementCursor(element, _getElementCursors(element)[1]);
}
function hideElementCursor(element) {
    _setElementCursor(element, _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getDefinedCursor('none'));
}
function _getElementCursors(element) {
    let map = _getElementCursors[ELEMENT_CURSORS_MAP];
    if (!(map instanceof WeakMap)) {
        map = new WeakMap();
        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {
            value: map,
        });
    }
    let cursors = map.get(element);
    if (!cursors) {
        cursors = [null, null];
        map.set(element, cursors);
    }
    return cursors;
}



/***/ }),

/***/ 79475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  CursorNames: () => (/* binding */ CursorNames),
  CursorSVG: () => (/* reexport */ CursorSVG),
  ImageMouseCursor: () => (/* reexport */ ImageMouseCursor),
  MouseCursor: () => (/* reexport */ MouseCursor/* default */.A),
  SVGMouseCursor: () => (/* reexport */ SVGMouseCursor),
  elementCursor: () => (/* reexport */ elementCursor),
  registerCursor: () => (/* reexport */ registerCursor),
  setCursorForElement: () => (/* reexport */ cursors_setCursorForElement)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js
var MouseCursor = __webpack_require__(94430);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js


const DEFAULT_NAME = 'image-cursor';
class ImageMouseCursor extends MouseCursor/* default */.A {
    constructor(url, x, y, name, fallback) {
        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);
        this.url = url;
        this.x = Number(x) || 0;
        this.y = Number(y) || 0;
    }
    getStyleProperty() {
        const { url, x, y } = this;
        let style = `url('${url}')`;
        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {
            style += ` ${x} ${y}`;
        }
        return this.addFallbackStyleProperty(style);
    }
    static getUniqueInstanceName(prefix) {
        return `${prefix}-${esm.utilities.getRuntimeId(ImageMouseCursor)}`;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js
const BASE = {
    iconContent: '',
    iconSize: 16,
    viewBox: {
        x: 16,
        y: 16,
    },
    mousePoint: {
        x: 8,
        y: 8,
    },
    mousePointerGroupString: `
    <path stroke="{{color}}" d="M8 16L8 0"></path>
    <path stroke="{{color}}" d="M16 8L0 8"></path>
  `,
};
const SEGMENTATION_CURSOR_BOUNDARIES = {
    x: 127,
    y: 60,
};
const MINUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
`;
const PLUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
<rect fill="{{color}}" x="95.84" y="9.38" width="15.85" height="47.14"/>
`;
const SCISSOR_ICON = `<path fill="{{color}}" d="M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z" transform="translate(-1.17 -0.96)"/>`;
const RECTANGLE_ICON = `<path fill="{{color}}" d="M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z" transform="translate(-8.86 -2.25)"/>`;
const CIRCLE_ICON = `<path fill="{{color}}" d="M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z" transform="translate(-8.86 -2.25)"/>`;
const CursorSVG = {
    Angle: extend(BASE, {
        name: 'Angle',
        iconContent: `<path fill="{{color}}" d="M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50
    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23
    10l50 50q10 10 10 23z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    ArrowAnnotate: extend(BASE, {
        name: 'ArrowAnnotate',
        iconContent: `<g id="arrowAnnotate-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="arrowAnnotate-arrow" d="M23,7 l-15,15 M7,17 l0,6 6,0" stroke-width="2" />
  </g>`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Bidirectional: extend(BASE, {
        name: 'Bidirectional',
        iconContent: `<g fill="{{color}}" stroke-width="3" stroke="{{color}}">
    <path d="M27.63 3.21L3.12 28.81"></path>
    <path d="M27.63 15.75L15.27 4.43"></path>
    <path d="M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z" ></path>
    <path d="M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z"></path>
    <path d="M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z"></path>
    <path d="M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z"></path>
  </g>`,
        viewBox: {
            x: 48,
            y: 48,
        },
    }),
    CobbAngle: extend(BASE, {
        name: 'CobbAngle',
        iconContent: `<g stroke="{{color}}" stroke-width="3">
    <path d="M28.59 2.34L3.82 12.32"></path>
    <path d="M28.59 29.66L3.82 19.68"></path>
    <path stroke-dasharray="2" fill-opacity="0" d="M12.37
      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15
      9.33C13.11 9.24 13.02 9 12.88 8.63">
    </path>
  </g>`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    CircleROI: extend(BASE, {
        name: 'CircleROI',
        iconContent: `<circle stroke="{{color}}" fill="none" stroke-width="3" cx="16" cy="16" r="14" />`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    EllipticalROI: extend(BASE, {
        name: 'EllipticalROI',
        iconContent: `<path stroke="{{color}}" fill="none" stroke-width="3" d="M30.74 15.76C30.74 20.99 24.14 25.23 16
    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14
    6.3 30.74 10.54 30.74 15.76Z" />`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    FreehandROI: extend(BASE, {
        name: 'FreehandROI',
        iconContent: `<g fill="{{color}}" stroke="{{color}}" stroke-width="2">
    <ellipse ry="1" rx="1" id="svg_3" cy="4.240343" cx="14.306499"/>
    <line id="svg_4" y2="3.58462" x2="12.242186" y1="3.997482" x1="13.432202"/>
    <line id="svg_5" y2="3.268901" x2="10.857882" y1="3.608906" x1="12.387902"/>
    <line id="svg_6" y2="3.147471" x2="9.740724" y1="3.293187" x1="10.955026"/>
    <line id="svg_7" y2="3.147471" x2="8.089274" y1="3.196043" x1="9.983585"/>
    <line id="svg_8" y2="3.268901" x2="6.874972" y1="3.123185" x1="8.307848"/>
    <line id="svg_9" y2="3.657478" x2="5.587812" y1="3.220329" x1="7.020688"/>
    <line id="svg_10" y2="4.046054" x2="4.737801" y1="3.560334" x1="5.854959"/>
    <line id="svg_11" y2="4.337487" x2="4.300652" y1="3.997482" x1="4.834945"/>
    <line id="svg_12" y2="4.726063" x2="3.88779" y1="4.191771" x1="4.470655"/>
    <line id="svg_15" y2="5.3575" x2="3.377783" y1="4.604633" x1="3.960648"/>
    <line id="svg_16" y2="6.183226" x2="2.916348" y1="5.138926" x1="3.547785"/>
    <line id="svg_17" y2="6.960379" x2="2.770632" y1="5.867507" x1="3.037779"/>
    <line id="svg_18" y2="7.713246" x2="2.673488" y1="6.741804" x1="2.819204"/>
    <line id="svg_19" y2="8.684687" x2="2.697774" y1="7.616102" x1="2.673488"/>
    <line id="svg_20" y2="9.753273" x2="2.892062" y1="8.611829" x1="2.697774"/>
    <line id="svg_21" y2="10.724714" x2="3.134923" y1="9.534698" x1="2.84349"/>
    <line id="svg_23" y2="11.647583" x2="3.596357" y1="10.578998" x1="3.086351"/>
    <line id="svg_25" y2="12.521881" x2="4.276366" y1="11.501867" x1="3.499213"/>
    <line id="svg_26" y2="13.930471" x2="5.830673" y1="12.376165" x1="4.13065"/>
    <line id="svg_28" y2="14.707624" x2="7.263549" y1="13.881899" x1="5.733528"/>
    <line id="svg_29" y2="15.339061" x2="8.963571" y1="14.61048" x1="7.06926"/>
    <line id="svg_30" y2="15.581921" x2="10.882168" y1="15.314775" x1="8.817855"/>
    <line id="svg_31" y2="15.460491" x2="12.023612" y1="15.581921" x1="10.785024"/>
    <line id="svg_33" y2="15.120487" x2="13.092197" y1="15.484777" x1="11.877895"/>
    <line id="svg_34" y2="14.586194" x2="13.86935" y1="15.217631" x1="12.897909"/>
    <line id="svg_35" y2="13.833327" x2="14.597931" y1="14.756196" x1="13.699348"/>
    <line id="svg_37" y2="12.716169" x2="15.180796" y1="13.881899" x1="14.549359"/>
    <line id="svg_39" y2="11.429009" x2="15.520801" y1="12.813313" x1="15.15651"/>
    <ellipse ry="1" rx="1" id="svg_40" cy="10.967574" cx="15.520801"/>
  </g>`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    FreehandROISculptor: extend(BASE, {
        name: 'FreehandROISculptor',
        iconContent: `<g id="icon-freehand-sculpt" fill="none" stroke-width="1.5" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <line id="svg_1" y2="2.559367" x2="10.184807" y1="4.467781" x1="8.81711"/>
    <line id="svg_4" y2="1.493836" x2="11.727442" y1="2.766112" x1="10.089386"/>
    <line id="svg_7" y2="1.080346" x2="13.047428" y1="1.748291" x1="11.345759"/>
    <line id="svg_8" y2="1.000829" x2="14.351511" y1="1.112153" x1="12.77707"/>
    <line id="svg_9" y2="1.350705" x2="15.242104" y1="0.905408" x1="13.969828"/>
    <line id="svg_10" y2="2.098167" x2="15.862339" y1="1.14396" x1="14.955842"/>
    <line id="svg_11" y2="3.195505" x2="16.41896" y1="1.939133" x1="15.766918"/>
    <line id="svg_12" y2="4.292843" x2="16.530284" y1="2.925147" x1="16.387153"/>
    <line id="svg_16" y2="5.644637" x2="16.196311" y1="3.831643" x1="16.593898"/>
    <line id="svg_18" y2="7.266789" x2="15.623787" y1="5.19934" x1="16.275829"/>
    <line id="svg_19" y2="10.813258" x2="14.526449" y1="6.726071" x1="15.766918"/>
    <line id="svg_20" y2="5.056209" x2="8.085552" y1="4.181519" x1="8.976145"/>
    <line id="svg_23" y2="5.326568" x2="7.481221" y1="4.78585" x1="8.403621"/>
    <line id="svg_24" y2="5.565119" x2="6.749662" y1="5.294761" x1="7.624352"/>
    <line id="svg_25" y2="5.994512" x2="5.429675" y1="5.533312" x1="6.956407"/>
    <line id="svg_27" y2="6.551133" x2="4.284627" y1="5.962706" x1="5.572807"/>
    <line id="svg_28" y2="7.584858" x2="3.044158" y1="6.392099" x1="4.427758"/>
    <line id="svg_29" y2="8.84123" x2="2.185372" y1="7.489437" x1="3.219096"/>
    <line id="svg_31" y2="10.606513" x2="1.644654" y1="8.602678" x1="2.280792"/>
    <line id="svg_32" y2="13.214679" x2="1.48562" y1="10.352058" x1="1.724171"/>
    <line id="svg_33" y2="14.375631" x2="1.676461" y1="12.992031" x1="1.453813"/>
    <line id="svg_34" y2="15.298031" x2="2.264889" y1="14.152983" x1="1.517427"/>
    <line id="svg_35" y2="16.172721" x2="3.521261" y1="14.948155" x1="1.915013"/>
    <line id="svg_36" y2="16.824762" x2="5.207027" y1="15.997783" x1="3.28271"/>
    <line id="svg_38" y2="17.063314" x2="7.035924" y1="16.745245" x1="4.968475"/>
    <line id="svg_39" y2="16.888376" x2="9.278311" y1="17.047411" x1="6.733758"/>
    <line id="svg_40" y2="16.284045" x2="10.661911" y1="16.983797" x1="8.992048"/>
    <line id="svg_41" y2="15.313934" x2="11.647925" y1="16.395369" x1="10.455166"/>
    <line id="svg_44" y2="13.898527" x2="12.82478" y1="15.425259" x1="11.504794"/>
    <line id="svg_45" y2="12.037824" x2="14.144766" y1="14.312017" x1="12.522614"/>
    <line id="svg_47" y2="10.59061" x2="14.605966" y1="12.228665" x1="13.953925"/>
    <ellipse ry="1" rx="1" id="svg_48" cy="3.982726" cx="13.460918"/>
  </g>`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    Length: extend(BASE, {
        name: 'Length',
        iconContent: `<g id="length-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="length-dashes" d="m22.5,6 -16.5,16.5" stroke-width="3" stroke-dasharray="0.6666,5" />
  </g>`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Height: extend(BASE, {
        name: 'Height',
        iconContent: `<path d="m 6 22 l 8.5 0 v -16 h 8" stroke-width="3" fill="none" stroke="{{color}}" />`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Probe: extend(BASE, {
        name: 'Probe',
        iconContent: `<path fill="{{color}}" d="M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75
    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73
    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5
    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5
    385.5-103 385.5 103 279.5 279.5 103 385.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    RectangleROI: extend(BASE, {
        name: 'RectangleROI',
        iconContent: `<path fill="{{color}}" d="M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47
    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0
    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119
    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    TextMarker: extend(BASE, {
        name: 'TextMarker',
        iconContent: `<path fill="{{color}}" d="M789 559l-170 450q33 0 136.5 2t160.5 2q19 0
    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29
    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15
    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5
    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0
    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11
    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0
    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58
    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Crosshairs: extend(BASE, {
        name: 'Crosshairs',
        iconContent: `<path fill="{{color}}" d="M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26
    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45
    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26
    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5
    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32
    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5
    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26
    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26
    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161
    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161
    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Eraser: extend(BASE, {
        name: 'Eraser',
        iconContent: `<path transform="translate(0,1792) scale(1,-1)" fill="{{color}}" d="M960 1408l336-384h-768l-336 384h768zm1013-1077q15
    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38
    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38
    0 69.5 20.5t47.5 54.5z" />`,
        viewBox: {
            x: 2048,
            y: 1792,
        },
    }),
    Magnify: extend(BASE, {
        name: 'Magnify',
        iconContent: `<path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />`,
        viewBox: {
            x: 512,
            y: 512,
        },
    }),
    Pan: extend(BASE, {
        name: 'Pan',
        iconContent: `<path fill="{{color}}" d="M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17
    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355
    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59
    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12
    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144
    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19
    45v448q0 42-39 59-13 5-25 5-26 0-45-19z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Rotate: extend(BASE, {
        name: 'Rotate',
        iconContent: `<path fill="{{color}}" d="M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39
    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5
    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0
    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109
    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298
    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14
    39 17 39 59z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    StackScroll: extend(BASE, {
        name: 'StackScroll',
        iconContent: `<path fill="{{color}}" d="M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0
    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547
    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z" />`,
        viewBox: {
            x: 24,
            y: 28,
        },
    }),
    WindowLevelRegion: extend(BASE, {
        name: 'WindowLevelRegion',
        iconContent: `<path fill="{{color}}" d="M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119
    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5
    84.5t84.5 203.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    WindowLevel: extend(BASE, {
        name: 'WindowLevel',
        iconContent: `
    <path fill="{{color}}" d="M14.5,3.5 a1 1 0 0 1 -11,11 Z" stroke="none" opacity="0.8" />
    <circle cx="9" cy="9" r="8" fill="none" stroke-width="2" stroke="{{color}}" />`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    Zoom: extend(BASE, {
        name: 'Zoom',
        iconContent: `
  <path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />
  <path fill="{{color}}" transform="scale(0.22,0.22) translate(1400,0)" d="M1216
    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19
    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26
    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z" />`,
        viewBox: {
            x: 640,
            y: 512,
        },
    }),
    SegmentationFreeHandEraseInside: extend(BASE, {
        name: 'SegmentationFreeHandEraseInside',
        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandFillInside: extend(BASE, {
        name: 'SegmentationFreeHandFillInside',
        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandEraseOutside: extend(BASE, {
        name: 'SegmentationFreeHandEraseOutside',
        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandFillOutside: extend(BASE, {
        name: 'SegmentationFreeHandFillOutside',
        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationRectangleEraseInside: extend(BASE, {
        name: 'SegmentationRectangleEraseInside',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    RectangleScissor: extend(BASE, {
        name: 'RectangleScissor',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.FILL_INSIDE': extend(BASE, {
        name: 'RectangleScissor.FILL_INSIDE',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {
        name: 'RectangleScissor.FILL_OUTSIDE',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {
        name: 'RectangleScissor.ERASE_OUTSIDE',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.ERASE_INSIDE': extend(BASE, {
        name: 'RectangleScissor.ERASE_INSIDE',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    CircleScissor: extend(BASE, {
        name: 'CircleScissor',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.FILL_INSIDE': extend(BASE, {
        name: 'CircleScissor.FILL_INSIDE',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {
        name: 'CircleScissor.ERASE_OUTSIDE',
        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.FILL_OUTSIDE': extend(BASE, {
        name: 'CircleScissor.FILL_OUTSIDE',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
};
function extend(base, values) {
    return Object.assign(Object.create(base), {
        ...values,
        name: values.name || base.name,
    });
}
function registerCursor(toolName, iconContent, viewBox) {
    CursorSVG[toolName] = extend(BASE, {
        iconContent,
        viewBox,
    });
}
function getDefinedSVGCursorDescriptor(name) {
    return CursorSVG[name];
}
const svgCursorNames = Object.keys(CursorSVG);


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
var helpers = __webpack_require__(76712);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js




const PROPERTY = 'color';
const STATE = enums.AnnotationStyleStates.Highlighted;
const MODE = enums.ToolModes.Active;
class SVGMouseCursor extends ImageMouseCursor {
    constructor(url, x, y, name, fallback) {
        super(url, x, y, name, fallback);
    }
    static getDefinedCursor(name, pointer = false, color) {
        if (!color) {
            color = (0,helpers/* getStyleProperty */.h)(PROPERTY, {}, STATE, MODE);
        }
        const urn = getCursorURN(name, pointer, color);
        let cursor = super.getDefinedCursor(urn);
        if (!cursor) {
            const descriptor = getDefinedSVGCursorDescriptor(name);
            if (descriptor) {
                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, super.getDefinedCursor('default'));
                super.setDefinedCursor(urn, cursor);
            }
        }
        return cursor;
    }
}
function format(template, dictionary) {
    const dict = Object(dictionary);
    const defined = Object.prototype.hasOwnProperty.bind(dict);
    return (template + '').replace(/\{\{(\w+)\}\}/g, (match, key) => {
        return defined(key) ? dict[key] + '' : '';
    });
}
function getCursorURN(name, pointer, color) {
    const type = pointer ? 'pointer' : 'cursor';
    return `${type}:${name}/${color}`;
}
function createSVGMouseCursor(descriptor, name, pointer, color, fallback) {
    const { x, y } = descriptor.mousePoint;
    return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color }), x, y, name, fallback);
}
function createSVGIconUrl(descriptor, pointer, options) {
    const blob = createSVGIconBlob(descriptor, pointer, options);
    const url = URL.createObjectURL(blob);
    const urn = `${url}#${descriptor.name || 'unknown'}-${pointer ? 'pointer' : 'cursor'}`;
    return urn;
}
function createSVGIconBlob(descriptor, pointer, options) {
    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);
    return new Blob([svgString], { type: 'image/svg+xml' });
}
function createSVGIcon(descriptor, options) {
    const { iconContent, iconSize, viewBox } = descriptor;
    const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${iconSize}" height="${iconSize}" viewBox="0 0
      ${viewBox.x} ${viewBox.y}">
      ${iconContent}
    </svg>`;
    return format(svgString, options);
}
function createSVGIconWithPointer(descriptor, options) {
    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;
    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);
    const svgSize = 16 + iconSize;
    const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">
      <g>${mousePointerGroupString}</g>
      <g transform="translate(16, 16) scale(${scale})">${iconContent}</g>
    </svg>`;
    return format(svgString, options);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor = __webpack_require__(7001);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js



function setCursorForElement(element, cursorName) {
    let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
    if (!cursor) {
        cursor = MouseCursor/* default */.A.getDefinedCursor(cursorName);
    }
    if (!cursor) {
        console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);
        cursor = MouseCursor/* default */.A.getDefinedCursor(cursorName);
    }
    (0,elementCursor.setElementCursor)(element, cursor);
}
/* harmony default export */ const cursors_setCursorForElement = (setCursorForElement);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js






const CursorNames = [...svgCursorNames, ...MouseCursor/* standardCursorNames */.i];



/***/ }),

/***/ 89578:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  draw: () => (/* reexport */ drawingSvg_draw),
  drawArrow: () => (/* reexport */ drawArrow),
  drawCircle: () => (/* reexport */ drawingSvg_drawCircle),
  drawEllipse: () => (/* reexport */ drawingSvg_drawEllipse),
  drawEllipseByCoordinates: () => (/* reexport */ drawingSvg_drawEllipseByCoordinates),
  drawHandle: () => (/* reexport */ drawingSvg_drawHandle),
  drawHandles: () => (/* reexport */ drawingSvg_drawHandles),
  drawHeight: () => (/* reexport */ drawHeight),
  drawLine: () => (/* reexport */ drawLine),
  drawLinkedTextBox: () => (/* reexport */ drawingSvg_drawLinkedTextBox),
  drawPath: () => (/* reexport */ drawPath),
  drawPolyline: () => (/* reexport */ drawPolyline),
  drawRect: () => (/* reexport */ drawRect),
  drawRectByCoordinates: () => (/* reexport */ drawRectByCoordinates),
  drawRedactionRect: () => (/* reexport */ drawRedactionRect),
  drawTextBox: () => (/* reexport */ drawingSvg_drawTextBox),
  setAttributesIfNecessary: () => (/* reexport */ drawingSvg_setAttributesIfNecessary),
  setNewAttributesIfValid: () => (/* reexport */ drawingSvg_setNewAttributesIfValid)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js
var state = __webpack_require__(85204);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js


const VIEWPORT_ELEMENT = 'viewport-element';
function getSvgDrawingHelper(element) {
    const enabledElement = (0,esm.getEnabledElement)(element);
    const { viewportId, renderingEngineId } = enabledElement;
    const canvasHash = `${viewportId}:${renderingEngineId}`;
    const svgLayerElement = _getSvgLayer(element);
    Object.keys(state/* state */.wk.svgNodeCache[canvasHash]).forEach((cacheKey) => {
        state/* state */.wk.svgNodeCache[canvasHash][cacheKey].touched = false;
    });
    return {
        svgLayerElement: svgLayerElement,
        svgNodeCacheForCanvas: state/* state */.wk.svgNodeCache,
        getSvgNode: getSvgNode.bind(this, canvasHash),
        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),
        setNodeTouched: setNodeTouched.bind(this, canvasHash),
        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),
    };
}
function _getSvgLayer(element) {
    const viewportElement = `.${VIEWPORT_ELEMENT}`;
    const internalDivElement = element.querySelector(viewportElement);
    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');
    return svgLayer;
}
function getSvgNode(canvasHash, cacheKey) {
    if (!state/* state */.wk.svgNodeCache[canvasHash]) {
        return;
    }
    if (state/* state */.wk.svgNodeCache[canvasHash][cacheKey]) {
        return state/* state */.wk.svgNodeCache[canvasHash][cacheKey].domRef;
    }
}
function appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {
    if (!state/* state */.wk.svgNodeCache[canvasHash]) {
        return null;
    }
    state/* state */.wk.svgNodeCache[canvasHash][cacheKey] = {
        touched: true,
        domRef: svgNode,
    };
    svgLayerElement.appendChild(svgNode);
}
function setNodeTouched(canvasHash, cacheKey) {
    if (!state/* state */.wk.svgNodeCache[canvasHash]) {
        return;
    }
    if (state/* state */.wk.svgNodeCache[canvasHash][cacheKey]) {
        state/* state */.wk.svgNodeCache[canvasHash][cacheKey].touched = true;
    }
}
function clearUntouched(svgLayerElement, canvasHash) {
    if (!state/* state */.wk.svgNodeCache[canvasHash]) {
        return;
    }
    Object.keys(state/* state */.wk.svgNodeCache[canvasHash]).forEach((cacheKey) => {
        const cacheEntry = state/* state */.wk.svgNodeCache[canvasHash][cacheKey];
        if (!cacheEntry.touched && cacheEntry.domRef) {
            svgLayerElement.removeChild(cacheEntry.domRef);
            delete state/* state */.wk.svgNodeCache[canvasHash][cacheKey];
        }
    });
}
/* harmony default export */ const drawingSvg_getSvgDrawingHelper = (getSvgDrawingHelper);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js

function draw(element, fn) {
    const svgDrawingHelper = drawingSvg_getSvgDrawingHelper(element);
    fn(svgDrawingHelper);
    svgDrawingHelper.clearUntouched();
}
/* harmony default export */ const drawingSvg_draw = (draw);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js
var _getHash = __webpack_require__(97181);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js
function setAttributesIfNecessary(attributes, svgNode) {
    Object.keys(attributes).forEach((key) => {
        const currentValue = svgNode.getAttribute(key);
        const newValue = attributes[key];
        if (newValue === undefined || newValue === '') {
            svgNode.removeAttribute(key);
        }
        else if (currentValue !== newValue) {
            svgNode.setAttribute(key, newValue);
        }
    });
}
/* harmony default export */ const drawingSvg_setAttributesIfNecessary = (setAttributesIfNecessary);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js
function setNewAttributesIfValid(attributes, svgNode) {
    Object.keys(attributes).forEach((key) => {
        const newValue = attributes[key];
        if (newValue !== undefined && newValue !== '') {
            svgNode.setAttribute(key, newValue);
        }
    });
}
/* harmony default export */ const drawingSvg_setNewAttributesIfValid = (setNewAttributesIfValid);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js



function drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {
    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        fill: 'transparent',
        width: '2',
        lineDash: undefined,
        lineWidth: undefined,
        strokeOpacity: 1,
        fillOpacity: 1,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'circle', circleUID);
    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    const attributes = {
        cx: `${center[0]}`,
        cy: `${center[1]}`,
        r: `${radius}`,
        stroke: color,
        fill,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'fill-opacity': fillOpacity,
        'stroke-opacity': strokeOpacity,
    };
    if (existingCircleElement) {
        drawingSvg_setAttributesIfNecessary(attributes, existingCircleElement);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newCircleElement = document.createElementNS(svgns, 'circle');
        if (dataId !== '') {
            newCircleElement.setAttribute('data-id', dataId);
        }
        drawingSvg_setNewAttributesIfValid(attributes, newCircleElement);
        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);
    }
}
/* harmony default export */ const drawingSvg_drawCircle = (drawCircle);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js



function drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'ellipse', ellipseUID);
    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);
    const [bottom, top, left, right] = canvasCoordinates;
    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);
    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);
    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;
    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];
    const radiusX = w / 2;
    const radiusY = h / 2;
    const attributes = {
        cx: `${center[0]}`,
        cy: `${center[1]}`,
        rx: `${radiusX}`,
        ry: `${radiusY}`,
        stroke: color,
        fill: 'transparent',
        transform: `rotate(${angle} ${center[0]} ${center[1]})`,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingEllipse) {
        drawingSvg_setAttributesIfNecessary(attributes, existingEllipse);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');
        if (dataId !== '') {
            svgEllipseElement.setAttribute('data-id', dataId);
        }
        drawingSvg_setNewAttributesIfValid(attributes, svgEllipseElement);
        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);
    }
}
/* harmony default export */ const drawingSvg_drawEllipseByCoordinates = (drawEllipseByCoordinates);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js


function drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {
    const top = [(corner1[0] + corner2[0]) / 2, corner1[1]];
    const bottom = [(corner1[0] + corner2[0]) / 2, corner2[1]];
    const left = [corner1[0], (corner1[1] + corner2[1]) / 2];
    const right = [corner2[0], (corner1[1] + corner2[1]) / 2];
    drawingSvg_drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, [bottom, top, left, right], (options = {}), (dataId = ''));
}
/* harmony default export */ const drawingSvg_drawEllipse = (drawEllipse);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js



function drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {
    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({
        color: 'rgb(0, 255, 0)',
        handleRadius: '6',
        width: '2',
        lineWidth: undefined,
        fill: 'transparent',
        type: 'circle',
        opacity: 1,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'handle', `hg-${handleGroupUID}-index-${uniqueIndex}`);
    let attributes;
    if (type === 'circle') {
        attributes = {
            cx: `${handle[0]}`,
            cy: `${handle[1]}`,
            r: handleRadius,
            stroke: color,
            fill,
            'stroke-width': strokeWidth,
            opacity: opacity,
        };
    }
    else if (type === 'rect') {
        const handleRadiusFloat = parseFloat(handleRadius);
        const side = handleRadiusFloat * 1.5;
        const x = handle[0] - side * 0.5;
        const y = handle[1] - side * 0.5;
        attributes = {
            x: `${x}`,
            y: `${y}`,
            width: `${side}`,
            height: `${side}`,
            stroke: color,
            fill,
            'stroke-width': strokeWidth,
            rx: `${side * 0.1}`,
            opacity: opacity,
        };
    }
    else {
        throw new Error(`Unsupported handle type: ${type}`);
    }
    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingHandleElement) {
        drawingSvg_setAttributesIfNecessary(attributes, existingHandleElement);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newHandleElement = document.createElementNS(svgns, type);
        drawingSvg_setNewAttributesIfValid(attributes, newHandleElement);
        svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);
    }
}
/* harmony default export */ const drawingSvg_drawHandle = (drawHandle);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js

function drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {
    handlePoints.forEach((handle, i) => {
        drawingSvg_drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);
    });
}
/* harmony default export */ const drawingSvg_drawHandles = (drawHandles);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js



function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color, width, lineWidth, lineDash, shadow } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
        shadow: undefined,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'line', lineUID);
    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);
    const dropShadowStyle = shadow
        ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`
        : '';
    const attributes = {
        x1: `${start[0]}`,
        y1: `${start[1]}`,
        x2: `${end[0]}`,
        y2: `${end[1]}`,
        stroke: color,
        style: dropShadowStyle,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingLine) {
        drawingSvg_setAttributesIfNecessary(attributes, existingLine);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newLine = document.createElementNS(svgns, 'line');
        if (dataId !== '') {
            newLine.setAttribute('data-id', dataId);
        }
        drawingSvg_setNewAttributesIfValid(attributes, newLine);
        svgDrawingHelper.appendNode(newLine, svgNodeHash);
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js

function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const midX = end[0] + (start[0] - end[0]) / 2;
    const endfirstLine = [midX, start[1]];
    const endsecondLine = [midX, end[1]];
    const firstLine = {
        start: start,
        end: endfirstLine,
    };
    const secondLine = {
        start: endfirstLine,
        end: endsecondLine,
    };
    const threeLine = {
        start: endsecondLine,
        end: end,
    };
    drawLine(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {
        color,
        width,
        lineWidth,
    });
    drawLine(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {
        color,
        width,
        lineWidth,
    });
    drawLine(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {
        color,
        width,
        lineWidth,
    });
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js



function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {
    if (points.length < 2) {
        return;
    }
    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'polyline', polylineUID);
    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);
    let pointsAttribute = '';
    for (const point of points) {
        pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
    }
    if (closePath) {
        const firstPoint = points[0];
        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;
    }
    const attributes = {
        points: pointsAttribute,
        stroke: color,
        fill: fillColor,
        'fill-opacity': fillOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingPolyLine) {
        drawingSvg_setAttributesIfNecessary(attributes, existingPolyLine);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newPolyLine = document.createElementNS(svgns, 'polyline');
        drawingSvg_setNewAttributesIfValid(attributes, newPolyLine);
        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js



function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {
    const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);
    const pointsArrays = hasSubArrays ? points : [points];
    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'path', pathUID);
    const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);
    let pointsAttribute = '';
    for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {
        const points = pointsArrays[i];
        const numPoints = points.length;
        if (numPoints < 2) {
            continue;
        }
        for (let j = 0; j < numPoints; j++) {
            const point = points[j];
            const cmd = j ? 'L' : 'M';
            pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
        }
        if (closePath) {
            pointsAttribute += 'Z ';
        }
    }
    if (!pointsAttribute) {
        return;
    }
    const attributes = {
        d: pointsAttribute,
        stroke: color,
        fill: fillColor,
        'fill-opacity': fillOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingNode) {
        drawingSvg_setAttributesIfNecessary(attributes, existingNode);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newNode = document.createElementNS(svgns, 'path');
        drawingSvg_setNewAttributesIfValid(attributes, newNode);
        svgDrawingHelper.appendNode(newNode, svgNodeHash);
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js


function drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {
    const mergedOptions = Object.assign({
        fontFamily: 'Helvetica, Arial, sans-serif',
        fontSize: '14px',
        color: 'rgb(255, 255, 0)',
        background: '',
        padding: 25,
        centerX: false,
        centerY: true,
    }, options);
    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);
    return textGroupBoundingBox;
}
function _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {
    const { padding, color, fontFamily, fontSize, background } = options;
    let textGroupBoundingBox;
    const [x, y] = [position[0] + padding, position[1] + padding];
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'text', textUID);
    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingTextGroup) {
        const textElement = existingTextGroup.querySelector('text');
        const textSpans = Array.from(textElement.children);
        for (let i = 0; i < textSpans.length; i++) {
            const textSpanElement = textSpans[i];
            const text = textLines[i] || '';
            textSpanElement.textContent = text;
        }
        if (textLines.length > textSpans.length) {
            for (let i = 0; i < textLines.length - textSpans.length; i++) {
                const textLine = textLines[i + textSpans.length];
                const textSpan = _createTextSpan(textLine);
                textElement.appendChild(textSpan);
            }
            existingTextGroup.appendChild(textElement);
            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);
        }
        const textAttributes = {
            fill: color,
            'font-size': fontSize,
            'font-family': fontFamily,
        };
        const textGroupAttributes = {
            transform: `translate(${x} ${y})`,
        };
        drawingSvg_setAttributesIfNecessary(textAttributes, textElement);
        drawingSvg_setAttributesIfNecessary(textGroupAttributes, existingTextGroup);
        textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const textGroup = document.createElementNS(svgns, 'g');
        textGroup.setAttribute('transform', `translate(${x} ${y})`);
        const textElement = _createTextElement(svgDrawingHelper, options);
        for (let i = 0; i < textLines.length; i++) {
            const textLine = textLines[i];
            const textSpan = _createTextSpan(textLine);
            textElement.appendChild(textSpan);
        }
        textGroup.appendChild(textElement);
        svgDrawingHelper.appendNode(textGroup, svgNodeHash);
        textGroupBoundingBox = _drawTextBackground(textGroup, background);
    }
    return Object.assign({}, textGroupBoundingBox, {
        x,
        y,
        height: textGroupBoundingBox.height + padding,
        width: textGroupBoundingBox.width + padding,
    });
}
function _createTextElement(svgDrawingHelper, options) {
    const { color, fontFamily, fontSize } = options;
    const svgns = 'http://www.w3.org/2000/svg';
    const textElement = document.createElementNS(svgns, 'text');
    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';
    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;
    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;
    textElement.setAttribute('x', '0');
    textElement.setAttribute('y', '0');
    textElement.setAttribute('fill', color);
    textElement.setAttribute('font-family', fontFamily);
    textElement.setAttribute('font-size', fontSize);
    textElement.setAttribute('style', combinedStyle);
    return textElement;
}
function _createTextSpan(text) {
    const svgns = 'http://www.w3.org/2000/svg';
    const textSpanElement = document.createElementNS(svgns, 'tspan');
    textSpanElement.setAttribute('x', '0');
    textSpanElement.setAttribute('dy', '1.2em');
    textSpanElement.textContent = text;
    return textSpanElement;
}
function _drawTextBackground(group, color) {
    let element = group.querySelector('rect.background');
    if (!color) {
        if (element) {
            group.removeChild(element);
        }
        return group.getBBox();
    }
    if (!element) {
        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        element.setAttribute('class', 'background');
        group.insertBefore(element, group.firstChild);
    }
    const bBox = group.getBBox();
    const attributes = {
        x: `${bBox.x}`,
        y: `${bBox.y}`,
        width: `${bBox.width}`,
        height: `${bBox.height}`,
        fill: color,
    };
    drawingSvg_setAttributesIfNecessary(attributes, element);
    return bBox;
}
/* harmony default export */ const drawingSvg_drawTextBox = (drawTextBox);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js
var findClosestPoint = __webpack_require__(90554);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js


function drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {
    const start = annotationAnchorPoints.length > 0
        ? (0,findClosestPoint/* default */.A)(annotationAnchorPoints, refPoint)
        : refPoint;
    const boundingBoxPoints = _boundingBoxPoints(boundingBox);
    const end = (0,findClosestPoint/* default */.A)(boundingBoxPoints, start);
    const mergedOptions = Object.assign({
        color: 'rgb(255, 255, 0)',
        lineWidth: '1',
        lineDash: '2,3',
    }, options);
    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);
}
function _boundingBoxPoints(boundingBox) {
    const { x: left, y: top, height, width } = boundingBox;
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const topMiddle = [left + halfWidth, top];
    const leftMiddle = [left, top + halfHeight];
    const bottomMiddle = [left + halfWidth, top + height];
    const rightMiddle = [left + width, top + halfHeight];
    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];
}
/* harmony default export */ const drawingSvg_drawLink = (drawLink);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js


function drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {
    const mergedOptions = Object.assign({
        handleRadius: '6',
        centering: {
            x: false,
            y: true,
        },
    }, options);
    const canvasBoundingBox = drawingSvg_drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);
    drawingSvg_drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);
    return canvasBoundingBox;
}
/* harmony default export */ const drawingSvg_drawLinkedTextBox = (drawLinkedTextBox);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js



function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = '') {
    const { color, width: _width, lineWidth, lineDash, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || _width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'rect', rectangleUID);
    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
    const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;
    const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);
    const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);
    const center = [
        (bottomRight[0] + topLeft[0]) / 2,
        (bottomRight[1] + topLeft[1]) / 2,
    ];
    const leftEdgeCenter = [
        (bottomLeft[0] + topLeft[0]) / 2,
        (bottomLeft[1] + topLeft[1]) / 2,
    ];
    const angle = (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *
        180) /
        Math.PI;
    const attributes = {
        x: `${center[0] - width / 2}`,
        y: `${center[1] - height / 2}`,
        width: `${width}`,
        height: `${height}`,
        stroke: color,
        fill: 'transparent',
        transform: `rotate(${angle} ${center[0]} ${center[1]})`,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingRect) {
        drawingSvg_setAttributesIfNecessary(attributes, existingRect);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgRectElement = document.createElementNS(svgns, 'rect');
        if (dataId !== '') {
            svgRectElement.setAttribute('data-id', dataId);
        }
        drawingSvg_setNewAttributesIfValid(attributes, svgRectElement);
        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js


function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {
    const topLeft = [start[0], start[1]];
    const topRight = [end[0], start[1]];
    const bottomLeft = [start[0], end[1]];
    const bottomRight = [end[0], end[1]];
    drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js

function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    const headLength = 10;
    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);
    const firstLine = {
        start: [
            end[0] - headLength * Math.cos(angle - Math.PI / 7),
            end[1] - headLength * Math.sin(angle - Math.PI / 7),
        ],
        end: end,
    };
    const secondLine = {
        start: [
            end[0] - headLength * Math.cos(angle + Math.PI / 7),
            end[1] - headLength * Math.sin(angle + Math.PI / 7),
        ],
        end: end,
    };
    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {
        color,
        width,
        lineWidth,
    });
    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {
        color,
        width,
        lineWidth,
    });
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js



function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {
    const { color, width: _width, lineWidth, lineDash, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || _width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'rect', rectangleUID);
    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];
    const width = Math.abs(start[0] - end[0]);
    const height = Math.abs(start[1] - end[1]);
    const attributes = {
        x: `${tlhc[0]}`,
        y: `${tlhc[1]}`,
        width: `${width}`,
        height: `${height}`,
        stroke: color,
        fill: 'black',
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingRect) {
        drawingSvg_setAttributesIfNecessary(attributes, existingRect);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgRectElement = document.createElementNS(svgns, 'rect');
        drawingSvg_setNewAttributesIfValid(attributes, svgRectElement);
        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js





















/***/ }),

/***/ 75183:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ChangeTypes;
(function (ChangeTypes) {
    ChangeTypes["Interaction"] = "Interaction";
    ChangeTypes["HandlesUpdated"] = "HandlesUpdated";
    ChangeTypes["StatsUpdated"] = "StatsUpdated";
    ChangeTypes["InitialSetup"] = "InitialSetup";
    ChangeTypes["Completed"] = "Completed";
    ChangeTypes["InterpolationUpdated"] = "InterpolationUpdated";
})(ChangeTypes || (ChangeTypes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChangeTypes);


/***/ }),

/***/ 94021:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events;
(function (Events) {
    Events["TOOL_ACTIVATED"] = "CORNERSTONE_TOOLS_TOOL_ACTIVATED";
    Events["TOOLGROUP_VIEWPORT_ADDED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED";
    Events["TOOLGROUP_VIEWPORT_REMOVED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED";
    Events["TOOL_MODE_CHANGED"] = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED";
    Events["ANNOTATION_ADDED"] = "CORNERSTONE_TOOLS_ANNOTATION_ADDED";
    Events["ANNOTATION_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED";
    Events["ANNOTATION_MODIFIED"] = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED";
    Events["ANNOTATION_REMOVED"] = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED";
    Events["ANNOTATION_SELECTION_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE";
    Events["ANNOTATION_LOCK_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE";
    Events["ANNOTATION_VISIBILITY_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE";
    Events["ANNOTATION_RENDERED"] = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED";
    Events["ANNOTATION_INTERPOLATION_PROCESS_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED";
    Events["INTERPOLATED_ANNOTATIONS_REMOVED"] = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED";
    Events["SEGMENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED";
    Events["SEGMENTATION_RENDERED"] = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED";
    Events["SEGMENTATION_REPRESENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED";
    Events["SEGMENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_ADDED";
    Events["SEGMENTATION_REPRESENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED";
    Events["SEGMENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED";
    Events["SEGMENTATION_REPRESENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED";
    Events["SEGMENTATION_DATA_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED";
    Events["KEY_DOWN"] = "CORNERSTONE_TOOLS_KEY_DOWN";
    Events["KEY_UP"] = "CORNERSTONE_TOOLS_KEY_UP";
    Events["MOUSE_DOWN"] = "CORNERSTONE_TOOLS_MOUSE_DOWN";
    Events["MOUSE_UP"] = "CORNERSTONE_TOOLS_MOUSE_UP";
    Events["MOUSE_DOWN_ACTIVATE"] = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE";
    Events["MOUSE_DRAG"] = "CORNERSTONE_TOOLS_MOUSE_DRAG";
    Events["MOUSE_MOVE"] = "CORNERSTONE_TOOLS_MOUSE_MOVE";
    Events["MOUSE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_CLICK";
    Events["MOUSE_DOUBLE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK";
    Events["MOUSE_WHEEL"] = "CORNERSTONE_TOOLS_MOUSE_WHEEL";
    Events["TOUCH_START"] = "CORNERSTONE_TOOLS_TOUCH_START";
    Events["TOUCH_START_ACTIVATE"] = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE";
    Events["TOUCH_PRESS"] = "CORNERSTONE_TOOLS_TOUCH_PRESS";
    Events["TOUCH_DRAG"] = "CORNERSTONE_TOOLS_TOUCH_DRAG";
    Events["TOUCH_END"] = "CORNERSTONE_TOOLS_TOUCH_END";
    Events["TOUCH_TAP"] = "CORNERSTONE_TOOLS_TAP";
    Events["TOUCH_SWIPE"] = "CORNERSTONE_TOOLS_SWIPE";
})(Events || (Events = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);


/***/ }),

/***/ 84093:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var StrategyCallbacks;
(function (StrategyCallbacks) {
    StrategyCallbacks["OnInteractionStart"] = "onInteractionStart";
    StrategyCallbacks["OnInteractionEnd"] = "onInteractionEnd";
    StrategyCallbacks["Preview"] = "preview";
    StrategyCallbacks["RejectPreview"] = "rejectPreview";
    StrategyCallbacks["AcceptPreview"] = "acceptPreview";
    StrategyCallbacks["Fill"] = "fill";
    StrategyCallbacks["StrategyFunction"] = "strategyFunction";
    StrategyCallbacks["CreateIsInThreshold"] = "createIsInThreshold";
    StrategyCallbacks["Initialize"] = "initialize";
    StrategyCallbacks["INTERNAL_setValue"] = "setValue";
    StrategyCallbacks["ComputeInnerCircleRadius"] = "computeInnerCircleRadius";
})(StrategyCallbacks || (StrategyCallbacks = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StrategyCallbacks);


/***/ }),

/***/ 49892:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ToolModes;
(function (ToolModes) {
    ToolModes["Active"] = "Active";
    ToolModes["Passive"] = "Passive";
    ToolModes["Enabled"] = "Enabled";
    ToolModes["Disabled"] = "Disabled";
})(ToolModes || (ToolModes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolModes);


/***/ }),

/***/ 10401:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ Swipe)
/* harmony export */ });
var Swipe;
(function (Swipe) {
    Swipe["UP"] = "UP";
    Swipe["DOWN"] = "DOWN";
    Swipe["LEFT"] = "LEFT";
    Swipe["RIGHT"] = "RIGHT";
})(Swipe || (Swipe = {}));



/***/ }),

/***/ 99737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AnnotationStyleStates: () => (/* reexport */ enums_AnnotationStyleStates),
  ChangeTypes: () => (/* reexport */ ChangeTypes/* default */.A),
  Events: () => (/* reexport */ Events/* default */.A),
  KeyboardBindings: () => (/* reexport */ ToolBindings/* KeyboardBindings */.q),
  MouseBindings: () => (/* reexport */ ToolBindings/* MouseBindings */.i),
  SegmentationRepresentations: () => (/* reexport */ SegmentationRepresentations/* default */.A),
  StrategyCallbacks: () => (/* reexport */ StrategyCallbacks/* default */.A),
  Swipe: () => (/* reexport */ Touch/* Swipe */.H),
  ToolModes: () => (/* reexport */ ToolModes/* default */.A),
  WorkerTypes: () => (/* reexport */ WorkerTypes)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js
var ToolBindings = __webpack_require__(66452);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js
var ToolModes = __webpack_require__(49892);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js
var AnnotationStyleStates;
(function (AnnotationStyleStates) {
    AnnotationStyleStates["Default"] = "";
    AnnotationStyleStates["Highlighted"] = "Highlighted";
    AnnotationStyleStates["Selected"] = "Selected";
    AnnotationStyleStates["Locked"] = "Locked";
    AnnotationStyleStates["AutoGenerated"] = "AutoGenerated";
})(AnnotationStyleStates || (AnnotationStyleStates = {}));
/* harmony default export */ const enums_AnnotationStyleStates = (AnnotationStyleStates);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var Events = __webpack_require__(94021);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js
var Touch = __webpack_require__(10401);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js
var StrategyCallbacks = __webpack_require__(84093);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js
var ChangeTypes = __webpack_require__(75183);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js
var WorkerTypes_ChangeTypes;
(function (ChangeTypes) {
    ChangeTypes["POLYSEG_CONTOUR_TO_LABELMAP"] = "Converting Contour to Labelmap";
    ChangeTypes["POLYSEG_SURFACE_TO_LABELMAP"] = "Converting Surfaces to Labelmap";
    ChangeTypes["POLYSEG_CONTOUR_TO_SURFACE"] = "Converting Contour to Surface";
    ChangeTypes["POLYSEG_LABELMAP_TO_SURFACE"] = "Converting Labelmap to Surface";
    ChangeTypes["SURFACE_CLIPPING"] = "Clipping Surfaces";
})(WorkerTypes_ChangeTypes || (WorkerTypes_ChangeTypes = {}));
/* harmony default export */ const WorkerTypes = (WorkerTypes_ChangeTypes);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js












/***/ }),

/***/ 50986:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ contourSegmentationCompletedListener),
/* harmony export */   r: () => (/* binding */ createPolylineHole)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _utilities_getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15295);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95527);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58640);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8056);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82056);
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93126);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44049);
/* harmony import */ var _utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(72967);
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(64843);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7754);
/* harmony import */ var _store_addTool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(68040);












const DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';
async function contourSegmentationCompletedListener(evt) {
    const sourceAnnotation = evt.detail
        .annotation;
    if (!(0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.isContourSegmentationAnnotation)(sourceAnnotation)) {
        return;
    }
    const viewport = getViewport(sourceAnnotation);
    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);
    if (!contourSegmentationAnnotations.length) {
        return;
    }
    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);
    const targetAnnotationInfo = findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations);
    if (!targetAnnotationInfo) {
        return;
    }
    const { targetAnnotation, targetPolyline, isContourHole } = targetAnnotationInfo;
    if (isContourHole) {
        const { contourHoleProcessingEnabled = false } = evt.detail;
        if (!contourHoleProcessingEnabled) {
            return;
        }
        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);
    }
    else {
        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);
    }
}
function isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {
    const toolName = 'PlanarFreehandContourSegmentationTool';
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroupForViewport)(viewport.id, viewport.renderingEngineId);
    let errorMessage;
    if (!toolGroup.hasTool(toolName)) {
        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;
    }
    else if (!toolGroup.getToolOptions(toolName)) {
        errorMessage = `Tool ${toolName} must be in active/passive state`;
    }
    if (errorMessage && !silent) {
        console.warn(errorMessage);
    }
    return !errorMessage;
}
function getViewport(annotation) {
    const viewports = (0,_utilities_getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(annotation);
    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));
    return viewportWithToolRegistered ?? viewports[0];
}
function convertContourPolylineToCanvasSpace(polyline, viewport) {
    const numPoints = polyline.length;
    const projectedPolyline = new Array(numPoints);
    for (let i = 0; i < numPoints; i++) {
        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);
    }
    return projectedPolyline;
}
function getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {
    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;
    const allAnnotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAllAnnotations)();
    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&
        targetAnnotation.annotationUID !== sourceAnnotationUID &&
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.isContourSegmentationAnnotation)(targetAnnotation) &&
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.areSameSegment)(targetAnnotation, sourceAnnotation) &&
        viewport.isReferenceViewable(targetAnnotation.metadata));
}
function findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations) {
    const sourceAABB = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.getAABB(sourcePolyline);
    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {
        const targetAnnotation = contourSegmentationAnnotations[i];
        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);
        const targetAABB = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.getAABB(targetPolyline);
        const aabbIntersect = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.aabb.intersectAABB(sourceAABB, targetAABB);
        const lineSegmentsIntersect = aabbIntersect &&
            _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.intersectPolyline(sourcePolyline, targetPolyline);
        const isContourHole = aabbIntersect &&
            !lineSegmentsIntersect &&
            _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoints(targetPolyline, sourcePolyline);
        if (lineSegmentsIntersect || isContourHole) {
            return { targetAnnotation, targetPolyline, isContourHole };
        }
    }
}
function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {
    const { windingDirection: targetWindingDirection } = targetAnnotation.data.contour;
    const { windingDirection: holeWindingDirection } = holeAnnotation.data.contour;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addChildAnnotation)(targetAnnotation, holeAnnotation);
    (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.removeContourSegmentationAnnotation)(holeAnnotation);
    const { contour: holeContour } = holeAnnotation.data;
    const holePolyline = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);
    (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(holeAnnotation, {
        points: holePolyline,
        closed: holeContour.closed,
    }, viewport);
    const { element } = viewport;
    const updatedToolNames = new Set([
        DEFAULT_CONTOUR_SEG_TOOL_NAME,
        targetAnnotation.metadata.toolName,
        holeAnnotation.metadata.toolName,
    ]);
    for (const toolName of updatedToolNames.values()) {
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, toolName);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportIdsToRender);
    }
}
function getContourHolesData(viewport, annotation) {
    return (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getChildAnnotations)(annotation).map((holeAnnotation) => {
        const polyline = convertContourPolylineToCanvasSpace(holeAnnotation.data.contour.polyline, viewport);
        return { annotation: holeAnnotation, polyline };
    });
}
function combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {
    if (!(0,_store_addTool__WEBPACK_IMPORTED_MODULE_11__/* .hasToolByName */ .l$)(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {
        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone`);
        return;
    }
    if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {
        return;
    }
    const sourceStartPoint = sourcePolyline[0];
    const mergePolylines = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoint(targetPolyline, sourceStartPoint);
    const contourHolesData = getContourHolesData(viewport, targetAnnotation);
    const unassignedContourHolesSet = new Set(contourHolesData);
    const reassignedContourHolesMap = new Map();
    const assignHoleToPolyline = (parentPolyline, holeData) => {
        let holes = reassignedContourHolesMap.get(parentPolyline);
        if (!holes) {
            holes = [];
            reassignedContourHolesMap.set(parentPolyline, holes);
        }
        holes.push(holeData);
        unassignedContourHolesSet.delete(holeData);
    };
    const newPolylines = [];
    if (mergePolylines) {
        const mergedPolyline = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.mergePolylines(targetPolyline, sourcePolyline);
        newPolylines.push(mergedPolyline);
        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));
    }
    else {
        const subtractedPolylines = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.subtractPolylines(targetPolyline, sourcePolyline);
        subtractedPolylines.forEach((newPolyline) => {
            newPolylines.push(newPolyline);
            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {
                const containsHole = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoints(newPolyline, holeData.polyline);
                if (containsHole) {
                    assignHoleToPolyline(newPolyline, holeData);
                    unassignedContourHolesSet.delete(holeData);
                }
            });
        });
    }
    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.clearParentAnnotation)(contourHoleData.annotation)));
    const { element } = viewport;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { metadata, data } = targetAnnotation;
    const { handles, segmentation } = data;
    const { textBox } = handles;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(sourceAnnotation.annotationUID);
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(targetAnnotation.annotationUID);
    for (let i = 0; i < newPolylines.length; i++) {
        const polyline = newPolylines[i];
        const startPoint = viewport.canvasToWorld(polyline[0]);
        const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);
        const newAnnotation = {
            metadata: {
                ...metadata,
                toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,
                originalToolName: metadata.originalToolName || metadata.toolName,
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [startPoint, endPoint],
                    textBox: textBox ? { ...textBox } : undefined,
                },
                contour: {
                    polyline: [],
                    closed: true,
                },
                spline: targetAnnotation.data.spline,
                segmentation: {
                    ...segmentation,
                },
            },
            annotationUID: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
            highlighted: true,
            invalidated: true,
            isLocked: false,
            isVisible: undefined,
            interpolationUID: targetAnnotation.interpolationUID,
            interpolationCompleted: targetAnnotation.interpolationCompleted,
        };
        (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(newAnnotation, {
            points: polyline,
            closed: true,
            targetWindingDirection: _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__/* .ContourWindingDirection */ .W.Clockwise,
        }, viewport);
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(newAnnotation, element);
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.addContourSegmentationAnnotation)(newAnnotation);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__/* .triggerAnnotationModified */ .XF)(newAnnotation, viewport.element);
        reassignedContourHolesMap
            .get(polyline)
            ?.forEach((holeData) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addChildAnnotation)(newAnnotation, holeData.annotation));
    }
    updateViewports(enabledElement, targetAnnotation, sourceAnnotation);
}
function updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {
    const { viewport } = enabledElement;
    const { element } = viewport;
    const updatedTtoolNames = new Set([
        DEFAULT_CONTOUR_SEG_TOOL_NAME,
        targetAnnotation.metadata.toolName,
        sourceAnnotation.metadata.toolName,
    ]);
    for (const toolName of updatedTtoolNames.values()) {
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, toolName);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportIdsToRender);
    }
    return new Promise((resolve) => window.requestAnimationFrame(resolve));
}


/***/ }),

/***/ 59718:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  tQ: () => (/* reexport */ annotationCompletedListener),
  nm: () => (/* reexport */ annotations_annotationModifiedListener),
  Gg: () => (/* reexport */ annotationRemovedListener),
  ge: () => (/* reexport */ annotations_annotationSelectionListener),
  _9: () => (/* reexport */ imageChangeEventListener),
  kt: () => (/* reexport */ keyboard/* default */.A),
  bH: () => (/* reexport */ mouse),
  qI: () => (/* reexport */ segmentationDataModifiedEventListener),
  sp: () => (/* reexport */ segmentationModifiedEventListener),
  F_: () => (/* reexport */ touch),
  CG: () => (/* reexport */ wheel)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js
var mouseDoubleClickListener = __webpack_require__(91099);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js
var mouseDownListener = __webpack_require__(68014);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js
var mouseMoveListener = __webpack_require__(41343);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js



function disable(element) {
    element.removeEventListener('dblclick', mouseDoubleClickListener/* default */.A);
    element.removeEventListener('mousedown', mouseDownListener/* default */.Ay);
    element.removeEventListener('mousemove', mouseMoveListener/* default */.A);
    element.removeEventListener('dblclick', mouseDownListener/* mouseDoubleClickIgnoreListener */.DF, {
        capture: true,
    });
}
function enable(element) {
    disable(element);
    element.addEventListener('dblclick', mouseDoubleClickListener/* default */.A);
    element.addEventListener('mousedown', mouseDownListener/* default */.Ay);
    element.addEventListener('mousemove', mouseMoveListener/* default */.A);
    element.addEventListener('dblclick', mouseDownListener/* mouseDoubleClickIgnoreListener */.DF, {
        capture: true,
    });
}
/* harmony default export */ const mouse = ({
    enable,
    disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js
var preventGhostClick = __webpack_require__(41666);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js + 1 modules
var touchStartListener = __webpack_require__(82603);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js


function touch_disable(element) {
    preventGhostClick/* default */.A.disable(element);
    element.removeEventListener('touchstart', touchStartListener/* default */.A);
}
function touch_enable(element) {
    touch_disable(element);
    preventGhostClick/* default */.A.enable(element);
    element.addEventListener('touchstart', touchStartListener/* default */.A, {
        passive: false,
    });
}
/* harmony default export */ const touch = ({
    enable: touch_enable,
    disable: touch_disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js + 1 modules
var wheelListener = __webpack_require__(17806);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js

function wheel_enable(element) {
    wheel_disable(element);
    element.addEventListener('wheel', wheelListener/* default */.A, { passive: false });
}
function wheel_disable(element) {
    element.removeEventListener('wheel', wheelListener/* default */.A);
}
/* harmony default export */ const wheel = ({
    enable: wheel_enable,
    disable: wheel_disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js
var keyboard = __webpack_require__(39595);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var SegmentationRenderingEngine = __webpack_require__(24917);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js + 2 modules
var segmentationState = __webpack_require__(98870);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js
var getSegmentationActor = __webpack_require__(59452);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js




const onLabelmapSegmentationDataModified = function (evt) {
    const { segmentationId, modifiedSlicesToUse } = evt.detail;
    const { representationData } = segmentationState.getSegmentation(segmentationId);
    const viewportIds = segmentationState.getViewportIdsWithSegmentation(segmentationId);
    const hasVolumeViewport = viewportIds.some((viewportId) => {
        const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId);
        return viewport instanceof esm.VolumeViewport;
    });
    const hasStackViewport = viewportIds.some((viewportId) => {
        const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId);
        return viewport instanceof esm.StackViewport;
    });
    const hasBothStackAndVolume = hasVolumeViewport && hasStackViewport;
    viewportIds.forEach((viewportId) => {
        const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (viewport instanceof esm.VolumeViewport) {
            performVolumeLabelmapUpdate({
                modifiedSlicesToUse: hasBothStackAndVolume ? [] : modifiedSlicesToUse,
                representationData,
                type: enums.SegmentationRepresentations.Labelmap,
            });
        }
        if (viewport instanceof esm.StackViewport) {
            performStackLabelmapUpdate({
                viewportIds,
                segmentationId,
            });
        }
    });
};
function performVolumeLabelmapUpdate({ modifiedSlicesToUse, representationData, type, }) {
    const segmentationVolume = esm.cache.getVolume(representationData[type].volumeId);
    if (!segmentationVolume) {
        console.warn('segmentation not found in cache');
        return;
    }
    const { imageData, vtkOpenGLTexture } = segmentationVolume;
    let slicesToUpdate;
    if (modifiedSlicesToUse?.length > 0) {
        slicesToUpdate = modifiedSlicesToUse;
    }
    else {
        const numSlices = imageData.getDimensions()[2];
        slicesToUpdate = [...Array(numSlices).keys()];
    }
    slicesToUpdate.forEach((i) => {
        vtkOpenGLTexture.setUpdatedFrame(i);
    });
    imageData.modified();
}
function performStackLabelmapUpdate({ viewportIds, segmentationId }) {
    viewportIds.forEach((viewportId) => {
        let representations = segmentationState.getSegmentationRepresentations(viewportId, { segmentationId });
        representations = representations.filter((representation) => representation.type === enums.SegmentationRepresentations.Labelmap);
        representations.forEach((representation) => {
            if (representation.segmentationId !== segmentationId) {
                return;
            }
            const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            if (viewport instanceof esm.VolumeViewport) {
                return;
            }
            const actorEntry = (0,getSegmentationActor/* getLabelmapActorEntry */.wV)(viewportId, segmentationId);
            if (!actorEntry) {
                return;
            }
            const segImageData = actorEntry.actor.getMapper().getInputData();
            const currentSegmentationImageId = segmentationState.getCurrentLabelmapImageIdForViewport(viewportId, segmentationId);
            const segmentationImage = esm.cache.getImage(currentSegmentationImageId);
            segImageData.modified();
            esm.utilities.updateVTKImageDataWithCornerstoneImage(segImageData, segmentationImage);
        });
    });
}
/* harmony default export */ const labelmap_onLabelmapSegmentationDataModified = (onLabelmapSegmentationDataModified);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js



const onSegmentationDataModified = function (evt) {
    const { segmentationId } = evt.detail;
    const { representationData } = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    if (representationData.Labelmap) {
        labelmap_onLabelmapSegmentationDataModified(evt);
    }
    (0,SegmentationRenderingEngine/* triggerSegmentationRenderBySegmentationId */.fy)(segmentationId);
};
/* harmony default export */ const segmentationDataModifiedEventListener = (onSegmentationDataModified);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js

const segmentationModifiedListener = function (evt) {
    const { segmentationId } = evt.detail;
    (0,SegmentationRenderingEngine/* triggerSegmentationRenderBySegmentationId */.fy)(segmentationId);
};
/* harmony default export */ const segmentationModifiedEventListener = (segmentationModifiedListener);

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var ImageData = __webpack_require__(58498);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js
var updateLabelmapSegmentationImageReferences = __webpack_require__(78231);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
var getCurrentLabelmapImageIdForViewport = __webpack_require__(97577);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js









const imageChangeEventListener_enable = function (element) {
    const { viewport } = (0,esm.getEnabledElement)(element);
    if (viewport instanceof esm.BaseVolumeViewport) {
        return;
    }
    element.addEventListener(esm.Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
    element.addEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const imageChangeEventListener_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
    element.removeEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const perViewportManualTriggers = new Map();
function _imageChangeEventListener(evt) {
    const eventData = evt.detail;
    const { viewportId, renderingEngineId } = eventData;
    const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId);
    if (!representations?.length) {
        return;
    }
    const labelmapRepresentations = representations.filter((representation) => representation.type === enums.SegmentationRepresentations.Labelmap);
    const actors = viewport.getActors();
    labelmapRepresentations.forEach((representation) => {
        const { segmentationId } = representation;
        (0,updateLabelmapSegmentationImageReferences/* updateLabelmapSegmentationImageReferences */.t)(viewportId, segmentationId);
    });
    const labelmapActors = labelmapRepresentations
        .map((representation) => {
        return (0,getSegmentationActor/* getLabelmapActorEntry */.wV)(viewportId, representation.segmentationId);
    })
        .filter((actor) => actor !== undefined);
    if (!labelmapActors.length) {
        return;
    }
    labelmapActors.forEach((actor) => {
        const validActor = labelmapRepresentations.find((representation) => {
            const derivedImageId = (0,getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdForViewport */.v)(viewportId, representation.segmentationId);
            return derivedImageId === actor.referencedId;
        });
        if (!validActor) {
            viewport.removeActors([actor.uid]);
        }
    });
    labelmapRepresentations.forEach((representation) => {
        const { segmentationId } = representation;
        const currentImageId = viewport.getCurrentImageId();
        const derivedImageId = (0,getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdForViewport */.v)(viewportId, segmentationId);
        if (!derivedImageId) {
            return;
        }
        const derivedImage = esm.cache.getImage(derivedImageId);
        if (!derivedImage) {
            console.warn('No derived image found in the cache for segmentation representation', representation);
            return;
        }
        const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);
        if (!segmentationActorInput) {
            const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);
            const currentImage = esm.cache.getImage(currentImageId) ||
                {
                    imageId: currentImageId,
                };
            const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);
            const originToUse = currentOrigin;
            const constructor = derivedImage.voxelManager.getConstructor();
            const newPixelData = derivedImage.voxelManager.getScalarData();
            const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
                name: 'Pixels',
                numberOfComponents: 1,
                values: new constructor(newPixelData),
            });
            const imageData = ImageData/* default.newInstance */.Ay.newInstance();
            imageData.setDimensions(dimensions[0], dimensions[1], 1);
            imageData.setSpacing(spacing);
            imageData.setDirection(direction);
            imageData.setOrigin(originToUse);
            imageData.getPointData().setScalars(scalarArray);
            imageData.modified();
            viewport.addImages([
                {
                    imageId: derivedImageId,
                    representationUID: `${segmentationId}-${enums.SegmentationRepresentations.Labelmap}`,
                    callback: ({ imageActor }) => {
                        imageActor.getMapper().setInputData(imageData);
                    },
                },
            ]);
            (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)(viewportId);
            return;
        }
        else {
            const segmentationImageData = segmentationActorInput.actor
                .getMapper()
                .getInputData();
            if (segmentationImageData.setDerivedImage) {
                segmentationImageData.setDerivedImage(derivedImage);
            }
            else {
                esm.utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);
            }
        }
        viewport.render();
        if (evt.type === esm.Enums.Events.IMAGE_RENDERED) {
            viewport.element.removeEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
        }
    });
}
/* harmony default export */ const imageChangeEventListener = ({
    enable: imageChangeEventListener_enable,
    disable: imageChangeEventListener_disable,
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/index.js





// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js
var contourSegmentation = __webpack_require__(64843);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js
var contourSegmentationCompleted = __webpack_require__(50986);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js

function contourSegmentationRemovedListener(evt) {
    const annotation = evt.detail.annotation;
    (0,contourSegmentation.removeContourSegmentationAnnotation)(annotation);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/index.js



;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js


function annotationCompletedListener(evt) {
    const annotation = evt.detail.annotation;
    if (contourSegmentation.isContourSegmentationAnnotation(annotation)) {
        (0,contourSegmentationCompleted/* default */.A)(evt);
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js
var triggerAnnotationRenderForViewportIds = __webpack_require__(58640);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js


function annotationSelectionListener(evt) {
    const deselectedAnnotation = evt.detail.removed;
    if (!deselectedAnnotation.length) {
        return;
    }
    const renderingEngines = (0,esm.getRenderingEngines)();
    renderingEngines.forEach((renderingEngine) => {
        const viewports = renderingEngine.getViewports();
        const viewportIds = viewports.map((vp) => vp.id);
        (0,triggerAnnotationRenderForViewportIds/* triggerAnnotationRenderForViewportIds */.t)(viewportIds);
    });
}
/* harmony default export */ const annotations_annotationSelectionListener = (annotationSelectionListener);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js

function annotationModifiedListener(evt) {
    const { viewportId } = evt.detail;
    (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewportId]);
}
/* harmony default export */ const annotations_annotationModifiedListener = (annotationModifiedListener);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js


function annotationRemovedListener(evt) {
    const annotation = evt.detail.annotation;
    if (contourSegmentation.isContourSegmentationAnnotation(annotation)) {
        contourSegmentationRemovedListener(evt);
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/index.js






;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js









/***/ }),

/***/ 55139:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AdvancedMagnifyTool: () => (/* reexport */ AdvancedMagnifyTool),
  AngleTool: () => (/* reexport */ annotation_AngleTool),
  AnnotationDisplayTool: () => (/* reexport */ base/* AnnotationDisplayTool */.wh),
  AnnotationTool: () => (/* reexport */ base/* AnnotationTool */.EC),
  ArrowAnnotateTool: () => (/* reexport */ annotation_ArrowAnnotateTool),
  BaseTool: () => (/* reexport */ base/* BaseTool */.oS),
  BidirectionalTool: () => (/* reexport */ BidirectionalTool/* default */.A),
  BrushTool: () => (/* reexport */ BrushTool/* default */.A),
  CONSTANTS: () => (/* reexport */ constants_namespaceObject),
  CircleROIStartEndThresholdTool: () => (/* reexport */ segmentation_CircleROIStartEndThresholdTool),
  CircleROITool: () => (/* reexport */ annotation_CircleROITool),
  CircleScissorsTool: () => (/* reexport */ segmentation_CircleScissorsTool),
  CobbAngleTool: () => (/* reexport */ annotation_CobbAngleTool),
  CrosshairsTool: () => (/* reexport */ tools_CrosshairsTool),
  DragProbeTool: () => (/* reexport */ annotation_DragProbeTool),
  ETDRSGridTool: () => (/* reexport */ annotation_ETDRSGridTool),
  EllipticalROITool: () => (/* reexport */ annotation_EllipticalROITool),
  Enums: () => (/* reexport */ enums),
  EraserTool: () => (/* reexport */ tools_AnnotationEraserTool),
  HeightTool: () => (/* reexport */ annotation_HeightTool),
  KeyImageTool: () => (/* reexport */ annotation_KeyImageTool),
  LengthTool: () => (/* reexport */ annotation_LengthTool),
  LivewireContourSegmentationTool: () => (/* reexport */ annotation_LivewireContourSegmentationTool),
  LivewireContourTool: () => (/* reexport */ annotation_LivewireContourTool),
  MIPJumpToClickTool: () => (/* reexport */ tools_MIPJumpToClickTool),
  MagnifyTool: () => (/* reexport */ tools_MagnifyTool),
  OrientationMarkerTool: () => (/* reexport */ tools_OrientationMarkerTool),
  OverlayGridTool: () => (/* reexport */ tools_OverlayGridTool),
  PaintFillTool: () => (/* reexport */ segmentation_PaintFillTool),
  PanTool: () => (/* reexport */ tools_PanTool),
  PlanarFreehandContourSegmentationTool: () => (/* reexport */ PlanarFreehandContourSegmentationTool/* default */.A),
  PlanarFreehandROITool: () => (/* reexport */ PlanarFreehandROITool/* default */.A),
  PlanarRotateTool: () => (/* reexport */ tools_PlanarRotateTool),
  ProbeTool: () => (/* reexport */ annotation_ProbeTool),
  RectangleROIStartEndThresholdTool: () => (/* reexport */ RectangleROIStartEndThresholdTool/* default */.A),
  RectangleROIThresholdTool: () => (/* reexport */ RectangleROIThresholdTool/* default */.A),
  RectangleROITool: () => (/* reexport */ RectangleROITool/* default */.A),
  RectangleScissorsTool: () => (/* reexport */ segmentation_RectangleScissorsTool),
  ReferenceCursors: () => (/* reexport */ tools_ReferenceCursors),
  ReferenceLinesTool: () => (/* reexport */ ReferenceLinesTool),
  ScaleOverlayTool: () => (/* reexport */ tools_ScaleOverlayTool),
  SculptorTool: () => (/* reexport */ tools_SculptorTool),
  SegmentSelectTool: () => (/* reexport */ segmentation_SegmentSelectTool),
  SegmentationIntersectionTool: () => (/* reexport */ tools_SegmentationIntersectionTool),
  SphereScissorsTool: () => (/* reexport */ segmentation_SphereScissorsTool),
  SplineContourSegmentationTool: () => (/* reexport */ annotation_SplineContourSegmentationTool),
  SplineROITool: () => (/* reexport */ annotation_SplineROITool),
  StackScrollTool: () => (/* reexport */ tools_StackScrollTool),
  Synchronizer: () => (/* reexport */ SynchronizerManager_Synchronizer),
  SynchronizerManager: () => (/* reexport */ SynchronizerManager_namespaceObject),
  ToolGroupManager: () => (/* reexport */ ToolGroupManager),
  TrackballRotateTool: () => (/* reexport */ tools_TrackballRotateTool),
  Types: () => (/* reexport */ types),
  UltrasoundDirectionalTool: () => (/* reexport */ annotation_UltrasoundDirectionalTool),
  VideoRedactionTool: () => (/* reexport */ annotation_VideoRedactionTool),
  VolumeRotateTool: () => (/* reexport */ tools_VolumeRotateTool),
  WindowLevelRegionTool: () => (/* reexport */ tools_WindowLevelRegionTool),
  WindowLevelTool: () => (/* reexport */ tools_WindowLevelTool),
  ZoomTool: () => (/* reexport */ tools_ZoomTool),
  addTool: () => (/* reexport */ addTool/* addTool */.Gx),
  annotation: () => (/* reexport */ annotation),
  cancelActiveManipulations: () => (/* reexport */ cancelActiveManipulations),
  cursors: () => (/* reexport */ cursors),
  destroy: () => (/* reexport */ init_destroy),
  drawing: () => (/* reexport */ drawingSvg),
  init: () => (/* reexport */ init),
  removeTool: () => (/* reexport */ addTool/* removeTool */.Bl),
  segmentation: () => (/* reexport */ segmentation),
  state: () => (/* reexport */ state/* state */.wk),
  synchronizers: () => (/* reexport */ synchronizers_namespaceObject),
  utilities: () => (/* reexport */ utilities)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js
var SynchronizerManager_namespaceObject = {};
__webpack_require__.r(SynchronizerManager_namespaceObject);
__webpack_require__.d(SynchronizerManager_namespaceObject, {
  createSynchronizer: () => (SynchronizerManager_createSynchronizer),
  destroy: () => (SynchronizerManager_destroy),
  destroySynchronizer: () => (SynchronizerManager_destroySynchronizer),
  getAllSynchronizers: () => (SynchronizerManager_getAllSynchronizers),
  getSynchronizer: () => (SynchronizerManager_getSynchronizer),
  getSynchronizersForViewport: () => (SynchronizerManager_getSynchronizersForViewport)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/constants/index.js
var constants_namespaceObject = {};
__webpack_require__.r(constants_namespaceObject);
__webpack_require__.d(constants_namespaceObject, {
  COLOR_LUT: () => (COLOR_LUT/* default */.A)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js
var synchronizers_namespaceObject = {};
__webpack_require__.r(synchronizers_namespaceObject);
__webpack_require__.d(synchronizers_namespaceObject, {
  createCameraPositionSynchronizer: () => (createCameraPositionSynchronizer),
  createImageSliceSynchronizer: () => (createImageSliceSynchronizer),
  createPresentationViewSynchronizer: () => (createPresentationViewSynchronizer),
  createSlabThicknessSynchronizer: () => (createSlabThicknessSynchronizer_createPresentationViewSynchronizer),
  createStackImageSynchronizer: () => (createStackImageSynchronizer),
  createVOISynchronizer: () => (createVOISynchronizer),
  createZoomPanSynchronizer: () => (createZoomPanSynchronizer)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState = __webpack_require__(82056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js
var addTool = __webpack_require__(68040);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js + 15 modules
var eventListeners = __webpack_require__(59718);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js
var triggerAnnotationRender = __webpack_require__(56069);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js


const onImageRendered = function (evt) {
    (0,triggerAnnotationRender/* default */.A)(evt.detail.element);
};
const enable = function (element) {
    element.addEventListener(esm.Enums.Events.IMAGE_RENDERED, onImageRendered);
};
const disable = function (element) {
    element.removeEventListener(esm.Enums.Events.IMAGE_RENDERED, onImageRendered);
};
/* harmony default export */ const imageRenderedEventDispatcher = ({
    enable,
    disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var Events = __webpack_require__(94021);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/index.js + 11 modules
var mouseEventHandlers = __webpack_require__(40100);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js


const mouseToolEventDispatcher_enable = function (element) {
    element.addEventListener(Events/* default */.A.MOUSE_CLICK, mouseEventHandlers/* mouseClick */.q_);
    element.addEventListener(Events/* default */.A.MOUSE_DOWN, mouseEventHandlers/* mouseDown */.cT);
    element.addEventListener(Events/* default */.A.MOUSE_DOWN_ACTIVATE, mouseEventHandlers/* mouseDownActivate */.Xd);
    element.addEventListener(Events/* default */.A.MOUSE_DOUBLE_CLICK, mouseEventHandlers/* mouseDoubleClick */.LM);
    element.addEventListener(Events/* default */.A.MOUSE_DRAG, mouseEventHandlers/* mouseDrag */.al);
    element.addEventListener(Events/* default */.A.MOUSE_MOVE, mouseEventHandlers/* mouseMove */.tG);
    element.addEventListener(Events/* default */.A.MOUSE_UP, mouseEventHandlers/* mouseUp */.Je);
    element.addEventListener(Events/* default */.A.MOUSE_WHEEL, mouseEventHandlers/* mouseWheel */.rO);
};
const mouseToolEventDispatcher_disable = function (element) {
    element.removeEventListener(Events/* default */.A.MOUSE_CLICK, mouseEventHandlers/* mouseClick */.q_);
    element.removeEventListener(Events/* default */.A.MOUSE_DOWN, mouseEventHandlers/* mouseDown */.cT);
    element.removeEventListener(Events/* default */.A.MOUSE_DOWN_ACTIVATE, mouseEventHandlers/* mouseDownActivate */.Xd);
    element.removeEventListener(Events/* default */.A.MOUSE_DOUBLE_CLICK, mouseEventHandlers/* mouseDoubleClick */.LM);
    element.removeEventListener(Events/* default */.A.MOUSE_DRAG, mouseEventHandlers/* mouseDrag */.al);
    element.removeEventListener(Events/* default */.A.MOUSE_MOVE, mouseEventHandlers/* mouseMove */.tG);
    element.removeEventListener(Events/* default */.A.MOUSE_UP, mouseEventHandlers/* mouseUp */.Je);
    element.removeEventListener(Events/* default */.A.MOUSE_WHEEL, mouseEventHandlers/* mouseWheel */.rO);
};
const mouseToolEventDispatcher = {
    enable: mouseToolEventDispatcher_enable,
    disable: mouseToolEventDispatcher_disable,
};
/* harmony default export */ const eventDispatchers_mouseToolEventDispatcher = (mouseToolEventDispatcher);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/index.js + 4 modules
var keyboardEventHandlers = __webpack_require__(74690);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js


const keyboardToolEventDispatcher_enable = function (element) {
    element.addEventListener(Events/* default */.A.KEY_DOWN, keyboardEventHandlers/* keyDown */.u);
    element.addEventListener(Events/* default */.A.KEY_UP, keyboardEventHandlers/* keyUp */.L);
};
const keyboardToolEventDispatcher_disable = function (element) {
    element.removeEventListener(Events/* default */.A.KEY_DOWN, keyboardEventHandlers/* keyDown */.u);
    element.removeEventListener(Events/* default */.A.KEY_UP, keyboardEventHandlers/* keyUp */.L);
};
const keyboardToolEventDispatcher = {
    enable: keyboardToolEventDispatcher_enable,
    disable: keyboardToolEventDispatcher_disable,
};
/* harmony default export */ const eventDispatchers_keyboardToolEventDispatcher = (keyboardToolEventDispatcher);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js
var getToolsWithModesForMouseEvent = __webpack_require__(70333);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js



const { Active, Passive, Enabled } = enums.ToolModes;
const onCameraModified = function (evt) {
    const enabledTools = (0,getToolsWithModesForMouseEvent/* default */.A)(evt, [
        Active,
        Passive,
        Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onCameraModified) {
            tool.onCameraModified(evt);
        }
    });
};
const cameraModifiedEventDispatcher_enable = function (element) {
    element.addEventListener(esm.Enums.Events.CAMERA_MODIFIED, onCameraModified);
};
const cameraModifiedEventDispatcher_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.CAMERA_MODIFIED, onCameraModified);
};
/* harmony default export */ const cameraModifiedEventDispatcher = ({
    enable: cameraModifiedEventDispatcher_enable,
    disable: cameraModifiedEventDispatcher_disable,
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js



const { Active: imageSpacingCalibratedEventDispatcher_Active, Passive: imageSpacingCalibratedEventDispatcher_Passive, Enabled: imageSpacingCalibratedEventDispatcher_Enabled } = enums.ToolModes;
const onImageSpacingCalibrated = function (evt) {
    const enabledTools = (0,getToolsWithModesForMouseEvent/* default */.A)(evt, [
        imageSpacingCalibratedEventDispatcher_Active,
        imageSpacingCalibratedEventDispatcher_Passive,
        imageSpacingCalibratedEventDispatcher_Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onImageSpacingCalibrated) {
            tool.onImageSpacingCalibrated(evt);
        }
    });
};
const imageSpacingCalibratedEventDispatcher_enable = function (element) {
    element.addEventListener(esm.Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
const imageSpacingCalibratedEventDispatcher_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
/* harmony default export */ const imageSpacingCalibratedEventDispatcher = ({
    enable: imageSpacingCalibratedEventDispatcher_enable,
    disable: imageSpacingCalibratedEventDispatcher_disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/index.js + 8 modules
var touchEventHandlers = __webpack_require__(84971);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js


const touchToolEventDispatcher_enable = function (element) {
    element.addEventListener(Events/* default */.A.TOUCH_START, touchEventHandlers/* touchStart */.gX);
    element.addEventListener(Events/* default */.A.TOUCH_START_ACTIVATE, touchEventHandlers/* touchStartActivate */.$F);
    element.addEventListener(Events/* default */.A.TOUCH_DRAG, touchEventHandlers/* touchDrag */.Oz);
    element.addEventListener(Events/* default */.A.TOUCH_END, touchEventHandlers/* touchEnd */.ls);
    element.addEventListener(Events/* default */.A.TOUCH_TAP, touchEventHandlers/* touchTap */.lI);
    element.addEventListener(Events/* default */.A.TOUCH_PRESS, touchEventHandlers/* touchPress */.x5);
};
const touchToolEventDispatcher_disable = function (element) {
    element.removeEventListener(Events/* default */.A.TOUCH_START, touchEventHandlers/* touchStart */.gX);
    element.removeEventListener(Events/* default */.A.TOUCH_START_ACTIVATE, touchEventHandlers/* touchStartActivate */.$F);
    element.removeEventListener(Events/* default */.A.TOUCH_DRAG, touchEventHandlers/* touchDrag */.Oz);
    element.removeEventListener(Events/* default */.A.TOUCH_END, touchEventHandlers/* touchEnd */.ls);
    element.removeEventListener(Events/* default */.A.TOUCH_PRESS, touchEventHandlers/* touchPress */.x5);
};
const touchToolEventDispatcher = {
    enable: touchToolEventDispatcher_enable,
    disable: touchToolEventDispatcher_disable,
};
/* harmony default export */ const eventDispatchers_touchToolEventDispatcher = (touchToolEventDispatcher);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js + 8 modules
var InterpolationManager = __webpack_require__(15773);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js



const annotationInterpolationEventDispatcher_enable = function () {
    esm.eventTarget.addEventListener(Events/* default */.A.ANNOTATION_COMPLETED, InterpolationManager/* default */.A.handleAnnotationCompleted);
    esm.eventTarget.addEventListener(Events/* default */.A.ANNOTATION_MODIFIED, InterpolationManager/* default */.A.handleAnnotationUpdate);
    esm.eventTarget.addEventListener(Events/* default */.A.ANNOTATION_REMOVED, InterpolationManager/* default */.A.handleAnnotationDelete);
};
const annotationInterpolationEventDispatcher_disable = function () {
    esm.eventTarget.removeEventListener(Events/* default */.A.ANNOTATION_COMPLETED, InterpolationManager/* default */.A.handleAnnotationCompleted);
    esm.eventTarget.removeEventListener(Events/* default */.A.ANNOTATION_MODIFIED, InterpolationManager/* default */.A.handleAnnotationUpdate);
    esm.eventTarget.removeEventListener(Events/* default */.A.ANNOTATION_REMOVED, InterpolationManager/* default */.A.handleAnnotationDelete);
};
/* harmony default export */ const annotationInterpolationEventDispatcher = ({
    enable: annotationInterpolationEventDispatcher_enable,
    disable: annotationInterpolationEventDispatcher_disable,
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js



const { Active: cameraResetEventDispatcher_Active, Passive: cameraResetEventDispatcher_Passive, Enabled: cameraResetEventDispatcher_Enabled } = enums.ToolModes;
const onCameraReset = function (evt) {
    const enabledTools = (0,getToolsWithModesForMouseEvent/* default */.A)(evt, [
        cameraResetEventDispatcher_Active,
        cameraResetEventDispatcher_Passive,
        cameraResetEventDispatcher_Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onResetCamera) {
            tool.onResetCamera(evt);
        }
    });
};
const cameraResetEventDispatcher_enable = function (element) {
    element.addEventListener(esm.Enums.Events.CAMERA_RESET, onCameraReset);
};
const cameraResetEventDispatcher_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.CAMERA_RESET, onCameraReset);
};
/* harmony default export */ const cameraResetEventDispatcher = ({
    enable: cameraResetEventDispatcher_enable,
    disable: cameraResetEventDispatcher_disable,
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/index.js










// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js
var state = __webpack_require__(85204);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js
var AnnotationRenderingEngine = __webpack_require__(39011);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js




function addEnabledElement(evt) {
    const { element, viewportId } = evt.detail;
    const svgLayer = _createSvgAnnotationLayer(viewportId);
    _setSvgNodeCache(element);
    _appendChild(svgLayer, element);
    AnnotationRenderingEngine/* annotationRenderingEngine */.o.addViewportElement(viewportId, element);
    eventListeners/* mouseEventListeners */.bH.enable(element);
    eventListeners/* wheelEventListener */.CG.enable(element);
    eventListeners/* touchEventListeners */.F_.enable(element);
    eventListeners/* keyEventListener */.kt.enable(element);
    eventListeners/* imageChangeEventListener */._9.enable(element);
    imageRenderedEventDispatcher.enable(element);
    cameraModifiedEventDispatcher.enable(element);
    imageSpacingCalibratedEventDispatcher.enable(element);
    cameraResetEventDispatcher.enable(element);
    eventDispatchers_mouseToolEventDispatcher.enable(element);
    eventDispatchers_keyboardToolEventDispatcher.enable(element);
    eventDispatchers_touchToolEventDispatcher.enable(element);
    state/* state */.wk.enabledElements.push(element);
}
function _createSvgAnnotationLayer(viewportId) {
    const svgns = 'http://www.w3.org/2000/svg';
    const svgLayer = document.createElementNS(svgns, 'svg');
    const svgLayerId = `svg-layer-${viewportId}`;
    svgLayer.classList.add('svg-layer');
    svgLayer.setAttribute('id', svgLayerId);
    svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svgLayer.style.width = '100%';
    svgLayer.style.height = '100%';
    svgLayer.style.pointerEvents = 'none';
    svgLayer.style.position = 'absolute';
    const defs = document.createElementNS(svgns, 'defs');
    const filter = document.createElementNS(svgns, 'filter');
    const feOffset = document.createElementNS(svgns, 'feOffset');
    const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');
    const feBlend = document.createElementNS(svgns, 'feBlend');
    filter.setAttribute('id', `shadow-${svgLayerId}`);
    filter.setAttribute('filterUnits', 'userSpaceOnUse');
    feOffset.setAttribute('result', 'offOut');
    feOffset.setAttribute('in', 'SourceGraphic');
    feOffset.setAttribute('dx', '0.5');
    feOffset.setAttribute('dy', '0.5');
    feColorMatrix.setAttribute('result', 'matrixOut');
    feColorMatrix.setAttribute('in', 'offOut');
    feColorMatrix.setAttribute('in2', 'matrix');
    feColorMatrix.setAttribute('values', '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0');
    feBlend.setAttribute('in', 'SourceGraphic');
    feBlend.setAttribute('in2', 'matrixOut');
    feBlend.setAttribute('mode', 'normal');
    filter.appendChild(feOffset);
    filter.appendChild(feColorMatrix);
    filter.appendChild(feBlend);
    defs.appendChild(filter);
    svgLayer.appendChild(defs);
    return svgLayer;
}
function _setSvgNodeCache(element) {
    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
    const elementHash = `${viewportId}:${renderingEngineId}`;
    state/* state */.wk.svgNodeCache[elementHash] = {};
}
function _appendChild(newNode, referenceNode) {
    referenceNode.querySelector('div.viewport-element').appendChild(newNode);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js
var store_filterToolsWithAnnotationsForElement = __webpack_require__(57725);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js
var utilities_getToolsWithModesForElement = __webpack_require__(39848);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js
var stateManagement = __webpack_require__(6802);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js

function getSynchronizersForViewport(viewportId, renderingEngineId) {
    const synchronizersFilteredByIds = [];
    if (!renderingEngineId && !viewportId) {
        throw new Error('At least one of renderingEngineId or viewportId should be given');
    }
    for (let i = 0; i < state/* state */.wk.synchronizers.length; i++) {
        const synchronizer = state/* state */.wk.synchronizers[i];
        const notDisabled = !synchronizer.isDisabled();
        const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);
        const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);
        if (notDisabled && (hasSourceViewport || hasTargetViewport)) {
            synchronizersFilteredByIds.push(synchronizer);
        }
    }
    return synchronizersFilteredByIds;
}
/* harmony default export */ const SynchronizerManager_getSynchronizersForViewport = (getSynchronizersForViewport);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js
var getToolGroupForViewport = __webpack_require__(65136);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js











const VIEWPORT_ELEMENT = 'viewport-element';
function removeEnabledElement(elementDisabledEvt) {
    const { element, viewportId } = elementDisabledEvt.detail;
    _resetSvgNodeCache(element);
    _removeSvgNode(element);
    AnnotationRenderingEngine/* annotationRenderingEngine */.o.removeViewportElement(viewportId, element);
    eventListeners/* mouseEventListeners */.bH.disable(element);
    eventListeners/* wheelEventListener */.CG.disable(element);
    eventListeners/* touchEventListeners */.F_.disable(element);
    eventListeners/* keyEventListener */.kt.disable(element);
    eventListeners/* imageChangeEventListener */._9.disable(element);
    imageRenderedEventDispatcher.disable(element);
    cameraModifiedEventDispatcher.disable(element);
    imageSpacingCalibratedEventDispatcher.disable(element);
    cameraResetEventDispatcher.disable(element);
    eventDispatchers_mouseToolEventDispatcher.disable(element);
    eventDispatchers_keyboardToolEventDispatcher.disable(element);
    eventDispatchers_touchToolEventDispatcher.disable(element);
    _removeViewportFromSynchronizers(element);
    _removeViewportFromToolGroup(element);
    _removeEnabledElement(element);
}
const _removeViewportFromSynchronizers = (element) => {
    const enabledElement = (0,esm.getEnabledElement)(element);
    const synchronizers = SynchronizerManager_getSynchronizersForViewport(enabledElement.viewportId, enabledElement.renderingEngineId);
    synchronizers.forEach((sync) => {
        sync.remove(enabledElement);
    });
};
const _removeViewportFromToolGroup = (element) => {
    const { renderingEngineId, viewportId } = (0,esm.getEnabledElement)(element);
    const toolGroup = (0,getToolGroupForViewport/* default */.A)(viewportId, renderingEngineId);
    if (toolGroup) {
        toolGroup.removeViewports(renderingEngineId, viewportId);
    }
};
const _removeAllToolsForElement = function (element) {
    const tools = getToolsWithModesForElement(element, [
        ToolModes.Active,
        ToolModes.Passive,
    ]);
    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);
    toolsWithData.forEach(({ annotations }) => {
        annotations.forEach((annotation) => {
            removeAnnotation(annotation.annotationUID);
        });
    });
};
function _resetSvgNodeCache(element) {
    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
    const elementHash = `${viewportId}:${renderingEngineId}`;
    delete state/* state */.wk.svgNodeCache[elementHash];
}
function _removeSvgNode(element) {
    const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);
    const svgLayer = internalViewportNode.querySelector('svg');
    if (svgLayer) {
        internalViewportNode.removeChild(svgLayer);
    }
}
const _removeEnabledElement = function (element) {
    const foundElementIndex = state/* state */.wk.enabledElements.findIndex((el) => el === element);
    if (foundElementIndex > -1) {
        state/* state */.wk.enabledElements.splice(foundElementIndex, 1);
    }
};
/* harmony default export */ const store_removeEnabledElement = (removeEnabledElement);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js



function cancelActiveManipulations(element) {
    const tools = (0,utilities_getToolsWithModesForElement/* default */.A)(element, [
        enums.ToolModes.Active,
        enums.ToolModes.Passive,
    ]);
    const toolsWithData = (0,store_filterToolsWithAnnotationsForElement/* default */.A)(element, tools);
    for (const { tool } of toolsWithData) {
        const annotationUID = tool.cancel(element);
        if (annotationUID) {
            return annotationUID;
        }
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js

class Synchronizer {
    constructor(synchronizerId, eventName, eventHandler, options) {
        this._viewportOptions = {};
        this._onEvent = (evt) => {
            if (this._ignoreFiredEvents === true) {
                return;
            }
            if (!this._targetViewports.length) {
                return;
            }
            const enabledElement = this._eventSource === 'element'
                ? (0,esm.getEnabledElement)(evt.currentTarget)
                : (0,esm.getEnabledElementByViewportId)(evt.detail?.viewportId);
            if (!enabledElement) {
                return;
            }
            const { renderingEngineId, viewportId } = enabledElement;
            if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {
                return;
            }
            this.fireEvent({
                renderingEngineId,
                viewportId,
            }, evt);
        };
        this._enabled = true;
        this._eventName = eventName;
        this._eventHandler = eventHandler;
        this._ignoreFiredEvents = false;
        this._sourceViewports = [];
        this._targetViewports = [];
        this._options = options || {};
        this._eventSource = this._options.eventSource || 'element';
        this._auxiliaryEvents = this._options.auxiliaryEvents || [];
        this.id = synchronizerId;
    }
    isDisabled() {
        return !this._enabled || !this._hasSourceElements();
    }
    setOptions(viewportId, options = {}) {
        this._viewportOptions[viewportId] = options;
    }
    setEnabled(enabled) {
        this._enabled = enabled;
    }
    getOptions(viewportId) {
        return this._viewportOptions[viewportId];
    }
    add(viewportInfo) {
        this.addTarget(viewportInfo);
        this.addSource(viewportInfo);
    }
    addSource(viewportInfo) {
        if (_containsViewport(this._sourceViewports, viewportInfo)) {
            return;
        }
        const { renderingEngineId, viewportId } = viewportInfo;
        const viewport = (0,esm.getRenderingEngine)(renderingEngineId).getViewport(viewportId);
        if (!viewport) {
            console.warn(`Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`);
            return;
        }
        const eventSource = this._eventSource === 'element' ? viewport.element : esm.eventTarget;
        eventSource.addEventListener(this._eventName, this._onEvent.bind(this));
        this._auxiliaryEvents.forEach(({ name, source }) => {
            const target = source === 'element' ? viewport.element : esm.eventTarget;
            target.addEventListener(name, this._onEvent.bind(this));
        });
        this._updateDisableHandlers();
        this._sourceViewports.push(viewportInfo);
    }
    addTarget(viewportInfo) {
        if (_containsViewport(this._targetViewports, viewportInfo)) {
            return;
        }
        this._targetViewports.push(viewportInfo);
        this._updateDisableHandlers();
    }
    getSourceViewports() {
        return this._sourceViewports;
    }
    getTargetViewports() {
        return this._targetViewports;
    }
    destroy() {
        this._sourceViewports.forEach((s) => this.removeSource(s));
        this._targetViewports.forEach((t) => this.removeTarget(t));
    }
    remove(viewportInfo) {
        this.removeTarget(viewportInfo);
        this.removeSource(viewportInfo);
    }
    removeSource(viewportInfo) {
        const index = _getViewportIndex(this._sourceViewports, viewportInfo);
        if (index === -1) {
            return;
        }
        const eventSource = this._eventSource === 'element'
            ? this.getViewportElement(viewportInfo)
            : esm.eventTarget;
        this._sourceViewports.splice(index, 1);
        eventSource.removeEventListener(this._eventName, this._eventHandler);
        this._auxiliaryEvents.forEach(({ name, source }) => {
            const target = source === 'element'
                ? this.getViewportElement(viewportInfo)
                : esm.eventTarget;
            target.removeEventListener(name, this._eventHandler);
        });
        this._updateDisableHandlers();
    }
    removeTarget(viewportInfo) {
        const index = _getViewportIndex(this._targetViewports, viewportInfo);
        if (index === -1) {
            return;
        }
        this._targetViewports.splice(index, 1);
        this._updateDisableHandlers();
    }
    hasSourceViewport(renderingEngineId, viewportId) {
        return _containsViewport(this._sourceViewports, {
            renderingEngineId,
            viewportId,
        });
    }
    hasTargetViewport(renderingEngineId, viewportId) {
        return _containsViewport(this._targetViewports, {
            renderingEngineId,
            viewportId,
        });
    }
    fireEvent(sourceViewport, sourceEvent) {
        if (this.isDisabled() || this._ignoreFiredEvents) {
            return;
        }
        this._ignoreFiredEvents = true;
        const promises = [];
        try {
            for (let i = 0; i < this._targetViewports.length; i++) {
                const targetViewport = this._targetViewports[i];
                const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;
                if (targetIsSource) {
                    continue;
                }
                const result = this._eventHandler(this, sourceViewport, targetViewport, sourceEvent, this._options);
                if (result instanceof Promise) {
                    promises.push(result);
                }
            }
        }
        catch (ex) {
            console.warn(`Synchronizer, for: ${this._eventName}`, ex);
        }
        finally {
            if (promises.length) {
                Promise.allSettled(promises).then(() => {
                    this._ignoreFiredEvents = false;
                });
            }
            else {
                this._ignoreFiredEvents = false;
            }
        }
    }
    _hasSourceElements() {
        return this._sourceViewports.length !== 0;
    }
    _updateDisableHandlers() {
        const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);
        const _remove = this.remove.bind(this);
        const disableHandler = (elementDisabledEvent) => {
            _remove(elementDisabledEvent.detail.element);
        };
        viewports.forEach((vp) => {
            const eventSource = this.getEventSource(vp);
            eventSource.removeEventListener(esm.Enums.Events.ELEMENT_DISABLED, disableHandler);
            eventSource.addEventListener(esm.Enums.Events.ELEMENT_DISABLED, disableHandler);
        });
    }
    getEventSource(viewportInfo) {
        return this._eventSource === 'element'
            ? this.getViewportElement(viewportInfo)
            : esm.eventTarget;
    }
    getViewportElement(viewportInfo) {
        const { renderingEngineId, viewportId } = viewportInfo;
        const renderingEngine = (0,esm.getRenderingEngine)(renderingEngineId);
        if (!renderingEngine) {
            throw new Error(`No RenderingEngine for Id: ${renderingEngineId}`);
        }
        return renderingEngine.getViewport(viewportId).element;
    }
}
function _getUniqueViewports(vp1, vp2) {
    const unique = [];
    const vps = vp1.concat(vp2);
    for (let i = 0; i < vps.length; i++) {
        const vp = vps[i];
        if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId &&
            vp.viewportId === u.viewportId)) {
            unique.push(vp);
        }
    }
    return unique;
}
function _getViewportIndex(arr, vp) {
    return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId &&
        vp.viewportId === ar.viewportId);
}
function _containsViewport(arr, vp) {
    return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId &&
        ar.viewportId === vp.viewportId);
}
/* harmony default export */ const SynchronizerManager_Synchronizer = (Synchronizer);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js
var svgNodeCache = __webpack_require__(48145);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js + 7 modules
var ToolGroupManager = __webpack_require__(7754);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js


function createSynchronizer(synchronizerId, eventName, eventHandler, options) {
    const synchronizerWithSameIdExists = state/* state */.wk.synchronizers.some((sync) => sync.id === synchronizerId);
    if (synchronizerWithSameIdExists) {
        throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);
    }
    const synchronizer = new SynchronizerManager_Synchronizer(synchronizerId, eventName, eventHandler, options);
    state/* state */.wk.synchronizers.push(synchronizer);
    return synchronizer;
}
/* harmony default export */ const SynchronizerManager_createSynchronizer = (createSynchronizer);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js

function destroy() {
    while (state/* state */.wk.synchronizers.length > 0) {
        const synchronizer = state/* state */.wk.synchronizers.pop();
        synchronizer.destroy();
    }
}
/* harmony default export */ const SynchronizerManager_destroy = (destroy);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js

function getSynchronizer(synchronizerId) {
    return state/* state */.wk.synchronizers.find((s) => s.id === synchronizerId);
}
/* harmony default export */ const SynchronizerManager_getSynchronizer = (getSynchronizer);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js

function getAllSynchronizers() {
    return state/* state */.wk.synchronizers;
}
/* harmony default export */ const SynchronizerManager_getAllSynchronizers = (getAllSynchronizers);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js

function destroySynchronizer(synchronizerId) {
    const synchronizerIndex = state/* state */.wk.synchronizers.findIndex((sync) => sync.id === synchronizerId);
    if (synchronizerIndex > -1) {
        const synchronizer = state/* state */.wk.synchronizers[synchronizerIndex];
        synchronizer.destroy();
        state/* state */.wk.synchronizers.splice(synchronizerIndex, 1);
    }
}
/* harmony default export */ const SynchronizerManager_destroySynchronizer = (destroySynchronizer);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js








;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/index.js










// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var SegmentationRenderingEngine = __webpack_require__(24917);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js

const segmentationRepresentationModifiedListener = function (evt) {
    const { viewportId } = evt.detail;
    (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)(viewportId);
};
/* harmony default export */ const segmentation_segmentationRepresentationModifiedListener = (segmentationRepresentationModifiedListener);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/init.js










let csToolsInitialized = false;
function init(defaultConfiguration = {}) {
    if (csToolsInitialized) {
        return;
    }
    _addCornerstoneEventListeners();
    _addCornerstoneToolsEventListeners();
    csToolsInitialized = true;
}
function init_destroy() {
    _removeCornerstoneEventListeners();
    _removeCornerstoneToolsEventListeners();
    ToolGroupManager.destroy();
    (0,state/* resetCornerstoneToolsState */.qh)();
    const annotationManager = (0,annotationState.getAnnotationManager)();
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    annotationManager.restoreAnnotations({});
    segmentationStateManager.resetState();
    csToolsInitialized = false;
}
function _addCornerstoneEventListeners() {
    _removeCornerstoneEventListeners();
    const elementEnabledEvent = esm.Enums.Events.ELEMENT_ENABLED;
    const elementDisabledEvent = esm.Enums.Events.ELEMENT_DISABLED;
    esm.eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);
    esm.eventTarget.addEventListener(elementDisabledEvent, store_removeEnabledElement);
    annotationInterpolationEventDispatcher.enable();
}
function _removeCornerstoneEventListeners() {
    const elementEnabledEvent = esm.Enums.Events.ELEMENT_ENABLED;
    const elementDisabledEvent = esm.Enums.Events.ELEMENT_DISABLED;
    esm.eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);
    esm.eventTarget.removeEventListener(elementDisabledEvent, store_removeEnabledElement);
    annotationInterpolationEventDispatcher.disable();
}
function _addCornerstoneToolsEventListeners() {
    _removeCornerstoneToolsEventListeners();
    esm.eventTarget.addEventListener(enums.Events.ANNOTATION_COMPLETED, eventListeners/* annotationCompletedListener */.tQ);
    esm.eventTarget.addEventListener(enums.Events.ANNOTATION_MODIFIED, eventListeners/* annotationModifiedListener */.nm);
    esm.eventTarget.addEventListener(enums.Events.ANNOTATION_SELECTION_CHANGE, eventListeners/* annotationSelectionListener */.ge);
    esm.eventTarget.addEventListener(enums.Events.ANNOTATION_SELECTION_CHANGE, eventListeners/* annotationSelectionListener */.ge);
    esm.eventTarget.addEventListener(enums.Events.ANNOTATION_REMOVED, eventListeners/* annotationRemovedListener */.Gg);
    esm.eventTarget.addEventListener(enums.Events.SEGMENTATION_MODIFIED, eventListeners/* segmentationModifiedListener */.sp);
    esm.eventTarget.addEventListener(enums.Events.SEGMENTATION_DATA_MODIFIED, eventListeners/* segmentationDataModifiedEventListener */.qI);
    esm.eventTarget.addEventListener(enums.Events.SEGMENTATION_REPRESENTATION_MODIFIED, segmentation_segmentationRepresentationModifiedListener);
    esm.eventTarget.addEventListener(enums.Events.SEGMENTATION_REPRESENTATION_ADDED, segmentation_segmentationRepresentationModifiedListener);
}
function _removeCornerstoneToolsEventListeners() {
    esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_COMPLETED, eventListeners/* annotationCompletedListener */.tQ);
    esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_MODIFIED, eventListeners/* annotationModifiedListener */.nm);
    esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_SELECTION_CHANGE, eventListeners/* annotationSelectionListener */.ge);
    esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_SELECTION_CHANGE, eventListeners/* annotationSelectionListener */.ge);
    esm.eventTarget.removeEventListener(enums.Events.SEGMENTATION_MODIFIED, eventListeners/* segmentationModifiedListener */.sp);
    esm.eventTarget.removeEventListener(enums.Events.SEGMENTATION_DATA_MODIFIED, eventListeners/* segmentationDataModifiedEventListener */.qI);
    esm.eventTarget.removeEventListener(enums.Events.SEGMENTATION_REPRESENTATION_MODIFIED, segmentation_segmentationRepresentationModifiedListener);
    esm.eventTarget.removeEventListener(enums.Events.SEGMENTATION_REPRESENTATION_ADDED, segmentation_segmentationRepresentationModifiedListener);
}
/* harmony default export */ const esm_init = ((/* unused pure expression or super */ null && (init)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js
var COLOR_LUT = __webpack_require__(93952);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/constants/index.js



;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js

function cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {
    const { camera } = cameraModifiedEvent.detail;
    const renderingEngine = (0,esm.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    tViewport.setCamera(camera);
    tViewport.render();
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js



const { CAMERA_MODIFIED } = esm.Enums.Events;
function createCameraPositionSynchronizer(synchronizerName) {
    const cameraPositionSynchronizer = SynchronizerManager_createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);
    return cameraPositionSynchronizer;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js

function presentationViewSyncCallback(_synchronizerInstance, sourceViewport, targetViewport, _sourceEvent, options) {
    const renderingEngine = (0,esm.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const presentationView = sViewport.getViewPresentation(options);
    tViewport.setViewPresentation(presentationView);
    tViewport.render();
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js



const { CAMERA_MODIFIED: createPresentationViewSynchronizer_CAMERA_MODIFIED } = esm.Enums.Events;
function createPresentationViewSynchronizer(synchronizerName, options) {
    const presentationView = SynchronizerManager_createSynchronizer(synchronizerName, createPresentationViewSynchronizer_CAMERA_MODIFIED, presentationViewSyncCallback, { viewPresentation: options });
    return presentationView;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js

function voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, modifiedEvent, options) {
    const eventDetail = modifiedEvent.detail;
    const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;
    const renderingEngine = (0,esm.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const tProperties = {
        voiRange: range,
    };
    if (options?.syncInvertState && invertStateChanged) {
        tProperties.invert = invert;
    }
    if (options?.syncColormap && colormap) {
        tProperties.colormap = colormap;
    }
    if (tViewport instanceof esm.BaseVolumeViewport) {
        const isFusion = tViewport._actors && tViewport._actors.size > 1;
        if (isFusion) {
            tViewport.setProperties(tProperties, volumeId);
        }
        else {
            tViewport.setProperties(tProperties);
        }
    }
    else if (tViewport instanceof esm.StackViewport) {
        tViewport.setProperties(tProperties);
    }
    else {
        throw new Error('Viewport type not supported.');
    }
    tViewport.render();
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js



function createVOISynchronizer(synchronizerName, options) {
    options = Object.assign({ syncInvertState: true, syncColormap: true }, options);
    const VOISynchronizer = SynchronizerManager_createSynchronizer(synchronizerName, esm.Enums.Events.VOI_MODIFIED, voiSyncCallback, {
        auxiliaryEvents: [
            {
                name: esm.Enums.Events.COLORMAP_MODIFIED,
            },
        ],
        ...options,
    });
    return VOISynchronizer;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js

function zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,esm.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const options = synchronizerInstance.getOptions(targetViewport.viewportId);
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    if (options?.syncZoom !== false) {
        const srcZoom = sViewport.getZoom();
        tViewport.setZoom(srcZoom);
    }
    if (options?.syncPan !== false) {
        const srcPan = sViewport.getPan();
        tViewport.setPan(srcPan);
    }
    tViewport.render();
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js



const { CAMERA_MODIFIED: createZoomPanSynchronizer_CAMERA_MODIFIED } = esm.Enums.Events;
function createZoomPanSynchronizer(synchronizerName) {
    const zoomPanSynchronizer = SynchronizerManager_createSynchronizer(synchronizerName, createZoomPanSynchronizer_CAMERA_MODIFIED, zoomPanSyncCallback);
    return zoomPanSynchronizer;
}

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var gl_matrix_esm = __webpack_require__(3823);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js

function areViewportsCoplanar(viewport1, viewport2) {
    const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();
    const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();
    const dotProducts = gl_matrix_esm/* vec3.dot */.eR.dot(viewPlaneNormal1, viewPlaneNormal2);
    return Math.abs(dotProducts) > 0.9;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js



const getSpatialRegistration = (targetId, sourceId) => esm.utilities.spatialRegistrationMetadataProvider.get('spatialRegistrationModule', targetId, sourceId);
async function imageSliceSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,esm.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const options = synchronizerInstance.getOptions(targetViewport.viewportId);
    if (options?.disabled) {
        return;
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const imageId1 = sViewport.getCurrentImageId();
    const imagePlaneModule1 = esm.metaData.get('imagePlaneModule', imageId1);
    const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;
    const targetImageIds = tViewport.getImageIds();
    if (!areViewportsCoplanar(sViewport, tViewport)) {
        return;
    }
    let registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
    if (!registrationMatrixMat4) {
        const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();
        const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();
        if (frameOfReferenceUID1 === frameOfReferenceUID2 &&
            options?.useInitialPosition !== false) {
            registrationMatrixMat4 = gl_matrix_esm/* mat4.identity */.pB.identity(gl_matrix_esm/* mat4.create */.pB.create());
        }
        else {
            esm.utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);
            registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
        }
        if (!registrationMatrixMat4) {
            return;
        }
    }
    const targetImagePositionPatientWithRegistrationMatrix = gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(gl_matrix_esm/* vec3.create */.eR.create(), sourceImagePositionPatient, registrationMatrixMat4);
    const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);
    let imageIndexToSet = closestImageIdIndex2.index;
    if (tViewport instanceof esm.VolumeViewport) {
        imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;
    }
    if (closestImageIdIndex2.index !== -1 &&
        tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {
        await esm.utilities.jumpToSlice(tViewport.element, {
            imageIndex: imageIndexToSet,
        });
    }
}
function _getClosestImageIdIndex(targetPoint, imageIds) {
    return imageIds.reduce((closestImageIdIndex, imageId, index) => {
        const { imagePositionPatient } = esm.metaData.get('imagePlaneModule', imageId);
        const distance = gl_matrix_esm/* vec3.distance */.eR.distance(imagePositionPatient, targetPoint);
        if (distance < closestImageIdIndex.distance) {
            return {
                distance,
                index,
            };
        }
        return closestImageIdIndex;
    }, {
        distance: Infinity,
        index: -1,
    });
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js



const { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = esm.Enums.Events;
function createImageSliceSynchronizer(synchronizerName) {
    const stackImageSynchronizer = SynchronizerManager_createSynchronizer(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {
        auxiliaryEvents: [
            {
                name: 'VOLUME_NEW_IMAGE',
            },
        ],
    });
    return stackImageSynchronizer;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js

function slabThicknessSyncCallback(_synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,esm.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const slabThickness = sViewport.getSlabThickness?.();
    if (!slabThickness) {
        return;
    }
    tViewport.setSlabThickness?.(slabThickness);
    tViewport.render();
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js



const { CAMERA_MODIFIED: createSlabThicknessSynchronizer_CAMERA_MODIFIED } = esm.Enums.Events;
function createSlabThicknessSynchronizer_createPresentationViewSynchronizer(synchronizerName) {
    const presentationView = SynchronizerManager_createSynchronizer(synchronizerName, createSlabThicknessSynchronizer_CAMERA_MODIFIED, slabThicknessSyncCallback);
    return presentationView;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js






const createStackImageSynchronizer = createImageSliceSynchronizer;


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js + 20 modules
var drawingSvg = __webpack_require__(89578);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js + 1 modules
var utilities = __webpack_require__(23566);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js + 4 modules
var cursors = __webpack_require__(79475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/types/index.js
var types = __webpack_require__(13369);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js + 1 modules
var annotation = __webpack_require__(47807);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js + 9 modules
var segmentation = __webpack_require__(1300);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js
var base = __webpack_require__(85817);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js


class PanTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    _dragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const deltaPointsWorld = deltaPoints.world;
        if (deltaPointsWorld[0] === 0 &&
            deltaPointsWorld[1] === 0 &&
            deltaPointsWorld[2] === 0) {
            return;
        }
        const camera = enabledElement.viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        enabledElement.viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        enabledElement.viewport.render();
    }
}
PanTool.toolName = 'Pan';
/* harmony default export */ const tools_PanTool = (PanTool);

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math.js
var Core_Math = __webpack_require__(84607);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js






class TrackballRotateTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            rotateIncrementDegrees: 2,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this._hasResolutionChanged = false;
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const actorEntry = viewport.getDefaultActor();
            const actor = actorEntry.actor;
            const mapper = actor.getMapper();
            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;
            if (!hasSampleDistance) {
                return true;
            }
            const originalSampleDistance = mapper.getSampleDistance();
            if (!this._hasResolutionChanged) {
                mapper.setSampleDistance(originalSampleDistance * 2);
                this._hasResolutionChanged = true;
                if (this.cleanUp !== null) {
                    document.removeEventListener('mouseup', this.cleanUp);
                }
                this.cleanUp = () => {
                    mapper.setSampleDistance(originalSampleDistance);
                    viewport.render();
                    this._hasResolutionChanged = false;
                };
                document.addEventListener('mouseup', this.cleanUp, { once: true });
            }
            return true;
        };
        this._getViewportsInfo = () => {
            const viewports = (0,ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.onSetToolActive = () => {
            const subscribeToElementResize = () => {
                const viewportsInfo = this._getViewportsInfo();
                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                    if (!this._resizeObservers.has(viewportId)) {
                        const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId) || { viewport: null };
                        if (!viewport) {
                            return;
                        }
                        const { element } = viewport;
                        const resizeObserver = new ResizeObserver(() => {
                            const element = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                            if (!element) {
                                return;
                            }
                            const { viewport } = element;
                            viewport.resetCamera();
                            viewport.render();
                        });
                        resizeObserver.observe(element);
                        this._resizeObservers.set(viewportId, resizeObserver);
                    }
                });
            };
            subscribeToElementResize();
            this._viewportAddedListener = (evt) => {
                if (evt.detail.toolGroupId === this.toolGroupId) {
                    subscribeToElementResize();
                }
            };
            esm.eventTarget.addEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
        };
        this.onSetToolDisabled = () => {
            this._resizeObservers.forEach((resizeObserver, viewportId) => {
                resizeObserver.disconnect();
                this._resizeObservers.delete(viewportId);
            });
            if (this._viewportAddedListener) {
                esm.eventTarget.removeEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
                this._viewportAddedListener = null;
            }
        };
        this.rotateCamera = (viewport, centerWorld, axis, angle) => {
            const vtkCamera = viewport.getVtkActiveCamera();
            const viewUp = vtkCamera.getViewUp();
            const focalPoint = vtkCamera.getFocalPoint();
            const position = vtkCamera.getPosition();
            const newPosition = [0, 0, 0];
            const newFocalPoint = [0, 0, 0];
            const newViewUp = [0, 0, 0];
            const transform = gl_matrix_esm/* mat4.identity */.pB.identity(new Float32Array(16));
            gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, centerWorld);
            gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, axis);
            gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, [
                -centerWorld[0],
                -centerWorld[1],
                -centerWorld[2],
            ]);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newPosition, position, transform);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newFocalPoint, focalPoint, transform);
            gl_matrix_esm/* mat4.identity */.pB.identity(transform);
            gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, axis);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newViewUp, viewUp, transform);
            viewport.setCamera({
                position: newPosition,
                viewUp: newViewUp,
                focalPoint: newFocalPoint,
            });
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _dragCallback(evt) {
        const { element, currentPoints, lastPoints } = evt.detail;
        const currentPointsCanvas = currentPoints.canvas;
        const lastPointsCanvas = lastPoints.canvas;
        const { rotateIncrementDegrees } = this.configuration;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const width = element.clientWidth;
        const height = element.clientHeight;
        const normalizedPosition = [
            currentPointsCanvas[0] / width,
            currentPointsCanvas[1] / height,
        ];
        const normalizedPreviousPosition = [
            lastPointsCanvas[0] / width,
            lastPointsCanvas[1] / height,
        ];
        const center = [width * 0.5, height * 0.5];
        const centerWorld = viewport.canvasToWorld(center);
        const normalizedCenter = [0.5, 0.5];
        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;
        const op = [normalizedPreviousPosition[0], 0, 0];
        const oe = [normalizedPosition[0], 0, 0];
        const opsq = op[0] ** 2;
        const oesq = oe[0] ** 2;
        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);
        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);
        const nop = [op[0], 0, lop];
        Core_Math/* default.normalize */.Ay.normalize(nop);
        const noe = [oe[0], 0, loe];
        Core_Math/* default.normalize */.Ay.normalize(noe);
        const dot = Core_Math/* default.dot */.Ay.dot(nop, noe);
        if (Math.abs(dot) > 0.0001) {
            const angleX = -2 *
                Math.acos(Core_Math/* default.clampValue */.Ay.clampValue(dot, -1.0, 1.0)) *
                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *
                rotateIncrementDegrees;
            const upVec = camera.viewUp;
            const atV = camera.viewPlaneNormal;
            const rightV = [0, 0, 0];
            const forwardV = [0, 0, 0];
            Core_Math/* default.cross */.Ay.cross(upVec, atV, rightV);
            Core_Math/* default.normalize */.Ay.normalize(rightV);
            Core_Math/* default.cross */.Ay.cross(atV, rightV, forwardV);
            Core_Math/* default.normalize */.Ay.normalize(forwardV);
            Core_Math/* default.normalize */.Ay.normalize(upVec);
            this.rotateCamera(viewport, centerWorld, forwardV, angleX);
            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *
                rotateIncrementDegrees;
            this.rotateCamera(viewport, centerWorld, rightV, angleY);
            viewport.render();
        }
    }
}
TrackballRotateTool.toolName = 'TrackballRotate';
/* harmony default export */ const tools_TrackballRotateTool = (TrackballRotateTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js


const DEFAULT_MULTIPLIER = 4;
const DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;
const PT = 'PT';
class WindowLevelTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {
            const middleSliceIndex = Math.floor(dimensions[2] / 2);
            const frameLength = dimensions[0] * dimensions[1];
            let bytesPerVoxel;
            let TypedArrayConstructor;
            if (scalarData instanceof Float32Array) {
                bytesPerVoxel = 4;
                TypedArrayConstructor = Float32Array;
            }
            else if (scalarData instanceof Uint8Array) {
                bytesPerVoxel = 1;
                TypedArrayConstructor = Uint8Array;
            }
            else if (scalarData instanceof Uint16Array) {
                bytesPerVoxel = 2;
                TypedArrayConstructor = Uint16Array;
            }
            else if (scalarData instanceof Int16Array) {
                bytesPerVoxel = 2;
                TypedArrayConstructor = Int16Array;
            }
            const buffer = scalarData.buffer;
            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;
            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);
            const { max, min } = this._getMinMax(frame, frameLength);
            return max - min;
        };
    }
    touchDragCallback(evt) {
        this.mouseDragCallback(evt);
    }
    mouseDragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;
        let isPreScaled = false;
        const properties = viewport.getProperties();
        if (viewport instanceof esm.VolumeViewport) {
            volumeId = viewport.getVolumeId();
            viewportsContainingVolumeUID =
                esm.utilities.getViewportsWithVolumeId(volumeId);
            ({ lower, upper } = properties.voiRange);
            const volume = esm.cache.getVolume(volumeId);
            if (!volume) {
                throw new Error('Volume not found ' + volumeId);
            }
            modality = volume.metadata.Modality;
            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;
        }
        else if (properties.voiRange) {
            modality = viewport.modality;
            ({ lower, upper } = properties.voiRange);
            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};
            isPreScaled =
                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;
        }
        else {
            throw new Error('Viewport is not a valid type');
        }
        if (modality === PT && isPreScaled) {
            newRange = this.getPTScaledNewRange({
                deltaPointsCanvas: deltaPoints.canvas,
                lower,
                upper,
                clientHeight: element.clientHeight,
                isPreScaled,
                viewport,
                volumeId,
            });
        }
        else {
            newRange = this.getNewRange({
                viewport,
                deltaPointsCanvas: deltaPoints.canvas,
                volumeId,
                lower,
                upper,
            });
        }
        if (newRange.lower >= newRange.upper) {
            return;
        }
        viewport.setProperties({
            voiRange: newRange,
        });
        viewport.render();
        if (viewport instanceof esm.VolumeViewport) {
            viewportsContainingVolumeUID.forEach((vp) => {
                if (viewport !== vp) {
                    vp.render();
                }
            });
            return;
        }
    }
    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {
        let multiplier = DEFAULT_MULTIPLIER;
        if (isPreScaled) {
            multiplier = 5 / clientHeight;
        }
        else {
            multiplier =
                this._getMultiplierFromDynamicRange(viewport, volumeId) ||
                    DEFAULT_MULTIPLIER;
        }
        const deltaY = deltaPointsCanvas[1];
        const wcDelta = deltaY * multiplier;
        upper -= wcDelta;
        upper = isPreScaled ? Math.max(upper, 0.1) : upper;
        return { lower, upper };
    }
    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {
        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||
            DEFAULT_MULTIPLIER;
        const wwDelta = deltaPointsCanvas[0] * multiplier;
        const wcDelta = deltaPointsCanvas[1] * multiplier;
        let { windowWidth, windowCenter } = esm.utilities.windowLevel.toWindowLevel(lower, upper);
        windowWidth += wwDelta;
        windowCenter += wcDelta;
        windowWidth = Math.max(windowWidth, 1);
        return esm.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);
    }
    _getMultiplierFromDynamicRange(viewport, volumeId) {
        let imageDynamicRange;
        if (volumeId) {
            const imageVolume = esm.cache.getVolume(volumeId);
            const { voxelManager } = viewport.getImageData();
            const middleSlicePixelData = voxelManager.getMiddleSliceData();
            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {
                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];
            }, [Infinity, -Infinity]);
            const BitsStored = imageVolume?.metadata?.BitsStored;
            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;
            imageDynamicRange = Math.min(calculatedDynamicRange, metadataDynamicRange);
        }
        else {
            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);
        }
        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;
        return ratio > 1 ? Math.round(ratio) : ratio;
    }
    _getImageDynamicRangeFromViewport(viewport) {
        const { imageData, voxelManager } = viewport.getImageData();
        if (voxelManager?.getRange) {
            const range = voxelManager.getRange();
            return range[1] - range[0];
        }
        const dimensions = imageData.getDimensions();
        if (imageData.getRange) {
            const imageDataRange = imageData.getRange();
            return imageDataRange[1] - imageDataRange[0];
        }
        let scalarData;
        if (imageData.getScalarData) {
            scalarData = imageData.getScalarData();
        }
        else {
            scalarData = imageData.getPointData().getScalars().getData();
        }
        if (dimensions[2] !== 1) {
            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);
        }
        let range;
        if (scalarData.getRange) {
            range = scalarData.getRange();
        }
        else {
            const { min, max } = this._getMinMax(scalarData, scalarData.length);
            range = [min, max];
        }
        return range[1] - range[0];
    }
    _getMinMax(frame, frameLength) {
        let min = Infinity;
        let max = -Infinity;
        for (let i = 0; i < frameLength; i++) {
            const voxel = frame[i];
            if (voxel < min) {
                min = voxel;
            }
            if (voxel > max) {
                max = voxel;
            }
        }
        return { max, min };
    }
}
WindowLevelTool.toolName = 'WindowLevel';
/* harmony default export */ const tools_WindowLevelTool = (WindowLevelTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js
var helpers_state = __webpack_require__(44049);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js + 4 modules
var viewportFilters = __webpack_require__(8056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor = __webpack_require__(7001);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js
var triggerAnnotationRenderForViewportIds = __webpack_require__(58640);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/index.js + 4 modules
var voi = __webpack_require__(93575);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js











class WindowLevelRegionTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            minWindowWidth: 10,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                    },
                    cachedStats: {},
                },
            };
            (0,stateManagement/* addAnnotation */.lC)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            (0,stateManagement/* removeAnnotation */.O8)(annotation.annotationUID);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            this.applyWindowLevelRegion(annotation, element);
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            const { currentPoints } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
            const worldPos = currentPoints.world;
            const { points } = data.handles;
            const DEFAULT_HANDLE_INDEX = 3;
            points[DEFAULT_HANDLE_INDEX] = [...worldPos];
            const bottomLeftCanvas = worldToCanvas(points[0]);
            const topRightCanvas = worldToCanvas(points[3]);
            const bottomRightCanvas = [
                topRightCanvas[0],
                bottomLeftCanvas[1],
            ];
            const topLeftCanvas = [
                bottomLeftCanvas[0],
                topRightCanvas[1],
            ];
            const bottomRightWorld = canvasToWorld(bottomRightCanvas);
            const topLeftWorld = canvasToWorld(topLeftCanvas);
            points[1] = bottomRightWorld;
            points[2] = topLeftWorld;
            annotation.invalidated = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,stateManagement/* getAnnotations */.Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const dataId = `${annotationUID}-rect`;
                const rectangleUID = '0';
                (0,drawingSvg.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                renderStatus = true;
            }
            return renderStatus;
        };
        this.applyWindowLevelRegion = (annotation, element) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const imageData = voi.windowLevel.extractWindowLevelRegionToolData(viewport);
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const startCanvas = canvasCoordinates[0];
            const endCanvas = canvasCoordinates[3];
            let left = Math.min(startCanvas[0], endCanvas[0]);
            let top = Math.min(startCanvas[1], endCanvas[1]);
            let width = Math.abs(startCanvas[0] - endCanvas[0]);
            let height = Math.abs(startCanvas[1] - endCanvas[1]);
            left = esm.utilities.clip(left, 0, imageData.width);
            top = esm.utilities.clip(top, 0, imageData.height);
            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));
            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));
            const pixelLuminanceData = voi.windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);
            const minMaxMean = voi.windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);
            if (this.configuration.minWindowWidth === undefined) {
                this.configuration.minWindowWidth = 10;
            }
            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);
            const windowCenter = minMaxMean.mean;
            const voiRange = esm.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);
            viewport.setProperties({ voiRange });
            viewport.render();
        };
        this.cancel = () => {
            return null;
        };
        this.isPointNearTool = () => {
            return null;
        };
        this.toolSelectedCallback = () => {
            return null;
        };
        this.handleSelectedCallback = () => {
            return null;
        };
        this._activateModify = () => {
            return null;
        };
        this._deactivateModify = () => {
            return null;
        };
    }
}
WindowLevelRegionTool.toolName = 'WindowLevelRegion';
/* harmony default export */ const tools_WindowLevelRegionTool = (WindowLevelRegionTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js


class StackScrollTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            invert: false,
            debounceIfNotLoaded: true,
            loop: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.deltaY = 1;
    }
    mouseWheelCallback(evt) {
        this._scroll(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    _dragCallback(evt) {
        this._scrollDrag(evt);
    }
    _scrollDrag(evt) {
        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;
        const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
        const { debounceIfNotLoaded, invert, loop } = this.configuration;
        const deltaPointY = deltaPoints.canvas[1];
        let volumeId;
        if (viewport instanceof esm.VolumeViewport) {
            volumeId = viewport.getVolumeId();
        }
        const pixelsPerImage = this._getPixelPerImage(viewport);
        const deltaY = deltaPointY + this.deltaY;
        if (!pixelsPerImage) {
            return;
        }
        if (Math.abs(deltaY) >= pixelsPerImage) {
            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);
            esm.utilities.scroll(viewport, {
                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,
                volumeId,
                debounceLoading: debounceIfNotLoaded,
                loop: loop,
            });
            this.deltaY = deltaY % pixelsPerImage;
        }
        else {
            this.deltaY = deltaY;
        }
    }
    _scroll(evt) {
        const { wheel, element } = evt.detail;
        const { direction } = wheel;
        const { invert } = this.configuration;
        const { viewport } = (0,esm.getEnabledElement)(element);
        const delta = direction * (invert ? -1 : 1);
        esm.utilities.scroll(viewport, {
            delta,
            debounceLoading: this.configuration.debounceIfNotLoaded,
            loop: this.configuration.loop,
            volumeId: viewport instanceof esm.BaseVolumeViewport
                ? viewport.getVolumeId()
                : undefined,
            scrollSlabs: this.configuration.scrollSlabs,
        });
    }
    _getPixelPerImage(viewport) {
        const { element } = viewport;
        const numberOfSlices = viewport.getNumberOfSlices();
        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));
    }
}
StackScrollTool.toolName = 'StackScroll';
/* harmony default export */ const tools_StackScrollTool = (StackScrollTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js
var angleBetweenLines = __webpack_require__(25963);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js




class PlanarRotateTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.mouseWheelCallback = (evt) => {
            const { element, wheel } = evt.detail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { invert } = this.configuration;
            const angle = wheel.direction * 10 * (invert ? -1 : 1);
            this.setAngle(viewport, angle);
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _dragCallback(evt) {
        const { element, currentPoints, startPoints } = evt.detail;
        const currentPointWorld = currentPoints.world;
        const startPointWorld = startPoints.world;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const width = element.clientWidth;
        const height = element.clientHeight;
        const centerCanvas = [width * 0.5, height * 0.5];
        const centerWorld = viewport.canvasToWorld(centerCanvas);
        let angle = (0,angleBetweenLines/* default */.A)([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);
        const { viewPlaneNormal } = camera;
        const v1 = gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), centerWorld, startPointWorld);
        const v2 = gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), centerWorld, currentPointWorld);
        const cross = gl_matrix_esm/* vec3.cross */.eR.cross(gl_matrix_esm/* vec3.create */.eR.create(), v1, v2);
        if (gl_matrix_esm/* vec3.dot */.eR.dot(viewPlaneNormal, cross) > 0) {
            angle = -angle;
        }
        if (Number.isNaN(angle)) {
            return;
        }
        this.setAngle(viewport, angle);
    }
    setAngle(viewport, angle) {
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        if (viewport instanceof esm.BaseVolumeViewport) {
            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;
            const rotMat = gl_matrix_esm/* mat4.identity */.pB.identity(new Float32Array(16));
            gl_matrix_esm/* mat4.rotate */.pB.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);
            const rotatedViewUp = gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(gl_matrix_esm/* vec3.create */.eR.create(), viewUp, rotMat);
            viewport.setCamera({ viewUp: rotatedViewUp });
        }
        else {
            const { rotation } = viewport.getViewPresentation();
            viewport.setViewPresentation({
                rotation: (rotation + angle + 360) % 360,
            });
        }
        viewport.render();
    }
}
PlanarRotateTool.toolName = 'PlanarRotate';
/* harmony default export */ const tools_PlanarRotateTool = (PlanarRotateTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js




class ZoomTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            zoomToCenter: false,
            minZoomScale: 0.001,
            maxZoomScale: 3000,
            pinchToZoom: true,
            pan: true,
            invert: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const camera = enabledElement.viewport.getCamera();
            const { focalPoint } = camera;
            this.initialMousePosWorld = worldPos;
            let dirVec = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
            dirVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), dirVec);
            this.dirVec = dirVec;
            return false;
        };
        this.preTouchStartCallback = (evt) => {
            if (!this.configuration.pinchToZoom) {
                return this.preMouseDownCallback(evt);
            }
        };
        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {
            const { element, deltaPoints } = evt.detail;
            const deltaY = pinch
                ? evt.detail.deltaDistance.canvas
                : deltaPoints.canvas[1];
            const size = [element.clientWidth, element.clientHeight];
            const { parallelScale, focalPoint, position } = camera;
            const zoomScale = 5 / size[1];
            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);
            const parallelScaleToSet = (1.0 - k) * parallelScale;
            let focalPointToSet = focalPoint;
            let positionToSet = position;
            if (!this.configuration.zoomToCenter) {
                const distanceToCanvasCenter = gl_matrix_esm/* vec3.distance */.eR.distance(focalPoint, this.initialMousePosWorld);
                positionToSet = gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(gl_matrix_esm/* vec3.create */.eR.create(), position, this.dirVec, -distanceToCanvasCenter * k);
                focalPointToSet = gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(gl_matrix_esm/* vec3.create */.eR.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);
            }
            const imageData = viewport.getImageData();
            let spacing = [1, 1, 1];
            if (imageData) {
                spacing = imageData.spacing;
            }
            const { minZoomScale, maxZoomScale } = this.configuration;
            const t = element.clientHeight * spacing[1] * 0.5;
            const scale = t / parallelScaleToSet;
            let cappedParallelScale = parallelScaleToSet;
            let thresholdExceeded = false;
            if (imageData) {
                if (scale < minZoomScale) {
                    cappedParallelScale = t / minZoomScale;
                    thresholdExceeded = true;
                }
                else if (scale >= maxZoomScale) {
                    cappedParallelScale = t / maxZoomScale;
                    thresholdExceeded = true;
                }
            }
            viewport.setCamera({
                parallelScale: cappedParallelScale,
                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,
                position: thresholdExceeded ? position : positionToSet,
            });
        };
        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {
            const { element, deltaPoints } = evt.detail;
            const deltaY = pinch
                ? evt.detail.deltaDistance.canvas
                : deltaPoints.canvas[1];
            const size = [element.clientWidth, element.clientHeight];
            const { position, focalPoint, viewPlaneNormal } = camera;
            const distance = Core_Math/* default.distance2BetweenPoints */.Ay.distance2BetweenPoints(position, focalPoint);
            const zoomScale = Math.sqrt(distance) / size[1];
            const directionOfProjection = [
                -viewPlaneNormal[0],
                -viewPlaneNormal[1],
                -viewPlaneNormal[2],
            ];
            const k = this.configuration.invert
                ? deltaY / zoomScale
                : deltaY * zoomScale;
            let tmp = k * directionOfProjection[0];
            position[0] += tmp;
            focalPoint[0] += tmp;
            tmp = k * directionOfProjection[1];
            position[1] += tmp;
            focalPoint[1] += tmp;
            tmp = k * directionOfProjection[2];
            position[2] += tmp;
            focalPoint[2] += tmp;
            viewport.setCamera({ position, focalPoint });
        };
        this.initialMousePosWorld = [0, 0, 0];
        this.dirVec = [0, 0, 0];
        if (this.configuration.pinchToZoom) {
            this.touchDragCallback = this._pinchCallback.bind(this);
        }
        else {
            this.touchDragCallback = this._dragCallback.bind(this);
        }
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _pinchCallback(evt) {
        const pointsList = evt.detail
            .currentPointsList;
        if (pointsList.length > 1) {
            const { element, currentPoints } = evt.detail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const worldPos = currentPoints.world;
            const { focalPoint } = camera;
            this.initialMousePosWorld = worldPos;
            let dirVec = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
            dirVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), dirVec);
            this.dirVec = dirVec;
            if (camera.parallelProjection) {
                this._dragParallelProjection(evt, viewport, camera, true);
            }
            else {
                this._dragPerspectiveProjection(evt, viewport, camera, true);
            }
            viewport.render();
        }
        if (this.configuration.pan) {
            this._panCallback(evt);
        }
    }
    _dragCallback(evt) {
        const { element } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        if (camera.parallelProjection) {
            this._dragParallelProjection(evt, viewport, camera);
        }
        else {
            this._dragPerspectiveProjection(evt, viewport, camera);
        }
        viewport.render();
    }
    _panCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const deltaPointsWorld = deltaPoints.world;
        const camera = enabledElement.viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        enabledElement.viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        enabledElement.viewport.render();
    }
}
ZoomTool.toolName = 'Zoom';
/* harmony default export */ const tools_ZoomTool = (ZoomTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js
var planar = __webpack_require__(13165);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js





class MIPJumpToClickTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            targetViewportIds: [],
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    mouseClickCallback(evt) {
        const { element, currentPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        const volumeId = viewport.getVolumeId();
        if (!volumeId) {
            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);
        }
        let maxIntensity = -Infinity;
        const maxFn = (intensity, point) => {
            if (intensity > maxIntensity) {
                maxIntensity = intensity;
                return point;
            }
        };
        const brightestPoint = (0,planar.getPointInLineOfSightWithCriteria)(viewport, currentPoints.world, volumeId, maxFn);
        if (!brightestPoint || !brightestPoint.length) {
            return;
        }
        const { targetViewportIds, toolGroupId } = this.configuration;
        const viewports = renderingEngine.getViewports().filter((vp) => {
            if (targetViewportIds?.indexOf(vp.id) >= 0) {
                return true;
            }
            const foundToolGroup = (0,ToolGroupManager.getToolGroupForViewport)(vp.id, renderingEngine.id);
            if (toolGroupId && toolGroupId === foundToolGroup?.id) {
                return true;
            }
            return false;
        });
        viewports.forEach((viewport) => {
            if (viewport instanceof esm.VolumeViewport) {
                viewport.jumpToWorld(brightestPoint);
            }
            else {
                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');
            }
        });
    }
}
MIPJumpToClickTool.toolName = 'MIPJumpToClickTool';
/* harmony default export */ const tools_MIPJumpToClickTool = (MIPJumpToClickTool);

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
var MatrixBuilder = __webpack_require__(89265);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js
var liangBarksyClip = __webpack_require__(35381);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js
var math_line = __webpack_require__(93258);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking = __webpack_require__(2076);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js
















const { RENDERING_DEFAULTS } = esm.CONSTANTS;
function defaultReferenceLineColor() {
    return 'rgb(0, 200, 0)';
}
function defaultReferenceLineControllable() {
    return true;
}
function defaultReferenceLineDraggableRotatable() {
    return true;
}
function defaultReferenceLineSlabThicknessControlsOn() {
    return true;
}
const OPERATION = {
    DRAG: 1,
    ROTATE: 2,
    SLAB: 3,
};
const EPSILON = 1e-3;
class CrosshairsTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse'],
        configuration: {
            shadow: true,
            viewportIndicators: false,
            viewportIndicatorsConfig: {
                radius: 5,
                x: null,
                y: null,
            },
            autoPan: {
                enabled: false,
                panSize: 10,
            },
            referenceLinesCenterGapRadius: 20,
            filterActorUIDsToSetSlabThickness: [],
            slabThicknessBlendMode: esm.Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,
            mobile: {
                enabled: false,
                opacity: 0.8,
                handleRadius: 9,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.toolCenter = [0, 0, 0];
        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { FrameOfReferenceUID, viewport } = enabledElement;
            const { element } = viewport;
            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();
            let annotations = this._getAnnotations(enabledElement);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (annotations.length) {
                (0,annotationState.removeAnnotation)(annotations[0].annotationUID);
            }
            const annotation = {
                highlighted: false,
                metadata: {
                    cameraPosition: [...position],
                    cameraFocalPoint: [...focalPoint],
                    FrameOfReferenceUID,
                    toolName: this.getToolName(),
                },
                data: {
                    handles: {
                        rotationPoints: [],
                        slabThicknessPoints: [],
                        toolCenter: this.toolCenter,
                    },
                    activeOperation: null,
                    activeViewportIds: [],
                    viewportId,
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            return {
                normal: viewPlaneNormal,
                point: viewport.canvasToWorld([
                    viewport.canvas.clientWidth / 2,
                    viewport.canvas.clientHeight / 2,
                ]),
            };
        };
        this._getViewportsInfo = () => {
            const viewports = (0,ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resetCrosshairs = () => {
            const viewportsInfo = this._getViewportsInfo();
            for (const viewportInfo of viewportsInfo) {
                const { viewportId, renderingEngineId } = viewportInfo;
                const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                const viewport = enabledElement.viewport;
                const resetPan = true;
                const resetZoom = true;
                const resetToCenter = true;
                const resetRotation = true;
                const suppressEvents = true;
                viewport.resetCamera({
                    resetPan,
                    resetZoom,
                    resetToCenter,
                    resetRotation,
                    suppressEvents,
                });
                viewport.resetSlabThickness();
                const { element } = viewport;
                let annotations = this._getAnnotations(enabledElement);
                annotations = this.filterInteractableAnnotationsForElement(element, annotations);
                if (annotations.length) {
                    (0,annotationState.removeAnnotation)(annotations[0].annotationUID);
                }
                viewport.render();
            }
            this._computeToolCenter(viewportsInfo);
        };
        this.computeToolCenter = () => {
            const viewportsInfo = this._getViewportsInfo();
            this._computeToolCenter(viewportsInfo);
        };
        this._computeToolCenter = (viewportsInfo) => {
            if (!viewportsInfo.length || viewportsInfo.length === 1) {
                console.warn('For crosshairs to operate, at least two viewports must be given.');
                return;
            }
            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;
            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);
            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);
            let normal3 = [0, 0, 0];
            let point3 = gl_matrix_esm/* vec3.create */.eR.create();
            if (thirdViewport) {
                ({ normal: normal3, point: point3 } =
                    this.initializeViewport(thirdViewport));
            }
            else {
                gl_matrix_esm/* vec3.add */.eR.add(point3, point1, point2);
                gl_matrix_esm/* vec3.scale */.eR.scale(point3, point3, 0.5);
                gl_matrix_esm/* vec3.cross */.eR.cross(normal3, normal1, normal2);
            }
            const firstPlane = esm.utilities.planar.planeEquation(normal1, point1);
            const secondPlane = esm.utilities.planar.planeEquation(normal2, point2);
            const thirdPlane = esm.utilities.planar.planeEquation(normal3, point3);
            this.toolCenter = esm.utilities.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const jumpWorld = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this._jump(enabledElement, jumpWorld);
            const annotations = this._getAnnotations(enabledElement);
            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);
            const { data } = filteredAnnotations[0];
            const { rotationPoints } = data.handles;
            const viewportIdArray = [];
            for (let i = 0; i < rotationPoints.length - 1; ++i) {
                const otherViewport = rotationPoints[i][1];
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                if (!viewportControllable || !viewportDraggableRotatable) {
                    continue;
                }
                viewportIdArray.push(otherViewport.id);
                i++;
            }
            data.activeViewportIds = [...viewportIdArray];
            data.handles.activeOperation = OPERATION.DRAG;
            evt.preventDefault();
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            return filteredAnnotations[0];
        };
        this.cancel = () => {
            console.log('Not implemented yet');
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.onCameraModified = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const viewport = enabledElement.viewport;
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const currentCamera = viewport.getCamera();
            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;
            const deltaCameraPosition = [0, 0, 0];
            Core_Math/* default.subtract */.Ay.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);
            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;
            const deltaCameraFocalPoint = [0, 0, 0];
            Core_Math/* default.subtract */.Ay.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);
            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];
            viewportAnnotation.metadata.cameraFocalPoint = [
                ...currentCamera.focalPoint,
            ];
            const viewportControllable = this._getReferenceLineControllable(viewport.id);
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);
            if (!esm.utilities.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&
                viewportControllable &&
                viewportDraggableRotatable) {
                let isRotation = false;
                const cameraModifiedSameForPosAndFocalPoint = esm.utilities.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);
                if (!cameraModifiedSameForPosAndFocalPoint) {
                    isRotation = true;
                }
                const cameraModifiedInPlane = Math.abs(Core_Math/* default.dot */.Ay.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;
                if (!isRotation && !cameraModifiedInPlane) {
                    this.toolCenter[0] += deltaCameraPosition[0];
                    this.toolCenter[1] += deltaCameraPosition[1];
                    this.toolCenter[2] += deltaCameraPosition[2];
                }
            }
            if (this.configuration.autoPan?.enabled) {
                const toolGroup = (0,ToolGroupManager.getToolGroupForViewport)(viewport.id, renderingEngine.id);
                const otherViewportIds = toolGroup
                    .getViewportIds()
                    .filter((id) => id !== viewport.id);
                otherViewportIds.forEach((viewportId) => {
                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);
                });
            }
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.onResetCamera = (evt) => {
            this.resetCrosshairs();
        };
        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {
            const { element, currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            let imageNeedsUpdate = false;
            for (let i = 0; i < filteredToolAnnotations.length; i++) {
                const annotation = filteredToolAnnotations[i];
                if ((0,annotationLocking.isAnnotationLocked)(annotation.annotationUID)) {
                    continue;
                }
                const { data, highlighted } = annotation;
                if (!data.handles) {
                    continue;
                }
                const previousActiveOperation = data.handles.activeOperation;
                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0
                    ? [...data.activeViewportIds]
                    : [];
                data.activeViewportIds = [];
                data.handles.activeOperation = null;
                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);
                let near = false;
                if (handleNearImagePoint) {
                    near = true;
                }
                else {
                    near = this._pointNearTool(element, annotation, canvasCoords, 6);
                }
                const nearToolAndNotMarkedActive = near && !highlighted;
                const notNearToolAndMarkedActive = !near && highlighted;
                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
                    annotation.highlighted = !highlighted;
                    imageNeedsUpdate = true;
                }
                else if (data.handles.activeOperation !== previousActiveOperation ||
                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {
                    imageNeedsUpdate = true;
                }
            }
            return imageNeedsUpdate;
        };
        this.filterInteractableAnnotationsForElement = (element, annotations) => {
            if (!annotations || !annotations.length) {
                return [];
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewportId } = enabledElement;
            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);
            return viewportUIDSpecificCrosshairs;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport, renderingEngine } = enabledElement;
            const { element } = viewport;
            const annotations = this._getAnnotations(enabledElement);
            const camera = viewport.getCamera();
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!annotations?.length || !viewportAnnotation?.data) {
                return renderStatus;
            }
            const annotationUID = viewportAnnotation.annotationUID;
            const { clientWidth, clientHeight } = viewport.canvas;
            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);
            const data = viewportAnnotation.data;
            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);
            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);
            const referenceLines = [];
            const canvasBox = [0, 0, clientWidth, clientHeight];
            otherViewportAnnotations.forEach((annotation) => {
                const { data } = annotation;
                data.handles.toolCenter = this.toolCenter;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
                const { clientWidth, clientHeight } = otherViewport.canvas;
                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
                const otherCanvasCenter = [
                    clientWidth * 0.5,
                    clientHeight * 0.5,
                ];
                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);
                const direction = [0, 0, 0];
                Core_Math/* default.cross */.Ay.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);
                Core_Math/* default.normalize */.Ay.normalize(direction);
                Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(direction, otherCanvasDiagonalLength);
                const pointWorld0 = [0, 0, 0];
                Core_Math/* default.add */.Ay.add(otherViewportCenterWorld, direction, pointWorld0);
                const pointWorld1 = [0, 0, 0];
                Core_Math/* default.subtract */.Ay.subtract(otherViewportCenterWorld, direction, pointWorld1);
                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);
                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);
                const canvasUnitVectorFromCenter = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);
                gl_matrix_esm/* vec2.normalize */.Zc.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
                const canvasVectorFromCenterLong = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);
                const canvasVectorFromCenterMid = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);
                const canvasVectorFromCenterShort = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);
                const canvasVectorFromCenterStart = gl_matrix_esm/* vec2.create */.Zc.create();
                const centerGap = this.configuration.referenceLinesCenterGapRadius;
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);
                const refLinePointOne = gl_matrix_esm/* vec2.create */.Zc.create();
                const refLinePointTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                const refLinePointThree = gl_matrix_esm/* vec2.create */.Zc.create();
                const refLinePointFour = gl_matrix_esm/* vec2.create */.Zc.create();
                let refLinesCenter = gl_matrix_esm/* vec2.clone */.Zc.clone(crosshairCenterCanvas);
                if (!otherViewportDraggableRotatable || !otherViewportControllable) {
                    refLinesCenter = gl_matrix_esm/* vec2.clone */.Zc.clone(otherViewportCenterCanvas);
                }
                gl_matrix_esm/* vec2.add */.Zc.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);
                gl_matrix_esm/* vec2.add */.Zc.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);
                (0,liangBarksyClip/* default */.A)(refLinePointOne, refLinePointTwo, canvasBox);
                (0,liangBarksyClip/* default */.A)(refLinePointThree, refLinePointFour, canvasBox);
                const rotHandleOne = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);
                const rotHandleTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.add */.Zc.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);
                let stHandlesCenterCanvas = gl_matrix_esm/* vec2.clone */.Zc.clone(crosshairCenterCanvas);
                if (!otherViewportDraggableRotatable &&
                    otherViewportSlabThicknessControlsOn) {
                    stHandlesCenterCanvas = gl_matrix_esm/* vec2.clone */.Zc.clone(otherViewportCenterCanvas);
                }
                let stHandlesCenterWorld = [...this.toolCenter];
                if (!otherViewportDraggableRotatable &&
                    otherViewportSlabThicknessControlsOn) {
                    stHandlesCenterWorld = [...otherViewportCenterWorld];
                }
                const worldUnitVectorFromCenter = [0, 0, 0];
                Core_Math/* default.subtract */.Ay.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);
                Core_Math/* default.normalize */.Ay.normalize(worldUnitVectorFromCenter);
                const { viewPlaneNormal } = camera;
                const { matrix } = MatrixBuilder/* default */.A
                    .buildFromDegree()
                    .rotate(90, viewPlaneNormal);
                const worldUnitOrthoVectorFromCenter = [0, 0, 0];
                gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);
                const slabThicknessValue = otherViewport.getSlabThickness();
                const worldOrthoVectorFromCenter = [
                    ...worldUnitOrthoVectorFromCenter,
                ];
                Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);
                const worldVerticalRefPoint = [0, 0, 0];
                Core_Math/* default.add */.Ay.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);
                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);
                const canvasOrthoVectorFromCenter = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);
                const stLinePointOne = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.add */.Zc.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);
                const stLinePointTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.add */.Zc.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.add */.Zc.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);
                (0,liangBarksyClip/* default */.A)(stLinePointOne, stLinePointTwo, canvasBox);
                const stLinePointThree = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.add */.Zc.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);
                const stLinePointFour = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);
                (0,liangBarksyClip/* default */.A)(stLinePointThree, stLinePointFour, canvasBox);
                const stHandleOne = gl_matrix_esm/* vec2.create */.Zc.create();
                const stHandleTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                const stHandleThree = gl_matrix_esm/* vec2.create */.Zc.create();
                const stHandleFour = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix_esm/* vec2.add */.Zc.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);
                gl_matrix_esm/* vec2.add */.Zc.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix_esm/* vec2.add */.Zc.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);
                gl_matrix_esm/* vec2.add */.Zc.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);
                referenceLines.push([
                    otherViewport,
                    refLinePointOne,
                    refLinePointTwo,
                    refLinePointThree,
                    refLinePointFour,
                    stLinePointOne,
                    stLinePointTwo,
                    stLinePointThree,
                    stLinePointFour,
                    rotHandleOne,
                    rotHandleTwo,
                    stHandleOne,
                    stHandleTwo,
                    stHandleThree,
                    stHandleFour,
                ]);
            });
            const newRtpoints = [];
            const newStpoints = [];
            const viewportColor = this._getReferenceLineColor(viewport.id);
            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
            referenceLines.forEach((line, lineIndex) => {
                const otherViewport = line[0];
                const viewportColor = this._getReferenceLineColor(otherViewport.id);
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||
                    this.configuration.mobile?.enabled;
                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||
                    this.configuration.mobile?.enabled;
                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);
                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
                let lineWidth = 1;
                const lineActive = data.handles.activeOperation !== null &&
                    data.handles.activeOperation === OPERATION.DRAG &&
                    selectedViewportId;
                if (lineActive) {
                    lineWidth = 2.5;
                }
                let lineUID = `${lineIndex}`;
                if (viewportControllable && viewportDraggableRotatable) {
                    lineUID = `${lineIndex}One`;
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {
                        color,
                        lineWidth,
                    });
                    lineUID = `${lineIndex}Two`;
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {
                        color,
                        lineWidth,
                    });
                }
                else {
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {
                        color,
                        lineWidth,
                    });
                }
                if (viewportControllable) {
                    color =
                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;
                    const rotationHandles = [line[9], line[10]];
                    const rotHandleWorldOne = [
                        viewport.canvasToWorld(line[9]),
                        otherViewport,
                        line[1],
                        line[2],
                    ];
                    const rotHandleWorldTwo = [
                        viewport.canvasToWorld(line[10]),
                        otherViewport,
                        line[3],
                        line[4],
                    ];
                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);
                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;
                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];
                    const slabThicknessHandleWorldOne = [
                        viewport.canvasToWorld(line[11]),
                        otherViewport,
                        line[5],
                        line[6],
                    ];
                    const slabThicknessHandleWorldTwo = [
                        viewport.canvasToWorld(line[12]),
                        otherViewport,
                        line[5],
                        line[6],
                    ];
                    const slabThicknessHandleWorldThree = [
                        viewport.canvasToWorld(line[13]),
                        otherViewport,
                        line[7],
                        line[8],
                    ];
                    const slabThicknessHandleWorldFour = [
                        viewport.canvasToWorld(line[14]),
                        otherViewport,
                        line[7],
                        line[8],
                    ];
                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);
                    if ((lineActive || this.configuration.mobile?.enabled) &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportDraggableRotatable &&
                        viewportSlabThicknessControlsOn) {
                        let handleUID = `${lineIndex}One`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius: this.configuration.mobile?.enabled
                                ? this.configuration.mobile?.handleRadius
                                : 3,
                            opacity: this.configuration.mobile?.enabled
                                ? this.configuration.mobile?.opacity
                                : 1,
                            type: 'circle',
                        });
                        handleUID = `${lineIndex}Two`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
                            color,
                            handleRadius: this.configuration.mobile?.enabled
                                ? this.configuration.mobile?.handleRadius
                                : 3,
                            opacity: this.configuration.mobile?.enabled
                                ? this.configuration.mobile?.opacity
                                : 1,
                            type: 'rect',
                        });
                    }
                    else if (lineActive &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportDraggableRotatable) {
                        const handleUID = `${lineIndex}`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius: this.configuration.mobile?.enabled
                                ? this.configuration.mobile?.handleRadius
                                : 3,
                            opacity: this.configuration.mobile?.enabled
                                ? this.configuration.mobile?.opacity
                                : 1,
                            type: 'circle',
                        });
                    }
                    else if (selectedViewportId &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportSlabThicknessControlsOn) {
                        const handleUID = `${lineIndex}`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
                            color,
                            handleRadius: this.configuration.mobile?.enabled
                                ? this.configuration.mobile?.handleRadius
                                : 3,
                            opacity: this.configuration.mobile?.enabled
                                ? this.configuration.mobile?.opacity
                                : 1,
                            type: 'rect',
                        });
                    }
                    else if (rotHandlesActive && viewportDraggableRotatable) {
                        const handleUID = `${lineIndex}`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius: 2,
                            fill: color,
                            type: 'circle',
                        });
                    }
                    else if (slabThicknessHandlesActive &&
                        selectedViewportId &&
                        viewportSlabThicknessControlsOn) {
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {
                            color,
                            handleRadius: 2,
                            fill: color,
                            type: 'rect',
                        });
                    }
                    const slabThicknessValue = otherViewport.getSlabThickness();
                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {
                        lineUID = `${lineIndex}STOne`;
                        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {
                            color,
                            width: 1,
                            lineDash: [2, 3],
                        });
                        lineUID = `${lineIndex}STTwo`;
                        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {
                            color,
                            width: line,
                            lineDash: [2, 3],
                        });
                    }
                }
            });
            renderStatus = true;
            data.handles.rotationPoints = newRtpoints;
            data.handles.slabThicknessPoints = newStpoints;
            if (this.configuration.viewportIndicators) {
                const { viewportIndicatorsConfig } = this.configuration;
                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;
                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;
                const referenceColorCoordinates = [
                    clientWidth * xOffset,
                    clientHeight * yOffset,
                ];
                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });
            }
            return renderStatus;
        };
        this._getAnnotations = (enabledElement) => {
            const { viewport } = enabledElement;
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element) || [];
            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);
            const toolGroupAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                return viewportIds.includes(data.viewportId);
            });
            return toolGroupAnnotations;
        };
        this._onNewVolume = () => {
            const viewportsInfo = this._getViewportsInfo();
            this._computeToolCenter(viewportsInfo);
        };
        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {
            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {
                return false;
            }
            viewportIdArrayOne.forEach((id) => {
                let itemFound = false;
                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {
                    if (id === viewportIdArrayTwo[i]) {
                        itemFound = true;
                        break;
                    }
                }
                if (itemFound === false) {
                    return false;
                }
            });
            return true;
        };
        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {
            const { viewportId, renderingEngine, viewport } = enabledElement;
            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);
            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const { viewPlaneNormal, position } = camera;
            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const targetViewport = renderingEngine.getViewport(viewportId);
                const cameraOfTarget = targetViewport.getCamera();
                return !(esm.utilities.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && esm.utilities.isEqual(cameraOfTarget.position, position, 1));
            });
            return viewportsWithDifferentCameras;
        };
        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {
            const { renderingEngine } = enabledElement;
            const { data } = referenceAnnotation;
            const viewport = renderingEngine.getViewport(data.viewportId);
            const linkedViewportAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return otherViewportControllable === true;
            });
            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            Core_Math/* default.normalize */.Ay.normalize(viewPlaneNormal);
            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                return (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&
                    esm.utilities.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));
            });
            return otherViewportsAnnotationsWithSameCameraDirection;
        };
        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {
            const { renderingEngine, viewport } = enabledElement;
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            Core_Math/* default.normalize */.Ay.normalize(viewPlaneNormal);
            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return (viewport !== otherViewport &&
                    otherViewportControllable === true);
            });
            const otherViewportsAnnotationsWithUniqueCameras = [];
            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {
                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                if (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    esm.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (esm.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        esm.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return (viewport !== otherViewport &&
                    otherViewportControllable !== true);
            });
            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {
                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                if (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    esm.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (esm.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        esm.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
            for (let i = 0; i < otherViewportAnnotations.length; ++i) {
                const annotation = otherViewportAnnotations[i];
                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {
                    continue;
                }
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                if (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    esm.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (esm.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        esm.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            return otherViewportsAnnotationsWithUniqueCameras;
        };
        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {
            const actors = viewport.getActors();
            const otherViewportActors = otherViewport.getActors();
            let sameScene = true;
            actors.forEach((actor) => {
                if (actors.length !== otherViewportActors.length ||
                    otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined) {
                    sameScene = false;
                }
            });
            return sameScene;
        };
        this._jump = (enabledElement, jumpWorld) => {
            state/* state */.wk.isInteractingWithTool = true;
            const { viewport, renderingEngine } = enabledElement;
            const annotations = this._getAnnotations(enabledElement);
            const delta = [0, 0, 0];
            Core_Math/* default.subtract */.Ay.subtract(jumpWorld, this.toolCenter, delta);
            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);
                return (this._getReferenceLineControllable(otherViewport.id) &&
                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&
                    sameScene);
            });
            if (viewportsAnnotationsToUpdate.length === 0) {
                state/* state */.wk.isInteractingWithTool = false;
                return false;
            }
            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
            state/* state */.wk.isInteractingWithTool = false;
            return true;
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = !this.configuration.mobile?.enabled;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            this.editData.annotation.data.handles.activeOperation = null;
            this.editData.annotation.data.activeViewportIds = [];
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const delta = eventDetail.deltaPoints.world;
            if (Math.abs(delta[0]) < 1e-3 &&
                Math.abs(delta[1]) < 1e-3 &&
                Math.abs(delta[2]) < 1e-3) {
                return;
            }
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const { handles } = viewportAnnotation.data;
            const { currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            if (handles.activeOperation === OPERATION.DRAG) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportDraggableRotatable === true &&
                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));
                });
                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
            }
            else if (handles.activeOperation === OPERATION.ROTATE) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportDraggableRotatable === true);
                });
                const dir1 = gl_matrix_esm/* vec2.create */.Zc.create();
                const dir2 = gl_matrix_esm/* vec2.create */.Zc.create();
                const center = [
                    this.toolCenter[0],
                    this.toolCenter[1],
                    this.toolCenter[2],
                ];
                const centerCanvas = viewport.worldToCanvas(center);
                const finalPointCanvas = eventDetail.currentPoints.canvas;
                const originalPointCanvas = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.sub */.Zc.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);
                gl_matrix_esm/* vec2.sub */.Zc.sub(dir1, originalPointCanvas, centerCanvas);
                gl_matrix_esm/* vec2.sub */.Zc.sub(dir2, finalPointCanvas, centerCanvas);
                let angle = gl_matrix_esm/* vec2.angle */.Zc.angle(dir1, dir2);
                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {
                    angle *= -1;
                }
                angle = Math.round(angle * 100) / 100;
                const rotationAxis = viewport.getCamera().viewPlaneNormal;
                const { matrix } = MatrixBuilder/* default */.A
                    .buildFromRadian()
                    .translate(center[0], center[1], center[2])
                    .rotate(angle, rotationAxis)
                    .translate(-center[0], -center[1], -center[2]);
                const otherViewportsIds = [];
                viewportsAnnotationsToUpdate.forEach((annotation) => {
                    const { data } = annotation;
                    data.handles.toolCenter = center;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const camera = otherViewport.getCamera();
                    const { viewUp, position, focalPoint } = camera;
                    viewUp[0] += position[0];
                    viewUp[1] += position[1];
                    viewUp[2] += position[2];
                    gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(focalPoint, focalPoint, matrix);
                    gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(position, position, matrix);
                    gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(viewUp, viewUp, matrix);
                    viewUp[0] -= position[0];
                    viewUp[1] -= position[1];
                    viewUp[2] -= position[2];
                    otherViewport.setCamera({
                        position,
                        viewUp,
                        focalPoint,
                    });
                    otherViewportsIds.push(otherViewport.id);
                });
                renderingEngine.renderViewports(otherViewportsIds);
            }
            else if (handles.activeOperation === OPERATION.SLAB) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportSlabThicknessControlsOn === true &&
                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));
                });
                if (referenceAnnotations.length === 0) {
                    return;
                }
                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);
                const viewportsIds = [];
                viewportsIds.push(viewport.id);
                viewportsAnnotationsToUpdate.forEach((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const camera = otherViewport.getCamera();
                    const normal = camera.viewPlaneNormal;
                    const dotProd = Core_Math/* default.dot */.Ay.dot(delta, normal);
                    const projectedDelta = [...normal];
                    Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(projectedDelta, dotProd);
                    if (Math.abs(projectedDelta[0]) > 1e-3 ||
                        Math.abs(projectedDelta[1]) > 1e-3 ||
                        Math.abs(projectedDelta[2]) > 1e-3) {
                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +
                            projectedDelta[1] * projectedDelta[1] +
                            projectedDelta[2] * projectedDelta[2]);
                        const currentPoint = eventDetail.lastPoints.world;
                        const direction = [0, 0, 0];
                        const currentCenter = [
                            this.toolCenter[0],
                            this.toolCenter[1],
                            this.toolCenter[2],
                        ];
                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                        if (!viewportDraggableRotatable) {
                            const { rotationPoints } = this.editData.annotation.data.handles;
                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);
                            if (otherViewportRotationPoints.length === 2) {
                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);
                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);
                                Core_Math/* default.add */.Ay.add(point1, point2, currentCenter);
                                Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(currentCenter, 0.5);
                            }
                        }
                        Core_Math/* default.subtract */.Ay.subtract(currentPoint, currentCenter, direction);
                        const dotProdDirection = Core_Math/* default.dot */.Ay.dot(direction, normal);
                        const projectedDirection = [...normal];
                        Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(projectedDirection, dotProdDirection);
                        const normalizedProjectedDirection = [
                            projectedDirection[0],
                            projectedDirection[1],
                            projectedDirection[2],
                        ];
                        gl_matrix_esm/* vec3.normalize */.eR.normalize(normalizedProjectedDirection, normalizedProjectedDirection);
                        const normalizedProjectedDelta = [
                            projectedDelta[0],
                            projectedDelta[1],
                            projectedDelta[2],
                        ];
                        gl_matrix_esm/* vec3.normalize */.eR.normalize(normalizedProjectedDelta, normalizedProjectedDelta);
                        let slabThicknessValue = otherViewport.getSlabThickness();
                        if (esm.utilities.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {
                            slabThicknessValue -= mod;
                        }
                        else {
                            slabThicknessValue += mod;
                        }
                        slabThicknessValue = Math.abs(slabThicknessValue);
                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);
                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);
                        if (near) {
                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
                        }
                        const toolGroup = (0,ToolGroupManager.getToolGroupForViewport)(otherViewport.id, renderingEngine.id);
                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());
                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);
                        viewportsIds.push(otherViewport.id);
                    }
                });
                renderingEngine.renderViewports(viewportsIds);
            }
        };
        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {
            const { data } = annotation;
            const { rotationPoints } = data.handles;
            for (let i = 0; i < rotationPoints.length - 1; ++i) {
                const otherViewport = rotationPoints[i][1];
                if (otherViewport.id !== lineViewport.id) {
                    continue;
                }
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                if (!viewportControllable) {
                    continue;
                }
                const lineSegment1 = {
                    start: {
                        x: rotationPoints[i][2][0],
                        y: rotationPoints[i][2][1],
                    },
                    end: {
                        x: rotationPoints[i][3][0],
                        y: rotationPoints[i][3][1],
                    },
                };
                const distanceToPoint1 = math_line.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
                const lineSegment2 = {
                    start: {
                        x: rotationPoints[i + 1][2][0],
                        y: rotationPoints[i + 1][2][1],
                    },
                    end: {
                        x: rotationPoints[i + 1][3][0],
                        y: rotationPoints[i + 1][3][1],
                    },
                };
                const distanceToPoint2 = math_line.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                    return true;
                }
                i++;
            }
            return false;
        };
        this._getReferenceLineColor =
            toolProps.configuration?.getReferenceLineColor ||
                defaultReferenceLineColor;
        this._getReferenceLineControllable =
            toolProps.configuration?.getReferenceLineControllable ||
                defaultReferenceLineControllable;
        this._getReferenceLineDraggableRotatable =
            toolProps.configuration?.getReferenceLineDraggableRotatable ||
                defaultReferenceLineDraggableRotatable;
        this._getReferenceLineSlabThicknessControlsOn =
            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||
                defaultReferenceLineSlabThicknessControlsOn;
    }
    onSetToolActive() {
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        this._subscribeToViewportNewVolumeSet(viewportsInfo);
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolPassive() {
        const viewportsInfo = this._getViewportsInfo();
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolEnabled() {
        const viewportsInfo = this._getViewportsInfo();
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolDisabled() {
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const annotations = this._getAnnotations(enabledElement);
            if (annotations?.length) {
                annotations.forEach((annotation) => {
                    (0,annotationState.removeAnnotation)(annotation.annotationUID);
                });
            }
        });
    }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
        if (point !== null) {
            return point;
        }
        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
        if (point !== null) {
            return point;
        }
    }
    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {
        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.removeEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _subscribeToViewportNewVolumeSet(viewports) {
        viewports.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.addEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _autoPanViewportIfNecessary(viewportId, renderingEngine) {
        const viewport = renderingEngine.getViewport(viewportId);
        const { clientWidth, clientHeight } = viewport.canvas;
        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);
        const pan = this.configuration.autoPan.panSize;
        const visiblePointCanvas = [
            toolCenterCanvas[0],
            toolCenterCanvas[1],
        ];
        if (toolCenterCanvas[0] < 0) {
            visiblePointCanvas[0] = pan;
        }
        else if (toolCenterCanvas[0] > clientWidth) {
            visiblePointCanvas[0] = clientWidth - pan;
        }
        if (toolCenterCanvas[1] < 0) {
            visiblePointCanvas[1] = pan;
        }
        else if (toolCenterCanvas[1] > clientHeight) {
            visiblePointCanvas[1] = clientHeight - pan;
        }
        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&
            visiblePointCanvas[1] === toolCenterCanvas[1]) {
            return;
        }
        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);
        const deltaPointsWorld = [
            visiblePointWorld[0] - this.toolCenter[0],
            visiblePointWorld[1] - this.toolCenter[1],
            visiblePointWorld[2] - this.toolCenter[2],
        ];
        const camera = viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        viewport.render();
    }
    setSlabThickness(viewport, slabThickness) {
        let actorUIDs;
        const { filterActorUIDsToSetSlabThickness } = this.configuration;
        if (filterActorUIDsToSetSlabThickness &&
            filterActorUIDsToSetSlabThickness.length > 0) {
            actorUIDs = filterActorUIDsToSetSlabThickness;
        }
        let blendModeToUse = this.configuration.slabThicknessBlendMode;
        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {
            blendModeToUse = esm.Enums.BlendModes.COMPOSITE;
        }
        const immediate = false;
        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);
        viewport.setSlabThickness(slabThickness, actorUIDs);
    }
    _isClockWise(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;
    }
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {
        viewportsAnnotationsToUpdate.forEach((annotation) => {
            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);
        });
    }
    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {
        const { data } = annotation;
        const viewport = renderingEngine.getViewport(data.viewportId);
        const camera = viewport.getCamera();
        const normal = camera.viewPlaneNormal;
        const dotProd = Core_Math/* default.dot */.Ay.dot(delta, normal);
        const projectedDelta = [...normal];
        Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(projectedDelta, dotProd);
        if (Math.abs(projectedDelta[0]) > 1e-3 ||
            Math.abs(projectedDelta[1]) > 1e-3 ||
            Math.abs(projectedDelta[2]) > 1e-3) {
            const newFocalPoint = [0, 0, 0];
            const newPosition = [0, 0, 0];
            Core_Math/* default.add */.Ay.add(camera.focalPoint, projectedDelta, newFocalPoint);
            Core_Math/* default.add */.Ay.add(camera.position, projectedDelta, newPosition);
            viewport.setCamera({
                focalPoint: newFocalPoint,
                position: newPosition,
            });
            viewport.render();
        }
    }
    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const { rotationPoints } = data.handles;
        for (let i = 0; i < rotationPoints.length; i++) {
            const point = rotationPoints[i][0];
            const otherViewport = rotationPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportDraggableRotatable) {
                continue;
            }
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            if (gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
                data.handles.activeOperation = OPERATION.ROTATE;
                this.editData = {
                    annotation,
                };
                return point;
            }
        }
        return null;
    }
    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const { slabThicknessPoints } = data.handles;
        for (let i = 0; i < slabThicknessPoints.length; i++) {
            const point = slabThicknessPoints[i][0];
            const otherViewport = slabThicknessPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
            if (!viewportSlabThicknessControlsOn) {
                continue;
            }
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            if (gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
                data.handles.activeOperation = OPERATION.SLAB;
                data.activeViewportIds = [otherViewport.id];
                this.editData = {
                    annotation,
                };
                return point;
            }
        }
        return null;
    }
    _pointNearTool(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { clientWidth, clientHeight } = viewport.canvas;
        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
        const { data } = annotation;
        const { rotationPoints } = data.handles;
        const { slabThicknessPoints } = data.handles;
        const viewportIdArray = [];
        for (let i = 0; i < rotationPoints.length - 1; ++i) {
            const otherViewport = rotationPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportControllable || !viewportDraggableRotatable) {
                continue;
            }
            const lineSegment1 = {
                start: {
                    x: rotationPoints[i][2][0],
                    y: rotationPoints[i][2][1],
                },
                end: {
                    x: rotationPoints[i][3][0],
                    y: rotationPoints[i][3][1],
                },
            };
            const distanceToPoint1 = math_line.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const lineSegment2 = {
                start: {
                    x: rotationPoints[i + 1][2][0],
                    y: rotationPoints[i + 1][2][1],
                },
                end: {
                    x: rotationPoints[i + 1][3][0],
                    y: rotationPoints[i + 1][3][1],
                },
            };
            const distanceToPoint2 = math_line.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                viewportIdArray.push(otherViewport.id);
                data.handles.activeOperation = OPERATION.DRAG;
            }
            i++;
        }
        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {
            const otherViewport = slabThicknessPoints[i][1];
            if (viewportIdArray.find((id) => id === otherViewport.id)) {
                continue;
            }
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
            if (!viewportControllable || !viewportSlabThicknessControlsOn) {
                continue;
            }
            const stPointLineCanvas1 = slabThicknessPoints[i][2];
            const stPointLineCanvas2 = slabThicknessPoints[i][3];
            const centerCanvas = gl_matrix_esm/* vec2.create */.Zc.create();
            gl_matrix_esm/* vec2.add */.Zc.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);
            gl_matrix_esm/* vec2.scale */.Zc.scale(centerCanvas, centerCanvas, 0.5);
            const canvasUnitVectorFromCenter = gl_matrix_esm/* vec2.create */.Zc.create();
            gl_matrix_esm/* vec2.subtract */.Zc.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);
            gl_matrix_esm/* vec2.normalize */.Zc.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
            const canvasVectorFromCenterStart = gl_matrix_esm/* vec2.create */.Zc.create();
            gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);
            const stPointLineCanvas1Start = gl_matrix_esm/* vec2.create */.Zc.create();
            const stPointLineCanvas2Start = gl_matrix_esm/* vec2.create */.Zc.create();
            gl_matrix_esm/* vec2.add */.Zc.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);
            gl_matrix_esm/* vec2.subtract */.Zc.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);
            const lineSegment1 = {
                start: {
                    x: stPointLineCanvas1Start[0],
                    y: stPointLineCanvas1Start[1],
                },
                end: {
                    x: stPointLineCanvas1[0],
                    y: stPointLineCanvas1[1],
                },
            };
            const distanceToPoint1 = math_line.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const lineSegment2 = {
                start: {
                    x: stPointLineCanvas2Start[0],
                    y: stPointLineCanvas2Start[1],
                },
                end: {
                    x: stPointLineCanvas2[0],
                    y: stPointLineCanvas2[1],
                },
            };
            const distanceToPoint2 = math_line.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                viewportIdArray.push(otherViewport.id);
                data.handles.activeOperation = null;
            }
            i++;
        }
        data.activeViewportIds = [...viewportIdArray];
        this.editData = {
            annotation,
        };
        return data.handles.activeOperation === OPERATION.DRAG ? true : false;
    }
}
CrosshairsTool.toolName = 'Crosshairs';
/* harmony default export */ const tools_CrosshairsTool = (CrosshairsTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js








const MAGNIFY_VIEWPORT_ID = 'magnify-viewport';
class MagnifyTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            magnifySize: 10,
            magnifyWidth: 250,
            magnifyHeight: 250,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._hasBeenRemoved = false;
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            if (!(viewport instanceof esm.StackViewport)) {
                throw new Error('MagnifyTool only works on StackViewports');
            }
            const referencedImageId = this._getReferencedImageId(viewport);
            if (!referencedImageId) {
                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                referencedImageId,
                viewportIdsToRender,
                enabledElement,
                renderingEngine,
                currentPoints,
            };
            this._createMagnificationViewport();
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return true;
        };
        this.preTouchStartCallback = (evt) => {
            this.preMouseDownCallback(evt);
        };
        this._createMagnificationViewport = () => {
            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const viewportProperties = viewport.getProperties();
            const { canvas: canvasPos, world: worldPos } = currentPoints;
            let magnifyToolElement;
            magnifyToolElement = element.querySelector('.magnifyTool');
            if (magnifyToolElement === null) {
                const magnifyElement = document.createElement('div');
                magnifyElement.classList.add('magnifyTool');
                magnifyElement.style.display = 'block';
                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;
                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;
                magnifyElement.style.position = 'absolute';
                magnifyToolElement = magnifyElement;
                const viewportElement = element.querySelector('.viewport-element');
                viewportElement.appendChild(magnifyElement);
                const viewportInput = {
                    viewportId: MAGNIFY_VIEWPORT_ID,
                    type: esm.Enums.ViewportType.STACK,
                    element: magnifyToolElement,
                };
                renderingEngine.enableElement(viewportInput);
            }
            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
            magnifyViewport.setStack([referencedImageId]).then(() => {
                if (this._hasBeenRemoved) {
                    return;
                }
                magnifyViewport.setProperties(viewportProperties);
                const { parallelScale } = viewport.getCamera();
                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +
                    Math.pow(focalPoint[1] - position[1], 2) +
                    Math.pow(focalPoint[2] - position[2], 2));
                const updatedFocalPoint = [
                    worldPos[0],
                    worldPos[1],
                    worldPos[2],
                ];
                const updatedPosition = [
                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],
                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],
                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],
                ];
                magnifyViewport.setCamera({
                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),
                    focalPoint: updatedFocalPoint,
                    position: updatedPosition,
                });
                magnifyViewport.render();
            });
            magnifyToolElement.style.display = 'block';
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const { deltaPoints, element, currentPoints } = eventDetail;
            const deltaPointsWorld = deltaPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
            const magnifyElement = element.querySelector('.magnifyTool');
            if (!magnifyElement) {
                return;
            }
            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
            const { focalPoint, position } = magnifyViewport.getCamera();
            const updatedPosition = [
                position[0] + deltaPointsWorld[0],
                position[1] + deltaPointsWorld[1],
                position[2] + deltaPointsWorld[2],
            ];
            const updatedFocalPoint = [
                focalPoint[0] + deltaPointsWorld[0],
                focalPoint[1] + deltaPointsWorld[1],
                focalPoint[2] + deltaPointsWorld[2],
            ];
            magnifyViewport.setCamera({
                focalPoint: updatedFocalPoint,
                position: updatedPosition,
            });
            magnifyViewport.render();
        };
        this._dragEndCallback = (evt) => {
            const { element } = evt.detail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);
            const viewportElement = element.querySelector('.viewport-element');
            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');
            viewportElement.removeChild(magnifyToolElement);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            this._hasBeenRemoved = true;
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            this._hasBeenRemoved = false;
            element.addEventListener(enums.Events.MOUSE_UP, this._dragEndCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._dragEndCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._dragEndCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._dragEndCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._dragEndCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._dragEndCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
    }
    _getReferencedImageId(viewport) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId;
        if (viewport instanceof esm.StackViewport) {
            referencedImageId = targetId.split('imageId:')[1];
        }
        return referencedImageId;
    }
}
MagnifyTool.toolName = 'Magnify';
/* harmony default export */ const tools_MagnifyTool = (MagnifyTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js
var annotationVisibility = __webpack_require__(29601);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js + 2 modules
var circle = __webpack_require__(77081);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js
var debounce = __webpack_require__(52905);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js
var point = __webpack_require__(29614);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js


















const MAGNIFY_CLASSNAME = 'advancedMagnifyTool';
const MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;
const { Events: csEvents } = esm.Enums;
const isSegmentation = (actor) => actor.uid !== actor.referencedId;
var AdvancedMagnifyToolActions;
(function (AdvancedMagnifyToolActions) {
    AdvancedMagnifyToolActions["ShowZoomFactorsList"] = "showZoomFactorsList";
})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));
const ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';
const PARALLEL_THRESHOLD = 1 - esm.CONSTANTS.EPSILON;
class AdvancedMagnifyTool extends base/* AnnotationTool */.EC {
    static { this.Actions = AdvancedMagnifyToolActions; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            magnifyingGlass: {
                radius: 125,
                zoomFactor: 3,
                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],
                autoPan: {
                    enabled: true,
                    padding: 10,
                },
            },
            actions: {
                showZoomFactorsList: {
                    method: 'showZoomFactorsList',
                    bindings: [
                        {
                            mouseButton: enums.MouseBindings.Secondary,
                            modifierKey: enums.KeyboardBindings.Shift,
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const { magnifyingGlass: config } = this.configuration;
            const { radius, zoomFactor, autoPan } = config;
            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotationUID = esm.utilities.uuidv4();
            const magnifyViewportId = esm.utilities.uuidv4();
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                annotationUID,
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    sourceViewportId: viewport.id,
                    magnifyViewportId,
                    zoomFactor,
                    isCanvasAnnotation: true,
                    handles: {
                        points: canvasHandlePoints,
                        activeHandleIndex: null,
                    },
                },
            };
            this.magnifyViewportManager.createViewport(annotation, {
                magnifyViewportId,
                sourceEnabledElement: enabledElement,
                position: canvasPos,
                radius,
                zoomFactor,
                autoPan: {
                    enabled: autoPan.enabled,
                    padding: autoPan.padding,
                    callback: (data) => {
                        const annotationPoints = annotation.data.handles.points;
                        const { canvas: canvasDelta } = data.delta;
                        for (let i = 0, len = annotationPoints.length; i < len; i++) {
                            const point = annotationPoints[i];
                            point[0] += canvasDelta[0];
                            point[1] += canvasDelta[1];
                            annotation.invalidated = true;
                        }
                    },
                },
            });
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.onSetToolDisabled = () => {
            this.magnifyViewportManager.dispose();
            const annotations = (0,annotationState.getAllAnnotations)();
            annotations.forEach((annotation) => {
                if (annotation.metadata.toolName === this.getToolName()) {
                    (0,annotationState.removeAnnotation)(annotation.annotationUID);
                }
            });
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points;
            const canvasTop = canvasCoordinates[0];
            const canvasBottom = canvasCoordinates[2];
            const canvasLeft = canvasCoordinates[3];
            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
            const center = [
                canvasLeft[0] + radius,
                canvasTop[1] + radius,
            ];
            const radiusPoint = (0,circle/* getCanvasCircleRadius */.r)([center, canvasCoords]);
            if (Math.abs(radiusPoint - radius) < proximity * 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            const { points } = data.handles;
            const handleIndex = points.findIndex((p) => p === handle);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { deltaPoints } = eventDetail;
            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];
            const { annotation, viewportIdsToRender } = this.editData;
            const { points } = annotation.data.handles;
            points.forEach((point) => {
                point[0] += canvasDelta[0];
                point[1] += canvasDelta[1];
            });
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const canvasDelta = deltaPoints.canvas;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += canvasDelta[0];
                    point[1] += canvasDelta[1];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { annotation } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points;
            const canvasTop = canvasCoordinates[0];
            const canvasBottom = canvasCoordinates[2];
            const canvasLeft = canvasCoordinates[3];
            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
            const canvasCenter = [
                canvasLeft[0] + radius,
                canvasTop[1] + radius,
            ];
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const newRadius = (0,circle/* getCanvasCircleRadius */.r)([
                canvasCenter,
                currentCanvasPoints,
            ]);
            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);
            points[0] = newCanvasHandlePoints[0];
            points[1] = newCanvasHandlePoints[1];
            points[2] = newCanvasHandlePoints[2];
            points[3] = newCanvasHandlePoints[3];
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
            this.editData = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===
                viewport.id);
            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!filteredAnnotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < filteredAnnotations.length; i++) {
                const annotation = filteredAnnotations[i];
                const { annotationUID, data } = annotation;
                const { magnifyViewportId, zoomFactor, handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points;
                const canvasTop = canvasCoordinates[0];
                const canvasBottom = canvasCoordinates[2];
                const canvasLeft = canvasCoordinates[3];
                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
                const center = [
                    canvasLeft[0] + radius,
                    canvasTop[1] + radius,
                ];
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-advancedMagnify`;
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineWidth: 5,
                }, dataId);
                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);
                magnifyViewport.position = center;
                magnifyViewport.radius = radius;
                magnifyViewport.zoomFactor = zoomFactor;
                magnifyViewport.update();
                renderStatus = true;
            }
            return renderStatus;
        };
        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {
            return [
                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],
                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],
                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],
                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],
            ];
        };
        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();
    }
    showZoomFactorsList(evt, annotation) {
        const { element, currentPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvas: canvasPoint } = currentPoints;
        const viewportElement = element.querySelector(':scope .viewport-element');
        const currentZoomFactor = annotation.data.zoomFactor;
        const remove = () => dropdown.parentElement.removeChild(dropdown);
        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {
            if (newZoomFactor !== undefined) {
                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);
                annotation.invalidated = true;
            }
            remove();
            viewport.render();
        });
        Object.assign(dropdown.style, {
            left: `${canvasPoint[0]}px`,
            top: `${canvasPoint[1]}px`,
        });
        viewportElement.appendChild(dropdown);
        dropdown.focus();
    }
    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {
        const { zoomFactorList } = this.configuration.magnifyingGlass;
        const dropdown = document.createElement('select');
        dropdown.size = 5;
        Object.assign(dropdown.style, {
            width: '50px',
            position: 'absolute',
        });
        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {
            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());
        });
        dropdown.addEventListener('change', (evt) => {
            evt.stopPropagation();
            onChangeCallback(dropdown.value);
        });
        dropdown.addEventListener('keydown', (evt) => {
            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||
                evt.key?.toLowerCase() === 'escape';
            if (shouldCancel) {
                evt.stopPropagation();
                onChangeCallback();
            }
        });
        zoomFactorList.forEach((zoomFactor) => {
            const option = document.createElement('option');
            option.label = zoomFactor;
            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;
            option.value = zoomFactor;
            option.defaultSelected = zoomFactor === currentZoomFactor;
            dropdown.add(option);
        });
        return dropdown;
    }
}
class AdvancedMagnifyViewportManager {
    constructor() {
        this.createViewport = (annotation, viewportInfo) => {
            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;
            const { viewport: sourceViewport } = sourceEnabledElement;
            const { element: sourceElement } = sourceViewport;
            const magnifyViewport = new AdvancedMagnifyViewport({
                magnifyViewportId,
                sourceEnabledElement,
                radius,
                position,
                zoomFactor,
                autoPan,
            });
            this._addSourceElementEventListener(sourceElement);
            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {
                annotation,
                magnifyViewport,
                magnifyViewportInfo: viewportInfo,
            });
            return magnifyViewport;
        };
        this._annotationRemovedCallback = (evt) => {
            const { annotation } = evt.detail;
            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {
                return;
            }
            this.destroyViewport(annotation.data.magnifyViewportId);
        };
        this._newStackImageCallback = (evt) => {
            const { viewportId: sourceViewportId, imageId } = evt.detail;
            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
            const { viewport } = (0,esm.getEnabledElementByViewportId)(sourceViewportId);
            if (viewport.stackActorReInitialized) {
                this._reset(sourceViewportId);
            }
            magnifyViewportsMapEntries.forEach(({ annotation }) => {
                annotation.metadata.referencedImageId = imageId;
                annotation.invalidated = true;
            });
        };
        this._newVolumeImageCallback = (evt) => {
            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;
            const renderingEngine = (0,esm.getRenderingEngine)(renderingEngineId);
            const sourceViewport = renderingEngine.getViewport(sourceViewportId);
            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();
            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
            magnifyViewportsMapEntries.forEach(({ annotation }) => {
                const { viewPlaneNormal } = annotation.metadata;
                const isParallel = Math.abs(gl_matrix_esm/* vec3.dot */.eR.dot(viewPlaneNormal, currentViewPlaneNormal)) >
                    PARALLEL_THRESHOLD;
                if (!isParallel) {
                    return;
                }
                const { handles } = annotation.data;
                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);
                const vecHandleToImagePlane = gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), worldImagePlanePoint, handles.points[0]);
                const worldDist = gl_matrix_esm/* vec3.dot */.eR.dot(vecHandleToImagePlane, currentViewPlaneNormal);
                const worldDelta = gl_matrix_esm/* vec3.scale */.eR.scale(gl_matrix_esm/* vec3.create */.eR.create(), currentViewPlaneNormal, worldDist);
                for (let i = 0, len = handles.points.length; i < len; i++) {
                    const point = handles.points[i];
                    point[0] += worldDelta[0];
                    point[1] += worldDelta[1];
                    point[2] += worldDelta[2];
                }
                annotation.invalidated = true;
            });
        };
        this._magnifyViewportsMap = new Map();
        this._initialize();
    }
    static getInstance() {
        AdvancedMagnifyViewportManager._singleton =
            AdvancedMagnifyViewportManager._singleton ??
                new AdvancedMagnifyViewportManager();
        return AdvancedMagnifyViewportManager._singleton;
    }
    getViewport(magnifyViewportId) {
        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;
    }
    dispose() {
        this._removeEventListeners();
        this._destroyViewports();
    }
    destroyViewport(magnifyViewportId) {
        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);
        if (magnifyViewportMapEntry) {
            const { magnifyViewport } = magnifyViewportMapEntry;
            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;
            const { element: sourceElement } = sourceViewport;
            this._removeSourceElementEventListener(sourceElement);
            magnifyViewport.dispose();
            this._magnifyViewportsMap.delete(magnifyViewportId);
        }
    }
    _destroyViewports() {
        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());
        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));
    }
    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {
        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());
        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {
            const { viewport } = magnifyViewport.sourceEnabledElement;
            return viewport.id === sourceViewportId;
        });
    }
    _reset(sourceViewportId) {
        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {
            this.destroyViewport(magnifyViewport.viewportId);
            const newEnabledElement = (0,esm.getEnabledElementByViewportId)(sourceViewportId);
            this.createViewport(annotation, {
                ...magnifyViewportInfo,
                sourceEnabledElement: {
                    ...newEnabledElement,
                },
            });
        });
    }
    _addEventListeners() {
        esm.eventTarget.addEventListener(enums.Events.ANNOTATION_REMOVED, this._annotationRemovedCallback);
    }
    _removeEventListeners() {
        esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_REMOVED, this._annotationRemovedCallback);
    }
    _addSourceElementEventListener(element) {
        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
        const newStackHandler = (evt) => {
            const { viewportId: sourceViewportId } = evt.detail;
            this._reset(sourceViewportId);
        };
        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);
        const newVolumeHandler = (evt) => {
            const { viewportId: sourceViewportId } = evt.detail;
            this._reset(sourceViewportId);
        };
        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);
        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
        element.newStackHandler = newStackHandler;
        element.newVolumeHandler = newVolumeHandler;
    }
    _removeSourceElementEventListener(element) {
        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);
        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);
        delete element.newStackHandler;
        delete element.newVolumeHandler;
    }
    _initialize() {
        this._addEventListeners();
    }
}
class AdvancedMagnifyViewport {
    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {
        this._enabledElement = null;
        this._sourceToolGroup = null;
        this._magnifyToolGroup = null;
        this._isViewportReady = false;
        this._radius = 0;
        this._resized = false;
        this._canAutoPan = false;
        this._viewportId = magnifyViewportId ?? esm.utilities.uuidv4();
        this._sourceEnabledElement = sourceEnabledElement;
        this._autoPan = autoPan;
        this.radius = radius;
        this.position = position;
        this.zoomFactor = zoomFactor;
        this.visible = true;
        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);
        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);
        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);
        this._mouseDragCallback = this._mouseDragCallback.bind(this);
        this._resizeViewportAsync = ((0,debounce/* default */.A)(this._resizeViewport.bind(this), 1));
        this._initialize();
    }
    get sourceEnabledElement() {
        return this._sourceEnabledElement;
    }
    get viewportId() {
        return this._viewportId;
    }
    get radius() {
        return this._radius;
    }
    set radius(radius) {
        if (Math.abs(this._radius - radius) > 0.00001) {
            this._radius = radius;
            this._resized = true;
        }
    }
    update() {
        const { radius, position, visible } = this;
        const { viewport } = this._enabledElement;
        const { element } = viewport;
        const size = 2 * radius;
        const [x, y] = position;
        if (this._resized) {
            this._resizeViewportAsync();
            this._resized = false;
        }
        Object.assign(element.style, {
            display: visible ? 'block' : 'hidden',
            width: `${size}px`,
            height: `${size}px`,
            left: `${-radius}px`,
            top: `${-radius}px`,
            transform: `translate(${x}px, ${y}px)`,
        });
        if (this._isViewportReady) {
            this._syncViewports();
            viewport.render();
        }
    }
    dispose() {
        const { viewport } = this._enabledElement;
        const { element } = viewport;
        const renderingEngine = viewport.getRenderingEngine();
        this._removeEventListeners(element);
        renderingEngine.disableElement(viewport.id);
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }
    _handleToolModeChanged(evt) {
        const { _magnifyToolGroup: magnifyToolGroup } = this;
        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;
        if (this._sourceToolGroup?.id !== toolGroupId) {
            return;
        }
        switch (mode) {
            case enums.ToolModes.Active:
                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);
                break;
            case enums.ToolModes.Passive:
                magnifyToolGroup.setToolPassive(toolName);
                break;
            case enums.ToolModes.Enabled:
                magnifyToolGroup.setToolEnabled(toolName);
                break;
            case enums.ToolModes.Disabled:
                magnifyToolGroup.setToolDisabled(toolName);
                break;
            default:
                throw new Error(`Unknow tool mode (${mode})`);
        }
    }
    _inheritBorderRadius(magnifyElement) {
        const viewport = magnifyElement.querySelector('.viewport-element');
        const canvas = magnifyElement.querySelector('.cornerstone-canvas');
        viewport.style.borderRadius = 'inherit';
        canvas.style.borderRadius = 'inherit';
    }
    _createViewportNode() {
        const magnifyElement = document.createElement('div');
        const { radius } = this;
        const size = radius * 2;
        magnifyElement.classList.add(MAGNIFY_CLASSNAME);
        Object.assign(magnifyElement.style, {
            display: 'block',
            width: `${size}px`,
            height: `${size}px`,
            position: 'absolute',
            overflow: 'hidden',
            borderRadius: '50%',
            boxSizing: 'border-box',
            left: `${-radius}px`,
            top: `${-radius}px`,
            transform: `translate(-1000px, -1000px)`,
        });
        return magnifyElement;
    }
    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {
        const { parallelScale } = viewport.getCamera();
        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;
        return parallelScale * (1 / zoomFactor) * canvasRatio;
    }
    _isStackViewport(viewport) {
        return 'setStack' in viewport;
    }
    _isVolumeViewport(viewport) {
        return 'addVolumes' in viewport;
    }
    _cloneToolGroups(sourceViewport, magnifyViewport) {
        const sourceActors = sourceViewport.getActors();
        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;
        const sourceToolGroup = (0,ToolGroupManager.getToolGroupForViewport)(sourceViewport.id, sourceViewport.renderingEngineId);
        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {
            const toolInstance = sourceToolGroup.getToolInstance(toolName);
            const isAnnotationTool = toolInstance instanceof base/* AnnotationTool */.EC &&
                !(toolInstance instanceof AdvancedMagnifyTool);
            return isAnnotationTool;
        });
        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);
        sourceActors.filter(isSegmentation).forEach((actor) => {
            (0,segmentation.addSegmentationRepresentations)(this.viewportId, [
                {
                    segmentationId: actor.referencedId,
                    type: enums.SegmentationRepresentations.Labelmap,
                },
            ]);
        });
        return { sourceToolGroup, magnifyToolGroup };
    }
    _cloneStack(sourceViewport, magnifyViewport) {
        const imageIds = sourceViewport.getImageIds();
        magnifyViewport.setStack(imageIds).then(() => {
            this._isViewportReady = true;
            this.update();
        });
    }
    _cloneVolumes(sourceViewport, magnifyViewport) {
        const actors = sourceViewport.getActors();
        const volumeInputArray = actors
            .filter((actor) => !isSegmentation(actor))
            .map((actor) => ({ volumeId: actor.uid }));
        magnifyViewport.setVolumes(volumeInputArray).then(() => {
            this._isViewportReady = true;
            this.update();
        });
        return magnifyViewport;
    }
    _cloneViewport(sourceViewport, magnifyElement) {
        const { viewportId: magnifyViewportId } = this;
        const renderingEngine = sourceViewport.getRenderingEngine();
        const { options: sourceViewportOptions } = sourceViewport;
        const viewportInput = {
            element: magnifyElement,
            viewportId: magnifyViewportId,
            type: sourceViewport.type,
            defaultOptions: { ...sourceViewportOptions },
        };
        renderingEngine.enableElement(viewportInput);
        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));
        if (this._isStackViewport(sourceViewport)) {
            this._cloneStack(sourceViewport, magnifyViewport);
        }
        else if (this._isVolumeViewport(sourceViewport)) {
            this._cloneVolumes(sourceViewport, magnifyViewport);
        }
        this._inheritBorderRadius(magnifyElement);
        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);
        this._sourceToolGroup = toolGroups.sourceToolGroup;
        this._magnifyToolGroup = toolGroups.magnifyToolGroup;
    }
    _cancelMouseEventCallback(evt) {
        evt.stopPropagation();
        evt.preventDefault();
    }
    _browserMouseUpCallback(evt) {
        const { element } = this._enabledElement.viewport;
        document.removeEventListener('mouseup', this._browserMouseUpCallback);
        element.addEventListener('mouseup', this._cancelMouseEventCallback);
        element.addEventListener('mousemove', this._cancelMouseEventCallback);
    }
    _browserMouseDownCallback(evt) {
        const { element } = this._enabledElement.viewport;
        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');
        document.addEventListener('mouseup', this._browserMouseUpCallback);
        element.removeEventListener('mouseup', this._cancelMouseEventCallback);
        element.removeEventListener('mousemove', this._cancelMouseEventCallback);
    }
    _mouseDragCallback(evt) {
        if (!state/* state */.wk.isInteractingWithTool) {
            return;
        }
        const { _autoPan: autoPan } = this;
        if (!autoPan.enabled || !this._canAutoPan) {
            return;
        }
        const { currentPoints } = evt.detail;
        const { viewport } = this._enabledElement;
        const { canvasToWorld } = viewport;
        const { canvas: canvasCurrent } = currentPoints;
        const { radius: magnifyRadius } = this;
        const canvasCenter = [magnifyRadius, magnifyRadius];
        const dist = (0,point.distanceToPoint)(canvasCenter, canvasCurrent);
        const maxDist = magnifyRadius - autoPan.padding;
        if (dist <= maxDist) {
            return;
        }
        const panDist = dist - maxDist;
        const canvasDeltaPos = gl_matrix_esm/* vec2.sub */.Zc.sub(gl_matrix_esm/* vec2.create */.Zc.create(), canvasCurrent, canvasCenter);
        gl_matrix_esm/* vec2.normalize */.Zc.normalize(canvasDeltaPos, canvasDeltaPos);
        gl_matrix_esm/* vec2.scale */.Zc.scale(canvasDeltaPos, canvasDeltaPos, panDist);
        const newCanvasPosition = gl_matrix_esm/* vec2.add */.Zc.add(gl_matrix_esm/* vec2.create */.Zc.create(), this.position, canvasDeltaPos);
        const currentWorldPos = canvasToWorld(this.position);
        const newWorldPos = canvasToWorld(newCanvasPosition);
        const worldDeltaPos = gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), newWorldPos, currentWorldPos);
        const autoPanCallbackData = {
            points: {
                currentPosition: {
                    canvas: this.position,
                    world: currentWorldPos,
                },
                newPosition: {
                    canvas: newCanvasPosition,
                    world: newWorldPos,
                },
            },
            delta: {
                canvas: canvasDeltaPos,
                world: worldDeltaPos,
            },
        };
        autoPan.callback(autoPanCallbackData);
    }
    _addBrowserEventListeners(element) {
        document.addEventListener('mousedown', this._browserMouseDownCallback, true);
        element.addEventListener('mousedown', this._cancelMouseEventCallback);
        element.addEventListener('mouseup', this._cancelMouseEventCallback);
        element.addEventListener('mousemove', this._cancelMouseEventCallback);
        element.addEventListener('dblclick', this._cancelMouseEventCallback);
    }
    _removeBrowserEventListeners(element) {
        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);
        document.removeEventListener('mouseup', this._browserMouseUpCallback);
        element.removeEventListener('mousedown', this._cancelMouseEventCallback);
        element.removeEventListener('mouseup', this._cancelMouseEventCallback);
        element.removeEventListener('mousemove', this._cancelMouseEventCallback);
        element.removeEventListener('dblclick', this._cancelMouseEventCallback);
    }
    _addEventListeners(element) {
        esm.eventTarget.addEventListener(enums.Events.TOOL_MODE_CHANGED, this._handleToolModeChanged);
        element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseDragCallback);
        element.addEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
        this._addBrowserEventListeners(element);
    }
    _removeEventListeners(element) {
        esm.eventTarget.removeEventListener(enums.Events.TOOL_MODE_CHANGED, this._handleToolModeChanged);
        element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseDragCallback);
        element.addEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
        this._removeBrowserEventListeners(element);
    }
    _initialize() {
        const { _sourceEnabledElement: sourceEnabledElement } = this;
        const { viewport: sourceViewport } = sourceEnabledElement;
        const { canvas: sourceCanvas } = sourceViewport;
        const magnifyElement = this._createViewportNode();
        sourceCanvas.parentNode.appendChild(magnifyElement);
        this._addEventListeners(magnifyElement);
        this._cloneViewport(sourceViewport, magnifyElement);
        this._enabledElement = (0,esm.getEnabledElement)(magnifyElement);
    }
    _syncViewportsCameras(sourceViewport, magnifyViewport) {
        const worldPos = sourceViewport.canvasToWorld(this.position);
        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);
        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +
            Math.pow(focalPoint[1] - position[1], 2) +
            Math.pow(focalPoint[2] - position[2], 2));
        const updatedFocalPoint = [
            worldPos[0],
            worldPos[1],
            worldPos[2],
        ];
        const updatedPosition = [
            updatedFocalPoint[0] + distance * viewPlaneNormal[0],
            updatedFocalPoint[1] + distance * viewPlaneNormal[1],
            updatedFocalPoint[2] + distance * viewPlaneNormal[2],
        ];
        magnifyViewport.setCamera({
            parallelScale,
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
    }
    _syncStackViewports(sourceViewport, magnifyViewport) {
        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());
    }
    _syncViewports() {
        const { viewport: sourceViewport } = this._sourceEnabledElement;
        const { viewport: magnifyViewport } = this._enabledElement;
        const sourceProperties = sourceViewport.getProperties();
        const imageData = magnifyViewport.getImageData();
        if (!imageData) {
            return;
        }
        magnifyViewport.setProperties(sourceProperties);
        this._syncViewportsCameras(sourceViewport, magnifyViewport);
        if (this._isStackViewport(sourceViewport)) {
            this._syncStackViewports(sourceViewport, magnifyViewport);
        }
        this._syncViewportsCameras(sourceViewport, magnifyViewport);
        magnifyViewport.render();
    }
    _resizeViewport() {
        const { viewport } = this._enabledElement;
        const renderingEngine = viewport.getRenderingEngine();
        renderingEngine.resize();
    }
}
AdvancedMagnifyTool.toolName = 'AdvancedMagnify';


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js
var AnnotationDisplayTool = __webpack_require__(6030);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js








const { EPSILON: ReferenceLinesTool_EPSILON } = esm.CONSTANTS;
class ReferenceLines extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            sourceViewportId: '',
            enforceSameFrameOfReference: true,
            showFullDimension: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.editData = null;
        this._init = () => {
            const renderingEngines = (0,esm.getRenderingEngines)();
            const renderingEngine = renderingEngines[0];
            if (!renderingEngine) {
                return;
            }
            let viewports = renderingEngine.getViewports();
            viewports = (0,viewportFilters.filterViewportsWithToolEnabled)(viewports, this.getToolName());
            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);
            if (!sourceViewport?.getImageData()) {
                return;
            }
            const { element } = sourceViewport;
            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();
            const sourceViewportCanvasCornersInWorld = esm.utilities.getViewportImageCornersInWorld(sourceViewport);
            let annotation = this.editData?.annotation;
            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();
            if (!annotation) {
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [...viewPlaneNormal],
                        viewUp: [...viewUp],
                        FrameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        handles: {
                            points: sourceViewportCanvasCornersInWorld,
                        },
                    },
                };
                (0,annotationState.addAnnotation)(newAnnotation, element);
                annotation = newAnnotation;
            }
            else {
                this.editData.annotation.data.handles.points =
                    sourceViewportCanvasCornersInWorld;
            }
            this.editData = {
                sourceViewportId: sourceViewport.id,
                renderingEngine,
                annotation,
            };
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewports
                .filter((viewport) => viewport.id !== sourceViewport.id)
                .map((viewport) => viewport.id));
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onSetToolConfiguration = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this._init();
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const { viewport: targetViewport } = enabledElement;
            if (!this.editData) {
                return false;
            }
            const { annotation, sourceViewportId } = this.editData;
            let renderStatus = false;
            const { viewport: sourceViewport } = (0,esm.getEnabledElementByViewportId)(sourceViewportId) || {};
            if (!sourceViewport) {
                return renderStatus;
            }
            if (sourceViewport.id === targetViewport.id) {
                return renderStatus;
            }
            if (!annotation || !annotation?.data?.handles?.points) {
                return renderStatus;
            }
            if (this.configuration.enforceSameFrameOfReference &&
                sourceViewport.getFrameOfReferenceUID() !==
                    targetViewport.getFrameOfReferenceUID()) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const topLeft = annotation.data.handles.points[0];
            const topRight = annotation.data.handles.points[1];
            const bottomLeft = annotation.data.handles.points[2];
            const bottomRight = annotation.data.handles.points[3];
            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();
            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();
            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {
                return renderStatus;
            }
            const targetViewportPlane = esm.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
            let pointSetToUse = pointSet1;
            let topBottomVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet1[0], pointSet1[1]);
            topBottomVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topBottomVec);
            let topRightVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet1[2], pointSet1[0]);
            topRightVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topRightVec);
            const newNormal = gl_matrix_esm/* vec3.cross */.eR.cross(gl_matrix_esm/* vec3.create */.eR.create(), topBottomVec, topRightVec);
            if (this.isParallel(newNormal, viewPlaneNormal)) {
                return renderStatus;
            }
            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
                pointSetToUse = pointSet2;
            }
            const lineStartWorld = esm.utilities.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
            const lineEndWorld = esm.utilities.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
            const { annotationUID } = annotation;
            styleSpecifier.annotationUID = annotationUID;
            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
            const color = this.getStyle('color', styleSpecifier, annotation);
            const shadow = this.getStyle('shadow', styleSpecifier, annotation);
            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
            if (this.configuration.showFullDimension) {
                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);
            }
            if (canvasCoordinates.length < 2) {
                return renderStatus;
            }
            const dataId = `${annotationUID}-line`;
            const lineUID = '1';
            (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                color,
                width: lineWidth,
                lineDash,
                shadow,
            }, dataId);
            renderStatus = true;
            return renderStatus;
        };
        this.isPerpendicular = (vec1, vec2) => {
            const dot = gl_matrix_esm/* vec3.dot */.eR.dot(vec1, vec2);
            return Math.abs(dot) < ReferenceLinesTool_EPSILON;
        };
    }
    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {
        const renderingEngine = targetViewport.getRenderingEngine();
        const targetId = this.getTargetId(targetViewport);
        const targetImage = this.getTargetImageData(targetId);
        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);
        if (referencedImageId && targetImage) {
            try {
                const { imageData, dimensions } = targetImage;
                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [
                    imageData.indexToWorld([0, 0, 0]),
                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),
                    imageData.indexToWorld([
                        dimensions[0] - 1,
                        dimensions[1] - 1,
                        0,
                    ]),
                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),
                ].map((world) => esm.utilities.worldToImageCoords(referencedImageId, world));
                const [lineStartImageCoord, lineEndImageCoord] = [
                    lineStartWorld,
                    lineEndWorld,
                ].map((world) => esm.utilities.worldToImageCoords(referencedImageId, world));
                canvasCoordinates = [
                    [topLeftImageCoord, topRightImageCoord],
                    [topRightImageCoord, bottomRightImageCoord],
                    [bottomLeftImageCoord, bottomRightImageCoord],
                    [topLeftImageCoord, bottomLeftImageCoord],
                ]
                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))
                    .filter((point) => point && this.isInBound(point, dimensions))
                    .map((point) => {
                    const world = esm.utilities.imageToWorldCoords(referencedImageId, point);
                    return targetViewport.worldToCanvas(world);
                });
            }
            catch (err) {
                console.log(err);
            }
        }
        return canvasCoordinates;
    }
    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {
        const [x1, y1] = line1Start;
        const [x2, y2] = line1End;
        const [x3, y3] = line2Start;
        const [x4, y4] = line2End;
        const a1 = y2 - y1;
        const b1 = x1 - x2;
        const c1 = x2 * y1 - x1 * y2;
        const a2 = y4 - y3;
        const b2 = x3 - x4;
        const c2 = x4 * y3 - x3 * y4;
        if (Math.abs(a1 * b2 - a2 * b1) < ReferenceLinesTool_EPSILON) {
            return;
        }
        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);
        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);
        return [x, y];
    }
    isParallel(vec1, vec2) {
        return Math.abs(gl_matrix_esm/* vec3.dot */.eR.dot(vec1, vec2)) > 1 - ReferenceLinesTool_EPSILON;
    }
    isInBound(point, dimensions) {
        return (point[0] >= 0 &&
            point[0] <= dimensions[0] &&
            point[1] >= 0 &&
            point[1] <= dimensions[1]);
    }
}
ReferenceLines.toolName = 'ReferenceLines';
/* harmony default export */ const ReferenceLinesTool = (ReferenceLines);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js







const { EPSILON: OverlayGridTool_EPSILON } = esm.CONSTANTS;
class OverlayGridTool extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            sourceImageIds: [],
        },
    }) {
        super(toolProps, defaultToolProps);
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onSetToolActive = () => {
            this._init();
        };
        this._init = () => {
            const sourceImageIds = this.configuration.sourceImageIds;
            if (!sourceImageIds?.length) {
                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');
                return;
            }
            const imagePlaneModule = esm.metaData.get('imagePlaneModule', sourceImageIds[0]);
            if (!imagePlaneModule) {
                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');
                return;
            }
            const { frameOfReferenceUID } = imagePlaneModule;
            const viewportsInfo = (0,ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportsInfo?.length) {
                console.warn('OverlayGridTool: No viewports found');
                return;
            }
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), frameOfReferenceUID);
            if (!annotations?.length) {
                const pointSets = sourceImageIds.map((id) => {
                    return this.calculateImageIdPointSets(id);
                });
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        FrameOfReferenceUID: frameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        viewportData: new Map(),
                        pointSets,
                    },
                };
                (0,annotationState.addAnnotation)(newAnnotation, frameOfReferenceUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.calculateImageIdPointSets = (imageId) => {
            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = esm.metaData.get('imagePlaneModule', imageId);
            const topLeft = [...imagePositionPatient];
            const topRight = [...imagePositionPatient];
            const bottomLeft = [...imagePositionPatient];
            const bottomRight = [...imagePositionPatient];
            gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);
            gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);
            gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);
            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
            return { pointSet1, pointSet2 };
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const sourceImageIds = this.configuration.sourceImageIds;
            let renderStatus = false;
            if (!sourceImageIds?.length) {
                return renderStatus;
            }
            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;
            const targetImageIds = targetViewport.getImageIds();
            if (targetImageIds.length < 2) {
                return renderStatus;
            }
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), FrameOfReferenceUID);
            if (!annotations?.length) {
                return renderStatus;
            }
            const annotation = annotations[0];
            const { annotationUID } = annotation;
            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));
            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {
                return renderStatus;
            }
            const targetViewportPlane = esm.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const pointSets = annotation.data.pointSets;
            const viewportData = annotation.data.viewportData;
            for (let i = 0; i < sourceImageIds.length; i++) {
                const { pointSet1, pointSet2 } = pointSets[i];
                const targetData = viewportData.get(targetViewport.id) ||
                    this.initializeViewportData(viewportData, targetViewport.id);
                if (!targetData.pointSetsToUse[i]) {
                    let pointSetToUse = pointSet1;
                    let topBottomVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet1[0], pointSet1[1]);
                    topBottomVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topBottomVec);
                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
                        pointSetToUse = pointSet2;
                    }
                    targetData.pointSetsToUse[i] = pointSetToUse;
                    targetData.lineStartsWorld[i] = esm.utilities.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
                    targetData.lineEndsWorld[i] = esm.utilities.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
                }
                const lineStartWorld = targetData.lineStartsWorld[i];
                const lineEndWorld = targetData.lineEndsWorld[i];
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const shadow = this.getStyle('shadow', styleSpecifier, annotation);
                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
                const dataId = `${annotationUID}-line`;
                const lineUID = `${i}`;
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
            }
            renderStatus = true;
            return renderStatus;
        };
        this.initializeViewportData = (viewportData, id) => {
            viewportData.set(id, {
                pointSetsToUse: [],
                lineStartsWorld: [],
                lineEndsWorld: [],
            });
            return viewportData.get(id);
        };
        this.isPerpendicular = (vec1, vec2) => {
            const dot = gl_matrix_esm/* vec3.dot */.eR.dot(vec1, vec2);
            return Math.abs(dot) < OverlayGridTool_EPSILON;
        };
    }
    isParallel(vec1, vec2) {
        return Math.abs(gl_matrix_esm/* vec3.dot */.eR.dot(vec1, vec2)) > 1 - OverlayGridTool_EPSILON;
    }
    getImageIdNormal(imageId) {
        const { imageOrientationPatient } = esm.metaData.get('imagePlaneModule', imageId);
        const rowCosineVec = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
        const colCosineVec = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
        return gl_matrix_esm/* vec3.cross */.eR.cross(gl_matrix_esm/* vec3.create */.eR.create(), rowCosineVec, colCosineVec);
    }
}
OverlayGridTool.toolName = 'OverlayGrid';
/* harmony default export */ const tools_OverlayGridTool = (OverlayGridTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js
var pointToString = __webpack_require__(38726);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js









class SegmentationIntersectionTool extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            opacity: 0.5,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._init = () => {
            const viewportsInfo = (0,ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportsInfo?.length) {
                console.warn(this.getToolName() + 'Tool: No viewports found');
                return;
            }
            const firstViewport = (0,esm.getRenderingEngine)(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);
            if (!firstViewport) {
                return;
            }
            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), frameOfReferenceUID);
            if (!annotations?.length) {
                const actorsWorldPointsMap = new Map();
                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        FrameOfReferenceUID: frameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        actorsWorldPointsMap,
                    },
                };
                (0,annotationState.addAnnotation)(newAnnotation, frameOfReferenceUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this._init();
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const { viewport, FrameOfReferenceUID } = enabledElement;
            let renderStatus = false;
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), FrameOfReferenceUID);
            if (!annotations?.length) {
                return renderStatus;
            }
            const annotation = annotations[0];
            const { annotationUID } = annotation;
            const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;
            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
            const actorEntries = viewport.getActors();
            const cacheId = getCacheId(viewport);
            actorEntries.forEach((actorEntry) => {
                if (!actorEntry?.clippingFilter) {
                    return;
                }
                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);
                if (!actorWorldPointMap) {
                    return;
                }
                if (!actorWorldPointMap.get(cacheId)) {
                    return;
                }
                let polyLineIdx = 1;
                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);
                for (let i = 0; i < worldPointsSet.length; i++) {
                    const worldPoints = worldPointsSet[i];
                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));
                    const options = {
                        color: color,
                        fillColor: color,
                        fillOpacity: this.configuration.opacity,
                        closePath: true,
                        lineWidth: 2,
                    };
                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;
                    (0,drawingSvg.drawPath)(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);
                    polyLineIdx++;
                }
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
function calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {
    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
        const viewport = (0,esm.getRenderingEngine)(renderingEngineId)?.getViewport(viewportId);
        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
    });
}
function calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {
    const actorEntries = viewport.getActors();
    const cacheId = getCacheId(viewport);
    actorEntries.forEach((actorEntry) => {
        if (!actorEntry?.clippingFilter) {
            return;
        }
        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);
        if (!actorWorldPointsMap) {
            actorWorldPointsMap = new Map();
            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);
        }
        if (!actorWorldPointsMap.get(cacheId)) {
            const polyData = actorEntry.clippingFilter.getOutputData();
            const worldPointsSet = utilities.polyDataUtils.getPolyDataPoints(polyData);
            if (!worldPointsSet) {
                return;
            }
            const colorArray = actorEntry.actor.getProperty().getColor();
            const color = colorToString(colorArray);
            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });
        }
    });
}
function getCacheId(viewport) {
    const { viewPlaneNormal } = viewport.getCamera();
    const imageIndex = viewport.getCurrentImageIdIndex();
    return `${viewport.id}-${(0,pointToString/* pointToString */.l)(viewPlaneNormal)}-${imageIndex}`;
}
function colorToString(colorArray) {
    function colorComponentToString(component) {
        let componentString = Math.floor(component * 255).toString(16);
        if (componentString.length === 1) {
            componentString = '0' + componentString;
        }
        return componentString;
    }
    return ('#' +
        colorComponentToString(colorArray[0]) +
        colorComponentToString(colorArray[1]) +
        colorComponentToString(colorArray[2]));
}
function removeExtraPoints(viewport, worldPointsSet) {
    return worldPointsSet.map((worldPoints) => {
        const canvasPoints = worldPoints.map((point) => {
            const canvasPoint = viewport.worldToCanvas(point);
            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];
        });
        let lastPoint;
        const newWorldPoints = [];
        let newCanvasPoints = [];
        for (let i = 0; i < worldPoints.length; i++) {
            if (lastPoint) {
                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {
                    newWorldPoints.push(worldPoints[i]);
                    newCanvasPoints.push(canvasPoints[i]);
                }
            }
            lastPoint = canvasPoints[i];
        }
        const firstPoint = newCanvasPoints[0];
        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {
            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {
                newCanvasPoints = newCanvasPoints.slice(0, j);
                return newWorldPoints.slice(0, j);
            }
        }
        return newWorldPoints;
    });
}
SegmentationIntersectionTool.toolName = 'SegmentationIntersection';
/* harmony default export */ const tools_SegmentationIntersectionTool = (SegmentationIntersectionTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js











class ReferenceCursors extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            displayThreshold: 5,
            positionSync: true,
            disableCursor: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isHandleOutsideImage = false;
        this._elementWithCursor = null;
        this._currentCursorWorldPosition = null;
        this._currentCanvasPosition = null;
        this._disableCursorEnabled = false;
        this.mouseMoveCallback = (evt) => {
            const { detail } = evt;
            const { element, currentPoints } = detail;
            this._currentCursorWorldPosition = currentPoints.world;
            this._currentCanvasPosition = currentPoints.canvas;
            this._elementWithCursor = element;
            const annotation = this.getActiveAnnotation(element);
            if (annotation === null) {
                this.createInitialAnnotation(currentPoints.world, element);
                return false;
            }
            this.updateAnnotationPosition(element, annotation);
            return false;
        };
        this.createInitialAnnotation = (worldPos, element) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            if (!enabledElement) {
                throw new Error('No enabled element found');
            }
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            if (!viewPlaneNormal || !viewUp) {
                throw new Error('Camera not found');
            }
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: {
                        points: [[...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                },
            };
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (annotations.length > 0) {
                return null;
            }
            const annotationId = (0,annotationState.addAnnotation)(annotation, element);
            if (annotationId === null) {
                return;
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.onCameraModified = (evt) => {
            const eventDetail = evt.detail;
            const { element, previousCamera, camera } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const viewport = enabledElement.viewport;
            if (element !== this._elementWithCursor) {
                return;
            }
            const oldFocalPoint = previousCamera.focalPoint;
            const cameraNormal = camera.viewPlaneNormal;
            const newFocalPoint = camera.focalPoint;
            const deltaCameraFocalPoint = [0, 0, 0];
            Core_Math/* default.subtract */.Ay.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);
            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {
                return;
            }
            const dotProduct = Core_Math/* default.dot */.Ay.dot(deltaCameraFocalPoint, cameraNormal);
            if (Math.abs(dotProduct) < 1e-2) {
                return;
            }
            if (!this._currentCanvasPosition) {
                return;
            }
            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);
            this._currentCursorWorldPosition = newWorldPos;
            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport, FrameOfReferenceUID } = enabledElement;
            const isElementWithCursor = this._elementWithCursor === viewport.element;
            if (this.configuration.positionSync && !isElementWithCursor) {
                this.updateViewportImage(viewport);
            }
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points } = handles;
                if (!annotationUID) {
                    return renderStatus;
                }
                styleSpecifier.annotationUID = annotationUID;
                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));
                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor
                    ? lineWidthBase
                    : lineWidthBase;
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (points[0].some((e) => isNaN(e))) {
                    return renderStatus;
                }
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const crosshairUIDs = {
                    upper: 'upper',
                    right: 'right',
                    lower: 'lower',
                    left: 'left',
                };
                const [x, y] = canvasCoordinates[0];
                const centerSpace = isElementWithCursor ? 20 : 7;
                const lineLength = isElementWithCursor ? 5 : 7;
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });
                renderStatus = true;
            }
            return renderStatus;
        };
        this._disableCursorEnabled = this.configuration.disableCursor;
    }
    onSetToolActive() {
        this._disableCursorEnabled = this.configuration.disableCursor;
        if (!this._disableCursorEnabled) {
            return;
        }
        const viewportIds = (0,ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
        if (!viewportIds) {
            return;
        }
        const enabledElements = viewportIds.map((e) => (0,esm.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
        enabledElements.forEach((element) => {
            if (element) {
                (0,elementCursor.hideElementCursor)(element.viewport.element);
            }
        });
    }
    onSetToolDisabled() {
        if (!this._disableCursorEnabled) {
            return;
        }
        const viewportIds = (0,ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
        if (!viewportIds) {
            return;
        }
        const enabledElements = viewportIds.map((e) => (0,esm.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
        enabledElements.forEach((element) => {
            if (element) {
                (0,elementCursor.resetElementCursor)(element.viewport.element);
            }
        });
    }
    getActiveAnnotation(element) {
        const annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
        if (!annotations.length) {
            return null;
        }
        const targetAnnotation = annotations[0];
        return targetAnnotation;
    }
    updateAnnotationPosition(element, annotation) {
        const worldPos = this._currentCursorWorldPosition;
        if (!worldPos) {
            return;
        }
        if (!annotation.data?.handles?.points) {
            return;
        }
        annotation.data.handles.points = [[...worldPos]];
        annotation.invalidated = true;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
        const enabledElement = (0,esm.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!(annotations instanceof Array) || annotations.length === 0) {
            return [];
        }
        const annotation = annotations[0];
        const viewport = (0,esm.getEnabledElement)(element)?.viewport;
        if (!viewport) {
            return [];
        }
        const camera = viewport.getCamera();
        const { viewPlaneNormal, focalPoint } = camera;
        if (!viewPlaneNormal || !focalPoint) {
            return [];
        }
        const points = annotation.data?.handles?.points;
        if (!(points instanceof Array) || points.length !== 1) {
            return [];
        }
        const worldPos = points[0];
        const plane = esm.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
        const distance = esm.utilities.planar.planeDistanceToPoint(plane, worldPos);
        return distance < this.configuration.displayThreshold ? [annotation] : [];
    }
    updateViewportImage(viewport) {
        const currentMousePosition = this._currentCursorWorldPosition;
        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {
            return;
        }
        if (viewport instanceof esm.StackViewport) {
            const closestIndex = esm.utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);
            if (closestIndex === null) {
                return;
            }
            if (closestIndex !== viewport.getCurrentImageIdIndex()) {
                viewport.setImageIdIndex(closestIndex);
            }
        }
        else if (viewport instanceof esm.VolumeViewport) {
            const { focalPoint, viewPlaneNormal } = viewport.getCamera();
            if (!focalPoint || !viewPlaneNormal) {
                return;
            }
            const plane = esm.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const currentDistance = esm.utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);
            if (Math.abs(currentDistance) < 0.5) {
                return;
            }
            const normalizedViewPlane = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), gl_matrix_esm/* vec3.fromValues */.eR.fromValues(...viewPlaneNormal));
            const scaledPlaneNormal = gl_matrix_esm/* vec3.scale */.eR.scale(gl_matrix_esm/* vec3.create */.eR.create(), normalizedViewPlane, currentDistance);
            const newFocalPoint = gl_matrix_esm/* vec3.add */.eR.add(gl_matrix_esm/* vec3.create */.eR.create(), gl_matrix_esm/* vec3.fromValues */.eR.fromValues(...focalPoint), scaledPlaneNormal);
            const isInBounds = true;
            if (isInBounds) {
                viewport.setCamera({ focalPoint: newFocalPoint });
                const renderingEngine = viewport.getRenderingEngine();
                if (renderingEngine) {
                    renderingEngine.renderViewport(viewport.id);
                }
            }
        }
    }
}
ReferenceCursors.toolName = 'ReferenceCursors';
/* harmony default export */ const tools_ReferenceCursors = (ReferenceCursors);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js






const viewportsWithAnnotations = [];
class ScaleOverlayTool extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            viewportId: '',
            scaleLocation: 'bottom',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.editData = null;
        this._init = () => {
            const renderingEngines = (0,esm.getRenderingEngines)();
            const renderingEngine = renderingEngines[0];
            if (!renderingEngine) {
                return;
            }
            const viewportIds = (0,ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportIds) {
                return;
            }
            const enabledElements = viewportIds.map((e) => (0,esm.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
            let { viewport } = enabledElements[0];
            const { FrameOfReferenceUID } = enabledElements[0];
            if (this.configuration.viewportId) {
                enabledElements.forEach((element) => {
                    if (element.viewport.id == this.configuration.viewportId) {
                        viewport = element.viewport;
                    }
                });
            }
            if (!viewport) {
                return;
            }
            const { viewUp, viewPlaneNormal } = viewport.getCamera();
            const viewportCanvasCornersInWorld = esm.utilities.getViewportImageCornersInWorld(viewport);
            let annotation = this.editData.annotation;
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element);
            if (annotations.length) {
                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
            }
            enabledElements.forEach((element) => {
                const { viewport } = element;
                if (!viewportsWithAnnotations.includes(viewport.id)) {
                    const newAnnotation = {
                        metadata: {
                            toolName: this.getToolName(),
                            viewPlaneNormal: [...viewPlaneNormal],
                            viewUp: [...viewUp],
                            FrameOfReferenceUID,
                            referencedImageId: null,
                        },
                        data: {
                            handles: {
                                points: esm.utilities.getViewportImageCornersInWorld(viewport),
                            },
                            viewportId: viewport.id,
                        },
                    };
                    viewportsWithAnnotations.push(viewport.id);
                    (0,annotationState.addAnnotation)(newAnnotation, viewport.element);
                    annotation = newAnnotation;
                }
            });
            if (this.editData.annotation &&
                this.editData.annotation.data.viewportId == viewport.id) {
                this.editData.annotation.data.handles.points =
                    viewportCanvasCornersInWorld;
                this.editData.annotation.data.viewportId = viewport.id;
            }
            this.editData = {
                viewport,
                renderingEngine,
                annotation,
            };
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this.configuration.viewportId = evt.detail.viewportId;
            this._init();
        };
        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {
            const scaleSizes = [
                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,
            ];
            let currentScaleSize;
            if (location == 'top' || location == 'bottom') {
                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&
                    scaleSize > worldWidthViewport * 0.2);
            }
            else {
                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&
                    scaleSize > worldHeightViewport * 0.2);
            }
            return currentScaleSize[0];
        };
        this.computeEndScaleTicks = (canvasCoordinates, location) => {
            const locationTickOffset = {
                bottom: [
                    [0, -10],
                    [0, -10],
                ],
                top: [
                    [0, 10],
                    [0, 10],
                ],
                left: [
                    [0, 0],
                    [10, 0],
                ],
                right: [
                    [0, 0],
                    [-10, 0],
                ],
            };
            const endTick1 = [
                [
                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],
                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],
                ],
                [
                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],
                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],
                ],
            ];
            const endTick2 = [
                [
                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],
                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],
                ],
                [
                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],
                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],
                ],
            ];
            return {
                endTick1: endTick1,
                endTick2: endTick2,
            };
        };
        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {
            let canvasScaleSize;
            if (location == 'bottom' || location == 'top') {
                canvasScaleSize = rightTick[0][0] - leftTick[0][0];
            }
            else if (location == 'left' || location == 'right') {
                canvasScaleSize = rightTick[0][1] - leftTick[0][1];
            }
            const tickIds = [];
            const tickUIDs = [];
            const tickCoordinates = [];
            let numberSmallTicks = scaleSize;
            if (scaleSize >= 50) {
                numberSmallTicks = scaleSize / 10;
            }
            const tickSpacing = canvasScaleSize / numberSmallTicks;
            for (let i = 0; i < numberSmallTicks - 1; i++) {
                const locationOffset = {
                    bottom: [
                        [tickSpacing * (i + 1), 0],
                        [tickSpacing * (i + 1), 5],
                    ],
                    top: [
                        [tickSpacing * (i + 1), 0],
                        [tickSpacing * (i + 1), -5],
                    ],
                    left: [
                        [0, tickSpacing * (i + 1)],
                        [-5, tickSpacing * (i + 1)],
                    ],
                    right: [
                        [0, tickSpacing * (i + 1)],
                        [5, tickSpacing * (i + 1)],
                    ],
                };
                tickIds.push(`${annotationUID}-tick${i}`);
                tickUIDs.push(`tick${i}`);
                if ((i + 1) % 5 == 0) {
                    tickCoordinates.push([
                        [
                            leftTick[0][0] + locationOffset[location][0][0],
                            leftTick[0][1] + locationOffset[location][0][1],
                        ],
                        [
                            leftTick[1][0] + locationOffset[location][0][0],
                            leftTick[1][1] + locationOffset[location][0][1],
                        ],
                    ]);
                }
                else {
                    tickCoordinates.push([
                        [
                            leftTick[0][0] + locationOffset[location][0][0],
                            leftTick[0][1] + locationOffset[location][0][1],
                        ],
                        [
                            leftTick[1][0] + locationOffset[location][1][0],
                            leftTick[1][1] + locationOffset[location][1][1],
                        ],
                    ]);
                }
            }
            return { tickIds, tickUIDs, tickCoordinates };
        };
        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {
            let worldCoordinates;
            let topBottomVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet[0], pointSet[1]);
            topBottomVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topBottomVec);
            let topRightVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet[2], pointSet[0]);
            topRightVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topRightVec);
            const midpointLocation = {
                bottom: [pointSet[1], pointSet[2]],
                top: [pointSet[0], pointSet[3]],
                right: [pointSet[2], pointSet[3]],
                left: [pointSet[0], pointSet[1]],
            };
            const midpoint = gl_matrix_esm/* vec3.add */.eR.add(gl_matrix_esm/* vec3.create */.eR.create(), midpointLocation[location][0], midpointLocation[location][0])
                .map((i) => i / 2);
            const offset = scaleSize /
                2 /
                Math.sqrt(Math.pow(topBottomVec[0], 2) +
                    Math.pow(topBottomVec[1], 2) +
                    Math.pow(topBottomVec[2], 2));
            if (location == 'top' || location == 'bottom') {
                worldCoordinates = [
                    gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), midpoint, topRightVec.map((i) => i * offset)),
                    gl_matrix_esm/* vec3.add */.eR.add(gl_matrix_esm/* vec3.create */.eR.create(), midpoint, topRightVec.map((i) => i * offset)),
                ];
            }
            else if (location == 'left' || location == 'right') {
                worldCoordinates = [
                    gl_matrix_esm/* vec3.add */.eR.add(gl_matrix_esm/* vec3.create */.eR.create(), midpoint, topBottomVec.map((i) => i * offset)),
                    gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), midpoint, topBottomVec.map((i) => i * offset)),
                ];
            }
            return worldCoordinates;
        };
        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {
            let scaleCanvasCoordinates;
            if (location == 'top' || location == 'bottom') {
                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];
                scaleCanvasCoordinates = [
                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],
                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],
                ];
            }
            else if (location == 'left' || location == 'right') {
                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];
                scaleCanvasCoordinates = [
                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],
                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],
                ];
            }
            return scaleCanvasCoordinates;
        };
        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {
            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);
            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);
            const locationBounds = {
                bottom: [-vReduction, -hReduction],
                top: [vReduction, hReduction],
                left: [vReduction, hReduction],
                right: [-vReduction, -hReduction],
            };
            const canvasBounds = {
                bottom: [canvasSize.height, canvasSize.width],
                top: [0, canvasSize.width],
                left: [canvasSize.height, 0],
                right: [canvasSize.height, canvasSize.width],
            };
            return {
                height: canvasBounds[location][0] + locationBounds[location][0],
                width: canvasBounds[location][1] + locationBounds[location][1],
            };
        };
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.editData.viewport) {
            return;
        }
        const location = this.configuration.scaleLocation;
        const { viewport } = enabledElement;
        const annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element);
        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
        const canvas = enabledElement.viewport.canvas;
        const renderStatus = false;
        if (!viewport) {
            return renderStatus;
        }
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        const canvasSize = {
            width: canvas.width / window.devicePixelRatio || 1,
            height: canvas.height / window.devicePixelRatio || 1,
        };
        const topLeft = annotation.data.handles.points[0];
        const topRight = annotation.data.handles.points[1];
        const bottomLeft = annotation.data.handles.points[2];
        const bottomRight = annotation.data.handles.points[3];
        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
        const worldWidthViewport = gl_matrix_esm/* vec3.distance */.eR.distance(bottomLeft, bottomRight);
        const worldHeightViewport = gl_matrix_esm/* vec3.distance */.eR.distance(topLeft, bottomLeft);
        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);
        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));
        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);
        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);
        const { annotationUID } = annotation;
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
        const color = this.getStyle('color', styleSpecifier, annotation);
        const shadow = this.getStyle('shadow', styleSpecifier, annotation);
        const scaleId = `${annotationUID}-scaleline`;
        const scaleLineUID = '1';
        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, scaleId);
        const leftTickId = `${annotationUID}-left`;
        const leftTickUID = '2';
        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, leftTickId);
        const rightTickId = `${annotationUID}-right`;
        const rightTickUID = '3';
        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, rightTickId);
        const locationTextOffest = {
            bottom: [-10, -42],
            top: [-12, -35],
            left: [-40, -20],
            right: [-50, -20],
        };
        const textCanvasCoordinates = [
            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],
            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],
        ];
        const textBoxLines = this._getTextLines(scaleSize);
        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);
        for (let i = 0; i < tickUIDs.length; i++) {
            (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {
                color,
                width: lineWidth,
                lineDash,
                shadow,
            }, tickIds[i]);
        }
        const textUID = 'text0';
        (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {
            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
            fontSize: '14px',
            lineDash: '2,3',
            lineWidth: '1',
            shadow: true,
            color: color,
        });
        return renderStatus;
    }
    _getTextLines(scaleSize) {
        let scaleSizeDisplayValue;
        let scaleSizeUnits;
        if (scaleSize >= 50) {
            scaleSizeDisplayValue = scaleSize / 10;
            scaleSizeUnits = ' cm';
        }
        else {
            scaleSizeDisplayValue = scaleSize;
            scaleSizeUnits = ' mm';
        }
        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];
        return textLines;
    }
}
ScaleOverlayTool.toolName = 'ScaleOverlay';
/* harmony default export */ const tools_ScaleOverlayTool = (ScaleOverlayTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js
var math = __webpack_require__(95527);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
var helpers = __webpack_require__(76712);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool/CircleSculptCursor.js
var CircleSculptCursor = __webpack_require__(16175);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/distancePointToContour.js
var distancePointToContour = __webpack_require__(13271);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js












class SculptorTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            minSpacing: 1,
            referencedToolNames: [
                'PlanarFreehandROI',
                'PlanarFreehandContourSegmentationTool',
            ],
            toolShape: 'circle',
            referencedToolName: 'PlanarFreehandROI',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.registeredShapes = new Map();
        this.isActive = false;
        this.commonData = {
            activeAnnotationUID: null,
            viewportIdsToRender: [],
            isEditingOpenContour: false,
            canvasLocation: undefined,
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const element = eventData.element;
            this.configureToolSize(evt);
            this.selectFreehandTool(eventData);
            if (this.commonData.activeAnnotationUID === null) {
                return;
            }
            this.isActive = true;
            (0,elementCursor.hideElementCursor)(element);
            this.activateModify(element);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === enums.ToolModes.Active) {
                this.configureToolSize(evt);
                this.updateCursor(evt);
            }
            else {
                this.commonData.canvasLocation = undefined;
            }
        };
        this.endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const config = this.configuration;
            const enabledElement = (0,esm.getEnabledElement)(element);
            this.isActive = false;
            this.deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { renderingEngineId, viewportId } = enabledElement;
            const toolGroup = (0,ToolGroupManager.getToolGroupForViewport)(viewportId, renderingEngineId);
            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
            const annotations = this.filterSculptableAnnotationsForElement(element);
            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
            if (toolInstance.configuration.calculateStats) {
                activeAnnotation.invalidated = true;
            }
            (0,helpers_state/* triggerAnnotationModified */.XF)(activeAnnotation, element);
        };
        this.dragCallback = (evt) => {
            const eventData = evt.detail;
            const element = eventData.element;
            this.updateCursor(evt);
            const annotations = this.filterSculptableAnnotationsForElement(element);
            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
            if (!annotations?.length || !this.isActive) {
                return;
            }
            const points = activeAnnotation.data.contour.polyline;
            this.sculpt(eventData, points);
        };
        this.registerShapes(CircleSculptCursor/* default */.A.shapeName, CircleSculptCursor/* default */.A);
        this.setToolShape(this.configuration.toolShape);
    }
    registerShapes(shapeName, shapeClass) {
        const shape = new shapeClass();
        this.registeredShapes.set(shapeName, shape);
    }
    sculpt(eventData, points) {
        const config = this.configuration;
        const element = eventData.element;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        this.sculptData = {
            mousePoint: eventData.currentPoints.world,
            mouseCanvasPoint: eventData.currentPoints.canvas,
            points,
            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),
            element: element,
        };
        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);
        if (pushedHandles.first !== undefined) {
            this.insertNewHandles(pushedHandles);
        }
    }
    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {
        const { element } = this.sculptData;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const nextHandleIndex = contourIndex(i + 1, points.length);
        const currentCanvasPoint = viewport.worldToCanvas(points[i]);
        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);
        const distanceToNextHandle = math.point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);
        if (distanceToNextHandle > maxSpacing) {
            indicesToInsertAfter.push(i);
        }
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const element = eventData.element;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine, viewport } = enabledElement;
        this.commonData.viewportIdsToRender = [viewport.id];
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
        this.commonData.canvasLocation = eventData.currentPoints.canvas;
        if (this.isActive) {
            activeAnnotation.highlighted = true;
        }
        else {
            const cursorShape = this.registeredShapes.get(this.selectedShape);
            const canvasCoords = eventData.currentPoints.canvas;
            cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);
        }
        (0,triggerAnnotationRenderForViewportIds/* triggerAnnotationRenderForViewportIds */.t)(this.commonData.viewportIdsToRender);
    }
    filterSculptableAnnotationsForElement(element) {
        const config = this.configuration;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngineId, viewportId } = enabledElement;
        const sculptableAnnotations = [];
        const toolGroup = (0,ToolGroupManager.getToolGroupForViewport)(viewportId, renderingEngineId);
        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
        config.referencedToolNames.forEach((referencedToolName) => {
            const annotations = (0,stateManagement/* getAnnotations */.Rh)(referencedToolName, element);
            if (annotations) {
                sculptableAnnotations.push(...annotations);
            }
        });
        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);
    }
    configureToolSize(evt) {
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        cursorShape.configureToolSize(evt);
    }
    insertNewHandles(pushedHandles) {
        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);
        let newIndexModifier = 0;
        for (let i = 0; i < indicesToInsertAfter?.length; i++) {
            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;
            this.insertHandleRadially(insertIndex);
            newIndexModifier++;
        }
    }
    findNewHandleIndices(pushedHandles) {
        const { points, maxSpacing } = this.sculptData;
        const indicesToInsertAfter = [];
        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {
            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);
        }
        return indicesToInsertAfter;
    }
    insertHandleRadially(insertIndex) {
        const { points } = this.sculptData;
        if (insertIndex > points.length - 1 &&
            this.commonData.isEditingOpenContour) {
            return;
        }
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        const previousIndex = insertIndex - 1;
        const nextIndex = contourIndex(insertIndex, points.length);
        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);
        const handleData = insertPosition;
        points.splice(insertIndex, 0, handleData);
    }
    selectFreehandTool(eventData) {
        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);
        if (closestAnnotationUID === undefined) {
            return;
        }
        this.commonData.activeAnnotationUID = closestAnnotationUID;
    }
    getClosestFreehandToolOnElement(eventData) {
        const { element } = eventData;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const config = this.configuration;
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const canvasPoints = eventData.currentPoints.canvas;
        const closest = {
            distance: Infinity,
            toolIndex: undefined,
            annotationUID: undefined,
        };
        for (let i = 0; i < annotations?.length; i++) {
            if (annotations[i].isLocked || !annotations[i].isVisible) {
                continue;
            }
            const distanceFromTool = (0,distancePointToContour/* distancePointToContour */.X)(viewport, annotations[i], canvasPoints);
            if (distanceFromTool === -1) {
                continue;
            }
            if (distanceFromTool < closest.distance) {
                closest.distance = distanceFromTool;
                closest.toolIndex = i;
                closest.annotationUID = annotations[i].annotationUID;
            }
        }
        this.commonData.isEditingOpenContour =
            !annotations[closest.toolIndex].data.contour.closed;
        config.referencedToolName =
            annotations[closest.toolIndex].metadata.toolName;
        return closest.annotationUID;
    }
    activateModify(element) {
        element.addEventListener(enums.Events.MOUSE_UP, this.endCallback);
        element.addEventListener(enums.Events.MOUSE_CLICK, this.endCallback);
        element.addEventListener(enums.Events.MOUSE_DRAG, this.dragCallback);
        element.addEventListener(enums.Events.TOUCH_TAP, this.endCallback);
        element.addEventListener(enums.Events.TOUCH_END, this.endCallback);
        element.addEventListener(enums.Events.TOUCH_DRAG, this.dragCallback);
    }
    deactivateModify(element) {
        element.removeEventListener(enums.Events.MOUSE_UP, this.endCallback);
        element.removeEventListener(enums.Events.MOUSE_CLICK, this.endCallback);
        element.removeEventListener(enums.Events.MOUSE_DRAG, this.dragCallback);
        element.removeEventListener(enums.Events.TOUCH_TAP, this.endCallback);
        element.removeEventListener(enums.Events.TOUCH_END, this.endCallback);
        element.removeEventListener(enums.Events.TOUCH_DRAG, this.dragCallback);
    }
    setToolShape(toolShape) {
        this.selectedShape =
            this.registeredShapes.get(toolShape) ?? CircleSculptCursor/* default */.A.shapeName;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        const { viewport } = enabledElement;
        const { element } = viewport;
        const viewportIdsToRender = this.commonData.viewportIdsToRender;
        if (!this.commonData.canvasLocation ||
            this.mode !== enums.ToolModes.Active ||
            !viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        let color = (0,helpers/* getStyleProperty */.h)('color', styleSpecifier, enums.AnnotationStyleStates.Default, this.mode);
        if (this.isActive) {
            color = (0,helpers/* getStyleProperty */.h)('color', styleSpecifier, enums.AnnotationStyleStates.Highlighted, this.mode);
        }
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {
            color,
        });
    }
}
const contourIndex = (i, length) => {
    return (i + length) % length;
};
SculptorTool.toolName = 'SculptorTool';
/* harmony default export */ const tools_SculptorTool = (SculptorTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js



const DIRECTIONS = {
    X: [1, 0, 0],
    Y: [0, 1, 0],
    Z: [0, 0, 1],
    CUSTOM: [],
};
class VolumeRotateTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            direction: DIRECTIONS.Z,
            rotateIncrementDegrees: 30,
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    mouseWheelCallback(evt) {
        const { element, wheel } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { direction, rotateIncrementDegrees } = this.configuration;
        const camera = viewport.getCamera();
        const { viewUp, position, focalPoint } = camera;
        const { direction: deltaY } = wheel;
        const [cx, cy, cz] = focalPoint;
        const [ax, ay, az] = direction;
        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;
        const newPosition = [0, 0, 0];
        const newFocalPoint = [0, 0, 0];
        const newViewUp = [0, 0, 0];
        const transform = gl_matrix_esm/* mat4.identity */.pB.identity(new Float32Array(16));
        gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, [cx, cy, cz]);
        gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, [ax, ay, az]);
        gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, [-cx, -cy, -cz]);
        gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newPosition, position, transform);
        gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newFocalPoint, focalPoint, transform);
        gl_matrix_esm/* mat4.identity */.pB.identity(transform);
        gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, [ax, ay, az]);
        gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newViewUp, viewUp, transform);
        viewport.setCamera({
            position: newPosition,
            viewUp: newViewUp,
            focalPoint: newFocalPoint,
        });
        viewport.render();
    }
}
VolumeRotateTool.toolName = 'VolumeRotateMouseWheel';
/* harmony default export */ const tools_VolumeRotateTool = (VolumeRotateTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js
var BidirectionalTool = __webpack_require__(25072);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js
var getCalibratedUnits = __webpack_require__(4096);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js
var throttle = __webpack_require__(27730);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js + 1 modules
var drawing = __webpack_require__(66990);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js
















const { transformWorldToIndex } = esm.utilities;
class LengthTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    ...viewport.getViewReference({ points: [worldPos] }),
                    toolName: this.getToolName(),
                    referencedImageId,
                    viewUp,
                    cameraPosition,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const dataId = `${annotationUID}-line`;
                const lineUID = '1';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateLength(pos1, pos2) {
        const dx = pos1[0] - pos2[0];
        const dy = pos1[1] - pos2[1];
        const dz = pos1[2] - pos2[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData, dimensions } = image;
            const index1 = transformWorldToIndex(imageData, worldPos1);
            const index2 = transformWorldToIndex(imageData, worldPos2);
            const handles = [index1, index2];
            const { scale, unit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, handles);
            const length = this._calculateLength(worldPos1, worldPos2) / scale;
            this._isInsideVolume(index1, index2, dimensions)
                ? (this.isHandleOutsideImage = false)
                : (this.isHandleOutsideImage = true);
            cachedStats[targetId] = {
                length,
                unit,
            };
        }
        annotation.invalidated = false;
        (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
        return cachedStats;
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { length, unit } = cachedVolumeStats;
    if (length === undefined || length === null || isNaN(length)) {
        return;
    }
    const textLines = [`${esm.utilities.roundNumber(length)} ${unit}`];
    return textLines;
}
LengthTool.toolName = 'Length';
/* harmony default export */ const annotation_LengthTool = (LengthTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js
















const { transformWorldToIndex: HeightTool_transformWorldToIndex } = esm.utilities;
class HeightTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: HeightTool_defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    ...viewport.getViewReference({ points: [worldPos] }),
                    toolName: this.getToolName(),
                    referencedImageId,
                    viewUp,
                    cameraPosition,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                const enabledElement = (0,esm.getEnabledElement)(element);
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                let activeHandleCanvasCoords;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const heightUID = '0';
                (0,drawingSvg.drawHeight)(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash: lineDash,
                });
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateHeight(pos1, pos2) {
        const dx = pos2[0] - pos1[0];
        const dy = pos2[1] - pos1[1];
        const dz = pos2[2] - pos1[2];
        if (dx == 0) {
            if (dy != 0) {
                return Math.abs(dz);
            }
            else {
                return 0;
            }
        }
        else if (dy == 0) {
            return Math.abs(dz);
        }
        else if (dz == 0) {
            return Math.abs(dy);
        }
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData, dimensions } = image;
            const index1 = HeightTool_transformWorldToIndex(imageData, worldPos1);
            const index2 = HeightTool_transformWorldToIndex(imageData, worldPos2);
            const handles = [index1, index2];
            const { scale, unit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, handles);
            const height = this._calculateHeight(worldPos1, worldPos2) / scale;
            const outside = this._isInsideVolume(index1, index2, dimensions);
            this.isHandleOutsideImage = outside;
            cachedStats[targetId] = {
                height,
                unit,
            };
        }
        annotation.invalidated = false;
        (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
        return cachedStats;
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function HeightTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { height, unit } = cachedVolumeStats;
    if (height === undefined || height === null || isNaN(height)) {
        return;
    }
    const textLines = [`${esm.utilities.roundNumber(height)} ${unit}`];
    return textLines;
}
HeightTool.toolName = 'Height';
/* harmony default export */ const annotation_HeightTool = (HeightTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js
var getPixelValueUnits = __webpack_require__(40634);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js
var isViewportPreScaled = __webpack_require__(18990);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js














const { transformWorldToIndex: ProbeTool_transformWorldToIndex } = esm.utilities;
class ProbeTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: ProbeTool_defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: { points: [[...worldPos]] },
                    cachedStats: {},
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { viewportId, renderingEngine } = (0,esm.getEnabledElement)(element);
            this.eventDispatchDetail = {
                viewportId,
                renderingEngineId: renderingEngine.id,
            };
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            data.handles.points[0] = [...worldPos];
            annotation.invalidated = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const annotationUID = annotation.annotationUID;
                const data = annotation.data;
                const point = data.handles.points[0];
                const canvasCoordinates = viewport.worldToCanvas(point);
                styleSpecifier.annotationUID = annotationUID;
                const { color } = this.getAnnotationStyle({ annotation, styleSpecifier });
                if (!data.cachedStats) {
                    data.cachedStats = {};
                }
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].value == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        index: null,
                        value: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                    if (viewport instanceof esm.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = esm.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = esm.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const handleGroupUID = '0';
                (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (textLines) {
                    const textCanvasCoordinates = [
                        canvasCoordinates[0] + 6,
                        canvasCoordinates[1] - 6,
                    ];
                    const textUID = '0';
                    (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);
                }
            }
            return renderStatus;
        };
    }
    isPointNearTool() {
        return false;
    }
    toolSelectedCallback() { }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { data } = annotation;
        const point = data.handles.points[0];
        const annotationCanvasCoordinate = viewport.worldToCanvas(point);
        const near = gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
        if (near === true) {
            return point;
        }
    }
    handleSelectedCallback(evt, annotation) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { renderingEngineId, viewport } = enabledElement;
        const { element } = viewport;
        const worldPos = data.handles.points[0];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const pixelUnitsOptions = {
                isPreScaled: (0,isViewportPreScaled/* isViewportPreScaled */.u)(viewport, targetId),
                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
            };
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { dimensions, imageData, metadata, voxelManager } = image;
            const modality = metadata.Modality;
            let ijk = ProbeTool_transformWorldToIndex(imageData, worldPos);
            ijk = gl_matrix_esm/* vec3.round */.eR.round(ijk, ijk);
            if (esm.utilities.indexWithinDimensions(ijk, dimensions)) {
                this.isHandleOutsideImage = false;
                let value = voxelManager.getAtIJKPoint(ijk);
                if (targetId.startsWith('imageId:')) {
                    const imageId = targetId.split('imageId:')[1];
                    const imageURI = esm.utilities.imageIdToURI(imageId);
                    const viewports = esm.utilities.getViewportsWithImageURI(imageURI);
                    const viewport = viewports[0];
                    ijk[2] = viewport.getCurrentImageIdIndex();
                }
                let modalityUnit;
                if (modality === 'US') {
                    const calibratedResults = (0,getCalibratedUnits/* getCalibratedProbeUnitsAndValue */.Xw)(image, [
                        ijk,
                    ]);
                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);
                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);
                    modalityUnit = hasEnhancedRegionValues
                        ? calibratedResults.units
                        : 'raw';
                }
                else {
                    modalityUnit = (0,getPixelValueUnits/* getPixelValueUnits */.j)(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                }
                cachedStats[targetId] = {
                    index: ijk,
                    value,
                    Modality: modality,
                    modalityUnit,
                };
            }
            else {
                this.isHandleOutsideImage = true;
                cachedStats[targetId] = {
                    index: ijk,
                    Modality: modality,
                };
            }
            annotation.invalidated = false;
            (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
        }
        return cachedStats;
    }
}
function ProbeTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { index, value, modalityUnit } = cachedVolumeStats;
    if (value === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
    if (value instanceof Array && modalityUnit instanceof Array) {
        for (let i = 0; i < value.length; i++) {
            textLines.push(`${esm.utilities.roundNumber(value[i])} ${modalityUnit[i]}`);
        }
    }
    else {
        textLines.push(`${esm.utilities.roundNumber(value)} ${modalityUnit}`);
    }
    return textLines;
}
ProbeTool.toolName = 'Probe';
/* harmony default export */ const annotation_ProbeTool = (ProbeTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js






class DragProbeTool extends annotation_ProbeTool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: DragProbeTool_defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.postMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                invalidated: true,
                highlighted: true,
                isVisible: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: { points: [[...worldPos]] },
                    cachedStats: {},
                },
            };
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.postTouchStartCallback = (evt) => {
            return this.postMouseDownCallback(evt);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            if (!this.editData) {
                return renderStatus;
            }
            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const annotation = this.editData.annotation;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const point = data.handles.points[0];
            const canvasCoordinates = viewport.worldToCanvas(point);
            styleSpecifier.annotationUID = annotationUID;
            const { color } = this.getAnnotationStyle({
                annotation,
                styleSpecifier,
            });
            if (!data.cachedStats[targetId] ||
                data.cachedStats[targetId].value == null) {
                data.cachedStats[targetId] = {
                    Modality: null,
                    index: null,
                    value: null,
                };
                this._calculateCachedStats(annotation, renderingEngine, enabledElement);
            }
            else if (annotation.invalidated) {
                this._calculateCachedStats(annotation, renderingEngine, enabledElement);
            }
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const handleGroupUID = '0';
            (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });
            renderStatus = true;
            const textLines = this.configuration.getTextLines(data, targetId);
            if (textLines) {
                const textCanvasCoordinates = [
                    canvasCoordinates[0] + 6,
                    canvasCoordinates[1] - 6,
                ];
                const textUID = '0';
                (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));
            }
            return renderStatus;
        };
    }
}
function DragProbeTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { index, value, modalityUnit } = cachedVolumeStats;
    if (value === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);
    return textLines;
}
DragProbeTool.toolName = 'DragProbe';
/* harmony default export */ const annotation_DragProbeTool = (DragProbeTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js
var RectangleROITool = __webpack_require__(4010);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js
var getWorldWidthAndHeightFromTwoPoints = __webpack_require__(40133);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js + 2 modules
var ellipse = __webpack_require__(87009);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js + 2 modules
var basic = __webpack_require__(79362);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js




















const { transformWorldToIndex: EllipticalROITool_transformWorldToIndex } = esm.utilities;
class EllipticalROITool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            storePointData: false,
            centerPointRadius: 0,
            getTextLines: EllipticalROITool_defaultGetTextLines,
            statsCalculator: basic.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                    initialRotation: viewport.getRotation(),
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                centerWorld: worldPos,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const canvasCorners = (0,ellipse.getCanvasEllipseCorners)(canvasCoordinates);
            const [canvasPoint1, canvasPoint2] = canvasCorners;
            const minorEllipse = {
                left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,
                top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,
                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,
                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,
            };
            const majorEllipse = {
                left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,
                top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,
                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,
                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,
            };
            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);
            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);
            if (pointInMajorEllipse && !pointInMinorEllipse) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            let centerCanvas;
            let centerWorld;
            let canvasWidth;
            let canvasHeight;
            let originalHandleCanvas;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                const { viewport } = (0,esm.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = viewport;
                handleIndex = points.findIndex((p) => p === handle);
                const pointsCanvas = points.map(worldToCanvas);
                originalHandleCanvas = pointsCanvas[handleIndex];
                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);
                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);
                centerCanvas = [
                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,
                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,
                ];
                centerWorld = canvasToWorld(centerCanvas);
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                canvasWidth,
                canvasHeight,
                centerWorld,
                originalHandleCanvas,
                movingTextBox,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const { renderingEngine } = (0,esm.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerWorld } = this.editData;
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];
            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];
            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];
            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { viewport } = (0,esm.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = viewport;
            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            const { data } = annotation;
            const { points } = data.handles;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            if (handleIndex === 0 || handleIndex === 1) {
                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
                const canvasBottom = [
                    centerCanvas[0],
                    centerCanvas[1] - dYCanvas,
                ];
                const canvasTop = [
                    centerCanvas[0],
                    centerCanvas[1] + dYCanvas,
                ];
                points[0] = canvasToWorld(canvasBottom);
                points[1] = canvasToWorld(canvasTop);
                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];
                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;
                const canvasLeft = [
                    centerCanvas[0] - newHalfCanvasWidth,
                    centerCanvas[1],
                ];
                const canvasRight = [
                    centerCanvas[0] + newHalfCanvasWidth,
                    centerCanvas[1],
                ];
                points[2] = canvasToWorld(canvasLeft);
                points[3] = canvasToWorld(canvasRight);
            }
            else {
                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
                const canvasLeft = [
                    centerCanvas[0] - dXCanvas,
                    centerCanvas[1],
                ];
                const canvasRight = [
                    centerCanvas[0] + dXCanvas,
                    centerCanvas[1],
                ];
                points[2] = canvasToWorld(canvasLeft);
                points[3] = canvasToWorld(canvasRight);
                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];
                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;
                const canvasBottom = [
                    centerCanvas[0],
                    centerCanvas[1] - newHalfCanvasHeight,
                ];
                const canvasTop = [
                    centerCanvas[0],
                    centerCanvas[1] + newHalfCanvasHeight,
                ];
                points[0] = canvasToWorld(canvasBottom);
                points[1] = canvasToWorld(canvasTop);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasCorners = ((0,ellipse.getCanvasEllipseCorners)(canvasCoordinates));
                const { centerPointRadius } = this.configuration;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                    };
                    this._calculateCachedStats(annotation, viewport, renderingEngine);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                    if (viewport instanceof esm.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = esm.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = esm.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-ellipse`;
                const ellipseUID = '0';
                (0,drawingSvg.drawEllipseByCoordinates)(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                if (centerPointRadius > 0) {
                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);
                    if (minRadius > 3 * centerPointRadius) {
                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);
                        (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCorners);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {
            const data = annotation.data;
            const { element } = viewport;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            const [topLeftCanvas, bottomRightCanvas] = ((0,ellipse.getCanvasEllipseCorners)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = EllipticalROITool_transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const post2Index = EllipticalROITool_transformWorldToIndex(imageData, worldPos2);
                post2Index[0] = Math.floor(post2Index[0]);
                post2Index[1] = Math.floor(post2Index[1]);
                post2Index[2] = Math.floor(post2Index[2]);
                this.isHandleOutsideImage = !this._isInsideVolume(pos1Index, post2Index, dimensions);
                const iMin = Math.min(pos1Index[0], post2Index[0]);
                const iMax = Math.max(pos1Index[0], post2Index[0]);
                const jMin = Math.min(pos1Index[1], post2Index[1]);
                const jMax = Math.max(pos1Index[1], post2Index[1]);
                const kMin = Math.min(pos1Index[2], post2Index[2]);
                const kMax = Math.max(pos1Index[2], post2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const center = [
                    (topLeftWorld[0] + bottomRightWorld[0]) / 2,
                    (topLeftWorld[1] + bottomRightWorld[1]) / 2,
                    (topLeftWorld[2] + bottomRightWorld[2]) / 2,
                ];
                const ellipseObj = {
                    center,
                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,
                };
                const { worldWidth, worldHeight } = (0,getWorldWidthAndHeightFromTwoPoints/* default */.A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                const isEmptyArea = worldWidth === 0 && worldHeight === 0;
                const handles = [pos1Index, post2Index];
                const { scale, areaUnit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, handles);
                const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /
                    scale /
                    scale;
                const pixelUnitsOptions = {
                    isPreScaled: (0,isViewportPreScaled/* isViewportPreScaled */.u)(viewport, targetId),
                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                };
                const modalityUnit = (0,getPixelValueUnits/* getPixelValueUnits */.j)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    boundsIJK,
                    imageData,
                    isInObject: (pointLPS) => (0,ellipse.pointInEllipse)(ellipseObj, pointLPS, { fast: true }),
                    returnPoints: this.configuration.storePointData,
                });
                const stats = this.configuration.statsCalculator.getStatistics();
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    mean: stats.mean?.value,
                    max: stats.max?.value,
                    stdDev: stats.stdDev?.value,
                    statsArray: stats.array,
                    pointsInShape,
                    isEmptyArea,
                    areaUnit,
                    modalityUnit,
                };
            }
            annotation.invalidated = false;
            (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
                esm.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    _pointInEllipseCanvas(ellipse, location) {
        const xRadius = ellipse.width / 2;
        const yRadius = ellipse.height / 2;
        if (xRadius <= 0.0 || yRadius <= 0.0) {
            return false;
        }
        const center = [ellipse.left + xRadius, ellipse.top + yRadius];
        const normalized = [location[0] - center[0], location[1] - center[1]];
        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +
            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=
            1.0;
        return inEllipse;
    }
    _getCanvasEllipseCenter(ellipseCanvasPoints) {
        const [bottom, top, left, right] = ellipseCanvasPoints;
        const topLeft = [left[0], top[1]];
        const bottomRight = [right[0], bottom[1]];
        return [
            (topLeft[0] + bottomRight[0]) / 2,
            (topLeft[1] + bottomRight[1]) / 2,
        ];
    }
}
function EllipticalROITool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (mean) {
        textLines.push(`Mean: ${esm.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (max) {
        textLines.push(`Max: ${esm.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (stdDev) {
        textLines.push(`Std Dev: ${esm.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
EllipticalROITool.toolName = 'EllipticalROI';
/* harmony default export */ const annotation_EllipticalROITool = (EllipticalROITool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js





















const { transformWorldToIndex: CircleROITool_transformWorldToIndex } = esm.utilities;
class CircleROITool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            storePointData: false,
            centerPointRadius: 0,
            getTextLines: CircleROITool_defaultGetTextLines,
            statsCalculator: basic.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const radius = (0,circle/* getCanvasCircleRadius */.r)(canvasCoordinates);
            const radiusPoint = (0,circle/* getCanvasCircleRadius */.r)([
                canvasCoordinates[0],
                canvasCoords,
            ]);
            if (Math.abs(radiusPoint - radius) < proximity / 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const { renderingEngine } = (0,esm.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            data.handles.points = [
                data.handles.points[0],
                canvasToWorld(currentCanvasPoints),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
            const { annotation, handleIndex } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => worldToCanvas(p));
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            if (handleIndex === 0) {
                const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
                const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
                const canvasCenter = currentCanvasPoints;
                const canvasEnd = [
                    canvasCoordinates[1][0] + dXCanvas,
                    canvasCoordinates[1][1] + dYCanvas,
                ];
                points[0] = canvasToWorld(canvasCenter);
                points[1] = canvasToWorld(canvasEnd);
            }
            else {
                points[1] = canvasToWorld(currentCanvasPoints);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                const radius = (0,circle/* getCanvasCircleRadius */.r)(canvasCoordinates);
                const canvasCorners = (0,circle/* getCanvasCircleCorners */.H)(canvasCoordinates);
                const { centerPointRadius } = this.configuration;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                        radius: null,
                        radiusUnit: null,
                        perimeter: null,
                    };
                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                    if (viewport instanceof esm.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = esm.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = esm.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-circle`;
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                if (centerPointRadius > 0) {
                    if (radius > 3 * centerPointRadius) {
                        (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCorners);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
            const data = annotation.data;
            const { element } = viewport;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            const [topLeftCanvas, bottomRightCanvas] = ((0,circle/* getCanvasCircleCorners */.H)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = CircleROITool_transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const pos2Index = CircleROITool_transformWorldToIndex(imageData, worldPos2);
                pos2Index[0] = Math.floor(pos2Index[0]);
                pos2Index[1] = Math.floor(pos2Index[1]);
                pos2Index[2] = Math.floor(pos2Index[2]);
                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
                    const iMin = Math.min(pos1Index[0], pos2Index[0]);
                    const iMax = Math.max(pos1Index[0], pos2Index[0]);
                    const jMin = Math.min(pos1Index[1], pos2Index[1]);
                    const jMax = Math.max(pos1Index[1], pos2Index[1]);
                    const kMin = Math.min(pos1Index[2], pos2Index[2]);
                    const kMax = Math.max(pos1Index[2], pos2Index[2]);
                    const boundsIJK = [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ];
                    const center = [
                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,
                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,
                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,
                    ];
                    const ellipseObj = {
                        center,
                        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
                        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
                        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,
                    };
                    const { worldWidth, worldHeight } = (0,getWorldWidthAndHeightFromTwoPoints/* default */.A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;
                    const handles = [pos1Index, pos2Index];
                    const { scale, unit, areaUnit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, handles);
                    const aspect = (0,getCalibratedUnits/* getCalibratedAspect */.CQ)(image);
                    const area = Math.abs(Math.PI *
                        (worldWidth / scale / 2) *
                        (worldHeight / aspect / scale / 2));
                    const pixelUnitsOptions = {
                        isPreScaled: (0,isViewportPreScaled/* isViewportPreScaled */.u)(viewport, targetId),
                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                    };
                    const modalityUnit = (0,getPixelValueUnits/* getPixelValueUnits */.j)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                        isInObject: (pointLPS) => (0,ellipse.pointInEllipse)(ellipseObj, pointLPS, { fast: true }),
                        boundsIJK,
                        imageData,
                        returnPoints: this.configuration.storePointData,
                    });
                    const stats = this.configuration.statsCalculator.getStatistics();
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                        area,
                        mean: stats.mean?.value,
                        max: stats.max?.value,
                        stdDev: stats.stdDev?.value,
                        statsArray: stats.array,
                        pointsInShape: pointsInShape,
                        isEmptyArea,
                        areaUnit,
                        radius: worldWidth / 2 / scale,
                        radiusUnit: unit,
                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,
                        modalityUnit,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            annotation.invalidated = false;
            (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
                esm.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
}
function CircleROITool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { radius, radiusUnit, area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;
    const textLines = [];
    if (radius) {
        const radiusLine = isEmptyArea
            ? `Radius: Oblique not supported`
            : `Radius: ${esm.utilities.roundNumber(radius)} ${radiusUnit}`;
        textLines.push(radiusLine);
    }
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (mean) {
        textLines.push(`Mean: ${esm.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (max) {
        textLines.push(`Max: ${esm.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (stdDev) {
        textLines.push(`Std Dev: ${esm.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
CircleROITool.toolName = 'CircleROI';
/* harmony default export */ const annotation_CircleROITool = (CircleROITool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js













const CROSSHAIR_SIZE = 5;
class ETDRSGridTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            degrees: [45, 135, 225, 315],
            diameters: [10, 30, 60],
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        points: [[...worldPos]],
                    },
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const center = viewport.worldToCanvas(points[0]);
            const radius = (0,circle/* getCanvasCircleRadius */.r)([center, canvasCoords]);
            if (Math.abs(radius) < proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const { renderingEngine } = (0,esm.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            data.handles.points = [
                canvasToWorld(currentCanvasPoints),
                canvasToWorld(currentCanvasPoints),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            const { deltaPoints } = eventDetail;
            const worldPosDelta = deltaPoints.world;
            const points = data.handles.points;
            points.forEach((point) => {
                point[0] += worldPosDelta[0];
                point[1] += worldPosDelta[1];
                point[2] += worldPosDelta[2];
            });
            annotation.invalidated = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
            const { annotation } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => worldToCanvas(p));
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
            const canvasCenter = currentCanvasPoints;
            const canvasEnd = [
                canvasCoordinates[1][0] + dXCanvas,
                canvasCoordinates[1][1] + dYCanvas,
            ];
            points[0] = canvasToWorld(canvasCenter);
            points[1] = canvasToWorld(canvasEnd);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                const { renderingEngine } = (0,esm.getEnabledElement)(element);
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                let lineUID = `${annotationUID}-crosshair-vertical`;
                let start = [center[0], center[1] + CROSSHAIR_SIZE];
                let end = [center[0], center[1] - CROSSHAIR_SIZE];
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                    color,
                    lineDash,
                    lineWidth,
                });
                lineUID = `${annotationUID}-crosshair-horizontal`;
                start = [center[0] + CROSSHAIR_SIZE, center[1]];
                end = [center[0] - CROSSHAIR_SIZE, center[1]];
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                    color,
                    lineDash,
                    lineWidth,
                });
                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));
                for (let i = 0; i < diametersCanvas.length; i++) {
                    const dataId = `${annotationUID}-circle-${i}`;
                    const circleUID = `${annotationUID}-circle-${i}`;
                    (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {
                        color,
                        lineDash,
                        lineWidth,
                    }, dataId);
                }
                const degreesRad = (x) => (x * Math.PI) / 180;
                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));
                for (let i = 0; i < angleRadians.length; i++) {
                    const lineUID = `${annotationUID}-line-${i}`;
                    const start = [
                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],
                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],
                    ];
                    const end = [
                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],
                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],
                    ];
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                renderStatus = true;
            }
            return renderStatus;
        };
    }
    worldMeasureToCanvas(measurement, viewport) {
        const p1 = viewport.canvasToWorld([
            viewport.canvas.width / 2,
            viewport.canvas.height / 2,
        ]);
        const { viewUp } = viewport.getCamera();
        const p2 = gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(gl_matrix_esm/* vec3.create */.eR.create(), p1, viewUp, measurement);
        const p1Canvas = viewport.worldToCanvas(p1);
        const p2Canvas = viewport.worldToCanvas(p2);
        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +
            Math.pow(p2Canvas[1] - p1Canvas[1], 2));
        return distance;
    }
}
ETDRSGridTool.toolName = 'ETDRSGrid';
/* harmony default export */ const annotation_ETDRSGridTool = (ETDRSGridTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js
var getMouseModifier = __webpack_require__(76910);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js
var ContourAnnotation = __webpack_require__(93126);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js
var CardinalSpline = __webpack_require__(71543);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js
var LinearSpline = __webpack_require__(63802);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js
var CatmullRomSpline = __webpack_require__(31147);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js
var BSpline = __webpack_require__(34115);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js + 1 modules
var ContourSegmentationBaseTool = __webpack_require__(36320);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js




















const SPLINE_MIN_POINTS = 3;
const SPLINE_CLICK_CLOSE_CURVE_DIST = 10;
const DEFAULT_SPLINE_CONFIG = {
    resolution: 20,
    controlPointAdditionDistance: 6,
    controlPointDeletionDistance: 6,
    showControlPointsConnectors: false,
    controlPointAdditionEnabled: true,
    controlPointDeletionEnabled: true,
};
var SplineTypesEnum;
(function (SplineTypesEnum) {
    SplineTypesEnum["Cardinal"] = "CARDINAL";
    SplineTypesEnum["Linear"] = "LINEAR";
    SplineTypesEnum["CatmullRom"] = "CATMULLROM";
    SplineTypesEnum["BSpline"] = "BSPLINE";
})(SplineTypesEnum || (SplineTypesEnum = {}));
var SplineToolActions;
(function (SplineToolActions) {
    SplineToolActions["AddControlPoint"] = "addControlPoint";
    SplineToolActions["DeleteControlPoint"] = "deleteControlPoint";
})(SplineToolActions || (SplineToolActions = {}));
class SplineROITool extends ContourSegmentationBaseTool/* default */.A {
    static { this.SplineTypes = SplineTypesEnum; }
    static { this.Actions = SplineToolActions; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            calculateStats: true,
            getTextLines: SplineROITool_defaultGetTextLines,
            contourHoleAdditionModifierKey: enums.KeyboardBindings.Shift,
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            spline: {
                configuration: {
                    [SplineTypesEnum.Cardinal]: {
                        Class: CardinalSpline/* CardinalSpline */.A,
                        scale: 0.5,
                    },
                    [SplineTypesEnum.CatmullRom]: {
                        Class: CatmullRomSpline/* CatmullRomSpline */.e,
                    },
                    [SplineTypesEnum.Linear]: {
                        Class: LinearSpline/* LinearSpline */.F,
                    },
                    [SplineTypesEnum.BSpline]: {
                        Class: BSpline/* BSpline */.k,
                        controlPointAdditionEnabled: false,
                        controlPointDeletionEnabled: false,
                        showControlPointsConnectors: true,
                    },
                },
                type: SplineTypesEnum.CatmullRom,
                drawPreviewEnabled: true,
                lastControlPointDeletionKeys: ['Backspace', 'Delete'],
            },
            actions: {
                [SplineToolActions.AddControlPoint]: {
                    method: 'addControlPointCallback',
                    bindings: [
                        {
                            mouseButton: enums.MouseBindings.Primary,
                            modifierKey: enums.KeyboardBindings.Shift,
                        },
                    ],
                },
                [SplineToolActions.DeleteControlPoint]: {
                    method: 'deleteControlPointCallback',
                    bindings: [
                        {
                            mouseButton: enums.MouseBindings.Primary,
                            modifierKey: enums.KeyboardBindings.Ctrl,
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.fireChangeOnUpdate = null;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const { instance: spline } = annotation.data.spline;
            return spline.isPointNearCurve(canvasCoords, proximity);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            this._activateModify(element);
            (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            annotation.autoGenerated = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));
            const { imageData, dimensions } = image;
            this.isHandleOutsideImage = data.handles.points
                .map((p) => esm.utilities.transformWorldToIndex(imageData, p))
                .some((index) => !esm.utilities.indexWithinDimensions(index, dimensions));
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            const changeType = newAnnotation
                ? enums.ChangeTypes.Completed
                : enums.ChangeTypes.HandlesUpdated;
            if (!this.fireChangeOnUpdate) {
                this.fireChangeOnUpdate = {
                    annotationUID: annotation.annotationUID,
                    changeType,
                    contourHoleProcessingEnabled,
                };
            }
            else {
                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;
                this.fireChangeOnUpdate.changeType = changeType;
            }
            (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            this.editData = null;
            this.isDrawing = false;
        };
        this._keyDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const key = eventDetail.key ?? '';
            const { lastControlPointDeletionKeys } = this.configuration.spline;
            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);
            if (!deleteLastPoint) {
                return;
            }
            const { annotation } = this.editData;
            const { data } = annotation;
            if (data.handles.points.length === SPLINE_MIN_POINTS) {
                this.cancel(element);
                return;
            }
            else {
                const controlPointIndex = data.handles.points.length - 1;
                this._deleteControlPointByIndex(element, annotation, controlPointIndex);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { drawPreviewEnabled } = this.configuration.spline;
            if (!drawPreviewEnabled) {
                return;
            }
            const { element } = evt.detail;
            const { renderingEngine } = (0,esm.getEnabledElement)(element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;
            (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === enums.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            if (data.contour.closed) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const { canvas: canvasPoint, world: worldPoint } = currentPoints;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            let closeContour = data.handles.points.length >= 2 && doubleClick;
            let addNewPoint = true;
            if (data.handles.points.length >= 3) {
                const { instance: spline } = data.spline;
                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
                if (closestControlPoint?.index === 0) {
                    addNewPoint = false;
                    closeContour = true;
                }
            }
            if (addNewPoint) {
                data.handles.points.push(worldPoint);
            }
            data.contour.closed = data.contour.closed || closeContour;
            annotation.invalidated = true;
            (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            if (data.contour.closed) {
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                this.moveAnnotation(annotation, worldPosDelta);
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        };
        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {
            const eventType = enums.Events.ANNOTATION_COMPLETED;
            const eventDetail = {
                annotation,
                changeType: enums.ChangeTypes.Completed,
                contourHoleProcessingEnabled,
            };
            (0,esm.triggerEvent)(esm.eventTarget, eventType, eventDetail);
        };
        this.triggerAnnotationModified = (annotation, enabledElement, changeType = enums.ChangeTypes.StatsUpdated) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = enums.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
                changeType,
            };
            (0,esm.triggerEvent)(esm.eventTarget, eventType, eventDetail);
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = enums.ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {
            if (changeType === enums.ChangeTypes.Completed) {
                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);
            }
            else {
                this.triggerAnnotationModified(annotation, enabledElement, changeType);
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.KEY_DOWN, this._keyDownCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(enums.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.KEY_DOWN, this._keyDownCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(enums.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
            const data = annotation.data;
            const targetId = this.getTargetId(viewport);
            if (!data.spline.instance.closed || !textboxStyle.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = 'textBox';
            const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        this.addControlPointCallback = (evt, annotation) => {
            const { data } = annotation;
            const splineType = data.spline.type;
            const splineConfig = this._getSplineConfig(splineType);
            const maxDist = splineConfig.controlPointAdditionDistance;
            if (splineConfig.controlPointAdditionEnabled === false) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { instance: spline } = data.spline;
            const canvasPos = evt.detail.currentPoints.canvas;
            const closestPointInfo = spline.getClosestPoint(canvasPos);
            if (closestPointInfo.distance > maxDist) {
                return;
            }
            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);
            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));
            annotation.invalidated = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        };
        this.deleteControlPointCallback = (evt, annotation) => {
            const splineType = annotation.data.spline.type;
            const splineConfig = this._getSplineConfig(splineType);
            const maxDist = splineConfig.controlPointDeletionDistance;
            if (splineConfig.controlPointDeletionEnabled === false) {
                return;
            }
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const { canvas: canvasPos } = currentPoints;
            const { instance: spline } = annotation.data.spline;
            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);
            if (!closestControlPoint) {
                return;
            }
            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);
        };
        this._calculateCachedStats = (annotation, element) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            if (!data.contour.closed) {
                return;
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { cachedStats } = data;
            const { polyline: points } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix_esm/* vec3.distance */.eR.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix_esm/* vec3.distance */.eR.distance(originalWorldPoint, deltaYPoint);
                const { imageData } = image;
                const { scale, areaUnit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, () => {
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);
                    const topLeftBBWorld = viewport.canvasToWorld([
                        canvasMinX,
                        canvasMinY,
                    ]);
                    const topLeftBBIndex = esm.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = esm.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;
                area *= deltaInX * deltaInY;
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    areaUnit,
                };
            }
            this.triggerAnnotationModified(annotation, enabledElement, enums.ChangeTypes.StatsUpdated);
            return cachedStats;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { canvas: canvasPos } = currentPoints;
        const contourHoleProcessingEnabled = (0,getMouseModifier/* default */.A)(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        const annotation = this.createAnnotation(evt);
        this.isDrawing = true;
        this.addAnnotation(annotation, element);
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
            lastCanvasPoint: canvasPos,
            contourHoleProcessingEnabled,
        };
        this._activateDraw(element);
        evt.preventDefault();
        (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        return annotation;
    }
    cancel(element) {
        if (!this.isDrawing) {
            return;
        }
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        (0,elementCursor.resetElementCursor)(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        if (newAnnotation) {
            (0,annotationState.removeAnnotation)(annotation.annotationUID);
        }
        super.cancelAnnotation(annotation);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        this.editData = null;
        return annotation.annotationUID;
    }
    isContourSegmentationTool() {
        return false;
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { element } = viewport;
        const annotation = renderContext.annotation;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const { points: controlPoints, activeHandleIndex } = handles;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;
        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));
        const { drawPreviewEnabled } = this.configuration.spline;
        const splineType = annotation.data.spline.type;
        const splineConfig = this._getSplineConfig(splineType);
        const spline = annotation.data.spline.instance;
        const childAnnotations = (0,annotationState.getChildAnnotations)(annotation);
        const missingAnnotation = childAnnotations.findIndex((it) => !it);
        if (missingAnnotation !== -1) {
            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);
        }
        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));
        splineAnnotationsGroup.forEach((annotation) => {
            const spline = this._updateSplineInstance(element, annotation);
            const splinePolylineCanvas = spline.getPolylinePoints();
            this.updateContourPolyline(annotation, {
                points: splinePolylineCanvas,
                closed: data.contour.closed,
                targetWindingDirection: ContourAnnotation/* ContourWindingDirection */.W.Clockwise,
            }, viewport, { updateWindingDirection: data.contour.closed });
        });
        super.renderAnnotationInstance(renderContext);
        if (!data.cachedStats[targetId] ||
            data.cachedStats[targetId].areaUnit == null) {
            data.cachedStats[targetId] = {
                Modality: null,
                area: null,
                areaUnit: null,
            };
            this._calculateCachedStats(annotation, element);
        }
        else if (annotation.invalidated) {
            this._throttledCalculateCachedStats(annotation, element);
        }
        let activeHandleCanvasCoords;
        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {
            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords || newAnnotation || highlighted) {
            const handleGroupUID = '0';
            (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                color,
                lineWidth,
                handleRadius: '3',
            });
        }
        if (drawPreviewEnabled &&
            spline.numControlPoints > 1 &&
            this.editData?.lastCanvasPoint &&
            !spline.closed) {
            const { lastCanvasPoint } = this.editData;
            const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
            (0,drawingSvg.drawPolyline)(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {
                color: '#9EA0CA',
                lineDash: lineDash,
                lineWidth: 1,
            });
        }
        if (splineConfig.showControlPointsConnectors) {
            const controlPointsConnectors = [...canvasCoordinates];
            if (spline.closed) {
                controlPointsConnectors.push(canvasCoordinates[0]);
            }
            (0,drawingSvg.drawPolyline)(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {
                color: 'rgba(255, 255, 255, 0.5)',
                lineWidth: 1,
            });
        }
        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {
            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);
            this.fireChangeOnUpdate = null;
        }
        annotation.invalidated = false;
        return true;
    }
    createInterpolatedSplineControl(annotation) {
        if (annotation.data.handles.points?.length) {
            return;
        }
        const { polyline } = annotation.data.contour;
        if (!polyline || !polyline.length) {
            return;
        }
        annotation.data.handles.points = [];
        const { points } = annotation.data.handles;
        const increment = Math.max(10, Math.floor(polyline.length / 20));
        for (let i = 0; i < polyline.length - increment; i += increment) {
            points.push(polyline[i]);
        }
        points.push(polyline[polyline.length - 1]);
    }
    createAnnotation(evt) {
        const contourAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const { type: splineType } = this.configuration.spline;
        const splineConfig = this._getSplineConfig(splineType);
        const spline = new splineConfig.Class();
        const createSpline = () => ({
            type: splineConfig.type,
            instance: spline,
            resolution: splineConfig.resolution,
        });
        let onInterpolationComplete;
        if (this.configuration.interpolation?.enabled) {
            onInterpolationComplete = (annotation) => {
                annotation.data.spline ||= createSpline();
                this.createInterpolatedSplineControl(annotation);
            };
        }
        return esm.utilities.deepMerge(contourAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
                spline: createSpline(),
                cachedStats: {},
            },
            onInterpolationComplete,
        });
    }
    _deleteControlPointByIndex(element, annotation, controlPointIndex) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { points: controlPoints } = annotation.data.handles;
        if (controlPoints.length === 3) {
            (0,annotationState.removeAnnotation)(annotation.annotationUID);
        }
        else {
            controlPoints.splice(controlPointIndex, 1);
        }
        const { renderingEngine } = enabledElement;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        annotation.invalidated = true;
        (0,utilities.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
    }
    _isSplineROIAnnotation(annotation) {
        return !!annotation.data?.spline;
    }
    _getSplineConfig(type) {
        const { configuration: config } = this;
        const splineConfigs = config.spline.configuration;
        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);
    }
    _updateSplineInstance(element, annotation) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { data } = annotation;
        const { type: splineType, instance: spline } = annotation.data.spline;
        const splineConfig = this._getSplineConfig(splineType);
        const worldPoints = data.handles.points;
        const canvasPoints = worldPoints.map(worldToCanvas);
        const resolution = splineConfig.resolution !== undefined
            ? parseInt(splineConfig.resolution)
            : undefined;
        const scale = splineConfig.scale !== undefined
            ? parseFloat(splineConfig.scale)
            : undefined;
        spline.setControlPoints(canvasPoints);
        spline.closed = !!data.contour.closed;
        if (!spline.fixedResolution &&
            resolution !== undefined &&
            spline.resolution !== resolution) {
            spline.resolution = resolution;
            annotation.invalidated = true;
        }
        if (spline instanceof CardinalSpline/* CardinalSpline */.A &&
            !spline.fixedScale &&
            scale !== undefined &&
            spline.scale !== scale) {
            spline.scale = scale;
            annotation.invalidated = true;
        }
        return spline;
    }
}
function SplineROITool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    return textLines;
}
SplineROITool.toolName = 'SplineROI';
/* harmony default export */ const annotation_SplineROITool = (SplineROITool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js


class SplineContourSegmentationTool extends annotation_SplineROITool {
    constructor(toolProps) {
        const initialProps = esm.utilities.deepMerge({
            configuration: {
                calculateStats: false,
            },
        }, toolProps);
        super(initialProps);
    }
    isContourSegmentationTool() {
        return true;
    }
}
SplineContourSegmentationTool.toolName = 'SplineContourSegmentationTool';
/* harmony default export */ const annotation_SplineContourSegmentationTool = (SplineContourSegmentationTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js
var PlanarFreehandROITool = __webpack_require__(28220);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js
var PlanarFreehandContourSegmentationTool = __webpack_require__(37590);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js
var findHandlePolylineIndex = __webpack_require__(98013);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LivewireScissors.js + 1 modules
var LivewireScissors = __webpack_require__(78044);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LiveWirePath.js
var LiveWirePath = __webpack_require__(38776);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js



















const CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;
class LivewireContourTool extends ContourSegmentationBaseTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            getTextLines: LivewireContourTool_defaultGetTextLines,
            calculateStats: true,
            preventHandleOutsideImage: false,
            contourHoleAdditionModifierKey: enums.KeyboardBindings.Shift,
            snapHandleNearby: 2,
            interpolation: {
                enabled: false,
                nearestEdge: 2,
                showInterpolationPolyline: false,
            },
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            actions: {
                undo: {
                    method: 'undo',
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const proximitySquared = proximity * proximity;
            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            let startPoint = canvasPoints[canvasPoints.length - 1];
            for (let i = 0; i < canvasPoints.length; i++) {
                const endPoint = canvasPoints[i];
                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);
                if (distanceToPointSquared <= proximitySquared) {
                    return true;
                }
                startPoint = endPoint;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            this._activateModify(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt, clearAnnotation = false) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            if ((this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) ||
                clearAnnotation) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
                this.clearEditData();
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                return;
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            const changeType = newAnnotation
                ? enums.ChangeTypes.Completed
                : enums.ChangeTypes.HandlesUpdated;
            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);
            this.clearEditData();
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = enums.ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {
            if (changeType === enums.ChangeTypes.Completed) {
                (0,helpers_state/* triggerContourAnnotationCompleted */.PS)(annotation, contourHoleProcessingEnabled);
            }
            else {
                (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, enabledElement.viewport.element, changeType);
            }
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === enums.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } = this.editData;
            if (this.editData.closed) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;
            let worldPos = worldPosOriginal;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const controlPoints = this.editData.currentPath.getControlPoints();
            let closePath = controlPoints.length >= 2 && doubleClick;
            if (controlPoints.length >= 2) {
                const closestHandlePoint = {
                    index: -1,
                    distSquared: Infinity,
                };
                for (let i = 0, len = controlPoints.length; i < len; i++) {
                    const controlPoint = controlPoints[i];
                    const worldControlPoint = sliceToWorld(controlPoint);
                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);
                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);
                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&
                        distSquared < closestHandlePoint.distSquared) {
                        closestHandlePoint.distSquared = distSquared;
                        closestHandlePoint.index = i;
                    }
                }
                if (closestHandlePoint.index === 0) {
                    closePath = true;
                }
            }
            const { snapHandleNearby } = this.configuration;
            if (snapHandleNearby && !this.editData.closed) {
                const currentPath = new LiveWirePath/* LivewirePath */.j();
                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);
                const pathPoints = this.scissors.findPathToPoint(snapPoint);
                currentPath.addPoints(pathPoints);
                currentPath.prependPath(this.editData.confirmedPath);
                worldPos = sliceToWorld(snapPoint);
                this.editData.currentPath = currentPath;
            }
            this.editData.closed = this.editData.closed || closePath;
            this.editData.confirmedPath = this.editData.currentPath;
            const lastPoint = this.editData.currentPath.getLastPoint();
            this.editData.confirmedPath.addControlPoint(lastPoint);
            annotation.data.handles.points.push(sliceToWorld(lastPoint));
            this.scissors.startSearch(worldToSlice(worldPos));
            annotation.invalidated = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (this.editData.closed) {
                this.updateAnnotation(this.editData.confirmedPath);
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { element, currentPoints } = evt.detail;
            const { world: worldPos, canvas: canvasPos } = currentPoints;
            const { renderingEngine } = (0,esm.getEnabledElement)(element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = canvasPos;
            const { width: imgWidth, height: imgHeight } = this.scissors;
            const { worldToSlice } = this.editData;
            const slicePoint = worldToSlice(worldPos);
            if (slicePoint[0] < 0 ||
                slicePoint[1] < 0 ||
                slicePoint[0] >= imgWidth ||
                slicePoint[1] >= imgHeight) {
                return;
            }
            const pathPoints = this.scissors.findPathToPoint(slicePoint);
            const currentPath = new LiveWirePath/* LivewirePath */.j();
            currentPath.addPoints(pathPoints);
            currentPath.prependPath(this.editData.confirmedPath);
            this.editData.currentPath = currentPath;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                console.warn('Drag annotation not implemented');
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                this.editHandle(worldPos, element, annotation, handleIndex);
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            if (newAnnotation) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.editData = null;
            this.scissors = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(enums.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(enums.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._calculateCachedStats = (annotation, element) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            if (!data.contour.closed) {
                return;
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const { cachedStats } = data;
            const { polyline: points } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix_esm/* vec3.distance */.eR.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix_esm/* vec3.distance */.eR.distance(originalWorldPoint, deltaYPoint);
                const { imageData } = image;
                const { scale, areaUnit } = (0,utilities.getCalibratedLengthUnitsAndScale)(image, () => {
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);
                    const topLeftBBWorld = viewport.canvasToWorld([
                        canvasMinX,
                        canvasMinY,
                    ]);
                    const topLeftBBIndex = esm.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = esm.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;
                area *= deltaInX * deltaInY;
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    areaUnit: areaUnit,
                };
            }
            this.triggerAnnotationModified(annotation, enabledElement, enums.ChangeTypes.StatsUpdated);
            return cachedStats;
        };
        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
            const data = annotation.data;
            const targetId = this.getTargetId(viewport);
            if (!data.contour.closed || !textboxStyle.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = 'textBox';
            const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        this.triggerAnnotationModified = (annotation, enabledElement, changeType = enums.ChangeTypes.StatsUpdated) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = enums.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
                changeType,
            };
            (0,esm.triggerEvent)(esm.eventTarget, eventType, eventDetail);
        };
        this._throttledCalculateCachedStats = (0,utilities.throttle)(this._calculateCachedStats, 100, { trailing: true });
    }
    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        this.isDrawing = true;
        const viewportImageData = viewport.getImageData();
        const { imageData: vtkImageData } = viewportImageData;
        let worldToSlice;
        let sliceToWorld;
        let width;
        let height;
        let scalarData;
        if (!(viewport instanceof esm.VolumeViewport)) {
            width = viewportImageData.dimensions[0];
            height = viewportImageData.dimensions[1];
            worldToSlice = (point) => {
                const ijkPoint = esm.utilities.transformWorldToIndex(vtkImageData, point);
                return [ijkPoint[0], ijkPoint[1]];
            };
            sliceToWorld = (point) => esm.utilities.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);
            scalarData = viewportImageData.scalarData;
        }
        else if (viewport instanceof esm.VolumeViewport) {
            const sliceImageData = esm.utilities.getCurrentVolumeViewportSlice(viewport);
            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;
            worldToSlice = (point) => {
                const ijkPoint = esm.utilities.transformWorldToIndex(vtkImageData, point);
                const slicePoint = gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);
                return [slicePoint[0], slicePoint[1]];
            };
            sliceToWorld = (point) => {
                const ijkPoint = gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);
                return esm.utilities.transformIndexToWorld(vtkImageData, ijkPoint);
            };
            scalarData = sliceImageData.scalarData;
            width = sliceImageData.width;
            height = sliceImageData.height;
        }
        else {
            throw new Error('Viewport not supported');
        }
        scalarData = esm.utilities.convertToGrayscale(scalarData, width, height);
        const { voiRange } = viewport.getProperties();
        const startPos = worldToSlice(worldPos);
        this.scissors = LivewireScissors/* LivewireScissors */.f.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
        if (nextPos) {
            this.scissorsNext = LivewireScissors/* LivewireScissors */.f.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
            this.scissorsNext.startSearch(worldToSlice(nextPos));
        }
        this.scissors.startSearch(startPos);
        const newAnnotation = !nextPos;
        const confirmedPath = new LiveWirePath/* LivewirePath */.j();
        const currentPath = new LiveWirePath/* LivewirePath */.j();
        const currentPathNext = newAnnotation ? undefined : new LiveWirePath/* LivewirePath */.j();
        confirmedPath.addPoint(startPos);
        confirmedPath.addControlPoint(startPos);
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        const lastCanvasPoint = viewport.worldToCanvas(worldPos);
        this.editData = {
            annotation,
            viewportIdsToRender,
            newAnnotation,
            hasMoved: false,
            lastCanvasPoint,
            confirmedPath,
            currentPath,
            confirmedPathNext: currentPathNext,
            closed: false,
            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,
            worldToSlice,
            sliceToWorld,
            contourHoleProcessingEnabled,
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const annotation = this.createAnnotation(evt);
        const contourHoleProcessingEnabled = (0,getMouseModifier/* default */.A)(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);
        this.addAnnotation(annotation, element);
        this._activateDraw(element);
        evt.preventDefault();
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(this.editData.viewportIdsToRender);
        return annotation;
    }
    clearEditData() {
        this.editData = null;
        this.scissors = null;
        this.scissorsNext = null;
        this.isDrawing = false;
    }
    editHandle(worldPos, element, annotation, handleIndex) {
        const { data } = annotation;
        const { points: handlePoints } = data.handles;
        const { length: numHandles } = handlePoints;
        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];
        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];
        if (!this.editData?.confirmedPathNext) {
            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);
            const { polyline } = data.contour;
            const confirmedPath = new LiveWirePath/* LivewirePath */.j();
            const confirmedPathNext = new LiveWirePath/* LivewirePath */.j();
            const { worldToSlice } = this.editData;
            const previousIndex = (0,findHandlePolylineIndex/* default */.A)(annotation, handleIndex - 1);
            const nextIndex = (0,findHandlePolylineIndex/* default */.A)(annotation, handleIndex + 1);
            if (nextIndex === -1 || previousIndex === -1) {
                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);
            }
            if (handleIndex === 0) {
                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));
            }
            else {
                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));
                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));
            }
            this.editData.confirmedPath = confirmedPath;
            this.editData.confirmedPathNext = confirmedPathNext;
        }
        const { editData, scissors } = this;
        const { worldToSlice, sliceToWorld } = editData;
        const { activeHandleIndex } = data.handles;
        if (activeHandleIndex === null || activeHandleIndex === undefined) {
            data.handles.activeHandleIndex = handleIndex;
        }
        else if (activeHandleIndex !== handleIndex) {
            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);
        }
        const slicePos = worldToSlice(worldPos);
        if (slicePos[0] < 0 ||
            slicePos[0] >= scissors.width ||
            slicePos[1] < 0 ||
            slicePos[1] >= scissors.height) {
            return;
        }
        handlePoints[handleIndex] = sliceToWorld(slicePos);
        const pathPointsLeft = scissors.findPathToPoint(slicePos);
        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);
        const currentPath = new LiveWirePath/* LivewirePath */.j();
        currentPath.prependPath(editData.confirmedPath);
        if (handleIndex !== 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        currentPath.addPoints(pathPointsRight.reverse());
        currentPath.appendPath(editData.confirmedPathNext);
        if (handleIndex === 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        editData.currentPath = currentPath;
        annotation.invalidated = true;
        editData.hasMoved = true;
        editData.closed = true;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        this.updateAnnotation(this.editData?.currentPath);
        return super.renderAnnotation(enabledElement, svgDrawingHelper);
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const contourSegmentationAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const annotation = esm.utilities.deepMerge(contourSegmentationAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
            },
        });
        return annotation;
    }
    undo(element, config, evt) {
        if (!this.editData) {
            return;
        }
        this._endCallback(evt, true);
    }
    renderAnnotationInstance(renderContext) {
        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;
        const { viewport } = enabledElement;
        const { element } = viewport;
        const { worldToCanvas } = viewport;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color } = annotationStyle;
        if (highlighted ||
            (newAnnotation &&
                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {
            const handleGroupUID = '0';
            const canvasHandles = handles.points.map(worldToCanvas);
            (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {
                color,
                lineDash,
                lineWidth,
            });
        }
        super.renderAnnotationInstance(renderContext);
        if (!data.cachedStats[targetId] ||
            data.cachedStats[targetId].areaUnit == null) {
            data.cachedStats[targetId] = {
                Modality: null,
                area: null,
                areaUnit: null,
            };
            this._calculateCachedStats(annotation, element);
        }
        else if (annotation.invalidated) {
            this._throttledCalculateCachedStats(annotation, element);
        }
        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
        return true;
    }
    updateAnnotation(livewirePath) {
        if (!this.editData || !livewirePath) {
            return;
        }
        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;
        let { pointArray: imagePoints } = livewirePath;
        if (imagePoints.length > 1) {
            imagePoints = [...imagePoints, imagePoints[0]];
        }
        const targetWindingDirection = newAnnotation && closed ? ContourAnnotation/* ContourWindingDirection */.W.Clockwise : undefined;
        this.updateContourPolyline(annotation, {
            points: imagePoints,
            closed,
            targetWindingDirection,
        }, {
            canvasToWorld: sliceToWorld,
            worldToCanvas: worldToSlice,
        });
    }
}
LivewireContourTool.toolName = 'LivewireContour';
/* harmony default export */ const annotation_LivewireContourTool = (LivewireContourTool);
function LivewireContourTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, areaUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = `Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    return textLines;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js






class LivewireContourSegmentationTool extends annotation_LivewireContourTool {
    updateInterpolatedAnnotation(annotation, enabledElement) {
        if (this.editData ||
            !annotation.invalidated ||
            !annotation.data.handles.interpolationSources) {
            return;
        }
        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;
        queueMicrotask(() => {
            if (!annotation.data.handles.interpolationSources) {
                return;
            }
            const { points } = annotation.data.handles;
            const { element } = enabledElement.viewport;
            this.setupBaseEditData(points[0], element, annotation);
            const { length: count } = points;
            const { scissors } = this;
            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;
            annotation.data.handles.originalPoints = points;
            const { worldToSlice, sliceToWorld } = this.editData;
            const handleSmoothing = [];
            if (nearestEdge) {
                let lastPoint = worldToSlice(points[points.length - 1]);
                points.forEach((point, hIndex) => {
                    const testPoint = worldToSlice(point);
                    lastPoint = testPoint;
                    handleSmoothing.push(testPoint);
                    scissors.startSearch(lastPoint);
                    scissors.findPathToPoint(testPoint);
                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));
                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);
                    if (!esm.utilities.isEqual(testPoint, minPoint)) {
                        handleSmoothing[hIndex] = minPoint;
                        lastPoint = minPoint;
                        points[hIndex] = sliceToWorld(minPoint);
                    }
                });
            }
            const acceptedPath = new LiveWirePath/* LivewirePath */.j();
            for (let i = 0; i < count; i++) {
                scissors.startSearch(worldToSlice(points[i]));
                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));
                acceptedPath.addPoints(path);
            }
            this.updateAnnotation(acceptedPath);
            this.scissors = null;
            this.scissorsNext = null;
            this.editData = null;
            annotation.data.handles.interpolationSources = null;
            if (repeatInterpolation) {
                (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, enabledElement.viewport.element, enums.ChangeTypes.InterpolationUpdated);
            }
        });
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        const { annotationUID } = annotation;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { showInterpolationPolyline } = this.configuration.interpolation || {};
        this.updateInterpolatedAnnotation?.(annotation, enabledElement);
        const { originalPolyline } = annotation.data.contour;
        const rendered = super.renderAnnotationInstance(renderContext);
        if (showInterpolationPolyline &&
            originalPolyline &&
            annotation.autoGenerated) {
            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);
            polylineCanvasPoints.push(polylineCanvasPoints[0]);
            (0,drawingSvg.drawPolyline)(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {
                color: '#70ffff',
                lineWidth: 1,
                fillOpacity: 0,
            });
        }
        return rendered;
    }
    isContourSegmentationTool() {
        return true;
    }
}
LivewireContourSegmentationTool.toolName = 'LivewireContourSegmentationTool';
/* harmony default export */ const annotation_LivewireContourSegmentationTool = (LivewireContourSegmentationTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js












class ArrowAnnotateTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            getTextCallback,
            changeTextCallback,
            preventHandleOutsideImage: false,
            arrowFirst: true,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const { arrowFirst } = this.configuration;
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    text: '',
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        arrowFirst,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            if (newAnnotation) {
                this.configuration.getTextCallback((text) => {
                    if (!text) {
                        (0,annotationState.removeAnnotation)(annotation.annotationUID);
                        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                        this.editData = null;
                        this.isDrawing = false;
                        return;
                    }
                    annotation.data.text = text;
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                    (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                });
            }
            else {
                (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.touchTapCallback = (evt) => {
            if (evt.detail.taps == 2) {
                this.doubleClickCallback(evt);
            }
        };
        this.doubleClickCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return;
            }
            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));
            if (!clickedAnnotation) {
                return;
            }
            const annotation = clickedAnnotation;
            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
            this.editData = null;
            this.isDrawing = false;
            evt.stopImmediatePropagation();
            evt.preventDefault();
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles, text } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                let activeHandleCanvasCoords;
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineWidth,
                    });
                }
                const arrowUID = '1';
                if (this.configuration.arrowFirst) {
                    (0,drawingSvg.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {
                        color,
                        width: lineWidth,
                        lineDash: lineDash,
                    });
                }
                else {
                    (0,drawingSvg.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {
                        color,
                        width: lineWidth,
                        lineDash: lineDash,
                    });
                }
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!text) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.text = updatedText;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
ArrowAnnotateTool.toolName = 'ArrowAnnotate';
/* harmony default export */ const annotation_ArrowAnnotateTool = (ArrowAnnotateTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js














class AngleTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: AngleTool_defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.angleStartedNotYetCompleted) {
                return;
            }
            this.angleStartedNotYetCompleted = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2, point3] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line1 = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            if (!point3) {
                return false;
            }
            const canvasPoint3 = viewport.worldToCanvas(point3);
            const line2 = {
                start: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
                end: {
                    x: canvasPoint3[0],
                    y: canvasPoint3[1],
                },
            };
            const distanceToPoint2 = math_line.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint2 <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {
                this.editData.handleIndex = 2;
                return;
            }
            this.angleStartedNotYetCompleted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                this.angleStartedNotYetCompleted = false;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].angle == null) {
                    data.cachedStats[targetId] = {
                        angle: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationLocking.isAnnotationLocked)(annotation.annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                let lineUID = '1';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                renderStatus = true;
                if (canvasCoordinates.length !== 3) {
                    return renderStatus;
                }
                lineUID = '2';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                if (!data.cachedStats[targetId]?.angle) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        if (data.handles.points.length !== 3) {
            return;
        }
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const worldPos3 = data.handles.points[2];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const angle = (0,angleBetweenLines/* default */.A)([worldPos1, worldPos2], [worldPos2, worldPos3]);
            const { dimensions, imageData } = this.getTargetImageData(targetId);
            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]
                .map((worldPos) => esm.utilities.transformWorldToIndex(imageData, worldPos))
                .some((index) => !esm.utilities.indexWithinDimensions(index, dimensions));
            cachedStats[targetId] = {
                angle: isNaN(angle) ? 'Incomplete Angle' : angle,
            };
        }
        annotation.invalidated = false;
        (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
        return cachedStats;
    }
}
function AngleTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { angle } = cachedVolumeStats;
    if (angle === undefined) {
        return;
    }
    if (isNaN(angle)) {
        return [`${angle}`];
    }
    const textLines = [
        `${esm.utilities.roundNumber(angle)} ${String.fromCharCode(176)}`,
    ];
    return textLines;
}
AngleTool.toolName = 'Angle';
/* harmony default export */ const annotation_AngleTool = (AngleTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js
var midPoint = __webpack_require__(82983);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js

















class CobbAngleTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: CobbAngleTool_defaultGetTextLines,
            showArcLines: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.angleStartedNotYetCompleted) {
                return;
            }
            this.angleStartedNotYetCompleted = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({
                viewport,
                points: data.handles.points,
                canvasCoords,
                proximity,
            });
            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({
                viewport,
                points: annotation.data.handles.points,
                canvasCoords,
                proximity,
            });
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
                isNearFirstLine,
                isNearSecondLine,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._mouseUpCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {
                (0,elementCursor.resetElementCursor)(element);
                this.editData.handleIndex = data.handles.points.length;
                return;
            }
            this.angleStartedNotYetCompleted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._mouseDownCallback = (evt) => {
            const { annotation, handleIndex } = this.editData;
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const worldPos = currentPoints.world;
            const { data } = annotation;
            if (handleIndex === 1) {
                data.handles.points[1] = worldPos;
                this.editData.hasMoved =
                    data.handles.points[1][0] !== data.handles.points[0][0] ||
                        data.handles.points[1][1] !== data.handles.points[0][0];
                return;
            }
            if (handleIndex === 3) {
                data.handles.points[3] = worldPos;
                this.editData.hasMoved =
                    data.handles.points[3][0] !== data.handles.points[2][0] ||
                        data.handles.points[3][1] !== data.handles.points[2][0];
                this.angleStartedNotYetCompleted = false;
                return;
            }
            this.editData.hasMoved = false;
            (0,elementCursor.hideElementCursor)(element);
            data.handles.points[2] = data.handles.points[3] = worldPos;
            this.editData.handleIndex = data.handles.points.length - 1;
        };
        this._mouseDragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined &&
                (isNearFirstLine || isNearSecondLine)) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                if (isNearFirstLine) {
                    const firstLinePoints = [points[0], points[1]];
                    firstLinePoints.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                }
                else if (isNearSecondLine) {
                    const secondLinePoints = [points[2], points[3]];
                    secondLinePoints.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                }
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            if (data.handles.points.length < 4) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
            this.editData = null;
            this.angleStartedNotYetCompleted = false;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._mouseUpCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._mouseUpCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._mouseUpCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._mouseUpCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._mouseUpCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseDragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._mouseUpCallback);
            element.addEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._mouseUpCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._mouseDragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._mouseUpCallback);
            element.removeEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].angle == null) {
                    data.cachedStats[targetId] = {
                        angle: null,
                        arc1Angle: null,
                        arc2Angle: null,
                        points: {
                            world: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null,
                            },
                            canvas: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null,
                            },
                        },
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];
                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];
                let lineUID = 'line1';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                renderStatus = true;
                if (canvasCoordinates.length < 4) {
                    return renderStatus;
                }
                lineUID = 'line2';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                lineUID = 'linkLine';
                const mid1 = (0,midPoint/* midPoint2 */.f)(firstLine[0], firstLine[1]);
                const mid2 = (0,midPoint/* midPoint2 */.f)(secondLine[0], secondLine[1]);
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {
                    color,
                    lineWidth: '1',
                    lineDash: '1,4',
                });
                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;
                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];
                if (this.configuration.showArcLines) {
                    lineUID = 'arc1';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {
                        color,
                        lineWidth: '1',
                    });
                    lineUID = 'arc2';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {
                        color,
                        lineWidth: '1',
                    });
                }
                if (!data.cachedStats[targetId]?.angle) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = 'cobbAngleText';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
                if (this.configuration.showArcLines) {
                    const arc1TextBoxUID = 'arcAngle1';
                    const arc1TextLine = [
                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,
                    ];
                    const arch1TextPosCanvas = (0,midPoint/* midPoint2 */.f)(arc1Start, arc1End);
                    (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {
                        ...options,
                        padding: 3,
                    });
                    const arc2TextBoxUID = 'arcAngle2';
                    const arc2TextLine = [
                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,
                    ];
                    const arch2TextPosCanvas = (0,midPoint/* midPoint2 */.f)(arc2Start, arc2End);
                    (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {
                        ...options,
                        padding: 3,
                    });
                }
            }
            return renderStatus;
        };
        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {
            const [point1, point2, point3, point4] = points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const canvasPoint3 = viewport.worldToCanvas(point3);
            const canvasPoint4 = viewport.worldToCanvas(point4);
            const line1 = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const line2 = {
                start: {
                    x: canvasPoint3[0],
                    y: canvasPoint3[1],
                },
                end: {
                    x: canvasPoint4[0],
                    y: canvasPoint4[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const distanceToPoint2 = math_line.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
            let isNearFirstLine = false;
            let isNearSecondLine = false;
            if (distanceToPoint <= proximity) {
                isNearFirstLine = true;
            }
            else if (distanceToPoint2 <= proximity) {
                isNearSecondLine = true;
            }
            return {
                distanceToPoint,
                distanceToPoint2,
                isNearFirstLine,
                isNearSecondLine,
            };
        };
        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {
            const linkLine = [mid1, mid2];
            const arc1Angle = (0,angleBetweenLines/* default */.A)(firstLine, linkLine);
            const arc2Angle = (0,angleBetweenLines/* default */.A)(secondLine, linkLine);
            const arc1Side = arc1Angle > 90 ? 1 : 0;
            const arc2Side = arc2Angle > 90 ? 0 : 1;
            const midLinkLine = (0,midPoint/* midPoint2 */.f)(linkLine[0], linkLine[1]);
            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +
                (linkLine[1][1] - linkLine[0][1]) ** 2);
            const ratio = 0.1;
            const midFirstLine = (0,midPoint/* midPoint2 */.f)(firstLine[0], firstLine[1]);
            const midSecondLine = (0,midPoint/* midPoint2 */.f)(secondLine[0], secondLine[1]);
            const directionVectorStartArc1 = [
                firstLine[arc1Side][0] - midFirstLine[0],
                firstLine[arc1Side][1] - midFirstLine[1],
            ];
            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);
            const normalizedDirectionStartArc1 = [
                directionVectorStartArc1[0] / magnitudeStartArc1,
                directionVectorStartArc1[1] / magnitudeStartArc1,
            ];
            const arc1Start = [
                midFirstLine[0] +
                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,
                midFirstLine[1] +
                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,
            ];
            const directionVectorEndArc1 = [
                midLinkLine[0] - mid1[0],
                midLinkLine[1] - mid1[1],
            ];
            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);
            const normalizedDirectionEndArc1 = [
                directionVectorEndArc1[0] / magnitudeEndArc1,
                directionVectorEndArc1[1] / magnitudeEndArc1,
            ];
            const arc1End = [
                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,
                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,
            ];
            const directionVectorStartArc2 = [
                secondLine[arc2Side][0] - midSecondLine[0],
                secondLine[arc2Side][1] - midSecondLine[1],
            ];
            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);
            const normalizedDirectionStartArc2 = [
                directionVectorStartArc2[0] / magnitudeStartArc2,
                directionVectorStartArc2[1] / magnitudeStartArc2,
            ];
            const arc2Start = [
                midSecondLine[0] +
                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,
                midSecondLine[1] +
                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,
            ];
            const directionVectorEndArc2 = [
                midLinkLine[0] - mid2[0],
                midLinkLine[1] - mid2[1],
            ];
            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);
            const normalizedDirectionEndArc2 = [
                directionVectorEndArc2[0] / magnitudeEndArc2,
                directionVectorEndArc2[1] / magnitudeEndArc2,
            ];
            const arc2End = [
                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,
                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,
            ];
            return {
                arc1Start,
                arc1End,
                arc2Start,
                arc2End,
                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,
                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,
            };
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 25, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        if (data.handles.points.length !== 4) {
            return;
        }
        const seg1 = [null, null];
        const seg2 = [null, null];
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < 2; i += 1) {
            for (let j = 2; j < 4; j += 1) {
                const dist = gl_matrix_esm/* vec3.distance */.eR.distance(data.handles.points[i], data.handles.points[j]);
                if (dist < minDist) {
                    minDist = dist;
                    seg1[1] = data.handles.points[i];
                    seg1[0] = data.handles.points[(i + 1) % 2];
                    seg2[0] = data.handles.points[j];
                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];
                }
            }
        }
        const { viewport } = enabledElement;
        const { element } = viewport;
        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));
        const firstLine = [canvasPoints[0], canvasPoints[1]];
        const secondLine = [canvasPoints[2], canvasPoints[3]];
        const mid1 = (0,midPoint/* midPoint2 */.f)(firstLine[0], firstLine[1]);
        const mid2 = (0,midPoint/* midPoint2 */.f)(secondLine[0], secondLine[1]);
        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({
            firstLine,
            secondLine,
            mid1,
            mid2,
        });
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            cachedStats[targetId] = {
                angle: (0,angleBetweenLines/* default */.A)(seg1, seg2),
                arc1Angle,
                arc2Angle,
                points: {
                    canvas: {
                        arc1Start,
                        arc1End,
                        arc2End,
                        arc2Start,
                    },
                    world: {
                        arc1Start: viewport.canvasToWorld(arc1Start),
                        arc1End: viewport.canvasToWorld(arc1End),
                        arc2End: viewport.canvasToWorld(arc2End),
                        arc2Start: viewport.canvasToWorld(arc2Start),
                    },
                },
            };
        }
        annotation.invalidated = false;
        (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
        return cachedStats;
    }
}
function CobbAngleTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { angle } = cachedVolumeStats;
    if (angle === undefined) {
        return;
    }
    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];
    return textLines;
}
CobbAngleTool.toolName = 'CobbAngle';
/* harmony default export */ const annotation_CobbAngleTool = (CobbAngleTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js













const { transformWorldToIndex: UltrasoundDirectionalTool_transformWorldToIndex } = esm.utilities;
class UltrasoundDirectionalTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: UltrasoundDirectionalTool_defaultGetTextLines,
            displayBothAxesDistances: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.startedDrawing) {
                return;
            }
            this.startedDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            if (!(viewport instanceof esm.StackViewport)) {
                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');
            }
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            return false;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.startedDrawing && data.handles.points.length === 1) {
                this.editData.handleIndex = 1;
                return;
            }
            this.startedDrawing = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                }
                this.editData = null;
                this.startedDrawing = false;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].xValues == null) {
                    data.cachedStats[targetId] = {
                        xValues: [0, 0],
                        yValues: [0, 0],
                        isHorizontal: false,
                        units: [''],
                        isUnitless: false,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let handleGroupUID = '0';
                (0,drawingSvg.drawHandle)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {
                    color,
                }, 0);
                renderStatus = true;
                if (canvasCoordinates.length !== 2) {
                    return renderStatus;
                }
                handleGroupUID = '1';
                (0,drawingSvg.drawHandle)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {
                    color,
                }, 1);
                const isUnitless = data.cachedStats[targetId].isUnitless;
                if (!isUnitless) {
                    const canvasPoint1 = canvasCoordinates[0];
                    const canvasPoint2 = canvasCoordinates[1];
                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
                    const isHorizontal = data.cachedStats[targetId].isHorizontal;
                    let projectedPointCanvas = [0, 0];
                    if (isHorizontal) {
                        projectedPointCanvas = [
                            canvasPoint1[0] + canvasDeltaX,
                            canvasPoint1[1],
                        ];
                    }
                    else {
                        projectedPointCanvas = [
                            canvasPoint1[0],
                            canvasPoint1[1] + canvasDeltaY,
                        ];
                    }
                    let dataId = `${annotationUID}-line-1`;
                    let lineUID = '1';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {
                        color,
                        width: 1,
                        shadow: this.configuration.shadow,
                    }, dataId);
                    dataId = `${annotationUID}-line-2`;
                    lineUID = '2';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {
                        color,
                        width: 1,
                        lineDash: [1, 1],
                        shadow: this.configuration.shadow,
                    }, dataId);
                }
                else {
                    const dataId = `${annotationUID}-line-1`;
                    const lineUID = '1';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                        color,
                        width: 1,
                        shadow: this.configuration.shadow,
                    }, dataId);
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {
        return;
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        this.editData = {
            handleIndex,
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        if (data.handles.points.length !== 2) {
            return;
        }
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData } = image;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[1];
            const imageIndex1 = UltrasoundDirectionalTool_transformWorldToIndex(imageData, worldPos1);
            const imageIndex2 = UltrasoundDirectionalTool_transformWorldToIndex(imageData, worldPos2);
            const { values: values1, units: units1 } = (0,getCalibratedUnits/* getCalibratedProbeUnitsAndValue */.Xw)(image, [imageIndex1]);
            const { values: values2, units: units2 } = (0,getCalibratedUnits/* getCalibratedProbeUnitsAndValue */.Xw)(image, [imageIndex2]);
            let xValues, yValues, units, isHorizontal;
            let isUnitless = false;
            if (units1[0] !== units2[0] ||
                units1[1] !== units2[1] ||
                (units1[0] === 'raw' && units2[0] === 'raw')) {
                const value = (0,point.distanceToPoint)(worldPos1, worldPos2);
                xValues = [value, 0];
                yValues = [value, 0];
                units = ['px'];
                isUnitless = true;
            }
            else {
                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);
                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);
                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);
                xValues = [values1[0], values2[0]];
                yValues = [values1[1], values2[1]];
                units = [units1[0], units1[1]];
            }
            cachedStats[targetId] = {
                xValues,
                yValues,
                isHorizontal,
                units,
                isUnitless,
            };
        }
        annotation.invalidated = false;
        (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
        return cachedStats;
    }
}
function UltrasoundDirectionalTool_defaultGetTextLines(data, targetId, configuration) {
    const cachedStats = data.cachedStats[targetId];
    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;
    if (isUnitless) {
        return [`${esm.utilities.roundNumber(xValues[0])} px`];
    }
    if (configuration.displayBothAxesDistances) {
        const dist1 = Math.abs(xValues[1] - xValues[0]);
        const dist2 = Math.abs(yValues[1] - yValues[0]);
        return [
            `${esm.utilities.roundNumber(dist1)} ${units[0]}`,
            `${esm.utilities.roundNumber(dist2)} ${units[1]}`,
        ];
    }
    if (isHorizontal) {
        const dist = Math.abs(xValues[1] - xValues[0]);
        return [`${esm.utilities.roundNumber(dist)} ${units[0]}`];
    }
    else {
        const dist = Math.abs(yValues[1] - yValues[0]);
        return [`${esm.utilities.roundNumber(dist)} ${units[1]}`];
    }
}
UltrasoundDirectionalTool.toolName = 'UltrasoundDirectionalTool';
/* harmony default export */ const annotation_UltrasoundDirectionalTool = (UltrasoundDirectionalTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js










class KeyImageTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            getTextCallback: KeyImageTool_getTextCallback,
            changeTextCallback: KeyImageTool_changeTextCallback,
            canvasPosition: [10, 10],
            canvasSize: 10,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = KeyImageTool.createAnnotation({
                metadata: { ...viewport.getViewReference(), referencedImageId },
            });
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.configuration.getTextCallback((text) => {
                if (!text) {
                    (0,annotationState.removeAnnotation)(annotation.annotationUID);
                    (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                    this.isDrawing = false;
                    return;
                }
                annotation.data.text = text;
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            });
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { canvasPosition, canvasSize } = this.configuration;
            if (!canvasPosition?.length) {
                return false;
            }
            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=
                canvasSize / 2 &&
                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=
                    canvasSize / 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            annotation.highlighted = true;
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
        };
        this.doubleClickCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return;
            }
            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));
            if (!clickedAnnotation) {
                return;
            }
            const annotation = clickedAnnotation;
            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
            this.isDrawing = false;
            evt.stopImmediatePropagation();
            evt.preventDefault();
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID } = annotation;
                styleSpecifier.annotationUID = annotationUID;
                const { color } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const { canvasPosition, canvasSize } = this.configuration;
                if (canvasPosition?.length) {
                    const arrowUID = '1';
                    (0,drawingSvg.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {
                        color,
                        width: 1,
                    });
                }
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
            }
            return renderStatus;
        };
    }
    cancel() {
    }
    handleSelectedCallback(evt, annotation, handle) {
    }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.text = updatedText;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, element);
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function KeyImageTool_getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function KeyImageTool_changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
KeyImageTool.toolName = 'KeyImage';
/* harmony default export */ const annotation_KeyImageTool = (KeyImageTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection = __webpack_require__(17343);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js




class AnnotationEraserTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            return this._deleteNearbyAnnotations(evt, 'mouse');
        };
        this.preTouchStartCallback = (evt) => {
            return this._deleteNearbyAnnotations(evt, 'touch');
        };
    }
    _deleteNearbyAnnotations(evt, interactionType) {
        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;
        const toolGroup = (0,ToolGroupManager.getToolGroupForViewport)(viewportId, renderingEngineId);
        if (!toolGroup) {
            return false;
        }
        const tools = toolGroup._toolInstances;
        const annotationsToRemove = [];
        for (const toolName in tools) {
            const toolInstance = tools[toolName];
            if (typeof toolInstance.isPointNearTool !== 'function' ||
                typeof toolInstance.filterInteractableAnnotationsForElement !==
                    'function') {
                continue;
            }
            const annotations = (0,annotationState.getAnnotations)(toolName, element);
            if (!annotations.length) {
                continue;
            }
            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations) || [];
            for (const annotation of interactableAnnotations) {
                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {
                    annotationsToRemove.push(annotation.annotationUID);
                }
            }
        }
        for (const annotationUID of annotationsToRemove) {
            (0,annotationSelection.setAnnotationSelected)(annotationUID);
            (0,annotationState.removeAnnotation)(annotationUID);
        }
        evt.preventDefault();
        return true;
    }
}
AnnotationEraserTool.toolName = 'Eraser';
/* harmony default export */ const tools_AnnotationEraserTool = (AnnotationEraserTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js
var fillRectangle = __webpack_require__(10088);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseRectangle.js
var eraseRectangle = __webpack_require__(47347);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js + 2 modules
var segmentationState = __webpack_require__(98870);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js











class RectangleScissorsTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: fillRectangle/* fillInsideRectangle */.p,
                ERASE_INSIDE: eraseRectangle/* eraseInsideRectangle */.M,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeLabelmapSegmentation = segmentation.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeLabelmapSegmentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeLabelmapSegmentation;
            const segmentIndex = segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = segmentation.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = segmentation.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            const { representationData } = (0,segmentationState.getSegmentation)(segmentationId);
            const labelmapData = representationData[enums.SegmentationRepresentations.Labelmap];
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                },
            };
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            if (viewport instanceof esm.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = esm.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                const segmentationImageId = (0,segmentationState.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                this.editData = {
                    ...this.editData,
                    imageId: segmentationImageId,
                };
            }
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            const { currentPoints } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
            const worldPos = currentPoints.world;
            const { points } = data.handles;
            points[handleIndex] = [...worldPos];
            let bottomLeftCanvas;
            let bottomRightCanvas;
            let topLeftCanvas;
            let topRightCanvas;
            let bottomLeftWorld;
            let bottomRightWorld;
            let topLeftWorld;
            let topRightWorld;
            switch (handleIndex) {
                case 0:
                case 3:
                    bottomLeftCanvas = worldToCanvas(points[0]);
                    topRightCanvas = worldToCanvas(points[3]);
                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                    bottomRightWorld = canvasToWorld(bottomRightCanvas);
                    topLeftWorld = canvasToWorld(topLeftCanvas);
                    points[1] = bottomRightWorld;
                    points[2] = topLeftWorld;
                    break;
                case 1:
                case 2:
                    bottomRightCanvas = worldToCanvas(points[1]);
                    topLeftCanvas = worldToCanvas(points[2]);
                    bottomLeftCanvas = [
                        topLeftCanvas[0],
                        bottomRightCanvas[1],
                    ];
                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];
                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                    topRightWorld = canvasToWorld(topRightCanvas);
                    points[0] = bottomLeftWorld;
                    points[3] = topRightWorld;
                    break;
            }
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
        };
        this._activateDraw = (element) => {
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const rectangleUID = '0';
            (0,drawingSvg.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
RectangleScissorsTool.toolName = 'RectangleScissor';
/* harmony default export */ const segmentation_RectangleScissorsTool = (RectangleScissorsTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js
var fillCircle = __webpack_require__(56789);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js
var eraseCircle = __webpack_require__(33852);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js










class CircleScissorsTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: fillCircle/* fillInsideCircle */.kr,
                ERASE_INSIDE: eraseCircle/* eraseInsideCircle */.r,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeLabelmapSegmentation = segmentation.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeLabelmapSegmentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeLabelmapSegmentation;
            const segmentIndex = segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = segmentation.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = segmentation.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            const { representationData } = (0,segmentationState.getSegmentation)(segmentationId);
            const labelmapData = representationData.Labelmap;
            if (!labelmapData) {
                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');
            }
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    isDrawing: true,
                    cachedStats: {},
                },
            };
            const viewportIdsToRender = [viewport.id];
            this.editData = {
                annotation,
                centerCanvas: canvasPos,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            if (viewport instanceof esm.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = esm.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                const segmentationImageId = (0,segmentationState.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                this.editData = {
                    ...this.editData,
                    imageId: segmentationImageId,
                };
            }
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const radius = Math.sqrt(dX * dX + dY * dY);
            const bottomCanvas = [
                centerCanvas[0],
                centerCanvas[1] + radius,
            ];
            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
            const leftCanvas = [
                centerCanvas[0] - radius,
                centerCanvas[1],
            ];
            const rightCanvas = [
                centerCanvas[0] + radius,
                centerCanvas[1],
            ];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            const { viewPlaneNormal, viewUp } = annotation.metadata;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                viewPlaneNormal,
                viewUp,
                strategySpecificConfiguration: {},
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
        };
        this._activateDraw = (element) => {
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { viewportIdsToRender } = this.editData;
            if (!viewportIdsToRender.includes(viewport.id)) {
                return renderStatus;
            }
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const bottom = canvasCoordinates[0];
            const top = canvasCoordinates[1];
            const center = [
                Math.floor((bottom[0] + top[0]) / 2),
                Math.floor((bottom[1] + top[1]) / 2),
            ];
            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const circleUID = '0';
            (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
CircleScissorsTool.toolName = 'CircleScissor';
/* harmony default export */ const segmentation_CircleScissorsTool = (CircleScissorsTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js
var fillSphere = __webpack_require__(17492);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js
var eraseSphere = __webpack_require__(1989);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js










class SphereScissorsTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: fillSphere/* fillInsideSphere */.Jq,
                ERASE_INSIDE: eraseSphere/* eraseInsideSphere */._,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeSegmentationRepresentation = segmentation.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeSegmentationRepresentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeSegmentationRepresentation;
            const segmentIndex = segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = segmentation.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = segmentation.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            this.isDrawing = true;
            const annotation = {
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    invalidated: true,
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                    highlighted: true,
                },
            };
            const viewportIdsToRender = [viewport.id];
            this.editData = {
                annotation,
                centerCanvas: canvasPos,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                toolGroupId: this.toolGroupId,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            const { representationData } = (0,segmentationState.getSegmentation)(segmentationId);
            const labelmapData = representationData[enums.SegmentationRepresentations.Labelmap];
            if (viewport instanceof esm.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = esm.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                this.editData = {
                    ...this.editData,
                };
            }
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const radius = Math.sqrt(dX * dX + dY * dY);
            const bottomCanvas = [
                centerCanvas[0],
                centerCanvas[1] + radius,
            ];
            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
            const leftCanvas = [
                centerCanvas[0] - radius,
                centerCanvas[1],
            ];
            const rightCanvas = [
                centerCanvas[0] + radius,
                centerCanvas[1],
            ];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;
            const { data } = annotation;
            const { viewPlaneNormal, viewUp } = annotation.metadata;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                segmentIndex,
                segmentsLocked,
                viewPlaneNormal,
                viewUp,
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
        };
        this._activateDraw = (element) => {
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { viewportIdsToRender } = this.editData;
            if (!viewportIdsToRender.includes(viewport.id)) {
                return renderStatus;
            }
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const bottom = canvasCoordinates[0];
            const top = canvasCoordinates[1];
            const center = [
                Math.floor((bottom[0] + top[0]) / 2),
                Math.floor((bottom[1] + top[1]) / 2),
            ];
            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const circleUID = '0';
            (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
SphereScissorsTool.toolName = 'SphereScissor';
/* harmony default export */ const segmentation_SphereScissorsTool = (SphereScissorsTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js
var RectangleROIThresholdTool = __webpack_require__(40336);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js
var RectangleROIStartEndThresholdTool = __webpack_require__(67847);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js





















const { transformWorldToIndex: CircleROIStartEndThresholdTool_transformWorldToIndex } = esm.utilities;
class CircleROIStartEndThresholdTool extends annotation_CircleROITool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            numSlicesToPropagate: 10,
            calculatePointsInsideVolume: false,
            getTextLines: CircleROIStartEndThresholdTool_defaultGetTextLines,
            statsCalculator: basic.BasicStatsCalculator,
            showTextBox: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            let referencedImageId, imageVolume, volumeId;
            if (viewport instanceof esm.StackViewport) {
                throw new Error('Stack Viewport Not implemented');
            }
            else {
                const targetId = this.getTargetId(viewport);
                volumeId = esm.utilities.getVolumeId(targetId);
                imageVolume = esm.cache.getVolume(volumeId);
                referencedImageId = esm.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const spacingInNormal = esm.utilities.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    volumeId,
                    spacingInNormal,
                    enabledElement,
                },
                data: {
                    label: '',
                    startCoordinate: startCoord,
                    endCoordinate: endCoord,
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                    },
                    cachedStats: {
                        pointsInVolume: [],
                        projectionPoints: [],
                        statistics: [],
                    },
                    labelmapUID: null,
                },
            };
            this._computeProjectionPoints(annotation, imageVolume);
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            const targetId = this.getTargetId(enabledElement.viewport);
            const imageVolume = esm.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
            if (this.configuration.calculatePointsInsideVolume) {
                this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state/* triggerAnnotationCompleted */.dZ)(annotation);
            }
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = (0,planar.filterAnnotationsWithinSamePlane)(annotations, viewport.getCamera());
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { startCoordinate, endCoordinate } = data;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                const radius = (0,circle/* getCanvasCircleRadius */.r)(canvasCoordinates);
                const { centerPointRadius } = this.configuration;
                const canvasCorners = (0,circle/* getCanvasCircleCorners */.H)(canvasCoordinates);
                const focalPoint = viewport.getCamera().focalPoint;
                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
                let tempStartCoordinate = startCoordinate;
                let tempEndCoordinate = endCoordinate;
                if (Array.isArray(startCoordinate)) {
                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);
                    data.startCoordinate = tempStartCoordinate;
                }
                if (Array.isArray(endCoordinate)) {
                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);
                    data.endCoordinate = tempEndCoordinate;
                }
                const roundedStartCoordinate = esm.utilities.roundToPrecision(data.startCoordinate);
                const roundedEndCoordinate = esm.utilities.roundToPrecision(data.endCoordinate);
                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
                const roundedCameraCoordinate = esm.utilities.roundToPrecision(cameraCoordinate);
                if (roundedCameraCoordinate <
                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||
                    roundedCameraCoordinate >
                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {
                    continue;
                }
                const middleCoordinate = esm.utilities.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);
                let isMiddleSlice = false;
                if (roundedCameraCoordinate === middleCoordinate) {
                    isMiddleSlice = true;
                }
                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;
                if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    isMiddleSlice) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                let lineWidthToUse = lineWidth;
                let lineDashToUse = lineDash;
                if (isMiddleSlice) {
                    lineWidthToUse = lineWidth;
                    lineDashToUse = [];
                }
                else {
                    lineDashToUse = [5, 5];
                }
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineDash: lineDashToUse,
                    lineWidth: lineWidthToUse,
                });
                if (centerPointRadius > 0) {
                    if (radius > 3 * centerPointRadius) {
                        (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                if (this.configuration.showTextBox == true &&
                    this.configuration.calculatePointsInsideVolume == true) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data);
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    let canvasTextBoxCoords;
                    if (!data.handles.textBox.hasMoved) {
                        canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCorners);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStatsTool, 100, { trailing: true });
    }
    _computeProjectionPoints(annotation, imageVolume) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, spacingInNormal } = metadata;
        const { imageData } = imageVolume;
        const { startCoordinate, endCoordinate } = data;
        const { points } = data.handles;
        const startIJK = CircleROIStartEndThresholdTool_transformWorldToIndex(imageData, points[0]);
        const endIJK = CircleROIStartEndThresholdTool_transformWorldToIndex(imageData, points[0]);
        const handlesToStart = esm.utilities.deepClone(points);
        const startWorld = gl_matrix_esm/* vec3.create */.eR.create();
        imageData.indexToWorldVec3(startIJK, startWorld);
        const endWorld = gl_matrix_esm/* vec3.create */.eR.create();
        imageData.indexToWorldVec3(endIJK, endWorld);
        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
            startWorld[2] = startCoordinate;
            endWorld[2] = endCoordinate;
            handlesToStart[0][2] = startCoordinate;
            handlesToStart[1][2] = startCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
            startWorld[0] = startCoordinate;
            endWorld[0] = endCoordinate;
            handlesToStart[0][0] = startCoordinate;
            handlesToStart[1][0] = startCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
            startWorld[1] = startCoordinate;
            endWorld[1] = endCoordinate;
            handlesToStart[0][1] = startCoordinate;
            handlesToStart[1][1] = startCoordinate;
        }
        const distance = gl_matrix_esm/* vec3.distance */.eR.distance(startWorld, endWorld);
        const newProjectionPoints = [];
        for (let dist = 0; dist < distance; dist += spacingInNormal) {
            newProjectionPoints.push(handlesToStart.map((point) => {
                const newPoint = gl_matrix_esm/* vec3.create */.eR.create();
                gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
                return Array.from(newPoint);
            }));
        }
        data.cachedStats.projectionPoints = newProjectionPoints;
    }
    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, viewUp } = metadata;
        const { viewport } = enabledElement;
        const projectionPoints = data.cachedStats.projectionPoints;
        const pointsInsideVolume = [[]];
        const image = this.getTargetImageData(targetId);
        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
        const [topLeftCanvas, bottomRightCanvas] = ((0,circle/* getCanvasCircleCorners */.H)(canvasCoordinates));
        const pos1 = viewport.canvasToWorld(topLeftCanvas);
        const pos2 = viewport.canvasToWorld(bottomRightCanvas);
        const { worldWidth, worldHeight } = (0,getWorldWidthAndHeightFromTwoPoints/* default */.A)(viewPlaneNormal, viewUp, pos1, pos2);
        const measureInfo = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, data.handles);
        const aspect = (0,getCalibratedUnits/* getCalibratedAspect */.CQ)(image);
        const area = Math.abs(Math.PI *
            (worldWidth / measureInfo.scale / 2) *
            (worldHeight / aspect / measureInfo.scale / 2));
        const modalityUnitOptions = {
            isPreScaled: (0,isViewportPreScaled/* isViewportPreScaled */.u)(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
        };
        const modalityUnit = (0,getPixelValueUnits/* getPixelValueUnits */.j)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        for (let i = 0; i < projectionPoints.length; i++) {
            if (!imageVolume) {
                continue;
            }
            const centerWorld = projectionPoints[i][0];
            const canvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));
            const [topLeftCanvas, bottomRightCanvas] = ((0,circle/* getCanvasCircleCorners */.H)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            const { dimensions, imageData, voxelManager } = imageVolume;
            const worldPos1Index = CircleROIStartEndThresholdTool_transformWorldToIndex(imageData, worldPos1);
            const worldProjectionPointIndex = CircleROIStartEndThresholdTool_transformWorldToIndex(imageData, centerWorld);
            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
            worldPos1Index[0] = Math.floor(worldPos1Index[0]);
            worldPos1Index[1] = Math.floor(worldPos1Index[1]);
            worldPos1Index[2] = Math.floor(worldPos1Index[2]);
            worldPos1Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            const worldPos2Index = CircleROIStartEndThresholdTool_transformWorldToIndex(imageData, worldPos2);
            worldPos2Index[0] = Math.floor(worldPos2Index[0]);
            worldPos2Index[1] = Math.floor(worldPos2Index[1]);
            worldPos2Index[2] = Math.floor(worldPos2Index[2]);
            worldPos2Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const center = centerWorld;
                const ellipseObj = {
                    center,
                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,
                };
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    isInObject: (pointLPS) => (0,ellipse.pointInEllipse)(ellipseObj, pointLPS),
                    boundsIJK,
                    imageData,
                    returnPoints: this.configuration.storePointData,
                });
                pointsInsideVolume.push(pointsInShape);
            }
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        data.cachedStats.pointsInVolume = pointsInsideVolume;
        data.cachedStats.statistics = {
            Modality: metadata.Modality,
            area,
            mean: stats.mean?.value,
            stdDev: stats.stdDev?.value,
            max: stats.max?.value,
            statsArray: stats.array,
            areaUnit: measureInfo.areaUnit,
            modalityUnit,
        };
    }
    _calculateCachedStatsTool(annotation, enabledElement) {
        const data = annotation.data;
        const { viewport } = enabledElement;
        const { cachedStats } = data;
        const targetId = this.getTargetId(viewport);
        const imageVolume = esm.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
        this._computeProjectionPoints(annotation, imageVolume);
        if (this.configuration.calculatePointsInsideVolume) {
            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
        }
        annotation.invalidated = false;
        (0,helpers_state/* triggerAnnotationModified */.XF)(annotation, viewport.element);
        return cachedStats;
    }
    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);
        const startPos = gl_matrix_esm/* vec3.create */.eR.create();
        gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);
        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
        return startCoord;
    }
    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);
        const endPos = gl_matrix_esm/* vec3.create */.eR.create();
        gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);
        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
        return endCoord;
    }
    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
        const viewplaneNormalAbs = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
        return indexOfDirection;
    }
    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        return pos[indexOfDirection];
    }
}
function CircleROIStartEndThresholdTool_defaultGetTextLines(data) {
    const cachedVolumeStats = data.cachedStats.statistics;
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${esm.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${esm.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${esm.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
CircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';
/* harmony default export */ const segmentation_CircleROIStartEndThresholdTool = (CircleROIStartEndThresholdTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js
var BrushTool = __webpack_require__(48736);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js
var floodFill = __webpack_require__(84882);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js







const { transformWorldToIndex: PaintFillTool_transformWorldToIndex, isEqual } = esm.utilities;
class PaintFillTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const { viewPlaneNormal } = camera;
            const activeSegmentationRepresentation = segmentation.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeSegmentationRepresentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeSegmentationRepresentation;
            const segmentIndex = segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = segmentation.segmentLocking.getLockedSegmentIndices(segmentationId);
            const { representationData } = (0,segmentationState.getSegmentation)(segmentationId);
            let dimensions;
            let direction;
            let scalarData;
            let index;
            let voxelManager;
            if (viewport instanceof esm.BaseVolumeViewport) {
                const { volumeId } = representationData[enums.SegmentationRepresentations.Labelmap];
                const segmentation = esm.cache.getVolume(volumeId);
                ({ dimensions, direction } = segmentation);
                voxelManager = segmentation.voxelManager;
                index = PaintFillTool_transformWorldToIndex(segmentation.imageData, worldPos);
            }
            else {
                const currentSegmentationImageId = (0,segmentationState.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                if (!currentSegmentationImageId) {
                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');
                }
                const { imageData } = viewport.getImageData();
                dimensions = imageData.getDimensions();
                direction = imageData.getDirection();
                const image = esm.cache.getImage(currentSegmentationImageId);
                voxelManager = image.voxelManager;
                index = PaintFillTool_transformWorldToIndex(imageData, worldPos);
            }
            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);
            if (fixedDimension === undefined) {
                console.warn('Oblique paint fill not yet supported');
                return;
            }
            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);
            if (index[0] < 0 ||
                index[0] >= dimensions[0] ||
                index[1] < 0 ||
                index[1] >= dimensions[1] ||
                index[2] < 0 ||
                index[2] >= dimensions[2]) {
                return;
            }
            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);
            if (segmentsLocked.includes(clickedLabelValue)) {
                return;
            }
            const floodFillResult = (0,floodFill/* default */.A)(floodFillGetter, inPlaneSeedPoint);
            const { flooded } = floodFillResult;
            flooded.forEach((index) => {
                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);
                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);
            });
            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);
            (0,triggerSegmentationEvents.triggerSegmentationDataModified)(segmentationId, framesModified);
            return true;
        };
        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {
            const { boundaries } = floodFillResult;
            if (fixedDimension === 2) {
                return [fixedDimensionValue];
            }
            let minJ = Infinity;
            let maxJ = -Infinity;
            for (let b = 0; b < boundaries.length; b++) {
                const j = boundaries[b][1];
                if (j < minJ) {
                    minJ = j;
                }
                if (j > maxJ) {
                    maxJ = j;
                }
            }
            const framesModified = [];
            for (let frame = minJ; frame <= maxJ; frame++) {
                framesModified.push(frame);
            }
            return framesModified;
        };
        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {
            let fixedDimensionValue;
            let inPlaneSeedPoint;
            switch (fixedDimension) {
                case 0:
                    fixedDimensionValue = seedIndex3D[0];
                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];
                    break;
                case 1:
                    fixedDimensionValue = seedIndex3D[1];
                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];
                    break;
                case 2:
                    fixedDimensionValue = seedIndex3D[2];
                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            const getScalarDataPosition = (x, y, z) => {
                return voxelManager.toIndex([x, y, z]);
            };
            const getLabelValue = (x, y, z) => {
                return voxelManager.getAtIJK(x, y, z);
            };
            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);
            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);
            return {
                getScalarDataPositionFromPlane,
                getLabelValue,
                floodFillGetter,
                inPlaneSeedPoint,
                fixedDimensionValue,
            };
        };
        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {
            let floodFillGetter;
            switch (fixedDimension) {
                case 0:
                    floodFillGetter = (y, z) => {
                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {
                            return;
                        }
                        return getLabelValue(fixedDimensionValue, y, z);
                    };
                    break;
                case 1:
                    floodFillGetter = (x, z) => {
                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {
                            return;
                        }
                        return getLabelValue(x, fixedDimensionValue, z);
                    };
                    break;
                case 2:
                    floodFillGetter = (x, y) => {
                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {
                            return;
                        }
                        return getLabelValue(x, y, fixedDimensionValue);
                    };
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            return floodFillGetter;
        };
        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {
            let getScalarDataPositionFromPlane;
            switch (fixedDimension) {
                case 0:
                    getScalarDataPositionFromPlane = (y, z) => {
                        return getScalarDataPosition(fixedDimensionValue, y, z);
                    };
                    break;
                case 1:
                    getScalarDataPositionFromPlane = (x, z) => {
                        return getScalarDataPosition(x, fixedDimensionValue, z);
                    };
                    break;
                case 2:
                    getScalarDataPositionFromPlane = (x, y) => {
                        return getScalarDataPosition(x, y, fixedDimensionValue);
                    };
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            return getScalarDataPositionFromPlane;
        };
    }
    getFixedDimension(viewPlaneNormal, direction) {
        const xDirection = direction.slice(0, 3);
        const yDirection = direction.slice(3, 6);
        const zDirection = direction.slice(6, 9);
        const absoluteOfViewPlaneNormal = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const absoluteOfXDirection = [
            Math.abs(xDirection[0]),
            Math.abs(xDirection[1]),
            Math.abs(xDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {
            return 0;
        }
        const absoluteOfYDirection = [
            Math.abs(yDirection[0]),
            Math.abs(yDirection[1]),
            Math.abs(yDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {
            return 1;
        }
        const absoluteOfZDirection = [
            Math.abs(zDirection[0]),
            Math.abs(zDirection[1]),
            Math.abs(zDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {
            return 2;
        }
    }
}
PaintFillTool.toolName = 'PaintFill';
/* harmony default export */ const segmentation_PaintFillTool = (PaintFillTool);

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js + 1 modules
var OrientationMarkerWidget = __webpack_require__(25161);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor.js + 2 modules
var AnnotatedCubeActor = __webpack_require__(85825);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AxesActor.js + 4 modules
var AxesActor = __webpack_require__(45700);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var Actor = __webpack_require__(7019);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var Mapper = __webpack_require__(82409);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/XML/XMLPolyDataReader.js + 8 modules
var XMLPolyDataReader = __webpack_require__(49368);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 9 modules
var PolyData = __webpack_require__(79484);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js












var OverlayMarkerType;
(function (OverlayMarkerType) {
    OverlayMarkerType[OverlayMarkerType["ANNOTATED_CUBE"] = 1] = "ANNOTATED_CUBE";
    OverlayMarkerType[OverlayMarkerType["AXES"] = 2] = "AXES";
    OverlayMarkerType[OverlayMarkerType["CUSTOM"] = 3] = "CUSTOM";
})(OverlayMarkerType || (OverlayMarkerType = {}));
class OrientationMarkerTool extends base/* BaseTool */.oS {
    static { this.CUBE = 1; }
    static { this.AXIS = 2; }
    static { this.VTPFILE = 3; }
    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            orientationWidget: {
                enabled: true,
                viewportCorner: OrientationMarkerWidget/* default */.Ay.Corners.BOTTOM_RIGHT,
                viewportSize: 0.15,
                minPixelSize: 100,
                maxPixelSize: 300,
            },
            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,
            overlayConfiguration: {
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {
                    faceProperties: {
                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },
                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },
                        yPlus: {
                            text: 'P',
                            faceColor: '#00ffff',
                            fontColor: 'white',
                            faceRotation: 180,
                        },
                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },
                        zPlus: { text: 'S' },
                        zMinus: { text: 'I' },
                    },
                    defaultStyle: {
                        fontStyle: 'bold',
                        fontFamily: 'Arial',
                        fontColor: 'black',
                        fontSizeScale: (res) => res / 2,
                        faceColor: '#0000ff',
                        edgeThickness: 0.1,
                        edgeColor: 'black',
                        resolution: 400,
                    },
                },
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {
                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this.onSetToolEnabled = () => {
            this.initViewports();
            this._subscribeToViewportEvents();
        };
        this.onSetToolActive = () => {
            this.initViewports();
            this._subscribeToViewportEvents();
        };
        this.onSetToolDisabled = () => {
            this.cleanUpData();
            this._unsubscribeToViewportNewVolumeSet();
        };
        this._getViewportsInfo = () => {
            const viewports = (0,ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resize = (viewportId) => {
            const orientationMarker = this.orientationMarkers[viewportId];
            if (!orientationMarker) {
                return;
            }
            const { orientationWidget } = orientationMarker;
            orientationWidget.updateViewport();
        };
        this.orientationMarkers = {};
        this.updatingOrientationMarker = {};
    }
    _unsubscribeToViewportNewVolumeSet() {
        const unsubscribe = () => {
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                const { element } = viewport;
                element.removeEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
                const resizeObserver = this._resizeObservers.get(viewportId);
                resizeObserver.unobserve(element);
            });
        };
        esm.eventTarget.removeEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
            if (evt.detail.toolGroupId !== this.toolGroupId) {
                return;
            }
            unsubscribe();
            this.initViewports();
        });
    }
    _subscribeToViewportEvents() {
        const subscribeToElementResize = () => {
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                const { element } = viewport;
                this.initViewports();
                element.addEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
                const resizeObserver = new ResizeObserver(() => {
                    setTimeout(() => {
                        const element = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                        if (!element) {
                            return;
                        }
                        const { viewport } = element;
                        this.resize(viewportId);
                        viewport.render();
                    }, 100);
                });
                resizeObserver.observe(element);
                this._resizeObservers.set(viewportId, resizeObserver);
            });
        };
        subscribeToElementResize();
        esm.eventTarget.addEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
            if (evt.detail.toolGroupId !== this.toolGroupId) {
                return;
            }
            subscribeToElementResize();
            this.initViewports();
        });
    }
    cleanUpData() {
        const renderingEngines = (0,esm.getRenderingEngines)();
        const renderingEngine = renderingEngines[0];
        const viewports = renderingEngine.getViewports();
        viewports.forEach((viewport) => {
            const orientationMarker = this.orientationMarkers[viewport.id];
            if (!orientationMarker) {
                return;
            }
            const { actor, orientationWidget } = orientationMarker;
            orientationWidget?.setEnabled(false);
            orientationWidget?.delete();
            actor?.delete();
            const renderWindow = viewport
                .getRenderingEngine()
                .offscreenMultiRenderWindow.getRenderWindow();
            renderWindow.render();
            viewport.getRenderingEngine().render();
            delete this.orientationMarkers[viewport.id];
        });
    }
    initViewports() {
        const renderingEngines = (0,esm.getRenderingEngines)();
        const renderingEngine = renderingEngines[0];
        if (!renderingEngine) {
            return;
        }
        let viewports = renderingEngine.getViewports();
        viewports = (0,viewportFilters.filterViewportsWithToolEnabled)(viewports, this.getToolName());
        viewports.forEach((viewport) => {
            const widget = viewport.getWidget(this.getToolName());
            if (!widget || widget.isDeleted()) {
                this.addAxisActorInViewport(viewport);
            }
        });
    }
    async addAxisActorInViewport(viewport) {
        const viewportId = viewport.id;
        if (!this.updatingOrientationMarker[viewportId]) {
            this.updatingOrientationMarker[viewportId] = true;
            const type = this.configuration.overlayMarkerType;
            const overlayConfiguration = this.configuration.overlayConfiguration[type];
            if (this.orientationMarkers[viewportId]) {
                const { actor, orientationWidget } = this.orientationMarkers[viewportId];
                viewport.getRenderer().removeActor(actor);
                orientationWidget.setEnabled(false);
            }
            let actor;
            if (type === 1) {
                actor = this.createAnnotationCube(overlayConfiguration);
            }
            else if (type === 2) {
                actor = AxesActor/* default.newInstance */.Ay.newInstance();
            }
            else if (type === 3) {
                actor = await this.createCustomActor();
            }
            const renderer = viewport.getRenderer();
            const renderWindow = viewport
                .getRenderingEngine()
                .offscreenMultiRenderWindow.getRenderWindow();
            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;
            const orientationWidget = OrientationMarkerWidget/* default.newInstance */.Ay.newInstance({
                actor,
                interactor: renderWindow.getInteractor(),
                parentRenderer: renderer,
            });
            orientationWidget.setEnabled(enabled);
            orientationWidget.setViewportCorner(viewportCorner);
            orientationWidget.setViewportSize(viewportSize);
            orientationWidget.setMinPixelSize(minPixelSize);
            orientationWidget.setMaxPixelSize(maxPixelSize);
            orientationWidget.updateMarkerOrientation();
            this.orientationMarkers[viewportId] = {
                orientationWidget,
                actor,
            };
            viewport.addWidget(this.getToolName(), orientationWidget);
            renderWindow.render();
            viewport.getRenderingEngine().render();
            this.updatingOrientationMarker[viewportId] = false;
        }
    }
    async createCustomActor() {
        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]
            .polyDataURL;
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const vtpReader = XMLPolyDataReader/* default.newInstance */.Ay.newInstance();
        vtpReader.parseAsArrayBuffer(arrayBuffer);
        vtpReader.update();
        const polyData = PolyData/* default.newInstance */.Ay.newInstance();
        polyData.shallowCopy(vtpReader.getOutputData());
        polyData.getPointData().setActiveScalars('Color');
        const mapper = Mapper/* default.newInstance */.Ay.newInstance();
        mapper.setInputData(polyData);
        mapper.setColorModeToDirectScalars();
        const actor = Actor/* default.newInstance */.Ay.newInstance();
        actor.setMapper(mapper);
        actor.rotateZ(180);
        return actor;
    }
    createAnnotationCube(overlayConfiguration) {
        const actor = AnnotatedCubeActor/* default.newInstance */.Ay.newInstance();
        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });
        actor.setXPlusFaceProperty({
            ...overlayConfiguration.faceProperties.xPlus,
        });
        actor.setXMinusFaceProperty({
            ...overlayConfiguration.faceProperties.xMinus,
        });
        actor.setYPlusFaceProperty({
            ...overlayConfiguration.faceProperties.yPlus,
        });
        actor.setYMinusFaceProperty({
            ...overlayConfiguration.faceProperties.yMinus,
        });
        actor.setZPlusFaceProperty({
            ...overlayConfiguration.faceProperties.zPlus,
        });
        actor.setZMinusFaceProperty({
            ...overlayConfiguration.faceProperties.zMinus,
        });
        return actor;
    }
    async createAnnotatedCubeActor() {
        const axes = AnnotatedCubeActor/* default.newInstance */.Ay.newInstance();
        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;
        axes.setDefaultStyle(defaultStyle);
        Object.keys(faceProperties).forEach((key) => {
            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;
            axes[methodName](faceProperties[key]);
        });
        return axes;
    }
}
OrientationMarkerTool.toolName = 'OrientationMarker';
/* harmony default export */ const tools_OrientationMarkerTool = (OrientationMarkerTool);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js + 1 modules
var segmentation_activeSegmentation = __webpack_require__(26228);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js
var segmentIndex = __webpack_require__(70930);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js + 15 modules
var utilities_segmentation = __webpack_require__(67470);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js










class SegmentSelectTool extends base/* BaseTool */.oS {
    static { this.SelectMode = {
        Inside: 'Inside',
        Border: 'Border',
    }; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            mode: SegmentSelectTool.SelectMode.Border,
            searchRadius: 6,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setActiveSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.hoverTimer = null;
    }
    _setActiveSegment(evt = {}) {
        if (state/* state */.wk.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0,esm.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentation = (0,segmentation_activeSegmentation.getActiveSegmentation)(viewport.id);
        if (!activeSegmentation) {
            return;
        }
        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);
    }
    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId, representationData } = activeSegmentation;
        let hoveredSegmentIndex;
        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {
            hoveredSegmentIndex = (0,utilities_segmentation.getSegmentIndexAtWorldPoint)(segmentationId, worldPoint, {
                viewport,
            });
        }
        else {
            if (representationData.Labelmap) {
                hoveredSegmentIndex = (0,utilities_segmentation.getSegmentIndexAtLabelmapBorder)(segmentationId, worldPoint, {
                    viewport,
                    searchRadius: this.configuration.searchRadius,
                });
            }
            else if (representationData.Contour) {
                hoveredSegmentIndex =
                    (0,utilities_segmentation.getHoveredContourSegmentationAnnotation)(segmentationId);
            }
            else if (representationData.Surface) {
            }
        }
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        (0,segmentIndex.setActiveSegmentIndex)(segmentationId, hoveredSegmentIndex);
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentationId);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIds);
    }
}
SegmentSelectTool.toolName = 'SegmentSelectTool';
/* harmony default export */ const segmentation_SegmentSelectTool = (SegmentSelectTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/index.js




















































// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js + 1 modules
var rectangle = __webpack_require__(92282);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js













class VideoRedactionTool extends base/* AnnotationTool */.EC {
    constructor(toolConfiguration = {}) {
        super(toolConfiguration, {
            supportedInteractionTypes: ['Mouse', 'Touch'],
            configuration: { shadow: true, preventHandleOutsideImage: false },
        });
        this.addNewAnnotation = (evt) => {
            const eventData = evt.detail;
            const { currentPoints, element } = eventData;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                metadata: {
                    viewPlaneNormal: [0, 0, 1],
                    viewUp: [0, 1, 0],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId,
                    toolName: this.getToolName(),
                },
                data: {
                    invalidated: true,
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                    active: true,
                },
            };
            (0,stateManagement/* addAnnotation */.lC)(annotation, element);
            const viewportUIDsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
            return annotation;
        };
        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);
                const near = gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;
                if (near === true) {
                    data.handles.activeHandleIndex = i;
                    return point;
                }
            }
            data.handles.activeHandleIndex = null;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasPoint1 = viewport.worldToCanvas(points[0]);
            const canvasPoint2 = viewport.worldToCanvas(points[3]);
            const rect = this._getRectangleImageCoordinates([
                canvasPoint1,
                canvasPoint2,
            ]);
            const point = [canvasCoords[0], canvasCoords[1]];
            const { left, top, width, height } = rect;
            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);
            if (distanceToPoint <= proximity) {
                return true;
            }
        };
        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { data } = annotation;
            data.active = true;
            const viewportUIDsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { data } = annotation;
            data.active = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportUIDsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
                handleIndex,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
            evt.preventDefault();
        };
        this._mouseUpCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.active = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,stateManagement/* removeAnnotation */.O8)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
        };
        this._mouseDragCallback = (evt) => {
            this.isDrawing = true;
            const eventData = evt.detail;
            const { element } = eventData;
            const { annotation, viewportUIDsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventData;
                const worldPosDelta = deltaPoints.world;
                const { points } = data.handles;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                data.invalidated = true;
            }
            else {
                const { currentPoints } = eventData;
                const enabledElement = (0,esm.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
                const worldPos = currentPoints.world;
                const { points } = data.handles;
                points[handleIndex] = [...worldPos];
                let bottomLeftCanvas;
                let bottomRightCanvas;
                let topLeftCanvas;
                let topRightCanvas;
                let bottomLeftWorld;
                let bottomRightWorld;
                let topLeftWorld;
                let topRightWorld;
                switch (handleIndex) {
                    case 0:
                    case 3:
                        bottomLeftCanvas = worldToCanvas(points[0]);
                        topRightCanvas = worldToCanvas(points[3]);
                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                        bottomRightWorld = canvasToWorld(bottomRightCanvas);
                        topLeftWorld = canvasToWorld(topLeftCanvas);
                        points[1] = bottomRightWorld;
                        points[2] = topLeftWorld;
                        break;
                    case 1:
                    case 2:
                        bottomRightCanvas = worldToCanvas(points[1]);
                        topLeftCanvas = worldToCanvas(points[2]);
                        bottomLeftCanvas = [
                            topLeftCanvas[0],
                            bottomRightCanvas[1],
                        ];
                        topRightCanvas = [
                            bottomRightCanvas[0],
                            topLeftCanvas[1],
                        ];
                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                        topRightWorld = canvasToWorld(topRightCanvas);
                        points[0] = bottomLeftWorld;
                        points[3] = topRightWorld;
                        break;
                }
                data.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
        };
        this._activateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._mouseUpCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseDragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._mouseUpCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._mouseUpCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._mouseDragCallback);
        };
        this._deactivateDraw = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._mouseUpCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._mouseDragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._mouseUpCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._mouseUpCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._mouseDragCallback);
        };
        this._activateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._mouseUpCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._mouseUpCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._mouseUpCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._mouseDragCallback);
        };
        this._deactivateModify = (element) => {
            state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._mouseUpCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._mouseUpCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._mouseUpCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._mouseDragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,stateManagement/* getAnnotations */.Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID } = annotation;
                const toolMetadata = annotation.metadata;
                const data = annotation.data;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return;
                }
                let activeHandleCanvasCoords;
                if (!this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const rectangleUID = '0';
                (0,drawingSvg.drawRedactionRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color: 'black',
                    lineDash,
                    lineWidth,
                });
            }
        };
        this._getRectangleImageCoordinates = (points) => {
            const [point0, point1] = points;
            return {
                left: Math.min(point0[0], point1[0]),
                top: Math.min(point0[1], point1[1]),
                width: Math.abs(point0[0] - point1[0]),
                height: Math.abs(point0[1] - point1[1]),
            };
        };
        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[3];
            const { cachedStats } = data;
            const targetUIDs = Object.keys(cachedStats);
            for (let i = 0; i < targetUIDs.length; i++) {
                const targetUID = targetUIDs[i];
                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);
                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;
                const worldPos1Index = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(0, 0, 0);
                const worldPos2Index = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(0, 0, 0);
                imageData.worldToIndexVec3(worldPos1, worldPos1Index);
                worldPos1Index[0] = Math.floor(worldPos1Index[0]);
                worldPos1Index[1] = Math.floor(worldPos1Index[1]);
                worldPos1Index[2] = Math.floor(worldPos1Index[2]);
                imageData.worldToIndexVec3(worldPos2, worldPos2Index);
                worldPos2Index[0] = Math.floor(worldPos2Index[0]);
                worldPos2Index[1] = Math.floor(worldPos2Index[1]);
                worldPos2Index[2] = Math.floor(worldPos2Index[2]);
                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                    this.isHandleOutsideImage = false;
                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                    const { worldWidth, worldHeight } = (0,getWorldWidthAndHeightFromTwoPoints/* default */.A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const area = worldWidth * worldHeight;
                    let count = 0;
                    let mean = 0;
                    let stdDev = 0;
                    const yMultiple = dimensions[0];
                    const zMultiple = dimensions[0] * dimensions[1];
                    for (let k = kMin; k <= kMax; k++) {
                        for (let j = jMin; j <= jMax; j++) {
                            for (let i = iMin; i <= iMax; i++) {
                                const value = scalarData[k * zMultiple + j * yMultiple + i];
                                count++;
                                mean += value;
                            }
                        }
                    }
                    mean /= count;
                    for (let k = kMin; k <= kMax; k++) {
                        for (let j = jMin; j <= jMax; j++) {
                            for (let i = iMin; i <= iMax; i++) {
                                const value = scalarData[k * zMultiple + j * yMultiple + i];
                                const valueMinusMean = value - mean;
                                stdDev += valueMinusMean * valueMinusMean;
                            }
                        }
                    }
                    stdDev /= count;
                    stdDev = Math.sqrt(stdDev);
                    cachedStats[targetUID] = {
                        Modality: metadata.Modality,
                        area,
                        mean,
                        stdDev,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetUID] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            data.invalidated = false;
            const eventType = enums.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportUID,
                renderingEngineUID,
                sceneUID: sceneUID,
            };
            (0,esm.triggerEvent)(esm.eventTarget, eventType, eventDetail);
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
                esm.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._getTargetVolumeUID = (scene) => {
            if (this.configuration.volumeUID) {
                return this.configuration.volumeUID;
            }
            const volumeActors = scene.getVolumeActors();
            if (!volumeActors && !volumeActors.length) {
                return;
            }
            return volumeActors[0].uid;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    cancel(element) {
        if (!this.isDrawing) {
            return;
        }
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        (0,elementCursor.resetElementCursor)(element);
        const { annotation, viewportUIDsToRender } = this.editData;
        const { data } = annotation;
        data.active = false;
        data.handles.activeHandleIndex = null;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
        this.editData = null;
        return annotation.metadata.annotationUID;
    }
    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {
        let imageVolume, viewport;
        if (targetUID.startsWith('stackTarget')) {
            const coloneIndex = targetUID.indexOf(':');
            const viewportUID = targetUID.substring(coloneIndex + 1);
            const viewport = renderingEngine.getViewport(viewportUID);
            imageVolume = viewport.getImageData();
        }
        else {
            imageVolume = esm.cache.getVolume(targetUID);
        }
        return { imageVolume, viewport };
    }
    _getTargetStackUID(viewport) {
        return `stackTarget:${viewport.uid}`;
    }
}
VideoRedactionTool.toolName = 'VideoRedaction';
/* harmony default export */ const annotation_VideoRedactionTool = (VideoRedactionTool);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/index.js

















/***/ }),

/***/ 39011:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ annotationRenderingEngine)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89578);
/* harmony import */ var _utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39848);




const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
class AnnotationRenderingEngine {
    constructor() {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._renderFlaggedViewports = () => {
            this._throwIfDestroyed();
            const elements = Array.from(this._viewportElements.values());
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                if (this._needsRender.has(element)) {
                    this._triggerRender(element);
                    this._needsRender.delete(element);
                    if (this._needsRender.size === 0) {
                        break;
                    }
                }
            }
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
            this._render();
        };
        this._viewportElements = new Map();
    }
    addViewportElement(viewportId, element) {
        this._viewportElements.set(viewportId, element);
    }
    removeViewportElement(viewportId, element) {
        this._viewportElements.delete(viewportId);
        this._needsRender.delete(element);
        this._reset();
    }
    renderViewport(element) {
        this._setViewportsToBeRenderedNextFrame([element]);
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _setAllViewportsToBeRenderedNextFrame() {
        const elements = [...this._viewportElements.values()];
        elements.forEach((element) => {
            this._needsRender.add(element);
        });
        this._renderFlaggedViewports();
    }
    _setViewportsToBeRenderedNextFrame(elements) {
        const elementsEnabled = [...this._viewportElements.values()];
        elements.forEach((element) => {
            if (elementsEnabled.indexOf(element) !== -1) {
                this._needsRender.add(element);
            }
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && this._animationFrameSet === false) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
            this._animationFrameSet = true;
        }
    }
    _triggerRender(element) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(enabledElement.renderingEngineId);
        if (!renderingEngine) {
            console.warn('rendering Engine has been destroyed');
            return;
        }
        const enabledTools = (0,_utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(element, [
            Active,
            Passive,
            Enabled,
        ]);
        const { renderingEngineId, viewportId } = enabledElement;
        const eventDetail = {
            element,
            renderingEngineId,
            viewportId,
        };
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.draw)(element, (svgDrawingHelper) => {
            let anyRendered = false;
            const handleDrawSvg = (tool) => {
                if (tool.renderAnnotation) {
                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);
                    anyRendered = anyRendered || rendered;
                }
            };
            enabledTools.forEach(handleDrawSvg);
            if (anyRendered) {
                (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(element, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_RENDERED, { ...eventDetail });
            }
        });
    }
    _reset() {
        window.cancelAnimationFrame(this._animationFrameHandle);
        this._needsRender.clear();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._setAllViewportsToBeRenderedNextFrame();
    }
}
const annotationRenderingEngine = new AnnotationRenderingEngine();



/***/ }),

/***/ 67013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   H: () => (/* binding */ defaultFrameOfReferenceSpecificAnnotationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);

class FrameOfReferenceSpecificAnnotationManager {
    constructor(uid) {
        this.getGroupKey = (annotationGroupSelector) => {
            if (typeof annotationGroupSelector === 'string') {
                return annotationGroupSelector;
            }
            const element = annotationGroupSelector;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            if (!enabledElement) {
                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');
            }
            return enabledElement.FrameOfReferenceUID;
        };
        this._imageVolumeModifiedHandler = (evt) => {
            const eventDetail = evt.detail;
            const { FrameOfReferenceUID } = eventDetail;
            const annotations = this.annotations;
            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
            if (!frameOfReferenceSpecificAnnotations) {
                return;
            }
            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                toolSpecificAnnotations.forEach((annotation) => {
                    const invalidated = annotation.invalidated;
                    if (invalidated !== undefined) {
                        annotation.invalidated = true;
                    }
                });
            });
        };
        this.getFramesOfReference = () => {
            return Object.keys(this.annotations);
        };
        this.getAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            if (!annotations[groupKey]) {
                return [];
            }
            if (toolName) {
                return annotations[groupKey][toolName]
                    ? annotations[groupKey][toolName]
                    : [];
            }
            return annotations[groupKey];
        };
        this.getAnnotation = (annotationUID) => {
            const annotations = this.annotations;
            for (const frameOfReferenceUID in annotations) {
                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];
                for (const toolName in frameOfReferenceAnnotations) {
                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];
                    for (const annotation of toolSpecificAnnotations) {
                        if (annotationUID === annotation.annotationUID) {
                            return annotation;
                        }
                    }
                }
            }
        };
        this.getNumberOfAnnotations = (groupKey, toolName) => {
            const annotations = this.getAnnotations(groupKey, toolName);
            if (!annotations.length) {
                return 0;
            }
            if (toolName) {
                return annotations.length;
            }
            let total = 0;
            for (const toolName in annotations) {
                total += annotations[toolName].length;
            }
            return total;
        };
        this.addAnnotation = (annotation, groupKey) => {
            const { metadata } = annotation;
            const { FrameOfReferenceUID, toolName } = metadata;
            groupKey = groupKey || FrameOfReferenceUID;
            const annotations = this.annotations;
            let frameOfReferenceSpecificAnnotations = annotations[groupKey];
            if (!frameOfReferenceSpecificAnnotations) {
                annotations[groupKey] = {};
                frameOfReferenceSpecificAnnotations = annotations[groupKey];
            }
            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
            if (!toolSpecificAnnotations) {
                frameOfReferenceSpecificAnnotations[toolName] = [];
                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
            }
            if (this.preprocessingFn) {
                annotation = this.preprocessingFn(annotation);
            }
            toolSpecificAnnotations.push(annotation);
        };
        this.removeAnnotation = (annotationUID) => {
            const { annotations } = this;
            for (const groupKey in annotations) {
                const groupAnnotations = annotations[groupKey];
                for (const toolName in groupAnnotations) {
                    const toolAnnotations = groupAnnotations[toolName];
                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);
                    if (index !== -1) {
                        toolAnnotations.splice(index, 1);
                        if (toolAnnotations.length === 0) {
                            delete groupAnnotations[toolName];
                        }
                    }
                }
                if (Object.keys(groupAnnotations).length === 0) {
                    delete annotations[groupKey];
                }
            }
        };
        this.removeAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            const removedAnnotations = [];
            if (!annotations[groupKey]) {
                return removedAnnotations;
            }
            if (toolName) {
                const annotationsForTool = annotations[groupKey][toolName];
                for (const annotation of annotationsForTool) {
                    this.removeAnnotation(annotation.annotationUID);
                    removedAnnotations.push(annotation);
                }
            }
            else {
                for (const toolName in annotations[groupKey]) {
                    const annotationsForTool = annotations[groupKey][toolName];
                    for (const annotation of annotationsForTool) {
                        this.removeAnnotation(annotation.annotationUID);
                        removedAnnotations.push(annotation);
                    }
                }
            }
            return removedAnnotations;
        };
        this.saveAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            if (groupKey && toolName) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                if (!frameOfReferenceSpecificAnnotations) {
                    return;
                }
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                return structuredClone(toolSpecificAnnotations);
            }
            else if (groupKey) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                return structuredClone(frameOfReferenceSpecificAnnotations);
            }
            return structuredClone(annotations);
        };
        this.restoreAnnotations = (state, groupKey, toolName) => {
            const annotations = this.annotations;
            if (groupKey && toolName) {
                let frameOfReferenceSpecificAnnotations = annotations[groupKey];
                if (!frameOfReferenceSpecificAnnotations) {
                    annotations[groupKey] = {};
                    frameOfReferenceSpecificAnnotations = annotations[groupKey];
                }
                frameOfReferenceSpecificAnnotations[toolName] = state;
            }
            else if (groupKey) {
                annotations[groupKey] = state;
            }
            else {
                this.annotations = structuredClone(state);
            }
        };
        this.getAllAnnotations = () => {
            return Object.values(this.annotations)
                .map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations))
                .flat(2);
        };
        this.getNumberOfAllAnnotations = () => {
            let count = 0;
            const annotations = this.annotations;
            for (const groupKey in annotations) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                for (const toolName in frameOfReferenceSpecificAnnotations) {
                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                    count += toolSpecificAnnotations.length;
                }
            }
            return count;
        };
        this.removeAllAnnotations = () => {
            const removedAnnotations = [];
            for (const annotation of this.getAllAnnotations()) {
                this.removeAnnotation(annotation.annotationUID);
                removedAnnotations.push(annotation);
            }
            return removedAnnotations;
        };
        if (!uid) {
            uid = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
        }
        this.annotations = {};
        this.uid = uid;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);
    }
    setPreprocessingFn(preprocessingFn) {
        this.preprocessingFn = preprocessingFn;
    }
}
const defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FrameOfReferenceSpecificAnnotationManager);


/***/ }),

/***/ 2076:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndSetAnnotationLocked: () => (/* binding */ checkAndSetAnnotationLocked),
/* harmony export */   getAnnotationsLocked: () => (/* binding */ getAnnotationsLocked),
/* harmony export */   getAnnotationsLockedCount: () => (/* binding */ getAnnotationsLockedCount),
/* harmony export */   isAnnotationLocked: () => (/* binding */ isAnnotationLocked),
/* harmony export */   setAnnotationLocked: () => (/* binding */ setAnnotationLocked),
/* harmony export */   unlockAllAnnotations: () => (/* binding */ unlockAllAnnotations)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _getAnnotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69059);



const globalLockedAnnotationUIDsSet = new Set();
function setAnnotationLocked(annotationUID, locked = true) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (locked) {
            lock(annotationUID, globalLockedAnnotationUIDsSet, detail);
        }
        else {
            unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);
        }
    }
    publish(detail, globalLockedAnnotationUIDsSet);
}
function unlockAllAnnotations() {
    const detail = makeEventDetail();
    clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);
    publish(detail, globalLockedAnnotationUIDsSet);
}
function getAnnotationsLocked() {
    return Array.from(globalLockedAnnotationUIDsSet);
}
function isAnnotationLocked(annotationUID) {
    return globalLockedAnnotationUIDsSet.has(annotationUID);
}
function getAnnotationsLockedCount() {
    return globalLockedAnnotationUIDsSet.size;
}
function checkAndSetAnnotationLocked(annotationUID) {
    const isLocked = isAnnotationLocked(annotationUID);
    setAnnotationLocked(annotationUID, isLocked);
    return isLocked;
}
function makeEventDetail() {
    return Object.freeze({
        added: [],
        removed: [],
        locked: [],
    });
}
function lock(annotationUID, lockedAnnotationUIDsSet, detail) {
    if (!lockedAnnotationUIDsSet.has(annotationUID)) {
        lockedAnnotationUIDsSet.add(annotationUID);
        detail.added.push(annotationUID);
        const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(annotationUID);
        if (annotation) {
            annotation.isLocked = true;
        }
    }
}
function unlock(annotationUID, lockedAnnotationUIDsSet, detail) {
    if (lockedAnnotationUIDsSet.delete(annotationUID)) {
        detail.removed.push(annotationUID);
        const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(annotationUID);
        if (annotation) {
            annotation.isLocked = false;
        }
    }
}
function clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {
    lockedAnnotationUIDsSet.forEach((annotationUID) => {
        unlock(annotationUID, lockedAnnotationUIDsSet, detail);
    });
}
function publish(detail, lockedAnnotationUIDsSet) {
    if (detail.added.length > 0 || detail.removed.length > 0) {
        lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_LOCK_CHANGE, detail);
    }
}



/***/ }),

/***/ 17343:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deselectAnnotation: () => (/* binding */ deselectAnnotation),
/* harmony export */   getAnnotationsSelected: () => (/* binding */ getAnnotationsSelected),
/* harmony export */   getAnnotationsSelectedByToolName: () => (/* binding */ getAnnotationsSelectedByToolName),
/* harmony export */   getAnnotationsSelectedCount: () => (/* binding */ getAnnotationsSelectedCount),
/* harmony export */   isAnnotationSelected: () => (/* binding */ isAnnotationSelected),
/* harmony export */   setAnnotationSelected: () => (/* binding */ setAnnotationSelected)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _getAnnotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69059);



const selectedAnnotationUIDs = new Set();
function setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {
    if (selected) {
        selectAnnotation(annotationUID, preserveSelected);
    }
    else {
        deselectAnnotation(annotationUID);
    }
}
function selectAnnotation(annotationUID, preserveSelected = false) {
    const detail = makeEventDetail();
    if (!preserveSelected) {
        clearSelectionSet(selectedAnnotationUIDs, detail);
        const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(annotationUID);
        if (annotation) {
            annotation.isSelected = true;
        }
    }
    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {
        selectedAnnotationUIDs.add(annotationUID);
        detail.added.push(annotationUID);
        const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(annotationUID);
        if (annotation) {
            annotation.isSelected = true;
        }
    }
    publish(detail, selectedAnnotationUIDs);
}
function deselectAnnotation(annotationUID) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (selectedAnnotationUIDs.delete(annotationUID)) {
            detail.removed.push(annotationUID);
            const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(annotationUID);
            annotation.isSelected = false;
        }
    }
    else {
        clearSelectionSet(selectedAnnotationUIDs, detail);
    }
    publish(detail, selectedAnnotationUIDs);
}
function getAnnotationsSelected() {
    return Array.from(selectedAnnotationUIDs);
}
function getAnnotationsSelectedByToolName(toolName) {
    return getAnnotationsSelected().filter((annotationUID) => {
        const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(annotationUID);
        return annotation?.metadata?.toolName === toolName;
    });
}
function isAnnotationSelected(annotationUID) {
    return selectedAnnotationUIDs.has(annotationUID);
}
function getAnnotationsSelectedCount() {
    return selectedAnnotationUIDs.size;
}
function makeEventDetail() {
    return Object.freeze({
        added: [],
        removed: [],
        selection: [],
    });
}
function clearSelectionSet(selectionSet, detail) {
    selectionSet.forEach((value) => {
        if (selectionSet.delete(value)) {
            detail.removed.push(value);
            const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(value);
            if (annotation) {
                annotation.isSelected = false;
            }
        }
    });
}
function publish(detail, selectionSet) {
    if (detail.added.length > 0 || detail.removed.length > 0) {
        selectionSet.forEach((item) => void detail.selection.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_SELECTION_CHANGE, detail);
    }
}



/***/ }),

/***/ 82056:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAnnotation: () => (/* binding */ addAnnotation),
/* harmony export */   addChildAnnotation: () => (/* binding */ addChildAnnotation),
/* harmony export */   clearParentAnnotation: () => (/* binding */ clearParentAnnotation),
/* harmony export */   getAllAnnotations: () => (/* binding */ getAllAnnotations),
/* harmony export */   getAnnotation: () => (/* reexport safe */ _getAnnotation__WEBPACK_IMPORTED_MODULE_2__.g),
/* harmony export */   getAnnotationManager: () => (/* binding */ getAnnotationManager),
/* harmony export */   getAnnotations: () => (/* binding */ getAnnotations),
/* harmony export */   getChildAnnotations: () => (/* binding */ getChildAnnotations),
/* harmony export */   getNumberOfAnnotations: () => (/* binding */ getNumberOfAnnotations),
/* harmony export */   getParentAnnotation: () => (/* binding */ getParentAnnotation),
/* harmony export */   invalidateAnnotation: () => (/* binding */ invalidateAnnotation),
/* harmony export */   removeAllAnnotations: () => (/* binding */ removeAllAnnotations),
/* harmony export */   removeAnnotation: () => (/* binding */ removeAnnotation),
/* harmony export */   removeAnnotations: () => (/* binding */ removeAnnotations),
/* harmony export */   resetAnnotationManager: () => (/* binding */ resetAnnotationManager),
/* harmony export */   setAnnotationManager: () => (/* binding */ setAnnotationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67013);
/* harmony import */ var _getAnnotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69059);
/* harmony import */ var _helpers_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44049);
/* harmony import */ var _annotationLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2076);
/* harmony import */ var _utilities_defineProperties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82107);
/* harmony import */ var _annotationVisibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29601);







let defaultManager = _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_1__/* .defaultFrameOfReferenceSpecificAnnotationManager */ .H;
const preprocessingFn = (annotation) => {
    annotation = (0,_utilities_defineProperties__WEBPACK_IMPORTED_MODULE_5__/* .checkAndDefineTextBoxProperty */ .Q)(annotation);
    annotation = (0,_utilities_defineProperties__WEBPACK_IMPORTED_MODULE_5__/* .checkAndDefineCachedStatsProperty */ .d)(annotation);
    const uid = annotation.annotationUID;
    const isLocked = (0,_annotationLocking__WEBPACK_IMPORTED_MODULE_4__.checkAndSetAnnotationLocked)(uid);
    annotation.isLocked = isLocked;
    const isVisible = (0,_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__.checkAndSetAnnotationVisibility)(uid);
    annotation.isVisible = isVisible;
    return annotation;
};
defaultManager.setPreprocessingFn(preprocessingFn);
function getAnnotationManager() {
    return defaultManager;
}
function setAnnotationManager(annotationManager) {
    defaultManager = annotationManager;
}
function resetAnnotationManager() {
    defaultManager = _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_1__/* .defaultFrameOfReferenceSpecificAnnotationManager */ .H;
}
function getAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    return manager.getAnnotations(groupKey, toolName);
}
function getAllAnnotations() {
    const manager = getAnnotationManager();
    return manager.getAllAnnotations();
}
function clearParentAnnotation(annotation) {
    const { annotationUID: childUID, parentAnnotationUID } = annotation;
    if (!parentAnnotationUID) {
        return;
    }
    const parentAnnotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(parentAnnotationUID);
    const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);
    parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);
    annotation.parentAnnotationUID = undefined;
}
function addChildAnnotation(parentAnnotation, childAnnotation) {
    const { annotationUID: parentUID } = parentAnnotation;
    const { annotationUID: childUID } = childAnnotation;
    clearParentAnnotation(childAnnotation);
    if (!parentAnnotation.childAnnotationUIDs) {
        parentAnnotation.childAnnotationUIDs = [];
    }
    if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {
        return;
    }
    parentAnnotation.childAnnotationUIDs.push(childUID);
    childAnnotation.parentAnnotationUID = parentUID;
}
function getParentAnnotation(annotation) {
    return annotation.parentAnnotationUID
        ? (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(annotation.parentAnnotationUID)
        : undefined;
}
function getChildAnnotations(annotation) {
    return (annotation.childAnnotationUIDs?.map((childAnnotationUID) => (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(childAnnotationUID)) ?? []);
}
function addAnnotation(annotation, annotationGroupSelector) {
    if (!annotation.annotationUID) {
        annotation.annotationUID = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
    }
    const manager = getAnnotationManager();
    if (annotationGroupSelector instanceof HTMLDivElement) {
        const groupKey = manager.getGroupKey(annotationGroupSelector);
        manager.addAnnotation(annotation, groupKey);
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_3__/* .triggerAnnotationAddedForElement */ .$f)(annotation, annotationGroupSelector);
    }
    else {
        manager.addAnnotation(annotation, undefined);
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_3__/* .triggerAnnotationAddedForFOR */ ._3)(annotation);
    }
    return annotation.annotationUID;
}
function getNumberOfAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    return manager.getNumberOfAnnotations(groupKey, toolName);
}
function removeAnnotation(annotationUID) {
    if (!annotationUID) {
        return;
    }
    const manager = getAnnotationManager();
    const annotation = manager.getAnnotation(annotationUID);
    if (!annotation) {
        return;
    }
    annotation.childAnnotationUIDs?.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));
    manager.removeAnnotation(annotationUID);
    (0,_helpers_state__WEBPACK_IMPORTED_MODULE_3__/* .triggerAnnotationRemoved */ .SH)({ annotation, annotationManagerUID: manager.uid });
}
function removeAllAnnotations() {
    const manager = getAnnotationManager();
    const removedAnnotations = manager.removeAllAnnotations();
    for (const annotation of removedAnnotations) {
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_3__/* .triggerAnnotationRemoved */ .SH)({
            annotation,
            annotationManagerUID: manager.uid,
        });
    }
}
function removeAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    const removedAnnotations = manager.removeAnnotations(groupKey, toolName);
    for (const annotation of removedAnnotations) {
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_3__/* .triggerAnnotationRemoved */ .SH)({
            annotation,
            annotationManagerUID: manager.uid,
        });
    }
}
function invalidateAnnotation(annotation) {
    let currAnnotation = annotation;
    while (currAnnotation) {
        currAnnotation.invalidated = true;
        currAnnotation = currAnnotation.parentAnnotationUID
            ? (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotation */ .g)(currAnnotation.parentAnnotationUID)
            : undefined;
    }
}



/***/ }),

/***/ 29601:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndSetAnnotationVisibility: () => (/* binding */ checkAndSetAnnotationVisibility),
/* harmony export */   isAnnotationVisible: () => (/* binding */ isAnnotationVisible),
/* harmony export */   setAnnotationVisibility: () => (/* binding */ setAnnotationVisibility),
/* harmony export */   showAllAnnotations: () => (/* binding */ showAllAnnotations)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17343);
/* harmony import */ var _getAnnotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(69059);




const globalHiddenAnnotationUIDsSet = new Set();
function setAnnotationVisibility(annotationUID, visible = true) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (visible) {
            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
        }
        else {
            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);
        }
    }
    publish(detail);
}
function showAllAnnotations() {
    const detail = makeEventDetail();
    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {
        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
    });
    publish(detail);
}
function isAnnotationVisible(annotationUID) {
    const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_3__/* .getAnnotation */ .g)(annotationUID);
    if (annotation) {
        return !globalHiddenAnnotationUIDsSet.has(annotationUID);
    }
}
function makeEventDetail() {
    return Object.freeze({
        lastVisible: [],
        lastHidden: [],
        hidden: [],
    });
}
function show(annotationUID, annotationUIDsSet, detail) {
    if (annotationUIDsSet.delete(annotationUID)) {
        detail.lastVisible.push(annotationUID);
        const annotation = (0,_getAnnotation__WEBPACK_IMPORTED_MODULE_3__/* .getAnnotation */ .g)(annotationUID);
        annotation.isVisible = true;
    }
}
function hide(annotationUID, annotationUIDsSet, detail) {
    if (!annotationUIDsSet.has(annotationUID)) {
        annotationUIDsSet.add(annotationUID);
        if ((0,_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.isAnnotationSelected)(annotationUID)) {
            (0,_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.deselectAnnotation)(annotationUID);
        }
        detail.lastHidden.push(annotationUID);
    }
}
function publish(detail) {
    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {
        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_VISIBILITY_CHANGE, detail);
    }
}
function checkAndSetAnnotationVisibility(annotationUID) {
    const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);
    setAnnotationVisibility(annotationUID, isVisible);
    return isVisible;
}



/***/ }),

/***/ 8710:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class ToolStyle {
    constructor() {
        const defaultConfig = {
            color: 'rgb(255, 255, 0)',
            colorHighlighted: 'rgb(0, 255, 0)',
            colorSelected: 'rgb(0, 220, 0)',
            colorLocked: 'rgb(209, 193, 90)',
            lineWidth: '1',
            lineDash: '',
            shadow: true,
            textBoxVisibility: true,
            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
            textBoxFontSize: '14px',
            textBoxColor: 'rgb(255, 255, 0)',
            textBoxColorHighlighted: 'rgb(0, 255, 0)',
            textBoxColorSelected: 'rgb(0, 255, 0)',
            textBoxColorLocked: 'rgb(209, 193, 90)',
            textBoxBackground: '',
            textBoxLinkLineWidth: '1',
            textBoxLinkLineDash: '2,3',
            textBoxShadow: true,
        };
        this._initializeConfig(defaultConfig);
    }
    getAnnotationToolStyles(annotationUID) {
        return this.config.annotations && this.config.annotations[annotationUID];
    }
    getViewportToolStyles(viewportId) {
        return this.config.viewports && this.config.viewports[viewportId];
    }
    getToolGroupToolStyles(toolGroupId) {
        return this.config.toolGroups && this.config.toolGroups[toolGroupId];
    }
    getDefaultToolStyles() {
        return this.config.default;
    }
    setAnnotationStyles(annotationUID, styles) {
        let annotationSpecificStyles = this.config.annotations;
        if (!annotationSpecificStyles) {
            this.config = {
                ...this.config,
                annotations: {},
            };
            annotationSpecificStyles = this.config.annotations;
        }
        annotationSpecificStyles[annotationUID] = styles;
    }
    setViewportToolStyles(viewportId, styles) {
        let viewportSpecificStyles = this.config.viewports;
        if (!viewportSpecificStyles) {
            this.config = {
                ...this.config,
                viewports: {},
            };
            viewportSpecificStyles = this.config.viewports;
        }
        viewportSpecificStyles[viewportId] = styles;
    }
    setToolGroupToolStyles(toolGroupId, styles) {
        let toolGroupSpecificStyles = this.config.toolGroups;
        if (!toolGroupSpecificStyles) {
            this.config = {
                ...this.config,
                toolGroups: {},
            };
            toolGroupSpecificStyles = this.config.toolGroups;
        }
        toolGroupSpecificStyles[toolGroupId] = styles;
    }
    setDefaultToolStyles(styles) {
        this.config.default = styles;
    }
    getStyleProperty(toolStyle, specifications) {
        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;
        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);
    }
    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {
        if (annotationUID) {
            const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);
            if (annotationToolStyles) {
                if (annotationToolStyles[property] !== undefined) {
                    return annotationToolStyles[property];
                }
            }
        }
        if (viewportId) {
            const viewportToolStyles = this.getViewportToolStyles(viewportId);
            if (viewportToolStyles) {
                if (viewportToolStyles[toolName] &&
                    viewportToolStyles[toolName][property] !== undefined) {
                    return viewportToolStyles[toolName][property];
                }
                if (viewportToolStyles.global &&
                    viewportToolStyles.global[property] !== undefined) {
                    return viewportToolStyles.global[property];
                }
            }
        }
        if (toolGroupId) {
            const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);
            if (toolGroupToolStyles) {
                if (toolGroupToolStyles[toolName] &&
                    toolGroupToolStyles[toolName][property] !== undefined) {
                    return toolGroupToolStyles[toolName][property];
                }
                if (toolGroupToolStyles.global &&
                    toolGroupToolStyles.global[property] !== undefined) {
                    return toolGroupToolStyles.global[property];
                }
            }
        }
        const globalStyles = this.getDefaultToolStyles();
        if (globalStyles[toolName] &&
            globalStyles[toolName][property] !== undefined) {
            return globalStyles[toolName][property];
        }
        if (globalStyles.global && globalStyles.global[property] !== undefined) {
            return globalStyles.global[property];
        }
    }
    _initializeConfig(config) {
        const toolStyles = {};
        for (const name in config) {
            toolStyles[name] = config[name];
        }
        this.config = {
            default: {
                global: toolStyles,
            },
        };
    }
}
const toolStyle = new ToolStyle();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toolStyle);


/***/ }),

/***/ 76712:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ getStyleProperty)
/* harmony export */ });
/* harmony import */ var _ToolStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8710);

function getHierarchalPropertyStyles(property, state, mode) {
    const list = [`${property}`];
    if (state) {
        list.push(`${list[0]}${state}`);
    }
    if (mode) {
        list.push(`${list[list.length - 1]}${mode}`);
    }
    return list;
}
function getStyleProperty(property, styleSpecifier, state, mode) {
    const alternatives = getHierarchalPropertyStyles(property, state, mode);
    for (let i = alternatives.length - 1; i >= 0; --i) {
        const style = _ToolStyle__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getStyleProperty(alternatives[i], styleSpecifier);
        if (style !== undefined) {
            return style;
        }
    }
}



/***/ }),

/***/ 49310:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getFont: () => (/* reexport */ config_getFont),
  getState: () => (/* reexport */ config_getState),
  style: () => (/* reexport */ ToolStyle/* default */.A)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking = __webpack_require__(2076);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection = __webpack_require__(17343);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js



function getState(annotation) {
    if (annotation) {
        if (annotation.data && annotation.highlighted) {
            return enums.AnnotationStyleStates.Highlighted;
        }
        if ((0,annotationSelection.isAnnotationSelected)(annotation.annotationUID)) {
            return enums.AnnotationStyleStates.Selected;
        }
        if ((0,annotationLocking.isAnnotationLocked)(annotation.annotationUID)) {
            return enums.AnnotationStyleStates.Locked;
        }
        if (annotation.data && annotation.autoGenerated) {
            return enums.AnnotationStyleStates.AutoGenerated;
        }
    }
    return enums.AnnotationStyleStates.Default;
}
/* harmony default export */ const config_getState = (getState);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
var helpers = __webpack_require__(76712);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js

function getFont(styleSpecifier, state, mode) {
    const fontSize = (0,helpers/* getStyleProperty */.h)('textBoxFontSize', styleSpecifier, state, mode);
    const fontFamily = (0,helpers/* getStyleProperty */.h)('textBoxFontFamily', styleSpecifier, state, mode);
    return `${fontSize}px ${fontFamily}`;
}
/* harmony default export */ const config_getFont = (getFont);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js
var ToolStyle = __webpack_require__(8710);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js






/***/ }),

/***/ 69059:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ getAnnotation)
/* harmony export */ });
/* harmony import */ var _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67013);

function getAnnotation(annotationUID) {
    const manager = _FrameOfReferenceSpecificAnnotationManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultFrameOfReferenceSpecificAnnotationManager */ .H;
    const annotation = manager.getAnnotation(annotationUID);
    return annotation;
}


/***/ }),

/***/ 44049:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $f: () => (/* binding */ triggerAnnotationAddedForElement),
/* harmony export */   PS: () => (/* binding */ triggerContourAnnotationCompleted),
/* harmony export */   SH: () => (/* binding */ triggerAnnotationRemoved),
/* harmony export */   XF: () => (/* binding */ triggerAnnotationModified),
/* harmony export */   _3: () => (/* binding */ triggerAnnotationAddedForFOR),
/* harmony export */   dZ: () => (/* binding */ triggerAnnotationCompleted)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7754);



function triggerAnnotationAddedForElement(annotation, element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { renderingEngine, viewportId } = enabledElement;
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_ADDED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId: renderingEngine.id,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationAddedForFOR(annotation) {
    const { toolName } = annotation.metadata;
    const toolGroups = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupsWithToolName)(toolName);
    if (!toolGroups.length) {
        return;
    }
    const viewportsToRender = [];
    toolGroups.forEach((toolGroup) => {
        toolGroup.viewportsInfo.forEach((viewportInfo) => {
            const { renderingEngineId, viewportId } = viewportInfo;
            const { FrameOfReferenceUID } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {
                viewportsToRender.push(viewportInfo);
            }
        });
    });
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_ADDED;
    const eventDetail = { annotation };
    if (!viewportsToRender.length) {
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
        return;
    }
    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {
        eventDetail.viewportId = viewportId;
        eventDetail.renderingEngineId = renderingEngineId;
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
    });
}
function triggerAnnotationRemoved(eventDetail) {
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_REMOVED;
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationModified(annotation, element, changeType = _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.HandlesUpdated) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId, renderingEngineId } = enabledElement;
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_MODIFIED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId,
        changeType,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationCompleted(annotation) {
    const eventDetail = {
        annotation,
    };
    _triggerAnnotationCompleted(eventDetail);
}
function triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {
    const eventDetail = {
        annotation,
        contourHoleProcessingEnabled,
    };
    _triggerAnnotationCompleted(eventDetail);
}
function _triggerAnnotationCompleted(eventDetail) {
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_COMPLETED;
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}



/***/ }),

/***/ 47807:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AnnotationGroup: () => (/* reexport */ AnnotationGroup),
  FrameOfReferenceSpecificAnnotationManager: () => (/* reexport */ FrameOfReferenceSpecificAnnotationManager/* default */.A),
  config: () => (/* reexport */ config),
  locking: () => (/* reexport */ annotationLocking),
  selection: () => (/* reexport */ annotationSelection),
  state: () => (/* reexport */ annotationState),
  visibility: () => (/* reexport */ annotationVisibility)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js + 2 modules
var config = __webpack_require__(49310);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking = __webpack_require__(2076);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection = __webpack_require__(17343);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState = __webpack_require__(82056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js
var annotationVisibility = __webpack_require__(29601);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js
var FrameOfReferenceSpecificAnnotationManager = __webpack_require__(67013);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var Events = __webpack_require__(94021);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js



class AnnotationGroup {
    constructor() {
        this.annotationUIDs = new Set();
        this._isVisible = true;
        this.visibleFilter = this.unboundVisibleFilter.bind(this);
    }
    unboundVisibleFilter(uid) {
        return !this._isVisible || !this.annotationUIDs.has(uid);
    }
    has(uid) {
        return this.annotationUIDs.has(uid);
    }
    setVisible(isVisible = true, baseEvent, filter) {
        if (this._isVisible === isVisible) {
            return;
        }
        this._isVisible = isVisible;
        this.annotationUIDs.forEach((uid) => {
            const annotation = (0,annotationState.getAnnotation)(uid);
            if (!annotation) {
                this.annotationUIDs.delete(uid);
                return;
            }
            if (annotation.isVisible === isVisible) {
                return;
            }
            if (!isVisible && filter?.(uid) === false) {
                return;
            }
            annotation.isVisible = isVisible;
            const eventDetail = {
                ...baseEvent,
                annotation,
            };
            (0,esm.triggerEvent)(esm.eventTarget, Events/* default */.A.ANNOTATION_MODIFIED, eventDetail);
        });
    }
    get isVisible() {
        return this._isVisible;
    }
    findNearby(uid, direction) {
        const uids = [...this.annotationUIDs];
        if (uids.length === 0) {
            return null;
        }
        if (!uid) {
            return uids[direction === 1 ? 0 : uids.length - 1];
        }
        const index = uids.indexOf(uid);
        if (index === -1 ||
            index + direction < 0 ||
            index + direction >= uids.length) {
            return null;
        }
        return uids[index + direction];
    }
    add(...annotationUIDs) {
        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.add(annotationUID));
    }
    remove(...annotationUIDs) {
        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.delete(annotationUID));
    }
    clear() {
        this.annotationUIDs.clear();
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js










/***/ }),

/***/ 24917:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fy: () => (/* binding */ triggerSegmentationRenderBySegmentationId),
/* harmony export */   h6: () => (/* binding */ triggerSegmentationRender)
/* harmony export */ });
/* unused harmony export segmentationRenderingEngine */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18682);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93210);
/* harmony import */ var _tools_displayTools_Surface_surfaceDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(67014);
/* harmony import */ var _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(25894);
/* harmony import */ var _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(684);
/* harmony import */ var _store_addTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68040);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(85204);
/* harmony import */ var _tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(37590);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7754);











const renderers = {
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Labelmap]: _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Ay,
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Contour]: _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A,
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Surface]: _tools_displayTools_Surface_surfaceDisplay__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay,
};
const planarContourToolName = _tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.toolName;
class SegmentationRenderingEngine {
    constructor() {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._getAllViewports = () => {
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngines)();
            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());
        };
        this._renderFlaggedSegmentations = () => {
            this._throwIfDestroyed();
            const viewportIds = Array.from(this._needsRender);
            viewportIds.forEach((viewportId) => {
                this._triggerRender(viewportId);
            });
            this._needsRender.clear();
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
        };
    }
    renderSegmentationsForViewport(viewportId) {
        const viewportIds = viewportId
            ? [viewportId]
            : this._getViewportIdsForSegmentation();
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    renderSegmentation(segmentationId) {
        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    _getViewportIdsForSegmentation(segmentationId) {
        const viewports = this._getAllViewports();
        const viewportIds = [];
        for (const viewport of viewports) {
            const viewportId = viewport.id;
            if (segmentationId) {
                const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId, { segmentationId });
                if (segmentationRepresentations?.length > 0) {
                    viewportIds.push(viewportId);
                }
            }
            else {
                const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId);
                if (segmentationRepresentations?.length > 0) {
                    viewportIds.push(viewportId);
                }
            }
        }
        return viewportIds;
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _setViewportsToBeRenderedNextFrame(viewportIds) {
        viewportIds.forEach((viewportId) => {
            this._needsRender.add(viewportId);
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && this._animationFrameSet === false) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);
            this._animationFrameSet = true;
        }
    }
    _triggerRender(viewportId) {
        const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId);
        if (!segmentationRepresentations?.length) {
            return;
        }
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId) || {};
        if (!viewport) {
            return;
        }
        const viewportRenderList = [];
        const segmentationRenderList = segmentationRepresentations.map((representation) => {
            if (representation.type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Contour) {
                this._addPlanarFreeHandToolIfAbsent(viewport);
            }
            const display = renderers[representation.type];
            try {
                const viewportId = display.render(viewport, representation);
                viewportRenderList.push(viewportId);
            }
            catch (error) {
                console.error(error);
            }
            return Promise.resolve({
                segmentationId: representation.segmentationId,
                type: representation.type,
            });
        });
        Promise.allSettled(segmentationRenderList).then((results) => {
            const segmentationDetails = results
                .filter((r) => r.status === 'fulfilled')
                .map((r) => r.value);
            function onSegmentationRender(evt) {
                const { element, viewportId } = evt.detail;
                element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onSegmentationRender);
                segmentationDetails.forEach((detail) => {
                    const eventDetail = {
                        viewportId,
                        segmentationId: detail.segmentationId,
                        type: detail.type,
                    };
                    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_RENDERED, {
                        ...eventDetail,
                    });
                });
            }
            const element = viewport.element;
            element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onSegmentationRender);
            viewport.render();
        });
    }
    _addPlanarFreeHandToolIfAbsent(viewport) {
        if (!(planarContourToolName in _store_state__WEBPACK_IMPORTED_MODULE_8__/* .state */ .wk.tools)) {
            (0,_store_addTool__WEBPACK_IMPORTED_MODULE_7__/* .addTool */ .Gx)(_tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);
        }
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroupForViewport)(viewport.id);
        if (!toolGroup.hasTool(planarContourToolName)) {
            toolGroup.addTool(planarContourToolName);
            toolGroup.setToolPassive(planarContourToolName);
        }
    }
}
function triggerSegmentationRender(viewportId) {
    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);
}
function triggerSegmentationRenderBySegmentationId(segmentationId) {
    segmentationRenderingEngine.renderSegmentation(segmentationId);
}
const segmentationRenderingEngine = new SegmentationRenderingEngine();



/***/ }),

/***/ 59475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Zm: () => (/* binding */ internalComputeVolumeLabelmapFromStack),
/* harmony export */   _6: () => (/* binding */ defaultSegmentationStateManager),
/* harmony export */   cC: () => (/* binding */ internalConvertStackToVolumeLabelmap)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33739);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99341);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49906);
/* harmony import */ var _SegmentationStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(92686);
/* harmony import */ var _events_triggerSegmentationAdded__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75419);







const initialDefaultState = {
    colorLUT: [],
    segmentations: [],
    viewportSegRepresentations: {},
};
class SegmentationStateManager {
    constructor(uid) {
        this._stackLabelmapImageIdReferenceMap = new Map();
        uid ||= _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
        this.state = Object.freeze(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(initialDefaultState));
        this.uid = uid;
    }
    getState() {
        return this.state;
    }
    updateState(updater) {
        const newState = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(this.state);
        updater(newState);
        this.state = Object.freeze(newState);
    }
    getColorLUT(lutIndex) {
        return this.state.colorLUT[lutIndex];
    }
    getNextColorLUTIndex() {
        return this.state.colorLUT.length;
    }
    resetState() {
        this.state = Object.freeze(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(initialDefaultState));
    }
    getSegmentation(segmentationId) {
        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
    }
    updateSegmentation(segmentationId, payload) {
        this.updateState((draftState) => {
            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
            if (!segmentation) {
                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);
                return;
            }
            Object.assign(segmentation, payload);
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationModified)(segmentationId);
    }
    addSegmentation(segmentation) {
        if (this.getSegmentation(segmentation.segmentationId)) {
            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);
        }
        this.updateState((state) => {
            const newSegmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(segmentation);
            if (newSegmentation.representationData.Labelmap &&
                'volumeId' in newSegmentation.representationData.Labelmap &&
                !('imageIds' in newSegmentation.representationData.Labelmap)) {
                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);
                newSegmentation.representationData
                    .Labelmap.imageIds = imageIds;
            }
            state.segmentations.push(newSegmentation);
        });
        (0,_events_triggerSegmentationAdded__WEBPACK_IMPORTED_MODULE_6__/* .triggerSegmentationAdded */ .R)(segmentation.segmentationId);
    }
    removeSegmentation(segmentationId) {
        this.updateState((state) => {
            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);
            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRemoved)(segmentationId);
    }
    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {
            type: type,
            segmentationId,
        });
        if (existingRepresentations.length > 0) {
            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);
            return;
        }
        this.updateState((state) => {
            if (!state.viewportSegRepresentations[viewportId]) {
                state.viewportSegRepresentations[viewportId] = [];
                _SegmentationStyle__WEBPACK_IMPORTED_MODULE_5__/* .segmentationStyle */ .Y.setRenderInactiveSegmentations(viewportId, true);
            }
            if (type !== _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap) {
                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);
            }
            else {
                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);
            }
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentationId, type);
    }
    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {
        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
        if (!segmentation) {
            return;
        }
        const segmentReps = {};
        Object.keys(segmentation.segments).forEach((segmentIndex) => {
            segmentReps[Number(segmentIndex)] = {
                visible: true,
            };
        });
        state.viewportSegRepresentations[viewportId].push({
            segmentationId,
            type,
            active: true,
            visible: true,
            colorLUTIndex: 0,
            segments: segmentReps,
            config: {
                ...getDefaultRenderingConfig(type),
                ...renderingConfig,
            },
        });
        this._setActiveSegmentation(state, viewportId, segmentationId);
    }
    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap)) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap, renderingConfig);
        }
        this.processLabelmapRepresentationAddition(viewportId, segmentationId);
        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap, renderingConfig);
    }
    async processLabelmapRepresentationAddition(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        const volumeViewport = enabledElement.viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport;
        const { representationData } = segmentation;
        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;
        const viewport = enabledElement.viewport;
        if (!volumeViewport && !isBaseVolumeSegmentation) {
            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);
        }
    }
    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {
        const currentImageId = viewport.getCurrentImageId();
        let viewableLabelmapImageIdFound = false;
        for (const labelmapImageId of labelmapImageIds) {
            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });
            if (viewableImageId) {
                viewableLabelmapImageIdFound = true;
                this._stackLabelmapImageIdReferenceMap
                    .get(segmentationId)
                    .set(currentImageId, labelmapImageId);
            }
        }
        if (updateCallback) {
            updateCallback(viewport, segmentationId, labelmapImageIds);
        }
        return viewableLabelmapImageIdFound
            ? this._stackLabelmapImageIdReferenceMap
                .get(segmentationId)
                .get(currentImageId)
            : undefined;
    }
    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return;
        }
        const labelmapImageIds = this.getLabelmapImageIds(representationData);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const stackViewport = enabledElement.viewport;
        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);
    }
    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return;
        }
        const labelmapImageIds = this.getLabelmapImageIds(representationData);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const stackViewport = enabledElement.viewport;
        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {
            const imageIds = stackViewport.getImageIds();
            imageIds.forEach((imageId, index) => {
                for (const labelmapImageId of labelmapImageIds) {
                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });
                    if (viewableImageId) {
                        this._stackLabelmapImageIdReferenceMap
                            .get(segmentationId)
                            .set(imageId, labelmapImageId);
                    }
                }
            });
        });
    }
    getLabelmapImageIds(representationData) {
        const labelmapData = representationData.Labelmap;
        let labelmapImageIds;
        if (labelmapData.imageIds) {
            labelmapImageIds = labelmapData
                .imageIds;
        }
        else if (!labelmapImageIds &&
            labelmapData.volumeId) {
            const volumeId = labelmapData
                .volumeId;
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            labelmapImageIds = volume.imageIds;
        }
        return labelmapImageIds;
    }
    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            return;
        }
        const stackViewport = enabledElement.viewport;
        const currentImageId = stackViewport.getCurrentImageId();
        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
        return imageIdReferenceMap.get(currentImageId);
    }
    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return [];
        }
        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const imageIds = viewport.getImageIds();
        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
        return imageIds.map((imageId) => {
            return associatedReferenceImageAndLabelmapImageIds.get(imageId);
        });
    }
    removeSegmentationRepresentationsInternal(viewportId, specifier) {
        const removedRepresentations = [];
        this.updateState((state) => {
            if (!state.viewportSegRepresentations[viewportId]) {
                return;
            }
            const currentRepresentations = state.viewportSegRepresentations[viewportId];
            let activeRepresentationRemoved = false;
            if (!specifier ||
                Object.values(specifier).every((value) => value === undefined)) {
                removedRepresentations.push(...currentRepresentations);
                delete state.viewportSegRepresentations[viewportId];
            }
            else {
                const { segmentationId, type } = specifier;
                state.viewportSegRepresentations[viewportId] =
                    currentRepresentations.filter((representation) => {
                        const shouldRemove = (segmentationId &&
                            type &&
                            representation.segmentationId === segmentationId &&
                            representation.type === type) ||
                            (segmentationId &&
                                !type &&
                                representation.segmentationId === segmentationId) ||
                            (!segmentationId && type && representation.type === type);
                        if (shouldRemove) {
                            removedRepresentations.push(representation);
                            if (representation.active) {
                                activeRepresentationRemoved = true;
                            }
                        }
                        return !shouldRemove;
                    });
                if (state.viewportSegRepresentations[viewportId].length === 0) {
                    delete state.viewportSegRepresentations[viewportId];
                }
                else if (activeRepresentationRemoved) {
                    state.viewportSegRepresentations[viewportId][0].active = true;
                }
            }
        });
        return removedRepresentations;
    }
    removeSegmentationRepresentations(viewportId, specifier) {
        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
        removedRepresentations.forEach((representation) => {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)(viewportId, representation.segmentationId, representation.type);
        });
        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);
        if (remainingRepresentations.length > 0 &&
            remainingRepresentations[0].active) {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);
        }
        return removedRepresentations;
    }
    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {
        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
        if (!suppressEvent) {
            removedRepresentations.forEach(({ segmentationId, type }) => {
                (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)(viewportId, segmentationId, type);
            });
        }
        return removedRepresentations;
    }
    _setActiveSegmentation(state, viewportId, segmentationId) {
        const viewport = state.viewportSegRepresentations[viewportId];
        if (!viewport) {
            return;
        }
        viewport.forEach((value) => {
            value.active = value.segmentationId === segmentationId;
        });
    }
    setActiveSegmentation(viewportId, segmentationId) {
        this.updateState((state) => {
            const viewport = state.viewportSegRepresentations[viewportId];
            if (!viewport) {
                return;
            }
            viewport.forEach((value) => {
                value.active = value.segmentationId === segmentationId;
            });
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
    }
    getActiveSegmentation(viewportId) {
        if (!this.state.viewportSegRepresentations[viewportId]) {
            return;
        }
        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);
        if (!activeSegRep) {
            return;
        }
        return this.getSegmentation(activeSegRep.segmentationId);
    }
    getSegmentationRepresentations(viewportId, specifier = {}) {
        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];
        if (!viewportRepresentations) {
            return [];
        }
        if (!specifier.type && !specifier.segmentationId) {
            return viewportRepresentations;
        }
        return viewportRepresentations.filter((representation) => {
            const typeMatch = specifier.type
                ? representation.type === specifier.type
                : true;
            const idMatch = specifier.segmentationId
                ? representation.segmentationId === specifier.segmentationId
                : true;
            return typeMatch && idMatch;
        });
    }
    getSegmentationRepresentation(viewportId, specifier) {
        return this.getSegmentationRepresentations(viewportId, specifier)[0];
    }
    getSegmentationRepresentationVisibility(viewportId, specifier) {
        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);
        return viewportRepresentation?.visible;
    }
    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
        this.updateState((state) => {
            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);
            if (!viewportRepresentations) {
                return;
            }
            viewportRepresentations.forEach((representation) => {
                representation.visible = visible;
                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {
                    segment.visible = visible;
                });
            });
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, specifier.segmentationId, specifier.type);
    }
    addColorLUT(colorLUT, lutIndex) {
        this.updateState((state) => {
            if (state.colorLUT[lutIndex]) {
                console.warn('Color LUT table already exists, overwriting');
            }
            state.colorLUT[lutIndex] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(colorLUT);
        });
    }
    removeColorLUT(colorLUTIndex) {
        this.updateState((state) => {
            delete state.colorLUT[colorLUTIndex];
        });
    }
    _getStackIdForImageIds(imageIds) {
        return imageIds
            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))
            .join('_');
    }
    getAllViewportSegmentationRepresentations() {
        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({
            viewportId,
            representations,
        }));
    }
    getSegmentationRepresentationsBySegmentationId(segmentationId) {
        const result = [];
        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {
            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);
            if (filteredReps.length > 0) {
                result.push({ viewportId, representations: filteredReps });
            }
        });
        return result;
    }
}
async function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {
    const segmentationImageIds = imageIds;
    const volumeId = options?.volumeId || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
    await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);
    return { volumeId };
}
async function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {
    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);
    const data = segmentation.representationData
        .Labelmap;
    const { volumeId } = await internalComputeVolumeLabelmapFromStack({
        imageIds: data.imageIds,
        options,
    });
    segmentation.representationData.Labelmap.volumeId = volumeId;
}
function getDefaultRenderingConfig(type) {
    const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
    const ofun = _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
    ofun.addPoint(0, 0);
    if (type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap) {
        return {
            cfun,
            ofun,
        };
    }
    else {
        return {};
    }
}
const defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');



/***/ }),

/***/ 92686:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ segmentationStyle)
/* harmony export */ });
/* harmony import */ var _tools_displayTools_Contour_contourConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67772);
/* harmony import */ var _tools_displayTools_Labelmap_labelmapConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53486);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81985);




class SegmentationStyle {
    constructor() {
        this.config = {
            global: {},
            segmentations: {},
            viewportsStyle: {},
        };
    }
    setStyle(specifier, styles) {
        const { viewportId, segmentationId, type, segmentIndex } = specifier;
        const currentStyles = this.getStyle(specifier);
        let updatedStyles;
        if (!viewportId && !segmentationId) {
            updatedStyles = {
                ...currentStyles,
                ...styles,
            };
        }
        else {
            updatedStyles = this.copyActiveToInactiveIfNotProvided({
                ...currentStyles,
                ...styles,
            }, type);
        }
        if (!type) {
            throw new Error('Type is required to set a style');
        }
        if (viewportId) {
            if (!this.config.viewportsStyle[viewportId]) {
                this.config.viewportsStyle[viewportId] = {
                    renderInactiveSegmentations: false,
                    representations: {},
                };
            }
            const representations = this.config.viewportsStyle[viewportId].representations;
            if (segmentationId) {
                if (!representations[segmentationId]) {
                    representations[segmentationId] = {};
                }
                if (!representations[segmentationId][type]) {
                    representations[segmentationId][type] = {};
                }
                const repConfig = representations[segmentationId][type];
                if (segmentIndex !== undefined) {
                    if (!repConfig.perSegment) {
                        repConfig.perSegment = {};
                    }
                    repConfig.perSegment[segmentIndex] = updatedStyles;
                }
                else {
                    repConfig.allSegments = updatedStyles;
                }
            }
            else {
                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';
                if (!representations[ALL_SEGMENTATIONS_KEY]) {
                    representations[ALL_SEGMENTATIONS_KEY] = {};
                }
                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {
                    representations[ALL_SEGMENTATIONS_KEY][type] = {};
                }
                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =
                    updatedStyles;
            }
        }
        else if (segmentationId) {
            if (!this.config.segmentations[segmentationId]) {
                this.config.segmentations[segmentationId] = {};
            }
            if (!this.config.segmentations[segmentationId][type]) {
                this.config.segmentations[segmentationId][type] = {};
            }
            const segConfig = this.config.segmentations[segmentationId][type];
            if (segmentIndex !== undefined) {
                if (!segConfig.perSegment) {
                    segConfig.perSegment = {};
                }
                segConfig.perSegment[segmentIndex] = updatedStyles;
            }
            else {
                segConfig.allSegments = updatedStyles;
            }
        }
        else {
            this.config.global[type] = updatedStyles;
        }
    }
    copyActiveToInactiveIfNotProvided(styles, type) {
        const processedStyles = { ...styles };
        if (type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap) {
            const labelmapStyles = processedStyles;
            labelmapStyles.renderOutlineInactive = labelmapStyles.renderOutline;
            labelmapStyles.outlineWidthInactive = labelmapStyles.outlineWidth;
            labelmapStyles.renderFillInactive = labelmapStyles.renderFill;
            labelmapStyles.fillAlphaInactive = labelmapStyles.fillAlpha;
            labelmapStyles.outlineOpacityInactive = labelmapStyles.outlineOpacity;
        }
        else if (type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour) {
            const contourStyles = processedStyles;
            contourStyles.outlineWidthInactive = contourStyles.outlineWidth;
            contourStyles.outlineOpacityInactive = contourStyles.outlineOpacity;
            contourStyles.outlineDashInactive = contourStyles.outlineDash;
            contourStyles.renderOutlineInactive = contourStyles.renderOutline;
            contourStyles.renderFillInactive = contourStyles.renderFill;
            contourStyles.fillAlphaInactive = contourStyles.fillAlpha;
        }
        return processedStyles;
    }
    getStyle(specifier) {
        const { viewportId, segmentationId, type, segmentIndex } = specifier;
        let combinedStyle = this.getDefaultStyle(type);
        let renderInactiveSegmentations = false;
        if (this.config.global[type]) {
            combinedStyle = {
                ...combinedStyle,
                ...this.config.global[type],
            };
        }
        if (this.config.segmentations[segmentationId]?.[type]) {
            combinedStyle = {
                ...combinedStyle,
                ...this.config.segmentations[segmentationId][type].allSegments,
            };
            if (segmentIndex !== undefined &&
                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],
                };
            }
        }
        if (viewportId && this.config.viewportsStyle[viewportId]) {
            renderInactiveSegmentations =
                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;
            const allSegmentationsKey = '__allSegmentations__';
            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,
                };
            }
            if (segmentationId &&
                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,
                };
                if (segmentIndex !== undefined &&
                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {
                    combinedStyle = {
                        ...combinedStyle,
                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],
                    };
                }
            }
        }
        return combinedStyle;
    }
    getRenderInactiveSegmentations(viewportId) {
        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;
    }
    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
        if (!this.config.viewportsStyle[viewportId]) {
            this.config.viewportsStyle[viewportId] = {
                renderInactiveSegmentations: false,
                representations: {},
            };
        }
        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =
            renderInactiveSegmentations;
    }
    getDefaultStyle(type) {
        switch (type) {
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap:
                return (0,_tools_displayTools_Labelmap_labelmapConfig__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)();
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour:
                return (0,_tools_displayTools_Contour_contourConfig__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)();
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Surface:
                return {};
            default:
                throw new Error(`Unknown representation type: ${type}`);
        }
    }
    clearSegmentationStyle(segmentationId) {
        if (this.config.segmentations[segmentationId]) {
            delete this.config.segmentations[segmentationId];
        }
    }
    clearAllSegmentationStyles() {
        this.config.segmentations = {};
    }
    clearViewportStyle(viewportId) {
        if (this.config.viewportsStyle[viewportId]) {
            delete this.config.viewportsStyle[viewportId];
        }
    }
    clearAllViewportStyles() {
        for (const viewportId in this.config.viewportsStyle) {
            const viewportStyle = this.config.viewportsStyle[viewportId];
            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;
            this.config.viewportsStyle[viewportId] = {
                renderInactiveSegmentations,
                representations: {},
            };
        }
    }
    resetToGlobalStyle() {
        this.clearAllSegmentationStyles();
        this.clearAllViewportStyles();
    }
    hasCustomStyle(specifier) {
        const { type } = specifier;
        const style = this.getStyle(specifier);
        const defaultStyle = this.getDefaultStyle(type);
        return !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_3__.utilities.deepEqual(style, defaultStyle);
    }
}
const segmentationStyle = new SegmentationStyle();



/***/ }),

/***/ 26228:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getActiveSegmentation: () => (/* binding */ activeSegmentation_getActiveSegmentation),
  setActiveSegmentation: () => (/* binding */ activeSegmentation_setActiveSegmentation)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js
var getActiveSegmentation = __webpack_require__(67165);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js

function setActiveSegmentation(viewportId, segmentationId) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js


function activeSegmentation_getActiveSegmentation(viewportId) {
    return (0,getActiveSegmentation/* getActiveSegmentation */.T)(viewportId);
}
function activeSegmentation_setActiveSegmentation(viewportId, segmentationId, suppressEvent = false) {
    setActiveSegmentation(viewportId, segmentationId);
}



/***/ }),

/***/ 4714:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ addColorLUT)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59475);
/* harmony import */ var _getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70906);
/* harmony import */ var _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93952);




function addColorLUT(colorLUT, index) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__/* .defaultSegmentationStateManager */ ._6;
    const indexToUse = index ?? (0,_getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_2__/* .getNextColorLUTIndex */ .u)();
    let colorLUTToUse = [...colorLUT];
    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {
        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');
        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];
    }
    colorLUTToUse = colorLUTToUse.map((color) => {
        if (color.length === 3) {
            return [color[0], color[1], color[2], 255];
        }
        return color;
    });
    if (colorLUTToUse.length < 255) {
        const missingColorLUTs = _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.slice(colorLUTToUse.length);
        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];
    }
    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);
    return indexToUse;
}


/***/ }),

/***/ 38816:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  At: () => (/* binding */ addContourRepresentationToViewport),
  cs: () => (/* binding */ addContourRepresentationToViewportMap),
  Wz: () => (/* binding */ addLabelmapRepresentationToViewport),
  w9: () => (/* binding */ addLabelmapRepresentationToViewportMap),
  gR: () => (/* binding */ addSegmentationRepresentations),
  Hr: () => (/* binding */ addSurfaceRepresentationToViewport),
  $j: () => (/* binding */ addSurfaceRepresentationToViewportMap)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js
var COLOR_LUT = __webpack_require__(93952);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js
var triggerAnnotationRenderForViewportIds = __webpack_require__(58640);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js
var addColorLUT = __webpack_require__(4714);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js
var getNextColorLUTIndex = __webpack_require__(70906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js
var getColorLUT = __webpack_require__(50409);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js








function internalAddSegmentationRepresentation(viewportId, representationInput) {
    const { segmentationId, config } = representationInput;
    const renderingConfig = {
        colorLUTIndex: getColorLUTIndex(config),
    };
    SegmentationStateManager/* defaultSegmentationStateManager */._6.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);
    if (representationInput.type === enums.SegmentationRepresentations.Contour) {
        (0,triggerAnnotationRenderForViewportIds/* triggerAnnotationRenderForViewportIds */.t)([viewportId]);
    }
    (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentationId);
}
function getColorLUTIndex(config) {
    const { colorLUTOrIndex } = config || {};
    const isIndexProvided = typeof colorLUTOrIndex === 'number';
    const selectedColorLUT = isIndexProvided
        ? (0,getColorLUT/* getColorLUT */.B)(colorLUTOrIndex)
        : COLOR_LUT/* default */.A;
    const colorLUTIndex = isIndexProvided
        ? colorLUTOrIndex
        : (0,getNextColorLUTIndex/* getNextColorLUTIndex */.u)();
    if (!isIndexProvided) {
        (0,addColorLUT/* addColorLUT */.u)(selectedColorLUT, colorLUTIndex);
    }
    return colorLUTIndex;
}


;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js


function addSegmentationRepresentations(viewportId, segmentationInputArray) {
    segmentationInputArray.map((segmentationInput) => {
        return internalAddSegmentationRepresentation(viewportId, segmentationInput);
    });
}
function addContourRepresentationToViewport(viewportId, contourInputArray) {
    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({
        ...input,
        type: enums.SegmentationRepresentations.Contour,
    })));
}
function addContourRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);
    }
    return results;
}
function addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {
    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({
        ...input,
        type: enums.SegmentationRepresentations.Labelmap,
    })));
}
function addLabelmapRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({
            ...input,
            type: enums.SegmentationRepresentations.Labelmap,
        })));
    }
}
function addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {
    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({
        ...input,
        type: enums.SegmentationRepresentations.Surface,
    })));
}
function addSurfaceRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);
    }
    return results;
}



/***/ }),

/***/ 30935:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  d: () => (/* binding */ addSegmentations)
});

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js


function normalizeSegmentationInput(segmentationInput) {
    const { segmentationId, representation, config } = segmentationInput;
    const { type, data: inputData } = representation;
    const data = inputData ? { ...inputData } : {};
    if (!data) {
        throw new Error('Segmentation representation data may not be undefined');
    }
    if (type === enums.SegmentationRepresentations.Contour) {
        normalizeContourData(data);
    }
    const normalizedSegments = normalizeSegments(config?.segments, type, data);
    delete config?.segments;
    return {
        segmentationId,
        label: config?.label ?? null,
        cachedStats: config?.cachedStats ?? {},
        segments: normalizedSegments,
        representationData: {
            [type]: {
                ...data,
            },
        },
    };
}
function normalizeContourData(contourData) {
    contourData.geometryIds = contourData.geometryIds ?? [];
    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();
}
function normalizeSegments(segmentsConfig, type, data) {
    const normalizedSegments = {};
    if (segmentsConfig) {
        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {
            normalizedSegments[segmentIndex] = {
                segmentIndex: Number(segmentIndex),
                label: segment.label ?? `Segment ${segmentIndex}`,
                locked: segment.locked ?? false,
                cachedStats: segment.cachedStats ?? {},
                active: segment.active ?? false,
            };
        });
    }
    else if (type === enums.SegmentationRepresentations.Surface) {
        normalizeSurfaceSegments(normalizedSegments, data);
    }
    else {
        normalizedSegments[1] = createDefaultSegment();
    }
    return normalizedSegments;
}
function normalizeSurfaceSegments(normalizedSegments, surfaceData) {
    const { geometryIds } = surfaceData;
    geometryIds.forEach((geometryId) => {
        const geometry = esm.cache.getGeometry(geometryId);
        if (geometry?.data) {
            const { segmentIndex } = geometry.data;
            normalizedSegments[segmentIndex] = { segmentIndex };
        }
    });
}
function createDefaultSegment() {
    return {
        segmentIndex: 1,
        label: 'Segment 1',
        locked: false,
        cachedStats: {},
        active: true,
    };
}
/* harmony default export */ const helpers_normalizeSegmentationInput = (normalizeSegmentationInput);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js



function addSegmentations(segmentationInputArray, suppressEvents) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationInputArray.forEach((segmentationInput) => {
        const segmentation = helpers_normalizeSegmentationInput(segmentationInput);
        segmentationStateManager.addSegmentation(segmentation);
        if (!suppressEvents) {
            (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentation.segmentationId);
        }
    });
}
/* harmony default export */ const segmentation_addSegmentations = ((/* unused pure expression or super */ null && (addSegmentations)));


/***/ }),

/***/ 93733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addColorLUT: () => (/* binding */ addColorLUT),
/* harmony export */   getSegmentIndexColor: () => (/* binding */ getSegmentIndexColor),
/* harmony export */   setColorLUT: () => (/* binding */ setColorLUT),
/* harmony export */   setSegmentIndexColor: () => (/* binding */ setSegmentIndexColor)
/* harmony export */ });
/* harmony import */ var _addColorLUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4714);
/* harmony import */ var _getColorLUT__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50409);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93210);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49906);




function addColorLUT(colorLUT, colorLUTIndex) {
    if (!colorLUT) {
        throw new Error('addColorLUT: colorLUT is required');
    }
    return (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_0__/* .addColorLUT */ .u)(colorLUT, colorLUTIndex);
}
function setColorLUT(viewportId, segmentationId, colorLUTsIndex) {
    if (!(0,_getColorLUT__WEBPACK_IMPORTED_MODULE_1__/* .getColorLUT */ .B)(colorLUTsIndex)) {
        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);
    }
    const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentationRepresentations */ .r$)(viewportId, { segmentationId });
    if (!segmentationRepresentations) {
        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);
    }
    segmentationRepresentations.forEach((segmentationRepresentation) => {
        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;
    });
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
}
function getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {
    const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentationRepresentations */ .r$)(viewportId, {
        segmentationId,
    });
    if (!representations || representations.length === 0) {
        return null;
    }
    const representation = representations[0];
    const { colorLUTIndex } = representation;
    const colorLUT = (0,_getColorLUT__WEBPACK_IMPORTED_MODULE_1__/* .getColorLUT */ .B)(colorLUTIndex);
    let colorValue = colorLUT[segmentIndex];
    if (!colorValue) {
        if (typeof segmentIndex !== 'number') {
            throw new Error(`Can't create colour for LUT index ${segmentIndex}`);
        }
        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];
    }
    return colorValue;
}
function setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {
    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);
    for (let i = 0; i < color.length; i++) {
        colorReference[i] = color[i];
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
}



/***/ }),

/***/ 98798:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ triggerSegmentationDataModified)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _utilities_segmentation_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64063);



function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse) {
    const eventDetail = {
        segmentationId,
        modifiedSlicesToUse,
    };
    (0,_utilities_segmentation_utilities__WEBPACK_IMPORTED_MODULE_2__/* .setSegmentationDirty */ .HM)(segmentationId);
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, eventDetail);
}


/***/ }),

/***/ 60740:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ getActiveSegmentIndex)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);

function getActiveSegmentIndex(segmentationId) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (segmentation) {
        const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);
        return activeSegmentIndex ? Number(activeSegmentIndex) : undefined;
    }
    return undefined;
}


/***/ }),

/***/ 67165:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getActiveSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getActiveSegmentation(viewportId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getActiveSegmentation(viewportId);
}


/***/ }),

/***/ 50409:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ getColorLUT)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getColorLUT(index) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getColorLUT(index);
}


/***/ }),

/***/ 97577:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ getCurrentLabelmapImageIdForViewport)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getCurrentLabelmapImageIdForViewport(viewportId, segmentationId);
}


/***/ }),

/***/ 70906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ getNextColorLUTIndex)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getNextColorLUTIndex() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getNextColorLUTIndex();
}


/***/ }),

/***/ 93210:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ut: () => (/* binding */ getSegmentationRepresentation),
/* harmony export */   ny: () => (/* binding */ getSegmentationRepresentationsBySegmentationId),
/* harmony export */   r$: () => (/* binding */ getSegmentationRepresentations)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentationRepresentations(viewportId, specifier = {}) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
}
function getSegmentationRepresentation(viewportId, specifier) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    if (!specifier.segmentationId || !specifier.type) {
        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');
    }
    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
    return representations?.[0];
}
function getSegmentationRepresentationsBySegmentationId(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);
}


/***/ }),

/***/ 33658:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ getSegmentationRepresentationVisibility)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentationRepresentationVisibility(viewportId, specifier) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);
}


/***/ }),

/***/ 70758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ getSegmentations)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentations() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    return state.segmentations;
}


/***/ }),

/***/ 58859:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ getViewportIdsWithSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getViewportIdsWithSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    const viewportSegRepresentations = state.viewportSegRepresentations;
    const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations)
        .filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId))
        .map(([viewportId]) => viewportId);
    return viewportIdsWithSegmentation;
}


/***/ }),

/***/ 42568:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getViewportSegmentations)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59475);


function getViewportSegmentations(viewportId, type) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    const viewportRepresentations = state.viewportSegRepresentations[viewportId];
    const segmentations = viewportRepresentations.map((representation) => {
        if (type && representation.type === type) {
            return (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(representation.segmentationId);
        }
        return (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(representation.segmentationId);
    });
    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);
    return filteredSegmentations;
}


/***/ }),

/***/ 6994:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ computeVolumeLabelmapFromStack)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

async function computeVolumeLabelmapFromStack(args) {
    return (0,_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .internalComputeVolumeLabelmapFromStack */ .Zm)(args);
}


/***/ }),

/***/ 1300:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  activeSegmentation: () => (/* reexport */ activeSegmentation),
  addContourRepresentationToViewport: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addContourRepresentationToViewport */.At),
  addContourRepresentationToViewportMap: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addContourRepresentationToViewportMap */.cs),
  addLabelmapRepresentationToViewport: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addLabelmapRepresentationToViewport */.Wz),
  addLabelmapRepresentationToViewportMap: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addLabelmapRepresentationToViewportMap */.w9),
  addSegmentationRepresentations: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addSegmentationRepresentations */.gR),
  addSegmentations: () => (/* reexport */ addSegmentations/* addSegmentations */.d),
  addSurfaceRepresentationToViewport: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addSurfaceRepresentationToViewport */.Hr),
  addSurfaceRepresentationToViewportMap: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addSurfaceRepresentationToViewportMap */.$j),
  config: () => (/* reexport */ config_namespaceObject),
  getLabelmapImageIds: () => (/* reexport */ getLabelmapImageIds),
  helpers: () => (/* binding */ helpers),
  polySeg: () => (/* reexport */ polySeg_namespaceObject),
  removeAllSegmentationRepresentations: () => (/* reexport */ removeSegmentationRepresentations/* removeAllSegmentationRepresentations */.us),
  removeAllSegmentations: () => (/* reexport */ removeSegmentation/* removeAllSegmentations */.j),
  removeContourRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeContourRepresentation */.OE),
  removeLabelmapRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeLabelmapRepresentation */.kN),
  removeSegment: () => (/* reexport */ removeSegment),
  removeSegmentation: () => (/* reexport */ removeSegmentation/* removeSegmentation */.z),
  removeSegmentationRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSegmentationRepresentation */.E8),
  removeSegmentationRepresentations: () => (/* reexport */ removeSegmentationRepresentations/* removeSegmentationRepresentations */.nc),
  removeSurfaceRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSurfaceRepresentation */.JC),
  segmentIndex: () => (/* reexport */ segmentation_segmentIndex),
  segmentLocking: () => (/* reexport */ segmentLocking),
  state: () => (/* reexport */ segmentationState),
  triggerSegmentationEvents: () => (/* reexport */ triggerSegmentationEvents),
  updateSegmentations: () => (/* reexport */ updateSegmentations)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js
var segmentationVisibility_namespaceObject = {};
__webpack_require__.r(segmentationVisibility_namespaceObject);
__webpack_require__.d(segmentationVisibility_namespaceObject, {
  getHiddenSegmentIndices: () => (getHiddenSegmentIndices),
  getSegmentIndexVisibility: () => (getSegmentIndexVisibility),
  getSegmentationRepresentationVisibility: () => (segmentationVisibility_getSegmentationRepresentationVisibility),
  setSegmentIndexVisibility: () => (setSegmentIndexVisibility),
  setSegmentationRepresentationVisibility: () => (segmentationVisibility_setSegmentationRepresentationVisibility)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js
var styleHelpers_namespaceObject = {};
__webpack_require__.r(styleHelpers_namespaceObject);
__webpack_require__.d(styleHelpers_namespaceObject, {
  getRenderInactiveSegmentations: () => (getRenderInactiveSegmentations),
  getStyle: () => (getStyle),
  hasCustomStyle: () => (hasCustomStyle),
  resetToGlobalStyle: () => (resetToGlobalStyle),
  setRenderInactiveSegmentations: () => (setRenderInactiveSegmentations),
  setStyle: () => (setStyle)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js
var config_namespaceObject = {};
__webpack_require__.r(config_namespaceObject);
__webpack_require__.d(config_namespaceObject, {
  color: () => (segmentationColor),
  style: () => (styleHelpers_namespaceObject),
  visibility: () => (segmentationVisibility_namespaceObject)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/index.js
var polySeg_namespaceObject = {};
__webpack_require__.r(polySeg_namespaceObject);
__webpack_require__.d(polySeg_namespaceObject, {
  canComputeRequestedRepresentation: () => (canComputeRequestedRepresentation/* canComputeRequestedRepresentation */.n),
  computeAndAddContourRepresentation: () => (computeAndAddContourRepresentation/* computeAndAddContourRepresentation */.D),
  computeAndAddLabelmapRepresentation: () => (computeAndAddLabelmapRepresentation/* computeAndAddLabelmapRepresentation */.z),
  computeAndAddSurfaceRepresentation: () => (computeAndAddSurfaceRepresentation/* computeAndAddSurfaceRepresentation */.o)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js + 1 modules
var removeSegmentationRepresentations = __webpack_require__(53662);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js + 1 modules
var addSegmentationRepresentationsToViewport = __webpack_require__(38816);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js + 1 modules
var addSegmentations = __webpack_require__(30935);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js


function updateSegmentations(segmentationUpdateArray, suppressEvents) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationUpdateArray.forEach((segmentationUpdate) => {
        segmentationStateManager.updateSegmentation(segmentationUpdate.segmentationId, segmentationUpdate.payload);
        if (!suppressEvents) {
            (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentationUpdate.segmentationId);
        }
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js + 1 modules
var activeSegmentation = __webpack_require__(26228);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js
var segmentLocking = __webpack_require__(26795);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js + 2 modules
var segmentationState = __webpack_require__(98870);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js
var segmentationColor = __webpack_require__(93733);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js

function setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationStateManager.setSegmentationRepresentationVisibility(viewportId, specifier, visible);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js
var getSegmentationRepresentationVisibility = __webpack_require__(33658);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var SegmentationRenderingEngine = __webpack_require__(24917);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js





function segmentationVisibility_setSegmentationRepresentationVisibility(viewportId, specifier, visibility) {
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, specifier);
    if (!representations) {
        return;
    }
    representations.forEach((representation) => {
        setSegmentationRepresentationVisibility(viewportId, {
            segmentationId: representation.segmentationId,
            type: representation.type,
        }, visibility);
    });
}
function segmentationVisibility_getSegmentationRepresentationVisibility(viewportId, specifier) {
    return (0,getSegmentationRepresentationVisibility/* getSegmentationRepresentationVisibility */.I)(viewportId, specifier);
}
function setSegmentIndexVisibility(viewportId, specifier, segmentIndex, visibility) {
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, specifier);
    if (!representations) {
        return;
    }
    representations.forEach((representation) => {
        representation.segments[segmentIndex].visible = visibility;
    });
    (0,SegmentationRenderingEngine/* triggerSegmentationRenderBySegmentationId */.fy)(specifier.segmentationId);
    (0,triggerSegmentationEvents.triggerSegmentationRepresentationModified)(viewportId, specifier.segmentationId);
}
function getSegmentIndexVisibility(viewportId, specifier, segmentIndex) {
    const hiddenSegments = getHiddenSegmentIndices(viewportId, specifier);
    return !hiddenSegments.has(segmentIndex);
}
function getHiddenSegmentIndices(viewportId, specifier) {
    const representation = (0,getSegmentationRepresentation/* getSegmentationRepresentation */.Ut)(viewportId, specifier);
    if (!representation) {
        return new Set();
    }
    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {
        if (!segment.visible) {
            acc.add(Number(segmentIndex));
        }
        return acc;
    }, new Set());
    return segmentsHidden;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js
var getSegmentations = __webpack_require__(70758);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js
var getViewportSegmentations = __webpack_require__(42568);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js
var SegmentationStyle = __webpack_require__(92686);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js





function getStyle(specifier) {
    return SegmentationStyle/* segmentationStyle */.Y.getStyle(specifier);
}
function setStyle(specifier, style) {
    SegmentationStyle/* segmentationStyle */.Y.setStyle(specifier, style);
    if (!specifier.viewportId && !specifier.segmentationId) {
        const segmentations = (0,getSegmentations/* getSegmentations */.K)();
        segmentations.forEach((segmentation) => {
            (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)(segmentation.segmentationId);
        });
    }
    (0,triggerSegmentationEvents.triggerSegmentationRepresentationModified)(specifier.viewportId, specifier.segmentationId, specifier.type);
}
function setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
    SegmentationStyle/* segmentationStyle */.Y.setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations);
    (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)(viewportId);
    const segmentations = (0,getViewportSegmentations/* getViewportSegmentations */.a)(viewportId);
    segmentations.forEach((segmentation) => {
        (0,triggerSegmentationEvents.triggerSegmentationRepresentationModified)(viewportId, segmentation.segmentationId);
    });
}
function getRenderInactiveSegmentations(viewportId) {
    return SegmentationStyle/* segmentationStyle */.Y.getRenderInactiveSegmentations(viewportId);
}
function resetToGlobalStyle() {
    SegmentationStyle/* segmentationStyle */.Y.resetToGlobalStyle();
    (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)();
}
function hasCustomStyle(specifier) {
    return SegmentationStyle/* segmentationStyle */.Y.hasCustomStyle(specifier);
}


;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js





// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js
var segmentation_segmentIndex = __webpack_require__(70930);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/convertStackToVolumeLabelmap.js
var convertStackToVolumeLabelmap = __webpack_require__(6273);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js
var computeVolumeLabelmapFromStack = __webpack_require__(6994);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation.js + 1 modules
var computeAndAddSurfaceRepresentation = __webpack_require__(58062);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Labelmap/computeAndAddLabelmapRepresentation.js
var computeAndAddLabelmapRepresentation = __webpack_require__(79462);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Contour/computeAndAddContourRepresentation.js
var computeAndAddContourRepresentation = __webpack_require__(13654);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/canComputeRequestedRepresentation.js
var canComputeRequestedRepresentation = __webpack_require__(69073);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/index.js






// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js



function clearSegmentValue(segmentationId, segmentIndex) {
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    if (segmentation.representationData.Labelmap) {
        const { representationData } = segmentation;
        const labelmapData = representationData.Labelmap;
        if ('imageIds' in labelmapData || 'volumeId' in labelmapData) {
            const items = 'imageIds' in labelmapData
                ? labelmapData.imageIds.map((imageId) => esm.cache.getImage(imageId))
                : [esm.cache.getVolume(labelmapData.volumeId)];
            items.forEach((item) => {
                if (!item) {
                    return;
                }
                const { voxelManager } = item;
                voxelManager.forEach(({ value, index }) => {
                    if (value === segmentIndex) {
                        voxelManager.setAtIndex(index, 0);
                    }
                });
            });
        }
        (0,triggerSegmentationEvents.triggerSegmentationDataModified)(segmentationId);
    }
    else {
        throw new Error('Invalid segmentation type, only labelmap is supported right now');
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js + 1 modules
var computeStackLabelmapFromVolume = __webpack_require__(21);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js
var getActiveSegmentIndex = __webpack_require__(60740);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var getViewportIdsWithSegmentation = __webpack_require__(58859);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js







function removeSegment(segmentationId, segmentIndex, options = {
    setNextSegmentAsActive: true,
}) {
    clearSegmentValue(segmentationId, segmentIndex);
    const isThisSegmentActive = (0,getActiveSegmentIndex/* getActiveSegmentIndex */.Q)(segmentationId) === segmentIndex;
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    const { segments } = segmentation;
    delete segments[segmentIndex];
    const updatedSegments = {
        ...segments,
    };
    updateSegmentations([
        {
            segmentationId,
            payload: {
                segments: updatedSegments,
            },
        },
    ]);
    if (isThisSegmentActive && options.setNextSegmentAsActive) {
        const segmentIndices = Object.keys(segments)
            .map(Number)
            .sort((a, b) => a - b);
        const currentIndex = segmentIndices.indexOf(segmentIndex);
        const nextSegmentIndex = segmentIndices[currentIndex + 1];
        const previousSegmentIndex = segmentIndices[currentIndex - 1];
        if (nextSegmentIndex !== undefined) {
            (0,segmentation_segmentIndex.setActiveSegmentIndex)(segmentationId, nextSegmentIndex);
        }
        else if (previousSegmentIndex !== undefined) {
            (0,segmentation_segmentIndex.setActiveSegmentIndex)(segmentationId, previousSegmentIndex);
        }
    }
    const viewportIds = (0,getViewportIdsWithSegmentation/* getViewportIdsWithSegmentation */.P)(segmentationId);
    viewportIds.forEach((viewportId) => {
        const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, {
            segmentationId,
        });
        representations.forEach((representation) => {
            delete representation.segments[segmentIndex];
        });
    });
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js


function getLabelmapImageIds(segmentationId) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    return segmentationStateManager.getLabelmapImageIds(segmentation.representationData);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js
var removeSegmentation = __webpack_require__(63427);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js


















const helpers = {
    clearSegmentValue: clearSegmentValue,
    convertStackToVolumeLabelmap: convertStackToVolumeLabelmap/* convertStackToVolumeLabelmap */.p,
    computeVolumeLabelmapFromStack: computeVolumeLabelmapFromStack/* computeVolumeLabelmapFromStack */.a,
    convertVolumeToStackLabelmap: computeStackLabelmapFromVolume/* convertVolumeToStackLabelmap */.f,
};



/***/ }),

/***/ 13654:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ computeAndAddContourRepresentation)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56005);
/* harmony import */ var _contourComputationStrategies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75499);



function computeAndAddContourRepresentation(segmentationId, options = {}) {
    return (0,_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_1__/* .computeAndAddRepresentation */ .d)(segmentationId, _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour, () => (0,_contourComputationStrategies__WEBPACK_IMPORTED_MODULE_2__/* .computeContourData */ .c)(segmentationId, options), () => undefined);
}


/***/ }),

/***/ 79462:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ computeAndAddLabelmapRepresentation)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56005);
/* harmony import */ var _labelmapComputationStrategies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89661);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59475);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49906);





async function computeAndAddLabelmapRepresentation(segmentationId, options = {}) {
    return (0,_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_1__/* .computeAndAddRepresentation */ .d)(segmentationId, _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap, () => (0,_labelmapComputationStrategies__WEBPACK_IMPORTED_MODULE_2__/* .computeLabelmapData */ .Y)(segmentationId, options), () => null, () => {
        _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_3__/* .defaultSegmentationStateManager */ ._6.processLabelmapRepresentationAddition(options.viewport.id, segmentationId);
        setTimeout(() => {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationDataModified)(segmentationId);
        }, 0);
    });
}


/***/ }),

/***/ 58062:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  o: () => (/* binding */ computeAndAddSurfaceRepresentation)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/computeAndAddRepresentation.js
var computeAndAddRepresentation = __webpack_require__(56005);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/surfaceComputationStrategies.js + 2 modules
var surfaceComputationStrategies = __webpack_require__(42867);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js
var getUniqueSegmentIndices = __webpack_require__(25758);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var getViewportIdsWithSegmentation = __webpack_require__(58859);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/createAndCacheSurfacesFromRaw.js
var createAndCacheSurfacesFromRaw = __webpack_require__(85884);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/updateSurfaceData.js









async function updateSurfaceData(segmentationId) {
    const surfacesObj = await (0,surfaceComputationStrategies/* computeSurfaceFromLabelmapSegmentation */.HE)(segmentationId);
    if (!surfacesObj) {
        return;
    }
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    const indices = (0,getUniqueSegmentIndices/* getUniqueSegmentIndices */.O)(segmentationId);
    if (!indices.length) {
        const geometryIds = segmentation.representationData.Surface.geometryIds;
        geometryIds.forEach((geometryId) => {
            const geometry = esm.cache.getGeometry(geometryId);
            const surface = geometry.data;
            surface.points = [];
            surface.polys = [];
        });
        (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentationId);
        return;
    }
    const promises = surfacesObj.map(({ data, segmentIndex }) => {
        const geometryId = `segmentation_${segmentationId}_surface_${segmentIndex}`;
        const geometry = esm.cache.getGeometry(geometryId);
        if (!geometry) {
            const viewportIds = (0,getViewportIdsWithSegmentation/* getViewportIdsWithSegmentation */.P)(segmentationId);
            return viewportIds.map((viewportId) => {
                const surfaceRepresentation = (0,getSegmentationRepresentation/* getSegmentationRepresentation */.Ut)(viewportId, {
                    segmentationId,
                    type: enums.SegmentationRepresentations.Surface,
                });
                return [surfaceRepresentation].map((surfaceRepresentation) => {
                    segmentation.representationData.Surface.geometryIds.set(segmentIndex, geometryId);
                    return (0,createAndCacheSurfacesFromRaw/* createAndCacheSurfacesFromRaw */.Y)(segmentationId, [{ segmentIndex, data }], {
                        segmentationId: surfaceRepresentation.segmentationId,
                    });
                });
            });
        }
        else if (indices.includes(segmentIndex)) {
            const surface = geometry.data;
            surface.points = data.points;
            surface.polys = data.polys;
        }
        else {
            const surface = geometry.data;
            surface.points = [];
            surface.polys = [];
        }
    });
    await Promise.all(promises);
    (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentationId);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation.js




function computeAndAddSurfaceRepresentation(segmentationId, options = {}) {
    return (0,computeAndAddRepresentation/* computeAndAddRepresentation */.d)(segmentationId, enums.SegmentationRepresentations.Surface, () => (0,surfaceComputationStrategies/* computeSurfaceData */.HN)(segmentationId, options), () => updateSurfaceData(segmentationId));
}


/***/ }),

/***/ 85884:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ createAndCacheSurfacesFromRaw)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _config_segmentationColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93733);
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33283);



async function createAndCacheSurfacesFromRaw(segmentationId, rawSurfacesData, options = {}) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentation */ .T)(segmentationId);
    const geometryIds = new Map();
    const promises = Object.keys(rawSurfacesData).map(async (index) => {
        const rawSurfaceData = rawSurfacesData[index];
        const segmentIndex = rawSurfaceData.segmentIndex;
        const color = (0,_config_segmentationColor__WEBPACK_IMPORTED_MODULE_1__.getSegmentIndexColor)(options.viewport.id, segmentation.segmentationId, segmentIndex).slice(0, 3);
        if (!color) {
            throw new Error('No color found for segment index, unable to create surface');
        }
        const closedSurface = {
            id: `segmentation_${segmentation.segmentationId}_surface_${segmentIndex}`,
            color,
            frameOfReferenceUID: 'test-frameOfReferenceUID',
            points: rawSurfaceData.data.points,
            polys: rawSurfaceData.data.polys,
            segmentIndex,
        };
        const geometryId = closedSurface.id;
        geometryIds.set(segmentIndex, geometryId);
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.geometryLoader.createAndCacheGeometry(geometryId, {
            type: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.GeometryType.SURFACE,
            geometryData: closedSurface,
        });
    });
    await Promise.all(promises);
    return {
        geometryIds,
    };
}


/***/ }),

/***/ 42867:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  HN: () => (/* binding */ computeSurfaceData),
  HE: () => (/* binding */ computeSurfaceFromLabelmapSegmentation)
});

// UNUSED EXPORTS: computeSurfaceFromContourSegmentation

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js
var getUniqueSegmentIndices = __webpack_require__(25758);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState = __webpack_require__(82056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/convertContourToSurface.js



const workerManager = (0,esm.getWebWorkerManager)();
const triggerWorkerProgress = (eventTarget, progress, id) => {
    (0,esm.triggerEvent)(eventTarget, esm.Enums.Events.WEB_WORKER_PROGRESS, {
        progress,
        type: enums.WorkerTypes.POLYSEG_CONTOUR_TO_SURFACE,
        id,
    });
};
async function convertContourToSurface(contourRepresentationData, segmentIndex) {
    const { annotationUIDsMap } = contourRepresentationData;
    const polylines = [];
    const numPointsArray = [];
    const annotationUIDs = annotationUIDsMap.get(segmentIndex);
    for (const annotationUID of annotationUIDs) {
        const annotation = (0,annotationState.getAnnotation)(annotationUID);
        const { polyline } = annotation.data
            .contour;
        numPointsArray.push(polyline.length);
        polyline.forEach((polyline) => polylines.push(...polyline));
    }
    triggerWorkerProgress(esm.eventTarget, 0, segmentIndex);
    const results = await workerManager.executeTask('polySeg', 'convertContourToSurface', {
        polylines,
        numPointsArray,
    }, {
        callbacks: [
            (progress) => {
                triggerWorkerProgress(esm.eventTarget, progress, segmentIndex);
            },
        ],
    });
    triggerWorkerProgress(esm.eventTarget, 100, segmentIndex);
    return results;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/createAndCacheSurfacesFromRaw.js
var createAndCacheSurfacesFromRaw = __webpack_require__(85884);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js
var computeVolumeLabelmapFromStack = __webpack_require__(6994);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/convertLabelmapToSurface.js



const convertLabelmapToSurface_workerManager = (0,esm.getWebWorkerManager)();
const convertLabelmapToSurface_triggerWorkerProgress = (eventTarget, progress, id) => {
    (0,esm.triggerEvent)(eventTarget, esm.Enums.Events.WEB_WORKER_PROGRESS, {
        progress,
        type: enums.WorkerTypes.POLYSEG_LABELMAP_TO_SURFACE,
        id,
    });
};
async function convertLabelmapToSurface(labelmapRepresentationData, segmentIndex) {
    let volumeId;
    if (labelmapRepresentationData.volumeId) {
        volumeId = labelmapRepresentationData
            .volumeId;
    }
    else {
        const { imageIds } = labelmapRepresentationData;
        ({ volumeId } = await (0,computeVolumeLabelmapFromStack/* computeVolumeLabelmapFromStack */.a)({
            imageIds,
        }));
    }
    const volume = esm.cache.getVolume(volumeId);
    const scalarData = volume.voxelManager.getCompleteScalarDataArray();
    const { dimensions, spacing, origin, direction } = volume;
    convertLabelmapToSurface_triggerWorkerProgress(esm.eventTarget, 0, segmentIndex);
    const results = await convertLabelmapToSurface_workerManager.executeTask('polySeg', 'convertLabelmapToSurface', {
        scalarData,
        dimensions,
        spacing,
        origin,
        direction,
        segmentIndex,
    }, {
        callbacks: [
            (progress) => {
                convertLabelmapToSurface_triggerWorkerProgress(esm.eventTarget, progress, segmentIndex);
            },
        ],
    });
    convertLabelmapToSurface_triggerWorkerProgress(esm.eventTarget, 100, segmentIndex);
    return results;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/surfaceComputationStrategies.js





async function computeSurfaceData(segmentationId, options = {}) {
    const segmentIndices = options.segmentIndices?.length
        ? options.segmentIndices
        : (0,getUniqueSegmentIndices/* getUniqueSegmentIndices */.O)(segmentationId);
    let rawSurfacesData;
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    const representationData = segmentation.representationData;
    try {
        if (representationData.Contour) {
            rawSurfacesData = await computeSurfaceFromContourSegmentation(segmentationId, {
                segmentIndices,
                ...options,
            });
        }
        else if (representationData.Labelmap) {
            rawSurfacesData = await computeSurfaceFromLabelmapSegmentation(segmentation.segmentationId, {
                segmentIndices,
                ...options,
            });
        }
    }
    catch (error) {
        console.error(error);
        throw error;
    }
    if (!rawSurfacesData) {
        throw new Error('Not enough data to convert to surface, currently only support converting volume labelmap to surface if available');
    }
    const surfacesData = await (0,createAndCacheSurfacesFromRaw/* createAndCacheSurfacesFromRaw */.Y)(segmentationId, rawSurfacesData, options);
    return surfacesData;
}
async function computeSurfaceFromLabelmapSegmentation(segmentationId, options = {}) {
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    if (!segmentation?.representationData?.Labelmap) {
        console.warn('Only support surface update from labelmaps');
        return;
    }
    const labelmapRepresentationData = segmentation.representationData.Labelmap;
    const segmentIndices = options.segmentIndices || (0,getUniqueSegmentIndices/* getUniqueSegmentIndices */.O)(segmentationId);
    const promises = segmentIndices.map((index) => {
        const surface = convertLabelmapToSurface(labelmapRepresentationData, index);
        return surface;
    });
    const surfaces = await Promise.allSettled(promises);
    const errors = surfaces.filter((p) => p.status === 'rejected');
    if (errors.length > 0) {
        console.error(errors);
        throw new Error('Failed to convert labelmap to surface');
    }
    const rawSurfacesData = surfaces
        .map((surface, index) => {
        if (surface.status === 'fulfilled') {
            return { segmentIndex: segmentIndices[index], data: surface.value };
        }
    })
        .filter(Boolean);
    return rawSurfacesData;
}
async function computeSurfaceFromContourSegmentation(segmentationId, options = {}) {
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    const contourRepresentationData = segmentation.representationData.Contour;
    const segmentIndices = options.segmentIndices || (0,getUniqueSegmentIndices/* getUniqueSegmentIndices */.O)(segmentationId);
    const promises = segmentIndices.map(async (index) => {
        const surface = await convertContourToSurface(contourRepresentationData, index);
        return { segmentIndex: index, data: surface };
    });
    const surfaces = await Promise.all(promises);
    return surfaces;
}



/***/ }),

/***/ 69073:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ canComputeRequestedRepresentation)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33283);
/* harmony import */ var _tools_displayTools_Labelmap_validateLabelmap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6934);



const conversionPaths = new Map([
    [
        _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap,
        new Set([
            _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Surface,
            _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour,
        ]),
    ],
    [
        _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour,
        new Set([
            _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap,
            _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Surface,
        ]),
    ],
    [
        _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Surface,
        new Set([_enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap]),
    ],
]);
function canComputeRequestedRepresentation(segmentationId, type) {
    const { representationData } = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_1__/* .getSegmentation */ .T)(segmentationId);
    const existingRepresentationTypes = getExistingRepresentationTypes(representationData);
    return existingRepresentationTypes.some((existingRepresentationType) => canConvertFromTo(existingRepresentationType, type));
}
function getExistingRepresentationTypes(representationData) {
    const supportedTypes = [];
    Object.keys(representationData).forEach((representationType) => {
        const representationTypeData = representationData[representationType];
        let validateFn;
        switch (representationType) {
            case _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap:
                validateFn = _tools_displayTools_Labelmap_validateLabelmap__WEBPACK_IMPORTED_MODULE_2__/* .validate */ .t;
                break;
        }
        if (validateFn) {
            try {
                validateFn(representationTypeData);
                supportedTypes.push(representationType);
            }
            catch (error) {
                console.warn(`Validation failed for labelmap of type ${representationType}`);
            }
        }
        else {
            supportedTypes.push(representationType);
        }
    });
    return supportedTypes;
}
async function canConvertFromTo(fromRepresentationType, toRepresentationType) {
    return (conversionPaths.get(fromRepresentationType)?.has(toRepresentationType) ||
        false);
}



/***/ }),

/***/ 56005:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ computeAndAddRepresentation)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _internalAddRepresentationData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44188);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49906);
/* harmony import */ var _utilities_debounce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52905);
/* harmony import */ var _registerPolySegWorker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(31199);






const computedRepresentations = new Map();
async function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {
    (0,_registerPolySegWorker__WEBPACK_IMPORTED_MODULE_5__/* .registerPolySegWorker */ .b)();
    const data = await computeFunction();
    (0,_internalAddRepresentationData__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)({
        segmentationId,
        type,
        data,
    });
    onComputationComplete?.();
    if (!computedRepresentations.has(segmentationId)) {
        computedRepresentations.set(segmentationId, []);
    }
    const representations = computedRepresentations.get(segmentationId);
    if (!representations.includes(type)) {
        representations.push(type);
    }
    subscribeToSegmentationChanges(updateFunction);
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationModified)(segmentationId);
    return data;
}
function subscribeToSegmentationChanges(updateFunction) {
    const debouncedUpdateFunction = (event) => {
        _debouncedSegmentationModified(event, updateFunction);
    };
    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);
}
const _debouncedSegmentationModified = (0,_utilities_debounce__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)((event, updateFunction) => {
    const segmentationId = event.detail.segmentationId;
    const representations = computedRepresentations.get(segmentationId);
    if (!representations || !representations.length) {
        return;
    }
    updateFunction(segmentationId);
    if (representations.length) {
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationModified)(segmentationId);
    }
}, 300);



/***/ }),

/***/ 63427:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ removeAllSegmentations),
/* harmony export */   z: () => (/* binding */ removeSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);
/* harmony import */ var _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53662);



function removeSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const viewportsWithSegmentation = segmentationStateManager
        .getAllViewportSegmentationRepresentations()
        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))
        .map(({ viewportId }) => viewportId);
    viewportsWithSegmentation.forEach((viewportId) => {
        (0,_removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* .removeSegmentationRepresentations */ .nc)(viewportId, { segmentationId });
    });
    segmentationStateManager.removeSegmentation(segmentationId);
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationRemoved)(segmentationId);
}
function removeAllSegmentations() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const segmentations = segmentationStateManager.getState().segmentations;
    segmentations.forEach((segmentation) => {
        removeSegmentation(segmentation.segmentationId);
    });
    segmentationStateManager.resetState();
}


/***/ }),

/***/ 53662:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  us: () => (/* binding */ removeAllSegmentationRepresentations),
  OE: () => (/* binding */ removeContourRepresentation),
  kN: () => (/* binding */ removeLabelmapRepresentation),
  E8: () => (/* binding */ removeSegmentationRepresentation),
  nc: () => (/* binding */ removeSegmentationRepresentations),
  JC: () => (/* binding */ removeSurfaceRepresentation)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js
var labelmapDisplay = __webpack_require__(684);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js
var contourDisplay = __webpack_require__(25894);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js
var surfaceDisplay = __webpack_require__(67014);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/index.js



;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js







function removeSegmentationRepresentation(viewportId, specifier, immediate) {
    return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function removeSegmentationRepresentations(viewportId, specifier, immediate) {
    return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function _removeSegmentationRepresentations(viewportId, specifier, immediate) {
    const { segmentationId, type } = specifier;
    _removeRepresentationObject(viewportId, segmentationId, type, immediate);
    return SegmentationStateManager/* defaultSegmentationStateManager */._6.removeSegmentationRepresentations(viewportId, {
        segmentationId,
        type,
    });
}
function removeAllSegmentationRepresentations() {
    const state = SegmentationStateManager/* defaultSegmentationStateManager */._6.getAllViewportSegmentationRepresentations();
    state.forEach(({ viewportId, representations }) => {
        representations.forEach(({ segmentationId, type }) => {
            removeSegmentationRepresentation(viewportId, {
                segmentationId,
                type,
            });
        });
    });
    SegmentationStateManager/* defaultSegmentationStateManager */._6.resetState();
}
function removeLabelmapRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Labelmap,
    }, immediate);
}
function removeContourRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Contour,
    }, immediate);
}
function removeSurfaceRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Surface,
    }, immediate);
}
function _removeRepresentationObject(viewportId, segmentationId, type, immediate) {
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, {
        segmentationId,
        type,
    });
    representations.forEach((representation) => {
        if (representation.type === SegmentationRepresentations/* default */.A.Labelmap) {
            labelmapDisplay/* default.removeRepresentation */.Ay.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
        else if (representation.type === SegmentationRepresentations/* default */.A.Contour) {
            contourDisplay/* default */.A.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
        else if (representation.type === SegmentationRepresentations/* default */.A.Surface) {
            surfaceDisplay/* default */.Ay.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
    });
    const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId) || {};
    if (viewport) {
        viewport.render();
    }
}



/***/ }),

/***/ 70930:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActiveSegmentIndex: () => (/* reexport safe */ _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_5__.Q),
/* harmony export */   setActiveSegmentIndex: () => (/* binding */ setActiveSegmentIndex)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7754);
/* harmony import */ var _utilities_segmentation_invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35706);
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33283);
/* harmony import */ var _getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58859);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49906);
/* harmony import */ var _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60740);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93210);







function setActiveSegmentIndex(segmentationId, segmentIndex) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentation */ .T)(segmentationId);
    if (typeof segmentIndex === 'string') {
        console.warn('segmentIndex is a string, converting to number');
        segmentIndex = Number(segmentIndex);
    }
    Object.values(segmentation.segments).forEach((segment) => {
        segment.active = false;
    });
    if (!segmentation.segments[segmentIndex]) {
        segmentation.segments[segmentIndex] = {
            segmentIndex,
            label: '',
            locked: false,
            cachedStats: {},
            active: false,
        };
    }
    if (segmentation.segments[segmentIndex].active !== true) {
        segmentation.segments[segmentIndex].active = true;
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationModified)(segmentationId);
    }
    const viewportIds = (0,_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getViewportIdsWithSegmentation */ .P)(segmentationId);
    viewportIds.forEach((viewportId) => {
        const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_6__/* .getSegmentationRepresentations */ .r$)(viewportId, {
            segmentationId,
        });
        representations.forEach((representation) => {
            if (!representation.segments[segmentIndex]) {
                representation.segments[segmentIndex] = {
                    visible: true,
                };
            }
        });
    });
    viewportIds.forEach((viewportId) => {
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroupForViewport)(viewportId);
        (0,_utilities_segmentation_invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_1__/* .invalidateBrushCursor */ .E)(toolGroup.id);
    });
}



/***/ }),

/***/ 26795:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLockedSegmentIndices: () => (/* binding */ getLockedSegmentIndices),
/* harmony export */   isSegmentIndexLocked: () => (/* binding */ isSegmentIndexLocked),
/* harmony export */   setSegmentIndexLocked: () => (/* binding */ setSegmentIndexLocked)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);


function isSegmentIndexLocked(segmentationId, segmentIndex) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    return segments[segmentIndex].locked;
}
function setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    segments[segmentIndex].locked = locked;
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationModified)(segmentationId);
}
function getLockedSegmentIndices(segmentationId) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);
    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));
}



/***/ }),

/***/ 98870:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  addColorLUT: () => (/* reexport */ addColorLUT/* addColorLUT */.u),
  addSegmentations: () => (/* reexport */ addSegmentations/* addSegmentations */.d),
  destroy: () => (/* binding */ destroy),
  getColorLUT: () => (/* reexport */ getColorLUT/* getColorLUT */.B),
  getCurrentLabelmapImageIdForViewport: () => (/* reexport */ getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdForViewport */.v),
  getNextColorLUTIndex: () => (/* reexport */ getNextColorLUTIndex/* getNextColorLUTIndex */.u),
  getSegmentation: () => (/* reexport */ getSegmentation/* getSegmentation */.T),
  getSegmentationRepresentation: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentation */.Ut),
  getSegmentationRepresentations: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentations */.r$),
  getSegmentationRepresentationsBySegmentationId: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentationsBySegmentationId */.ny),
  getSegmentations: () => (/* reexport */ getSegmentations/* getSegmentations */.K),
  getStackSegmentationImageIdsForViewport: () => (/* reexport */ getStackSegmentationImageIdsForViewport),
  getViewportIdsWithSegmentation: () => (/* reexport */ getViewportIdsWithSegmentation/* getViewportIdsWithSegmentation */.P),
  getViewportSegmentations: () => (/* reexport */ getViewportSegmentations/* getViewportSegmentations */.a),
  removeAllSegmentationRepresentations: () => (/* reexport */ removeSegmentationRepresentations/* removeAllSegmentationRepresentations */.us),
  removeAllSegmentations: () => (/* reexport */ removeSegmentation/* removeAllSegmentations */.j),
  removeColorLUT: () => (/* reexport */ removeColorLUT),
  removeContourRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeContourRepresentation */.OE),
  removeLabelmapRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeLabelmapRepresentation */.kN),
  removeSegmentation: () => (/* reexport */ removeSegmentation/* removeSegmentation */.z),
  removeSegmentationRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSegmentationRepresentation */.E8),
  removeSurfaceRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSurfaceRepresentation */.JC),
  updateLabelmapSegmentationImageReferences: () => (/* reexport */ updateLabelmapSegmentationImageReferences/* updateLabelmapSegmentationImageReferences */.t)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js
var getSegmentations = __webpack_require__(70758);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js + 1 modules
var addSegmentations = __webpack_require__(30935);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js
var removeSegmentation = __webpack_require__(63427);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js + 1 modules
var removeSegmentationRepresentations = __webpack_require__(53662);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js
var addColorLUT = __webpack_require__(4714);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js
var getColorLUT = __webpack_require__(50409);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js
var getNextColorLUTIndex = __webpack_require__(70906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js

function removeColorLUT(colorLUTIndex) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationStateManager.removeColorLUT(colorLUTIndex);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js
var getViewportSegmentations = __webpack_require__(42568);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var getViewportIdsWithSegmentation = __webpack_require__(58859);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
var getCurrentLabelmapImageIdForViewport = __webpack_require__(97577);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js
var updateLabelmapSegmentationImageReferences = __webpack_require__(78231);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js

function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js
















function destroy() {
    SegmentationStateManager/* defaultSegmentationStateManager */._6.resetState();
}



/***/ }),

/***/ 49906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationDataModified: () => (/* reexport safe */ _events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_0__.Q),
/* harmony export */   triggerSegmentationModified: () => (/* reexport safe */ _events_triggerSegmentationModified__WEBPACK_IMPORTED_MODULE_1__.G),
/* harmony export */   triggerSegmentationRemoved: () => (/* reexport safe */ _events_triggerSegmentationRemoved__WEBPACK_IMPORTED_MODULE_2__.B),
/* harmony export */   triggerSegmentationRepresentationModified: () => (/* reexport safe */ _events_triggerSegmentationRepresentationModified__WEBPACK_IMPORTED_MODULE_3__.r),
/* harmony export */   triggerSegmentationRepresentationRemoved: () => (/* reexport safe */ _events_triggerSegmentationRepresentationRemoved__WEBPACK_IMPORTED_MODULE_4__.O)
/* harmony export */ });
/* harmony import */ var _events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98798);
/* harmony import */ var _events_triggerSegmentationModified__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9726);
/* harmony import */ var _events_triggerSegmentationRemoved__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1485);
/* harmony import */ var _events_triggerSegmentationRepresentationModified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44951);
/* harmony import */ var _events_triggerSegmentationRepresentationRemoved__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65290);








/***/ }),

/***/ 78231:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ updateLabelmapSegmentationImageReferences)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);
}


/***/ }),

/***/ 65136:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85204);


function getToolGroupForViewport(viewportId, renderingEngineId) {
    if (!renderingEngineId) {
        renderingEngineId = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngines)().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;
    }
    const toolGroupFilteredByIds = _state__WEBPACK_IMPORTED_MODULE_1__/* .state */ .wk.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&
        (!vp.viewportId || vp.viewportId === viewportId)));
    if (!toolGroupFilteredByIds.length) {
        return;
    }
    if (toolGroupFilteredByIds.length > 1) {
        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only
      have one tool group per viewport in a renderingEngine.`);
    }
    return toolGroupFilteredByIds[0];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getToolGroupForViewport);


/***/ }),

/***/ 7754:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  createToolGroup: () => (/* reexport */ ToolGroupManager_createToolGroup),
  destroy: () => (/* reexport */ ToolGroupManager_destroy),
  destroyToolGroup: () => (/* reexport */ ToolGroupManager_destroyToolGroup),
  getAllToolGroups: () => (/* reexport */ ToolGroupManager_getAllToolGroups),
  getToolGroup: () => (/* reexport */ ToolGroupManager_getToolGroup),
  getToolGroupForViewport: () => (/* reexport */ getToolGroupForViewport/* default */.A),
  getToolGroupsWithToolName: () => (/* reexport */ ToolGroupManager_getToolGroupsWithToolName)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js
var state = __webpack_require__(85204);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/lodash.get/index.js
var lodash_get = __webpack_require__(93008);
var lodash_get_default = /*#__PURE__*/__webpack_require__.n(lodash_get);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js + 4 modules
var cursors = __webpack_require__(79475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor = __webpack_require__(7001);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js

function getToolGroup(toolGroupId) {
    return state/* state */.wk.toolGroups.find((s) => s.id === toolGroupId);
}
/* harmony default export */ const ToolGroupManager_getToolGroup = (getToolGroup);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js








const { Active, Passive, Enabled, Disabled } = enums.ToolModes;
const PRIMARY_BINDINGS = [{ mouseButton: enums.MouseBindings.Primary }];
class ToolGroup {
    constructor(id) {
        this.viewportsInfo = [];
        this.toolOptions = {};
        this.currentActivePrimaryToolName = null;
        this.prevActivePrimaryToolName = null;
        this.restoreToolOptions = {};
        this._toolInstances = {};
        this.id = id;
    }
    getViewportIds() {
        return this.viewportsInfo.map(({ viewportId }) => viewportId);
    }
    getViewportsInfo() {
        return this.viewportsInfo.slice();
    }
    getToolInstance(toolInstanceName) {
        const toolInstance = this._toolInstances[toolInstanceName];
        if (!toolInstance) {
            console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);
            return;
        }
        return toolInstance;
    }
    getToolInstances() {
        return this._toolInstances;
    }
    hasTool(toolName) {
        return !!this._toolInstances[toolName];
    }
    addTool(toolName, configuration = {}) {
        const toolDefinition = state/* state */.wk.tools[toolName];
        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';
        const localToolInstance = this.toolOptions[toolName];
        if (!hasToolName) {
            console.warn('Tool with configuration did not produce a toolName: ', configuration);
            return;
        }
        if (!toolDefinition) {
            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);
            return;
        }
        if (localToolInstance) {
            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);
            return;
        }
        const { toolClass: ToolClass } = toolDefinition;
        const toolProps = {
            name: toolName,
            toolGroupId: this.id,
            configuration,
        };
        const instantiatedTool = new ToolClass(toolProps);
        this._toolInstances[toolName] = instantiatedTool;
    }
    addToolInstance(toolName, parentClassName, configuration = {}) {
        let ToolClassToUse = state/* state */.wk.tools[toolName]
            ?.toolClass;
        if (!ToolClassToUse) {
            const ParentClass = state/* state */.wk.tools[parentClassName]
                .toolClass;
            class ToolInstance extends ParentClass {
            }
            ToolInstance.toolName = toolName;
            ToolClassToUse = ToolInstance;
            state/* state */.wk.tools[toolName] = {
                toolClass: ToolInstance,
            };
        }
        this.addTool(ToolClassToUse.toolName, configuration);
    }
    addViewport(viewportId, renderingEngineId) {
        if (typeof viewportId !== 'string') {
            throw new Error('viewportId must be defined and be a string');
        }
        const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);
        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {
            this.viewportsInfo.push({
                viewportId,
                renderingEngineId: renderingEngineUIDToUse,
            });
        }
        const toolName = this.getActivePrimaryMouseButtonTool();
        const runtimeSettings = esm.Settings.getRuntimeSettings();
        if (runtimeSettings.get('useCursors')) {
            this.setViewportsCursorByToolName(toolName);
        }
        const eventDetail = {
            toolGroupId: this.id,
            viewportId,
            renderingEngineId: renderingEngineUIDToUse,
        };
        (0,esm.triggerEvent)(esm.eventTarget, enums.Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);
    }
    removeViewports(renderingEngineId, viewportId) {
        const indices = [];
        this.viewportsInfo.forEach((vpInfo, index) => {
            let match = false;
            if (vpInfo.renderingEngineId === renderingEngineId) {
                match = true;
                if (viewportId && vpInfo.viewportId !== viewportId) {
                    match = false;
                }
            }
            if (match) {
                indices.push(index);
            }
        });
        if (indices.length) {
            for (let i = indices.length - 1; i >= 0; i--) {
                this.viewportsInfo.splice(indices[i], 1);
            }
        }
        const eventDetail = {
            toolGroupId: this.id,
            viewportId,
            renderingEngineId,
        };
        (0,esm.triggerEvent)(esm.eventTarget, enums.Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);
    }
    setActiveStrategy(toolName, strategyName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);
            return;
        }
        toolInstance.setActiveStrategy(strategyName);
    }
    setToolMode(toolName, mode, options = {}) {
        if (!toolName) {
            console.warn('setToolMode: toolName must be defined');
            return;
        }
        if (mode === enums.ToolModes.Active) {
            this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);
            return;
        }
        if (mode === enums.ToolModes.Passive) {
            this.setToolPassive(toolName);
            return;
        }
        if (mode === enums.ToolModes.Enabled) {
            this.setToolEnabled(toolName);
            return;
        }
        if (mode === enums.ToolModes.Disabled) {
            this.setToolDisabled(toolName);
            return;
        }
        console.warn('setToolMode: mode must be defined');
    }
    setToolActive(toolName, toolBindingsOptions = {}) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        if (!toolInstance) {
            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);
            return;
        }
        const prevBindings = this.toolOptions[toolName]
            ? this.toolOptions[toolName].bindings
            : [];
        const newBindings = toolBindingsOptions.bindings
            ? toolBindingsOptions.bindings
            : [];
        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {
            const TouchBinding = binding.numTouchPoints !== undefined;
            const MouseBinding = binding.mouseButton !== undefined;
            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&
                (TouchBinding || MouseBinding)) {
                unique.push(binding);
            }
            return unique;
        }, []);
        const toolOptions = {
            bindings: bindingsToUse,
            mode: Active,
        };
        this.toolOptions[toolName] = toolOptions;
        this._toolInstances[toolName].mode = Active;
        const runtimeSettings = esm.Settings.getRuntimeSettings();
        const useCursor = runtimeSettings.get('useCursors');
        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {
            this.setViewportsCursorByToolName(toolName);
        }
        else {
            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();
            if (!activeToolIdentifier && useCursor) {
                const cursor = cursors.MouseCursor.getDefinedCursor('default');
                this._setCursorForViewports(cursor);
            }
        }
        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {
            if (this.prevActivePrimaryToolName === null) {
                this.prevActivePrimaryToolName = toolName;
            }
            else {
                this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;
            }
            this.currentActivePrimaryToolName = toolName;
        }
        if (typeof toolInstance.onSetToolActive === 'function') {
            toolInstance.onSetToolActive();
        }
        this._renderViewports();
        const eventDetail = {
            toolGroupId: this.id,
            toolName,
            toolBindingsOptions,
        };
        (0,esm.triggerEvent)(esm.eventTarget, enums.Events.TOOL_ACTIVATED, eventDetail);
        this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);
    }
    setToolPassive(toolName, options) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const prevToolOptions = this.getToolOptions(toolName);
        const toolOptions = Object.assign({
            bindings: prevToolOptions ? prevToolOptions.bindings : [],
        }, prevToolOptions, {
            mode: Passive,
        });
        const matchBindings = Array.isArray(options?.removeAllBindings)
            ? options.removeAllBindings
            : this.getDefaultPrimaryBindings();
        toolOptions.bindings = toolOptions.bindings.filter((binding) => options?.removeAllBindings !== true &&
            !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));
        let mode = Passive;
        if (toolOptions.bindings.length !== 0) {
            mode = Active;
            toolOptions.mode = mode;
        }
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = mode;
        if (typeof toolInstance.onSetToolPassive === 'function') {
            toolInstance.onSetToolPassive();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Passive);
    }
    setToolEnabled(toolName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const toolOptions = {
            bindings: [],
            mode: Enabled,
        };
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = Enabled;
        if (typeof toolInstance.onSetToolEnabled === 'function') {
            toolInstance.onSetToolEnabled();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Enabled);
    }
    setToolDisabled(toolName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const toolOptions = {
            bindings: [],
            mode: Disabled,
        };
        this.restoreToolOptions[toolName] = this.toolOptions[toolName];
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = Disabled;
        if (typeof toolInstance.onSetToolDisabled === 'function') {
            toolInstance.onSetToolDisabled();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Disabled);
    }
    getToolOptions(toolName) {
        const toolOptionsForTool = this.toolOptions[toolName];
        if (toolOptionsForTool === undefined) {
            return;
        }
        return toolOptionsForTool;
    }
    getActivePrimaryMouseButtonTool() {
        return Object.keys(this.toolOptions).find((toolName) => {
            const toolOptions = this.toolOptions[toolName];
            return (toolOptions.mode === Active &&
                this._hasMousePrimaryButtonBinding(toolOptions));
        });
    }
    setViewportsCursorByToolName(toolName, strategyName) {
        const cursor = this._getCursor(toolName, strategyName);
        this._setCursorForViewports(cursor);
    }
    _getCursor(toolName, strategyName) {
        let cursorName;
        let cursor;
        if (strategyName) {
            cursorName = `${toolName}.${strategyName}`;
            cursor = cursors.SVGMouseCursor.getDefinedCursor(cursorName, true);
            if (cursor) {
                return cursor;
            }
        }
        cursorName = `${toolName}`;
        cursor = cursors.SVGMouseCursor.getDefinedCursor(cursorName, true);
        if (cursor) {
            return cursor;
        }
        cursorName = toolName;
        cursor = cursors.SVGMouseCursor.getDefinedCursor(cursorName, true);
        if (cursor) {
            return cursor;
        }
        return cursors.MouseCursor.getDefinedCursor('default');
    }
    _setCursorForViewports(cursor) {
        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            (0,elementCursor.initElementCursor)(viewport.element, cursor);
        });
    }
    setToolConfiguration(toolName, configuration, overwrite) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
            return false;
        }
        let _configuration;
        if (overwrite) {
            _configuration = configuration;
        }
        else {
            _configuration = Object.assign(toolInstance.configuration, configuration);
        }
        toolInstance.configuration = _configuration;
        if (typeof toolInstance.onSetToolConfiguration === 'function') {
            toolInstance.onSetToolConfiguration();
        }
        this._renderViewports();
        return true;
    }
    getDefaultMousePrimary() {
        return enums.MouseBindings.Primary;
    }
    getDefaultPrimaryBindings() {
        return PRIMARY_BINDINGS;
    }
    getToolConfiguration(toolName, configurationPath) {
        if (this._toolInstances[toolName] === undefined) {
            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
            return;
        }
        const _configuration = lodash_get_default()(this._toolInstances[toolName].configuration, configurationPath) ||
            this._toolInstances[toolName].configuration;
        return esm.utilities.deepClone(_configuration);
    }
    getPrevActivePrimaryToolName() {
        return this.prevActivePrimaryToolName;
    }
    setActivePrimaryTool(toolName) {
        const activeToolName = this.getCurrentActivePrimaryToolName();
        this.setToolDisabled(activeToolName);
        this.setToolActive(toolName, {
            bindings: [{ mouseButton: enums.MouseBindings.Primary }],
        });
    }
    getCurrentActivePrimaryToolName() {
        return this.currentActivePrimaryToolName;
    }
    clone(newToolGroupId, fnToolFilter = null) {
        let toolGroup = ToolGroupManager_getToolGroup(newToolGroupId);
        if (toolGroup) {
            console.debug(`ToolGroup ${newToolGroupId} already exists`);
            return toolGroup;
        }
        toolGroup = new ToolGroup(newToolGroupId);
        state/* state */.wk.toolGroups.push(toolGroup);
        fnToolFilter = fnToolFilter ?? (() => true);
        Object.keys(this._toolInstances)
            .filter(fnToolFilter)
            .forEach((toolName) => {
            const sourceToolInstance = this._toolInstances[toolName];
            const sourceToolOptions = this.toolOptions[toolName];
            const sourceToolMode = sourceToolInstance.mode;
            toolGroup.addTool(toolName);
            toolGroup.setToolMode(toolName, sourceToolMode, {
                bindings: sourceToolOptions.bindings ?? [],
            });
        });
        return toolGroup;
    }
    _hasMousePrimaryButtonBinding(toolOptions) {
        const primaryBindings = this.getDefaultPrimaryBindings();
        return toolOptions?.bindings?.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));
    }
    _renderViewports() {
        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            (0,esm.getRenderingEngine)(renderingEngineId).renderViewport(viewportId);
        });
    }
    _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {
        const eventDetail = {
            toolGroupId: this.id,
            toolName,
            mode,
            toolBindingsOptions,
        };
        (0,esm.triggerEvent)(esm.eventTarget, enums.Events.TOOL_MODE_CHANGED, eventDetail);
    }
    _findRenderingEngine(viewportId, renderingEngineId) {
        const renderingEngines = (0,esm.getRenderingEngines)();
        if (renderingEngines?.length === 0) {
            throw new Error('No rendering engines found.');
        }
        if (renderingEngineId) {
            return renderingEngineId;
        }
        const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));
        if (matchingEngines.length === 0) {
            if (renderingEngines.length === 1) {
                return renderingEngines[0].id;
            }
            throw new Error('No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');
        }
        if (matchingEngines.length > 1) {
            throw new Error('Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');
        }
        return matchingEngines[0].id;
    }
}
function hasSameBinding(binding1, binding2) {
    if (binding1.mouseButton !== binding2.mouseButton) {
        return false;
    }
    if (binding1.numTouchPoints !== binding2.numTouchPoints) {
        return false;
    }
    return binding1.modifierKey === binding2.modifierKey;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js


function createToolGroup(toolGroupId) {
    const toolGroupWithIdExists = state/* state */.wk.toolGroups.some((tg) => tg.id === toolGroupId);
    if (toolGroupWithIdExists) {
        console.warn(`'${toolGroupId}' already exists.`);
        return;
    }
    const toolGroup = new ToolGroup(toolGroupId);
    state/* state */.wk.toolGroups.push(toolGroup);
    return toolGroup;
}
/* harmony default export */ const ToolGroupManager_createToolGroup = (createToolGroup);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js

function destroyToolGroup(toolGroupId) {
    const toolGroupIndex = state/* state */.wk.toolGroups.findIndex((tg) => tg.id === toolGroupId);
    if (toolGroupIndex > -1) {
        state/* state */.wk.toolGroups.splice(toolGroupIndex, 1);
    }
}
/* harmony default export */ const ToolGroupManager_destroyToolGroup = (destroyToolGroup);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js


function destroy() {
    const toolGroups = [...state/* state */.wk.toolGroups];
    for (const toolGroup of toolGroups) {
        ToolGroupManager_destroyToolGroup(toolGroup.id);
    }
    state/* state */.wk.toolGroups = [];
}
/* harmony default export */ const ToolGroupManager_destroy = (destroy);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js
var getToolGroupForViewport = __webpack_require__(65136);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js

function getAllToolGroups() {
    return state/* state */.wk.toolGroups;
}
/* harmony default export */ const ToolGroupManager_getAllToolGroups = (getAllToolGroups);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js


const MODES = [enums.ToolModes.Active, enums.ToolModes.Passive, enums.ToolModes.Enabled];
function getToolGroupsWithToolName(toolName) {
    return state/* state */.wk.toolGroups.filter(({ toolOptions }) => {
        const toolGroupToolNames = Object.keys(toolOptions);
        for (let i = 0; i < toolGroupToolNames.length; i++) {
            if (toolName !== toolGroupToolNames[i]) {
                continue;
            }
            if (!toolOptions[toolName]) {
                continue;
            }
            if (MODES.includes(toolOptions[toolName].mode)) {
                return true;
            }
        }
        return false;
    });
}
/* harmony default export */ const ToolGroupManager_getToolGroupsWithToolName = (getToolGroupsWithToolName);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js










/***/ }),

/***/ 68040:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bl: () => (/* binding */ removeTool),
/* harmony export */   Gx: () => (/* binding */ addTool),
/* harmony export */   l$: () => (/* binding */ hasToolByName)
/* harmony export */ });
/* unused harmony export hasTool */
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);

function addTool(ToolClass) {
    const toolName = ToolClass.toolName;
    const toolAlreadyAdded = _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName] !== undefined;
    if (!toolName) {
        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);
    }
    _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName] = {
        toolClass: ToolClass,
    };
}
function hasTool(ToolClass) {
    const toolName = ToolClass.toolName;
    return !!(toolName && state.tools[toolName]);
}
function hasToolByName(toolName) {
    return !!(toolName && _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName]);
}
function removeTool(ToolClass) {
    const toolName = ToolClass.toolName;
    if (!toolName) {
        throw new Error(`No tool found for: ${ToolClass.name}`);
    }
    if (!_state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName] !== undefined) {
        delete _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName];
    }
    else {
        throw new Error(`${toolName} cannot be removed because it has not been added`);
    }
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (addTool)));


/***/ }),

/***/ 85204:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   qh: () => (/* binding */ resetCornerstoneToolsState),
/* harmony export */   wk: () => (/* binding */ state)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48145);

const defaultState = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A,
    enabledElements: [],
    handleRadius: 6,
};
let state = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A,
    enabledElements: [],
    handleRadius: 6,
};
function resetCornerstoneToolsState() {
    (0,_svgNodeCache__WEBPACK_IMPORTED_MODULE_0__/* .resetSvgNodeCache */ .e)();
    state = {
        ...structuredClone({
            ...defaultState,
            svgNodeCache: {},
        }),
        svgNodeCache: {
            ...defaultState.svgNodeCache,
        },
    };
}



/***/ }),

/***/ 48145:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   e: () => (/* binding */ resetSvgNodeCache)
/* harmony export */ });
let svgNodeCache = {};
function resetSvgNodeCache() {
    svgNodeCache = {};
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (svgNodeCache);


/***/ }),

/***/ 25072:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81985);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(89578);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(8056);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(93258);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(66990);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(58640);

















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class BidirectionalTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .AnnotationTool */ .EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            let canvasPoint1 = viewport.worldToCanvas(points[0]);
            let canvasPoint2 = viewport.worldToCanvas(points[1]);
            let line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            let distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            canvasPoint1 = viewport.worldToCanvas(points[2]);
            canvasPoint2 = viewport.worldToCanvas(points[3]);
            line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const data = annotation.data;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            if (this.editData.handleIndex !== undefined) {
                const { points } = data.handles;
                const firstLineSegmentLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(points[0], points[1]);
                const secondLineSegmentLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(points[2], points[3]);
                if (secondLineSegmentLength > firstLineSegmentLength) {
                    const longAxis = [[...points[2]], [...points[3]]];
                    const shortAxisPoint0 = [...points[0]];
                    const shortAxisPoint1 = [...points[1]];
                    const longAxisVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);
                    const counterClockWisePerpendicularToLongAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);
                    const currentShortAxisVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);
                    let shortAxis;
                    if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.dot */ .Zc.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {
                        shortAxis = [shortAxisPoint0, shortAxisPoint1];
                    }
                    else {
                        shortAxis = [shortAxisPoint1, shortAxisPoint0];
                    }
                    data.handles.points = [
                        longAxis[0],
                        longAxis[1],
                        shortAxis[0],
                        shortAxis[1],
                    ];
                }
            }
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__/* .triggerAnnotationCompleted */ .dZ)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { worldToCanvas } = viewport;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            const worldPos = currentPoints.world;
            data.handles.points[handleIndex] = [...worldPos];
            const canvasCoordPoints = data.handles.points.map(worldToCanvas);
            const canvasCoords = {
                longLineSegment: {
                    start: {
                        x: canvasCoordPoints[0][0],
                        y: canvasCoordPoints[0][1],
                    },
                    end: {
                        x: canvasCoordPoints[1][0],
                        y: canvasCoordPoints[1][1],
                    },
                },
                shortLineSegment: {
                    start: {
                        x: canvasCoordPoints[2][0],
                        y: canvasCoordPoints[2][1],
                    },
                    end: {
                        x: canvasCoordPoints[3][0],
                        y: canvasCoordPoints[3][1],
                    },
                },
            };
            const dist = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoordPoints[0], canvasCoordPoints[1]);
            const shortAxisDistFromCenter = dist / 3;
            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;
            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const vectorX = dx / length;
            const vectorY = dy / length;
            const xMid = (canvasCoords.longLineSegment.start.x +
                canvasCoords.longLineSegment.end.x) /
                2;
            const yMid = (canvasCoords.longLineSegment.start.y +
                canvasCoords.longLineSegment.end.y) /
                2;
            const startX = xMid + shortAxisDistFromCenter * vectorY;
            const startY = yMid - shortAxisDistFromCenter * vectorX;
            const endX = xMid - shortAxisDistFromCenter * vectorY;
            const endY = yMid + shortAxisDistFromCenter * vectorX;
            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);
            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            this.editData.hasMoved = true;
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragModifyHandle(evt);
                annotation.invalidated = true;
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._dragModifyHandle = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { annotation, handleIndex: movingHandleIndex } = this.editData;
            const { data } = annotation;
            const worldPos = currentPoints.world;
            const canvasCoordHandlesCurrent = [
                viewport.worldToCanvas(data.handles.points[0]),
                viewport.worldToCanvas(data.handles.points[1]),
                viewport.worldToCanvas(data.handles.points[2]),
                viewport.worldToCanvas(data.handles.points[3]),
            ];
            const firstLineSegment = {
                start: {
                    x: canvasCoordHandlesCurrent[0][0],
                    y: canvasCoordHandlesCurrent[0][1],
                },
                end: {
                    x: canvasCoordHandlesCurrent[1][0],
                    y: canvasCoordHandlesCurrent[1][1],
                },
            };
            const secondLineSegment = {
                start: {
                    x: canvasCoordHandlesCurrent[2][0],
                    y: canvasCoordHandlesCurrent[2][1],
                },
                end: {
                    x: canvasCoordHandlesCurrent[3][0],
                    y: canvasCoordHandlesCurrent[3][1],
                },
            };
            const proposedPoint = [...worldPos];
            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);
            if (movingHandleIndex === 0 || movingHandleIndex === 1) {
                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;
                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];
                const fixedHandleToProposedCoordVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);
                const fixedHandleToOldCoordVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -
                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -
                    fixedHandleCanvasCoord[1]);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);
                const proposedFirstLineSegment = {
                    start: {
                        x: fixedHandleCanvasCoord[0],
                        y: fixedHandleCanvasCoord[1],
                    },
                    end: {
                        x: proposedCanvasCoord[0],
                        y: proposedCanvasCoord[1],
                    },
                };
                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {
                    return;
                }
                const centerOfRotation = fixedHandleCanvasCoord;
                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);
                let firstPointX = canvasCoordHandlesCurrent[2][0];
                let firstPointY = canvasCoordHandlesCurrent[2][1];
                let secondPointX = canvasCoordHandlesCurrent[3][0];
                let secondPointY = canvasCoordHandlesCurrent[3][1];
                firstPointX -= centerOfRotation[0];
                firstPointY -= centerOfRotation[1];
                secondPointX -= centerOfRotation[0];
                secondPointY -= centerOfRotation[1];
                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);
                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);
                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);
                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);
                firstPointX = rotatedFirstPoint + centerOfRotation[0];
                firstPointY = rotatedFirstPointY + centerOfRotation[1];
                secondPointX = rotatedSecondPoint + centerOfRotation[0];
                secondPointY = rotatedSecondPointY + centerOfRotation[1];
                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);
                const newSecondPoint = viewport.canvasToWorld([
                    secondPointX,
                    secondPointY,
                ]);
                data.handles.points[movingHandleIndex] = proposedPoint;
                data.handles.points[2] = newFirstPoint;
                data.handles.points[3] = newSecondPoint;
            }
            else {
                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;
                const canvasCoordsCurrent = {
                    longLineSegment: {
                        start: firstLineSegment.start,
                        end: firstLineSegment.end,
                    },
                    shortLineSegment: {
                        start: secondLineSegment.start,
                        end: secondLineSegment.end,
                    },
                };
                const longLineSegmentVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [
                    canvasCoordsCurrent.longLineSegment.end.x,
                    canvasCoordsCurrent.longLineSegment.end.y,
                ], [
                    canvasCoordsCurrent.longLineSegment.start.x,
                    canvasCoordsCurrent.longLineSegment.start.y,
                ]);
                const longLineSegmentVecNormalized = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), longLineSegmentVec);
                const proposedToCurrentVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [
                    canvasCoordHandlesCurrent[movingHandleIndex][0],
                    canvasCoordHandlesCurrent[movingHandleIndex][1],
                ]);
                const movementLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.length */ .Zc.length(proposedToCurrentVec);
                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);
                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;
                const newTranslatedPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scaleAndAdd */ .Zc.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [
                    canvasCoordHandlesCurrent[translateHandleIndex][0],
                    canvasCoordHandlesCurrent[translateHandleIndex][1],
                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);
                if (this._movingLongAxisWouldPutItThroughShortAxis({
                    start: {
                        x: proposedCanvasCoord[0],
                        y: proposedCanvasCoord[1],
                    },
                    end: {
                        x: newTranslatedPoint[0],
                        y: newTranslatedPoint[1],
                    },
                }, {
                    start: {
                        x: canvasCoordsCurrent.longLineSegment.start.x,
                        y: canvasCoordsCurrent.longLineSegment.start.y,
                    },
                    end: {
                        x: canvasCoordsCurrent.longLineSegment.end.x,
                        y: canvasCoordsCurrent.longLineSegment.end.y,
                    },
                })) {
                    return;
                }
                const intersectionPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
                if (!intersectionPoint) {
                    return;
                }
                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);
                data.handles.points[movingHandleIndex] = proposedPoint;
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__/* .triggerAnnotationCompleted */ .dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragDrawCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragDrawCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = true;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        width: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId1 = `${annotationUID}-line-1`;
                const dataId2 = `${annotationUID}-line-2`;
                const lineUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    lineDash,
                    lineWidth,
                    shadow,
                }, dataId1);
                const secondLineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLine)(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                    shadow,
                }, dataId2);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_14__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {
            const vectorInSecondLineDirection = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);
            const extendedSecondLineSegment = {
                start: {
                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,
                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,
                },
                end: {
                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,
                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,
                },
            };
            const proposedIntersectionPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
            const wouldPutThroughShortAxis = !proposedIntersectionPoint;
            return wouldPutThroughShortAxis;
        };
        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { element } = enabledElement.viewport;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[1];
            const worldPos3 = data.handles.points[2];
            const worldPos4 = data.handles.points[3];
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { imageData, dimensions } = image;
                const index1 = transformWorldToIndex(imageData, worldPos1);
                const index2 = transformWorldToIndex(imageData, worldPos2);
                const index3 = transformWorldToIndex(imageData, worldPos3);
                const index4 = transformWorldToIndex(imageData, worldPos4);
                const handles1 = [index1, index2];
                const handles2 = [index3, index4];
                const { scale: scale1, unit: units1 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles1);
                const { scale: scale2, unit: units2 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles2);
                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;
                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;
                const length = dist1 > dist2 ? dist1 : dist2;
                const width = dist1 > dist2 ? dist2 : dist1;
                const unit = dist1 > dist2 ? units1 : units2;
                const widthUnit = dist1 > dist2 ? units2 : units1;
                this._isInsideVolume(index1, index2, index3, index4, dimensions)
                    ? (this.isHandleOutsideImage = false)
                    : (this.isHandleOutsideImage = true);
                cachedStats[targetId] = {
                    length,
                    width,
                    unit,
                    widthUnit,
                };
            }
            annotation.invalidated = false;
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__/* .triggerAnnotationModified */ .XF)(annotation, element);
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index3, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index4, dimensions));
        };
        this._getSignedAngle = (vector1, vector2) => {
            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const worldPos = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        this.isDrawing = true;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const annotation = {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID,
                referencedImageId,
                ...viewport.getViewReference({ points: [worldPos] }),
            },
            data: {
                handles: {
                    points: [
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                    ],
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex: 1,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
        };
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
        evt.preventDefault();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
        return annotation;
    }
    _calculateLength(pos1, pos2) {
        const dx = pos1[0] - pos2[0];
        const dy = pos1[1] - pos2[1];
        const dz = pos1[2] - pos2[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
}
function defaultGetTextLines(data, targetId) {
    const { cachedStats, label } = data;
    const { length, width, unit } = cachedStats[targetId];
    const textLines = [];
    if (label) {
        textLines.push(label);
    }
    if (length === undefined) {
        return textLines;
    }
    textLines.push(`L: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(length)} ${unit || unit}`, `W: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(width)} ${unit}`);
    return textLines;
}
BidirectionalTool.toolName = 'Bidirectional';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BidirectionalTool);


/***/ }),

/***/ 37590:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);
/* harmony import */ var _PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28220);



class PlanarFreehandContourSegmentationTool extends _PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A {
    constructor(toolProps) {
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge({
            configuration: {
                calculateStats: false,
                allowOpenContours: false,
            },
        }, toolProps);
        super(initialProps);
    }
    isContourSegmentationTool() {
        return true;
    }
    renderAnnotationInstance(renderContext) {
        const annotation = renderContext.annotation;
        const { invalidated } = annotation;
        const renderResult = super.renderAnnotationInstance(renderContext);
        if (invalidated) {
            const { segmentationId } = annotation.data.segmentation;
            (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationDataModified)(segmentationId);
        }
        return renderResult;
    }
}
PlanarFreehandContourSegmentationTool.toolName =
    'PlanarFreehandContourSegmentationTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlanarFreehandContourSegmentationTool);


/***/ }),

/***/ 28220:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95527);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13165);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(27730);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8056);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(58640);
/* harmony import */ var _planarFreehandROITool_drawLoop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(55927);
/* harmony import */ var _planarFreehandROITool_editLoopCommon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(92400);
/* harmony import */ var _planarFreehandROITool_closedContourEditLoop__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(57999);
/* harmony import */ var _planarFreehandROITool_openContourEditLoop__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(69855);
/* harmony import */ var _planarFreehandROITool_openContourEndEditLoop__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(70734);
/* harmony import */ var _planarFreehandROITool_renderMethods__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(58161);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(89578);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(66990);
/* harmony import */ var _utilities_math_polyline__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(92984);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(79362);
/* harmony import */ var _utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(93843);
/* harmony import */ var _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(36320);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(99737);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(40634);

























const { pointCanProjectOnLine } = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.polyline;
const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS;
const PARALLEL_THRESHOLD = 1 - EPSILON;
class PlanarFreehandROITool extends _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_21__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            shadow: true,
            preventHandleOutsideImage: false,
            contourHoleAdditionModifierKey: _enums__WEBPACK_IMPORTED_MODULE_22__.KeyboardBindings.Shift,
            alwaysRenderOpenContourHandles: {
                enabled: false,
                radius: 2,
            },
            allowOpenContours: true,
            closeContourProximity: 10,
            checkCanvasEditFallbackProximity: 6,
            makeClockWise: true,
            subPixelResolution: 4,
            smoothing: {
                smoothOnAdd: false,
                smoothOnEdit: false,
                knotsRatioPercentageOnAdd: 40,
                knotsRatioPercentageOnEdit: 40,
            },
            interpolation: {
                enabled: false,
                onInterpolationComplete: null,
            },
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            displayOnePointAsCrosshairs: false,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isEditingClosed = false;
        this.isEditingOpen = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const annotation = this.createAnnotation(evt);
            this.addAnnotation(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.activateDraw(evt, annotation, viewportIdsToRender);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            if (annotation.data.contour.closed) {
                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);
            }
            else {
                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);
            }
            evt.preventDefault();
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { polyline: points } = annotation.data.contour;
            let previousPoint = viewport.worldToCanvas(points[0]);
            for (let i = 1; i < points.length; i++) {
                const p1 = previousPoint;
                const p2 = viewport.worldToCanvas(points[i]);
                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);
                if (canProject) {
                    return true;
                }
                previousPoint = p2;
            }
            if (!annotation.data.contour.closed) {
                return false;
            }
            const pStart = viewport.worldToCanvas(points[0]);
            const pEnd = viewport.worldToCanvas(points[points.length - 1]);
            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);
        };
        this.cancel = (element) => {
            const isDrawing = this.isDrawing;
            const isEditingOpen = this.isEditingOpen;
            const isEditingClosed = this.isEditingClosed;
            if (isDrawing) {
                this.cancelDrawing(element);
            }
            else if (isEditingOpen) {
                this.cancelOpenContourEdit(element);
            }
            else if (isEditingClosed) {
                this.cancelClosedContourEdit(element);
            }
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { cachedStats } = data;
            const { polyline: points, closed } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { imageData, metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const modalityUnitOptions = {
                    isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__/* .isViewportPreScaled */ .u)(viewport, targetId),
                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                };
                const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_23__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
                const calibratedScale = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, () => {
                    const polyline = data.contour.polyline;
                    const numPoints = polyline.length;
                    const projectedPolyline = new Array(numPoints);
                    for (let i = 0; i < numPoints; i++) {
                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);
                    }
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.polyline.getAABB(projectedPolyline);
                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);
                    const topLeftBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                if (closed) {
                    this.updateClosedCachedStats({
                        targetId,
                        viewport,
                        canvasCoordinates,
                        points,
                        imageData,
                        metadata,
                        cachedStats,
                        modalityUnit,
                        calibratedScale,
                    });
                }
                else {
                    this.updateOpenCachedStats({
                        metadata,
                        canvasCoordinates,
                        targetId,
                        cachedStats,
                        modalityUnit,
                        calibratedScale,
                    });
                }
            }
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_14__/* .triggerAnnotationModified */ .XF)(annotation, enabledElement.viewport.element, _enums__WEBPACK_IMPORTED_MODULE_22__.ChangeTypes.StatsUpdated);
            annotation.invalidated = false;
            return cachedStats;
        };
        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {
            const { data } = annotation;
            const targetId = this.getTargetId(viewport);
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
            if (!options.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_16__.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = '1';
            const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_15__.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        (0,_planarFreehandROITool_drawLoop__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_editLoopCommon__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_closedContourEditLoop__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_openContourEditLoop__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_openContourEndEditLoop__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_renderMethods__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A)(this);
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations || !annotations.length) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let annotationsToDisplay;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            const camera = viewport.getCamera();
            const { spacingInNormalDirection } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getTargetVolumeAndSpacingInNormalDir(viewport, camera);
            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);
        }
        else {
            annotationsToDisplay = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_4__.filterAnnotationsForDisplay)(viewport, annotations);
        }
        return annotationsToDisplay;
    }
    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
        const { viewPlaneNormal } = camera;
        const annotationsWithParallelNormals = annotations.filter((td) => {
            const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;
            const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.dot */ .eR.dot(viewPlaneNormal, annotationViewPlaneNormal)) >
                PARALLEL_THRESHOLD;
            return annotationViewPlaneNormal && isParallel;
        });
        if (!annotationsWithParallelNormals.length) {
            return [];
        }
        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
        const { focalPoint } = camera;
        const annotationsWithinSlice = [];
        for (const annotation of annotationsWithParallelNormals) {
            const data = annotation.data;
            const point = data.contour.polyline[0];
            if (!annotation.isVisible) {
                continue;
            }
            const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.sub */ .eR.sub(dir, focalPoint, point);
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.dot */ .eR.dot(dir, viewPlaneNormal);
            if (Math.abs(dot) < halfSpacingInNormalDirection) {
                annotationsWithinSlice.push(annotation);
            }
        }
        return annotationsWithinSlice;
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const worldPos = evt.detail.currentPoints.world;
        const contourAnnotation = super.createAnnotation(evt);
        const onInterpolationComplete = (annotation) => {
            annotation.data.handles.points.length = 0;
        };
        const annotation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(contourAnnotation, {
            data: {
                contour: {
                    polyline: [[...worldPos]],
                },
                label: '',
                cachedStats: {},
            },
            onInterpolationComplete,
        });
        return annotation;
    }
    getAnnotationStyle(context) {
        return super.getAnnotationStyle(context);
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, targetId, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        let renderStatus = false;
        const { viewport, renderingEngine } = enabledElement;
        const isDrawing = this.isDrawing;
        const isEditingOpen = this.isEditingOpen;
        const isEditingClosed = this.isEditingClosed;
        if (!(isDrawing || isEditingOpen || isEditingClosed)) {
            if (this.configuration.displayOnePointAsCrosshairs &&
                annotation.data.contour.polyline.length === 1) {
                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);
            }
            else {
                this.renderContour(enabledElement, svgDrawingHelper, annotation);
            }
        }
        else {
            const activeAnnotationUID = this.commonData.annotation.annotationUID;
            if (annotation.annotationUID === activeAnnotationUID) {
                if (isDrawing) {
                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);
                }
                else if (isEditingClosed) {
                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                }
                else if (isEditingOpen) {
                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                }
                else {
                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);
                }
            }
            else {
                if (this.configuration.displayOnePointAsCrosshairs &&
                    annotation.data.contour.polyline.length === 1) {
                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);
                }
                else {
                    this.renderContour(enabledElement, svgDrawingHelper, annotation);
                }
            }
            renderStatus = true;
        }
        if (!this.configuration.calculateStats) {
            return;
        }
        this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);
        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);
        return renderStatus;
    }
    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {
        const activeAnnotationUID = this.commonData?.annotation.annotationUID;
        if (annotation.annotationUID === activeAnnotationUID &&
            !this.commonData?.movingTextBox) {
            return;
        }
        if (!this.commonData?.movingTextBox) {
            const { data } = annotation;
            if (!data.cachedStats[targetId] ||
                data.cachedStats[targetId].areaUnit == null) {
                data.cachedStats[targetId] = {
                    Modality: null,
                    area: null,
                    max: null,
                    mean: null,
                    stdDev: null,
                    areaUnit: null,
                };
                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
            }
            else if (annotation.invalidated) {
                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
            }
        }
    }
    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, }) {
        const { scale, areaUnit, units } = calibratedScale;
        const { voxelManager } = viewport.getImageData();
        const canvasPoint = canvasCoordinates[0];
        const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
        const deltaXPoint = viewport.canvasToWorld([
            canvasPoint[0] + 1,
            canvasPoint[1],
        ]);
        const deltaYPoint = viewport.canvasToWorld([
            canvasPoint[0],
            canvasPoint[1] + 1,
        ]);
        const deltaInX = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(originalWorldPoint, deltaXPoint);
        const deltaInY = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(originalWorldPoint, deltaYPoint);
        const worldPosIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, points[0]);
        worldPosIndex[0] = Math.floor(worldPosIndex[0]);
        worldPosIndex[1] = Math.floor(worldPosIndex[1]);
        worldPosIndex[2] = Math.floor(worldPosIndex[2]);
        let iMin = worldPosIndex[0];
        let iMax = worldPosIndex[0];
        let jMin = worldPosIndex[1];
        let jMax = worldPosIndex[1];
        let kMin = worldPosIndex[2];
        let kMax = worldPosIndex[2];
        for (let j = 1; j < points.length; j++) {
            const worldPosIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, points[j]);
            worldPosIndex[0] = Math.floor(worldPosIndex[0]);
            worldPosIndex[1] = Math.floor(worldPosIndex[1]);
            worldPosIndex[2] = Math.floor(worldPosIndex[2]);
            iMin = Math.min(iMin, worldPosIndex[0]);
            iMax = Math.max(iMax, worldPosIndex[0]);
            jMin = Math.min(jMin, worldPosIndex[1]);
            jMax = Math.max(jMax, worldPosIndex[1]);
            kMin = Math.min(kMin, worldPosIndex[2]);
            kMax = Math.max(kMax, worldPosIndex[2]);
        }
        const worldPosIndex2 = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, points[1]);
        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);
        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);
        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);
        let area = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.polyline.getArea(canvasCoordinates) / scale / scale;
        area *= deltaInX * deltaInY;
        const iDelta = 0.01 * (iMax - iMin);
        const jDelta = 0.01 * (jMax - jMin);
        const kDelta = 0.01 * (kMax - kMin);
        iMin = Math.floor(iMin - iDelta);
        iMax = Math.ceil(iMax + iDelta);
        jMin = Math.floor(jMin - jDelta);
        jMax = Math.ceil(jMax + jDelta);
        kMin = Math.floor(kMin - kDelta);
        kMax = Math.ceil(kMax + kDelta);
        const boundsIJK = [
            [iMin, iMax],
            [jMin, jMax],
            [kMin, kMax],
        ];
        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);
        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);
        let curRow = 0;
        let intersections = [];
        let intersectionCounter = 0;
        const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
            imageData,
            isInObject: (pointLPS, _pointIJK) => {
                let result = true;
                const point = viewport.worldToCanvas(pointLPS);
                if (point[1] != curRow) {
                    intersectionCounter = 0;
                    curRow = point[1];
                    intersections = (0,_utilities_math_polyline__WEBPACK_IMPORTED_MODULE_17__.getLineSegmentIntersectionsCoordinates)(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);
                    intersections.sort((function (index) {
                        return function (a, b) {
                            return a[index] === b[index]
                                ? 0
                                : a[index] < b[index]
                                    ? -1
                                    : 1;
                        };
                    })(0));
                }
                if (intersections.length && point[0] > intersections[0][0]) {
                    intersections.shift();
                    intersectionCounter++;
                }
                if (intersectionCounter % 2 === 0) {
                    result = false;
                }
                return result;
            },
            boundsIJK,
            returnPoints: this.configuration.storePointData,
        });
        const stats = this.configuration.statsCalculator.getStatistics();
        cachedStats[targetId] = {
            Modality: metadata.Modality,
            area,
            perimeter: (0,_utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .A)(canvasCoordinates, closed) / scale,
            mean: stats.mean?.value,
            max: stats.max?.value,
            stdDev: stats.stdDev?.value,
            statsArray: stats.array,
            pointsInShape: pointsInShape,
            areaUnit,
            modalityUnit,
            unit: units,
        };
    }
    updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale, }) {
        const { scale, units } = calibratedScale;
        cachedStats[targetId] = {
            Modality: metadata.Modality,
            length: (0,_utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .A)(canvasCoordinates, false) / scale,
            modalityUnit,
            getPixelValueUnitunit: units,
        };
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, stdDev, length, perimeter, max, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (mean) {
        textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (Number.isFinite(max)) {
        textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (stdDev) {
        textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    if (perimeter) {
        textLines.push(`Perimeter: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(perimeter)} ${unit}`);
    }
    if (length) {
        textLines.push(`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(length)} ${unit}`);
    }
    return textLines;
}
PlanarFreehandROITool.toolName = 'PlanarFreehandROI';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlanarFreehandROITool);


/***/ }),

/***/ 4010:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81985);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(89578);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(8056);
/* harmony import */ var _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(92282);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(66990);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(35489);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(58640);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(40634);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(79362);




















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class RectangleROITool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                },
            };
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasPoint1 = viewport.worldToCanvas(points[0]);
            const canvasPoint2 = viewport.worldToCanvas(points[3]);
            const rect = this._getRectangleImageCoordinates([
                canvasPoint1,
                canvasPoint2,
            ]);
            const point = [canvasCoords[0], canvasCoords[1]];
            const { left, top, width, height } = rect;
            const distanceToPoint = _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_12__.distanceToPoint([left, top, width, height], point);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .removeAnnotation */ .O8)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__/* .triggerAnnotationCompleted */ .dZ)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { points } = data.handles;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
                const worldPos = currentPoints.world;
                const { points } = data.handles;
                points[handleIndex] = [...worldPos];
                let bottomLeftCanvas;
                let bottomRightCanvas;
                let topLeftCanvas;
                let topRightCanvas;
                let bottomLeftWorld;
                let bottomRightWorld;
                let topLeftWorld;
                let topRightWorld;
                switch (handleIndex) {
                    case 0:
                    case 3:
                        bottomLeftCanvas = worldToCanvas(points[0]);
                        topRightCanvas = worldToCanvas(points[3]);
                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                        bottomRightWorld = canvasToWorld(bottomRightCanvas);
                        topLeftWorld = canvasToWorld(topLeftCanvas);
                        points[1] = bottomRightWorld;
                        points[2] = topLeftWorld;
                        break;
                    case 1:
                    case 2:
                        bottomRightCanvas = worldToCanvas(points[1]);
                        topLeftCanvas = worldToCanvas(points[2]);
                        bottomLeftCanvas = [
                            topLeftCanvas[0],
                            bottomRightCanvas[1],
                        ];
                        topRightCanvas = [
                            bottomRightCanvas[0],
                            topLeftCanvas[1],
                        ];
                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                        topRightWorld = canvasToWorld(topRightCanvas);
                        points[0] = bottomLeftWorld;
                        points[3] = topRightWorld;
                        break;
                }
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__/* .triggerAnnotationCompleted */ .dZ)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .getAnnotations */ .Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const { viewPlaneNormal, viewUp } = viewport.getCamera();
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                    };
                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-rect`;
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawRectByCoordinates)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_13__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._getRectangleImageCoordinates = (points) => {
            const [point0, point1] = points;
            return {
                left: Math.min(point0[0], point1[0]),
                top: Math.min(point0[1], point1[1]),
                width: Math.abs(point0[0] - point1[0]),
                height: Math.abs(point0[1] - point1[1]),
            };
        };
        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[3];
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const pos2Index = transformWorldToIndex(imageData, worldPos2);
                pos2Index[0] = Math.floor(pos2Index[0]);
                pos2Index[1] = Math.floor(pos2Index[1]);
                pos2Index[2] = Math.floor(pos2Index[2]);
                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
                    this.isHandleOutsideImage = false;
                    const iMin = Math.min(pos1Index[0], pos2Index[0]);
                    const iMax = Math.max(pos1Index[0], pos2Index[0]);
                    const jMin = Math.min(pos1Index[1], pos2Index[1]);
                    const jMax = Math.max(pos1Index[1], pos2Index[1]);
                    const kMin = Math.min(pos1Index[2], pos2Index[2]);
                    const kMax = Math.max(pos1Index[2], pos2Index[2]);
                    const boundsIJK = [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ];
                    const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const handles = [pos1Index, pos2Index];
                    const { scale, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles);
                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);
                    const pixelUnitsOptions = {
                        isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__/* .isViewportPreScaled */ .u)(viewport, targetId),
                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                    };
                    const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                        boundsIJK,
                        imageData,
                        returnPoints: this.configuration.storePointData,
                    });
                    const stats = this.configuration.statsCalculator.getStatistics();
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                        area,
                        mean: stats.mean?.value,
                        stdDev: stats.stdDev?.value,
                        max: stats.max?.value,
                        statsArray: stats.array,
                        pointsInShape: pointsInShape,
                        areaUnit,
                        modalityUnit,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            annotation.invalidated = false;
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__/* .triggerAnnotationModified */ .XF)(annotation, element);
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
RectangleROITool.toolName = 'RectangleROI';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROITool);


/***/ }),

/***/ 6030:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37234);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56069);
/* harmony import */ var _utilities_planar_filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94418);
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76712);
/* harmony import */ var _stateManagement_annotation_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(49310);







class AnnotationDisplayTool extends _BaseTool__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A {
    constructor() {
        super(...arguments);
        this.onImageSpacingCalibrated = (evt) => {
            const { element, imageId } = evt.detail;
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(imageId);
            const annotationManager = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotationManager)();
            const framesOfReference = annotationManager.getFramesOfReference();
            framesOfReference.forEach((frameOfReference) => {
                const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];
                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {
                    return;
                }
                toolSpecificAnnotations.forEach((annotation) => {
                    if (!annotation.metadata?.referencedImageId) {
                        return;
                    }
                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(annotation.metadata.referencedImageId);
                    if (referencedImageURI === imageURI) {
                        annotation.invalidated = true;
                        annotation.data.cachedStats = {};
                    }
                });
                (0,_utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(element);
            });
        };
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations || !annotations.length) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        return (0,_utilities_planar_filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewport, annotations);
    }
    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
        }
        return referencedImageId;
    }
    getStyle(property, specifications, annotation) {
        return (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_5__/* .getStyleProperty */ .h)(property, specifications, (0,_stateManagement_annotation_config__WEBPACK_IMPORTED_MODULE_6__.getState)(annotation), this.mode);
    }
}
AnnotationDisplayTool.toolName = 'AnnotationDisplayTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationDisplayTool);


/***/ }),

/***/ 37234:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49892);


class BaseTool {
    constructor(toolProps, defaultToolProps) {
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(defaultToolProps, toolProps);
        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;
        if (!configuration.strategies) {
            configuration.strategies = {};
            configuration.defaultStrategy = undefined;
            configuration.activeStrategy = undefined;
            configuration.strategyOptions = {};
        }
        this.toolGroupId = toolGroupId;
        this.supportedInteractionTypes = supportedInteractionTypes || [];
        this.configuration = Object.assign({}, configuration);
        this.mode = _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Disabled;
    }
    getToolName() {
        return this.constructor.toolName;
    }
    applyActiveStrategy(enabledElement, operationData) {
        const { strategies, activeStrategy } = this.configuration;
        return strategies[activeStrategy]?.call(this, enabledElement, operationData);
    }
    applyActiveStrategyCallback(enabledElement, operationData, callbackType) {
        const { strategies, activeStrategy } = this.configuration;
        if (!strategies[activeStrategy]) {
            throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);
        }
        return strategies[activeStrategy][callbackType]?.call(this, enabledElement, operationData);
    }
    setConfiguration(newConfiguration) {
        this.configuration = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(this.configuration, newConfiguration);
    }
    setActiveStrategy(strategyName) {
        this.setConfiguration({ activeStrategy: strategyName });
    }
    getTargetImageData(targetId) {
        if (targetId.startsWith('imageId:')) {
            const imageId = targetId.split('imageId:')[1];
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(imageId);
            let viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithImageURI(imageURI);
            if (!viewports || !viewports.length) {
                return;
            }
            viewports = viewports.filter((viewport) => {
                return viewport.getCurrentImageId() === imageId;
            });
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else if (targetId.startsWith('volumeId:')) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithVolumeId(volumeId);
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else if (targetId.startsWith('videoId:')) {
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(targetId);
            const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithImageURI(imageURI);
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else {
            throw new Error('getTargetIdImage: targetId must start with "imageId:" or "volumeId:"');
        }
    }
    getTargetId(viewport) {
        const targetId = viewport.getViewReferenceId?.();
        if (targetId) {
            return targetId;
        }
        throw new Error('getTargetId: viewport must have a getViewReferenceId method');
    }
}
BaseTool.toolName = 'BaseTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseTool);


/***/ }),

/***/ 85817:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EC: () => (/* reexport safe */ _AnnotationTool__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   oS: () => (/* reexport safe */ _BaseTool__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   wh: () => (/* reexport safe */ _AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_2__.A)
/* harmony export */ });
/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37234);
/* harmony import */ var _AnnotationTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91350);
/* harmony import */ var _AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6030);






/***/ }),

/***/ 25894:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18682);
/* harmony import */ var _contourHandler_handleContourSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22384);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33283);
/* harmony import */ var _stateManagement_segmentation_polySeg_canComputeRequestedRepresentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(69073);
/* harmony import */ var _stateManagement_segmentation_polySeg_Contour_computeAndAddContourRepresentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13654);
/* harmony import */ var _removeContourFromElement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87420);







let polySegConversionInProgress = false;
const processedViewportSegmentations = new Map();
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    if (!renderImmediate) {
        return;
    }
    (0,_removeContourFromElement__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(viewportId, segmentationId);
    viewport.render();
}
async function render(viewport, contourRepresentation) {
    const { segmentationId } = contourRepresentation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    let contourData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour];
    if (!contourData &&
        (0,_stateManagement_segmentation_polySeg_canComputeRequestedRepresentation__WEBPACK_IMPORTED_MODULE_4__/* .canComputeRequestedRepresentation */ .n)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour) &&
        !polySegConversionInProgress) {
        polySegConversionInProgress = true;
        contourData = await (0,_stateManagement_segmentation_polySeg_Contour_computeAndAddContourRepresentation__WEBPACK_IMPORTED_MODULE_5__/* .computeAndAddContourRepresentation */ .D)(segmentationId, {
            viewport,
        });
        polySegConversionInProgress = false;
    }
    if (!contourData) {
        return;
    }
    if (!contourData.geometryIds?.length) {
        return;
    }
    (0,_contourHandler_handleContourSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .handleContourSegmentation */ .d)(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});


/***/ }),

/***/ 684:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports render, removeRepresentation */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _addLabelmapToElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36014);
/* harmony import */ var _removeLabelmapFromElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88234);
/* harmony import */ var _stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26228);
/* harmony import */ var _stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50409);
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97577);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33283);
/* harmony import */ var _stateManagement_segmentation_polySeg_canComputeRequestedRepresentation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(69073);
/* harmony import */ var _stateManagement_segmentation_polySeg_Labelmap_computeAndAddLabelmapRepresentation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(79462);
/* harmony import */ var _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(92686);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(18682);
/* harmony import */ var _stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(47098);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(60740);
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(59452);














const MAX_NUMBER_COLORS = 255;
const labelMapConfigCache = new Map();
let polySegConversionInProgress = false;
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    labelMapConfigCache.forEach((value, key) => {
        if (key.includes(segmentationId)) {
            labelMapConfigCache.delete(key);
        }
    });
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeLabelmapFromElement__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(viewport.element, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, representation) {
    const { segmentationId } = representation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_6__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        console.warn('No segmentation found for segmentationId: ', segmentationId);
        return;
    }
    let labelmapData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A.Labelmap];
    let labelmapActorEntry = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_13__/* .getLabelmapActorEntry */ .wV)(viewport.id, segmentationId);
    if (!labelmapData &&
        (0,_stateManagement_segmentation_polySeg_canComputeRequestedRepresentation__WEBPACK_IMPORTED_MODULE_7__/* .canComputeRequestedRepresentation */ .n)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A.Labelmap) &&
        !polySegConversionInProgress) {
        polySegConversionInProgress = true;
        labelmapData = await (0,_stateManagement_segmentation_polySeg_Labelmap_computeAndAddLabelmapRepresentation__WEBPACK_IMPORTED_MODULE_8__/* .computeAndAddLabelmapRepresentation */ .z)(segmentationId, {
            viewport,
        });
        if (!labelmapData) {
            throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);
        }
        polySegConversionInProgress = false;
    }
    if (!labelmapData) {
        return;
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
        if (!labelmapActorEntry) {
            await _addLabelmapToViewport(viewport, labelmapData, segmentationId);
        }
        labelmapActorEntry = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_13__/* .getLabelmapActorEntry */ .wV)(viewport.id, segmentationId);
    }
    else {
        const labelmapImageId = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__/* .getCurrentLabelmapImageIdForViewport */ .v)(viewport.id, segmentationId);
        if (!labelmapImageId) {
            return;
        }
        if (!labelmapActorEntry) {
            await _addLabelmapToViewport(viewport, labelmapData, segmentationId);
        }
        labelmapActorEntry = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_13__/* .getLabelmapActorEntry */ .wV)(viewport.id, segmentationId);
    }
    if (!labelmapActorEntry) {
        return;
    }
    _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);
}
function _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {
    const { segmentationId } = segmentationRepresentation;
    const { cfun, ofun } = segmentationRepresentation.config;
    const { colorLUTIndex } = segmentationRepresentation;
    const activeSegmentation = (0,_stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_3__.getActiveSegmentation)(viewportId);
    const isActiveLabelmap = activeSegmentation?.segmentationId === segmentationId;
    const labelmapStyle = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_9__/* .segmentationStyle */ .Y.getStyle({
        viewportId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A.Labelmap,
        segmentationId,
    });
    const renderInactiveSegmentations = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_9__/* .segmentationStyle */ .Y.getRenderInactiveSegmentations(viewportId);
    const colorLUT = (0,_stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .getColorLUT */ .B)(colorLUTIndex);
    const numColors = Math.min(256, colorLUT.length);
    const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta, } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);
    const segmentsHidden = (0,_stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_11__/* .internalGetHiddenSegmentIndices */ .s)(viewportId, {
        segmentationId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A.Labelmap,
    });
    for (let i = 0; i < numColors; i++) {
        const segmentIndex = i;
        const segmentColor = colorLUT[segmentIndex];
        const perSegmentStyle = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_9__/* .segmentationStyle */ .Y.getStyle({
            viewportId,
            type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A.Labelmap,
            segmentationId,
            segmentIndex,
        });
        const segmentSpecificLabelmapConfig = perSegmentStyle;
        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);
        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {
            fillAlpha,
            renderFill,
            renderOutline,
            segmentColor,
            outlineWidth,
            segmentsHidden: segmentsHidden,
            cfun,
            ofun,
        });
        if (forceColorUpdate) {
            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);
        }
        if (forceOpacityUpdate) {
            if (renderFill) {
                const segmentOpacity = segmentsHidden.has(segmentIndex)
                    ? 0
                    : (segmentColor[3] / 255) * fillAlpha;
                ofun.removePoint(segmentIndex);
                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);
            }
            else {
                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);
            }
        }
    }
    const labelmapActor = labelmapActorEntry.actor;
    labelmapActor.getProperty().setRGBTransferFunction(0, cfun);
    ofun.setClamping(false);
    labelmapActor.getProperty().setScalarOpacity(0, ofun);
    labelmapActor.getProperty().setInterpolationTypeToNearest();
    if (renderOutline) {
        labelmapActor.getProperty().setUseLabelOutline(renderOutline);
        labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);
        const activeSegmentIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_12__/* .getActiveSegmentIndex */ .Q)(segmentationRepresentation.segmentationId);
        const outlineWidths = new Array(numColors - 1);
        for (let i = 1; i < numColors; i++) {
            const isHidden = segmentsHidden.has(i);
            if (isHidden) {
                outlineWidths[i - 1] = 0;
                continue;
            }
            outlineWidths[i - 1] =
                i === activeSegmentIndex
                    ? outlineWidth + activeSegmentOutlineWidthDelta
                    : outlineWidth;
        }
        labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);
    }
    else {
        labelmapActor
            .getProperty()
            .setLabelOutlineThickness(new Array(numColors - 1).fill(0));
    }
    const visible = isActiveLabelmap || renderInactiveSegmentations;
    labelmapActor.setVisibility(visible);
}
function _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {
    const segmentLabelmapConfig = segmentsLabelmapConfig || {};
    const configToUse = {
        ...labelmapConfig,
        ...segmentLabelmapConfig,
    };
    const fillAlpha = isActiveLabelmap
        ? configToUse.fillAlpha
        : configToUse.fillAlphaInactive;
    const outlineWidth = isActiveLabelmap
        ? configToUse.outlineWidth
        : configToUse.outlineWidthInactive;
    const renderFill = isActiveLabelmap
        ? configToUse.renderFill
        : configToUse.renderFillInactive;
    const renderOutline = isActiveLabelmap
        ? configToUse.renderOutline
        : configToUse.renderOutlineInactive;
    const outlineOpacity = isActiveLabelmap
        ? configToUse.outlineOpacity
        : configToUse.outlineOpacityInactive;
    const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;
    return {
        fillAlpha,
        outlineWidth,
        renderFill,
        renderOutline,
        outlineOpacity,
        activeSegmentOutlineWidthDelta,
    };
}
function _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun, }) {
    const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;
    const oldConfig = labelMapConfigCache.get(cacheUID);
    if (!oldConfig) {
        labelMapConfigCache.set(cacheUID, {
            fillAlpha,
            renderFill,
            renderOutline,
            outlineWidth,
            segmentColor: segmentColor.slice(),
            segmentsHidden: new Set(segmentsHidden),
            cfunMTime: cfun.getMTime(),
            ofunMTime: ofun.getMTime(),
        });
        return {
            forceOpacityUpdate: true,
            forceColorUpdate: true,
        };
    }
    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime, } = oldConfig;
    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||
        oldSegmentColor[1] !== segmentColor[1] ||
        oldSegmentColor[2] !== segmentColor[2];
    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||
        oldFillAlpha !== fillAlpha ||
        oldRenderFill !== renderFill ||
        oldRenderOutline !== renderOutline ||
        oldOutlineWidth !== outlineWidth ||
        oldSegmentsHidden !== segmentsHidden;
    if (forceOpacityUpdate || forceColorUpdate) {
        labelMapConfigCache.set(cacheUID, {
            fillAlpha,
            renderFill,
            renderOutline,
            outlineWidth,
            segmentColor: segmentColor.slice(),
            segmentsHidden: new Set(segmentsHidden),
            cfunMTime: cfun.getMTime(),
            ofunMTime: ofun.getMTime(),
        });
    }
    return {
        forceOpacityUpdate,
        forceColorUpdate,
    };
}
async function _addLabelmapToViewport(viewport, labelmapData, segmentationId) {
    await (0,_addLabelmapToElement__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport.element, labelmapData, segmentationId);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});



/***/ }),

/***/ 67014:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports render, removeRepresentation */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18682);
/* harmony import */ var _removeSurfaceFromElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20552);
/* harmony import */ var _addOrUpdateSurfaceToElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18796);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33283);
/* harmony import */ var _stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50409);
/* harmony import */ var _stateManagement_segmentation_polySeg_canComputeRequestedRepresentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(69073);
/* harmony import */ var _stateManagement_segmentation_polySeg_Surface_computeAndAddSurfaceRepresentation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(58062);








const { ViewportType } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums;
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeSurfaceFromElement__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(viewport.element, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, representation) {
    const { segmentationId } = representation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    let SurfaceData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface];
    if (!SurfaceData &&
        (0,_stateManagement_segmentation_polySeg_canComputeRequestedRepresentation__WEBPACK_IMPORTED_MODULE_6__/* .canComputeRequestedRepresentation */ .n)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface)) {
        SurfaceData = await (0,_stateManagement_segmentation_polySeg_Surface_computeAndAddSurfaceRepresentation__WEBPACK_IMPORTED_MODULE_7__/* .computeAndAddSurfaceRepresentation */ .o)(segmentationId, {
            viewport,
        });
        if (!SurfaceData) {
            throw new Error(`No Surface data found for segmentationId ${segmentationId}.`);
        }
    }
    const { geometryIds } = SurfaceData;
    if (!geometryIds?.size) {
        console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);
    }
    const { colorLUTIndex } = representation;
    const colorLUT = (0,_stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_5__/* .getColorLUT */ .B)(colorLUTIndex);
    const surfaces = [];
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        if (!geometry?.data) {
            console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);
            return;
        }
        const segmentIndex = geometry.data.segmentIndex;
        const surface = geometry.data;
        const color = colorLUT[segmentIndex];
        surface.color = color.slice(0, 3);
        surfaces.push(surface);
        (0,_addOrUpdateSurfaceToElement__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewport.element, surface, segmentationId);
    });
    viewport.render();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});



/***/ }),

/***/ 48736:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85817);
/* harmony import */ var _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17492);
/* harmony import */ var _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1989);
/* harmony import */ var _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56789);
/* harmony import */ var _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33852);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(99737);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(89578);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(98870);
/* harmony import */ var _stateManagement_segmentation_segmentLocking__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(26795);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(60740);
/* harmony import */ var _stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(93733);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(67165);
















class BrushTool extends _base__WEBPACK_IMPORTED_MODULE_2__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE_CIRCLE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__/* .fillInsideCircle */ .kr,
                ERASE_INSIDE_CIRCLE: _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_6__/* .eraseInsideCircle */ .r,
                FILL_INSIDE_SPHERE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__/* .fillInsideSphere */ .Jq,
                ERASE_INSIDE_SPHERE: _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_4__/* .eraseInsideSphere */ ._,
                THRESHOLD_INSIDE_CIRCLE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__/* .thresholdInsideCircle */ .q,
                THRESHOLD_INSIDE_SPHERE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__/* .thresholdInsideSphere */ .rd,
            },
            strategySpecificConfiguration: {
                THRESHOLD: {
                    threshold: [-150, -70],
                },
            },
            defaultStrategy: 'FILL_INSIDE_CIRCLE',
            activeStrategy: 'FILL_INSIDE_CIRCLE',
            thresholdVolumeId: null,
            brushSize: 25,
            preview: {
                enabled: false,
                previewColors: {},
                previewTimeMs: 250,
                previewMoveDistance: 8,
                dragMoveDistance: 4,
                dragTimeMs: 500,
            },
            actions: {
                [_enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.AcceptPreview]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.AcceptPreview,
                    bindings: [
                        {
                            key: 'Enter',
                        },
                    ],
                },
                [_enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.RejectPreview]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.RejectPreview,
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._previewData = {
            preview: null,
            element: null,
            timerStart: 0,
            timer: null,
            startPoint: [NaN, NaN],
            isDrag: false,
        };
        this.onSetToolPassive = (evt) => {
            this.disableCursor();
        };
        this.onSetToolEnabled = () => {
            this.disableCursor();
        };
        this.onSetToolDisabled = (evt) => {
            this.disableCursor();
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this._editData = this.createEditData(element);
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
            evt.preventDefault();
            this._previewData.isDrag = false;
            this._previewData.timerStart = Date.now();
            const hoverData = this._hoverData || this.createHoverData(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(hoverData.viewportIdsToRender);
            const operationData = this.getOperationData(element);
            this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.OnInteractionStart);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === _enums__WEBPACK_IMPORTED_MODULE_7__.ToolModes.Active) {
                this.updateCursor(evt);
                if (!this.configuration.preview.enabled) {
                    return;
                }
                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;
                const { currentPoints, element } = evt.detail;
                const { canvas } = currentPoints;
                const { preview, startPoint, timer, timerStart, isDrag } = this._previewData;
                const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.distance */ .Zc.distance(canvas, startPoint);
                const time = Date.now() - timerStart;
                if (delta > previewMoveDistance ||
                    (time > previewTimeMs && delta > dragMoveDistance)) {
                    if (timer) {
                        window.clearTimeout(timer);
                        this._previewData.timer = null;
                    }
                    if (preview && !isDrag) {
                        this.rejectPreview(element);
                    }
                }
                if (!this._previewData.timer) {
                    const timer = window.setTimeout(this.previewCallback, 250);
                    Object.assign(this._previewData, {
                        timerStart: Date.now(),
                        timer,
                        startPoint: canvas,
                        element,
                    });
                }
            }
        };
        this.previewCallback = () => {
            this._previewData.timer = null;
            if (this._previewData.preview) {
                return;
            }
            this._previewData.preview = this.applyActiveStrategyCallback((0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._previewData.element), this.getOperationData(this._previewData.element), _enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.Preview);
        };
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.updateCursor(evt);
            const { viewportIdsToRender } = this._hoverData;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
            const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.distance */ .Zc.distance(currentPoints.canvas, this._previewData.startPoint);
            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;
            if (!this._previewData.isDrag &&
                this._previewData.preview &&
                Date.now() - this._previewData.timerStart < dragTimeMs &&
                delta < dragMoveDistance) {
                return;
            }
            this._previewData.preview = this.applyActiveStrategy(enabledElement, this.getOperationData(element));
            this._previewData.element = element;
            this._previewData.timerStart = Date.now() + dragTimeMs;
            this._previewData.isDrag = true;
            this._previewData.startPoint = currentPoints.canvas;
        };
        this._endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = this.getOperationData(element);
            if (!this._previewData.preview && !this._previewData.isDrag) {
                this.applyActiveStrategy(enabledElement, operationData);
            }
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
            this.updateCursor(evt);
            this._editData = null;
            this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.OnInteractionEnd);
            if (!this._previewData.isDrag) {
                this.acceptPreview(element);
            }
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    disableCursor() {
        this._hoverData = undefined;
        this.rejectPreview();
    }
    createEditData(element) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const activeSegmentation = (0,_stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_15__/* .getActiveSegmentation */ .T)(viewport.id);
        if (!activeSegmentation) {
            const event = new CustomEvent(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ERROR_EVENT, {
                detail: {
                    type: 'Segmentation',
                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',
                },
                cancelable: true,
            });
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.dispatchEvent(event);
            return null;
        }
        const { segmentationId } = activeSegmentation;
        const segmentsLocked = (0,_stateManagement_segmentation_segmentLocking__WEBPACK_IMPORTED_MODULE_12__.getLockedSegmentIndices)(segmentationId);
        const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_11__.getSegmentation)(segmentationId);
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const { volumeId } = representationData[_enums__WEBPACK_IMPORTED_MODULE_7__.SegmentationRepresentations.Labelmap];
            const actors = viewport.getActors();
            const isStackViewport = viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport;
            if (isStackViewport) {
                const event = new CustomEvent(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ERROR_EVENT, {
                    detail: {
                        type: 'Segmentation',
                        message: 'Cannot perform brush operation on the selected viewport',
                    },
                    cancelable: true,
                });
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.dispatchEvent(event);
                return null;
            }
            const volumes = actors.map((actorEntry) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(actorEntry.referencedId));
            const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            const referencedVolumeIdToThreshold = volumes.find((volume) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;
            return {
                volumeId,
                referencedVolumeId: this.configuration.thresholdVolumeId ?? referencedVolumeIdToThreshold,
                segmentsLocked,
            };
        }
        else {
            const segmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_11__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
            if (!segmentationImageId) {
                return;
            }
            if (this.configuration.activeStrategy.includes('SPHERE')) {
                const referencedImageIds = viewport.getImageIds();
                const isValidVolumeForSphere = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
                if (!isValidVolumeForSphere) {
                    throw new Error('Volume is not reconstructable for sphere manipulation');
                }
                const volumeId = `${segmentationId}_${viewport.id}`;
                const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                if (volume) {
                    return {
                        imageId: segmentationImageId,
                        segmentsLocked,
                        override: {
                            voxelManager: volume.voxelManager,
                            imageData: volume.imageData,
                        },
                    };
                }
                else {
                    const labelmapImageIds = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_11__.getStackSegmentationImageIdsForViewport)(viewport.id, segmentationId);
                    if (!labelmapImageIds || labelmapImageIds.length === 1) {
                        return {
                            imageId: segmentationImageId,
                            segmentsLocked,
                        };
                    }
                    const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);
                    return {
                        imageId: segmentationImageId,
                        segmentsLocked,
                        override: {
                            voxelManager: volume.voxelManager,
                            imageData: volume.imageData,
                        },
                    };
                }
            }
            else {
                return {
                    imageId: segmentationImageId,
                    segmentsLocked,
                };
            }
        }
    }
    createHoverData(element, centerCanvas) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const viewportIdsToRender = [viewport.id];
        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};
        const brushCursor = {
            metadata: {
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                referencedImageId: '',
                toolName: this.getToolName(),
                segmentColor,
            },
            data: {},
        };
        return {
            brushCursor,
            centerCanvas,
            segmentIndex,
            viewport,
            segmentationId,
            segmentColor,
            viewportIdsToRender,
        };
    }
    getActiveSegmentationData(viewport) {
        const viewportId = viewport.id;
        const activeRepresentation = (0,_stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_15__/* .getActiveSegmentation */ .T)(viewportId);
        if (!activeRepresentation) {
            return;
        }
        const { segmentationId } = activeRepresentation;
        const segmentIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_13__/* .getActiveSegmentIndex */ .Q)(segmentationId);
        if (!segmentIndex) {
            return;
        }
        const segmentColor = (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_14__.getSegmentIndexColor)(viewportId, segmentationId, segmentIndex);
        return {
            segmentIndex,
            segmentationId,
            segmentColor,
        };
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const { element } = eventData;
        const { currentPoints } = eventData;
        const centerCanvas = currentPoints.canvas;
        this._hoverData = this.createHoverData(element, centerCanvas);
        this._calculateCursor(element, centerCanvas);
        if (!this._hoverData) {
            return;
        }
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this._hoverData.viewportIdsToRender);
    }
    getOperationData(element) {
        const editData = this._editData || this.createEditData(element);
        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);
        const { data, metadata = {} } = brushCursor || {};
        const { viewPlaneNormal, viewUp } = metadata;
        const operationData = {
            ...editData,
            points: data?.handles?.points,
            segmentIndex,
            previewColors: this.configuration.preview.enabled
                ? this.configuration.preview.previewColors
                : null,
            viewPlaneNormal,
            toolGroupId: this.toolGroupId,
            segmentationId,
            viewUp,
            strategySpecificConfiguration: this.configuration.strategySpecificConfiguration,
            preview: this._previewData?.preview,
        };
        return operationData;
    }
    _calculateCursor(element, centerCanvas) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvasToWorld } = viewport;
        const camera = viewport.getCamera();
        const { brushSize } = this.configuration;
        const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
        const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.cross */ .eR.cross(viewRight, viewUp, viewPlaneNormal);
        const centerCursorInWorld = canvasToWorld([
            centerCanvas[0],
            centerCanvas[1],
        ]);
        const bottomCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const topCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const leftCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const rightCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        for (let i = 0; i <= 2; i++) {
            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;
            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;
            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;
            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;
        }
        if (!this._hoverData) {
            return;
        }
        const { brushCursor } = this._hoverData;
        const { data } = brushCursor;
        if (data.handles === undefined) {
            data.handles = {};
        }
        data.handles.points = [
            bottomCursorInWorld,
            topCursorInWorld,
            leftCursorInWorld,
            rightCursorInWorld,
        ];
        const activeStrategy = this.configuration.activeStrategy;
        const strategy = this.configuration.strategies[activeStrategy];
        if (typeof strategy.computeInnerCircleRadius === 'function') {
            strategy.computeInnerCircleRadius({
                configuration: this.configuration,
                viewport,
            });
        }
        data.invalidated = false;
    }
    rejectPreview(element = this._previewData.element) {
        if (!element || !this._previewData.preview) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.RejectPreview);
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    acceptPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.AcceptPreview);
        this._previewData.isDrag = false;
        this._previewData.preview = null;
    }
    invalidateBrushCursor() {
        if (this._hoverData === undefined) {
            return;
        }
        const { data } = this._hoverData.brushCursor;
        const { viewport } = this._hoverData;
        data.invalidated = true;
        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};
        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this._hoverData) {
            return;
        }
        const { viewport } = enabledElement;
        const viewportIdsToRender = this._hoverData.viewportIdsToRender;
        if (!viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const brushCursor = this._hoverData.brushCursor;
        if (brushCursor.data.invalidated === true) {
            const { centerCanvas } = this._hoverData;
            const { element } = viewport;
            this._calculateCursor(element, centerCanvas);
        }
        const toolMetadata = brushCursor.metadata;
        if (!toolMetadata) {
            return;
        }
        const annotationUID = toolMetadata.brushCursorUID;
        const data = brushCursor.data;
        const { points } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const bottom = canvasCoordinates[0];
        const top = canvasCoordinates[1];
        const center = [
            Math.floor((bottom[0] + top[0]) / 2),
            Math.floor((bottom[1] + top[1]) / 2),
        ];
        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;
        if (!viewport.getRenderingEngine()) {
            console.warn('Rendering Engine has been destroyed');
            return;
        }
        const circleUID = '0';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
            color,
        });
        const activeStrategy = this.configuration.activeStrategy;
        const { dynamicRadiusInCanvas } = this.configuration
            .strategySpecificConfiguration[activeStrategy] || {
            dynamicRadiusInCanvas: 0,
        };
        if (dynamicRadiusInCanvas) {
            const circleUID1 = '1';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawCircle)(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {
                color,
            });
        }
    }
}
BrushTool.toolName = 'Brush';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushTool);


/***/ }),

/***/ 67847:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4096);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3823);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2076);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(89578);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8056);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27730);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(66990);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(35489);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(29601);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(44049);
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(4010);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(79362);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(13165);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(40634);



















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class RectangleROIStartEndThresholdTool extends _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            storePointData: false,
            numSlicesToPropagate: 10,
            computePointsInsideVolume: false,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_16__.BasicStatsCalculator,
            showTextBox: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            let referencedImageId, imageVolume, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                throw new Error('Stack Viewport Not implemented');
            }
            else {
                const targetId = this.getTargetId(viewport);
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const spacingInNormal = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
            const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);
            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    enabledElement,
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                    volumeId,
                    spacingInNormal,
                },
                data: {
                    label: '',
                    startCoordinate: startCoord,
                    endCoordinate: endCoord,
                    cachedStats: {
                        pointsInVolume: [],
                        projectionPoints: [],
                        projectionPointsImageIds: [referencedImageId],
                        statistics: [],
                    },
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    labelmapUID: null,
                },
            };
            this._computeProjectionPoints(annotation, imageVolume);
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .removeAnnotation */ .O8)(annotation.annotationUID);
            }
            const targetId = this.getTargetId(enabledElement.viewport);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
            if (this.configuration.calculatePointsInsideVolume) {
                this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__/* .triggerAnnotationCompleted */ .dZ)(annotation);
            }
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .getAnnotations */ .Rh)(this.getToolName(), viewport.element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_17__.filterAnnotationsWithinSamePlane)(annotations, viewport.getCamera());
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { startCoordinate, endCoordinate } = data;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const focalPoint = viewport.getCamera().focalPoint;
                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
                let startCoord = startCoordinate;
                let endCoord = endCoordinate;
                if (Array.isArray(startCoordinate)) {
                    startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);
                    data.startCoordinate = startCoord;
                    data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = startCoord;
                    data.startCoordinate = startCoord;
                    data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = startCoord;
                }
                if (Array.isArray(endCoordinate)) {
                    endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);
                    data.endCoordinate = endCoord;
                    data.endCoordinate = endCoord;
                }
                const roundedStartCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(startCoord);
                const roundedEndCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(endCoord);
                const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
                const roundedCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(coord);
                if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||
                    roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {
                    continue;
                }
                if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, enabledElement);
                }
                let firstOrLastSlice = false;
                if (roundedCoord === roundedStartCoord ||
                    roundedCoord === roundedEndCoord) {
                    firstOrLastSlice = true;
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_10__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    firstOrLastSlice) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                let lineDashToUse = lineDash;
                if (!firstOrLastSlice) {
                    lineDashToUse = 2;
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash: lineDashToUse,
                    lineWidth,
                });
                renderStatus = true;
                if (this.configuration.showTextBox &&
                    this.configuration.calculatePointsInsideVolume) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data);
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    if (!data.handles.textBox.hasMoved) {
                        const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_8__.getTextBoxCoordsCanvas)(canvasCoordinates);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(this._calculateCachedStatsTool, 100, { trailing: true });
    }
    _computeProjectionPoints(annotation, imageVolume) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, spacingInNormal } = metadata;
        const { imageData } = imageVolume;
        const { startCoordinate, endCoordinate } = data;
        const { points } = data.handles;
        const startIJK = transformWorldToIndex(imageData, points[0]);
        const endIJK = transformWorldToIndex(imageData, points[0]);
        const startWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        imageData.indexToWorldVec3(startIJK, startWorld);
        const endWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        imageData.indexToWorldVec3(endIJK, endWorld);
        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
            startWorld[2] = startCoordinate;
            endWorld[2] = endCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
            startWorld[0] = startCoordinate;
            endWorld[0] = endCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
            startWorld[1] = startCoordinate;
            endWorld[1] = endCoordinate;
        }
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.distance */ .eR.distance(startWorld, endWorld);
        const newProjectionPoints = [];
        for (let dist = 0; dist < distance; dist += spacingInNormal) {
            newProjectionPoints.push(points.map((point) => {
                const newPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
                return Array.from(newPoint);
            }));
        }
        data.cachedStats.projectionPoints = newProjectionPoints;
    }
    _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, viewUp } = metadata;
        const { viewport } = enabledElement;
        const projectionPoints = data.cachedStats.projectionPoints;
        const pointsInsideVolume = [[]];
        const image = this.getTargetImageData(targetId);
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[3];
        const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
        const measureInfo = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, data.habdles);
        const area = Math.abs(worldWidth * worldHeight) /
            (measureInfo.scale * measureInfo.scale);
        const modalityUnitOptions = {
            isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_15__/* .isViewportPreScaled */ .u)(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
        };
        const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_18__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        for (let i = 0; i < projectionPoints.length; i++) {
            if (!imageVolume) {
                continue;
            }
            const projectionPoint = projectionPoints[i][0];
            const { dimensions, imageData, voxelManager } = imageVolume;
            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);
            const worldProjectionPointIndex = transformWorldToIndex(imageData, projectionPoint);
            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
            worldPos1Index[0] = Math.floor(worldPos1Index[0]);
            worldPos1Index[1] = Math.floor(worldPos1Index[1]);
            worldPos1Index[2] = Math.floor(worldPos1Index[2]);
            worldPos1Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);
            worldPos2Index[0] = Math.floor(worldPos2Index[0]);
            worldPos2Index[1] = Math.floor(worldPos2Index[1]);
            worldPos2Index[2] = Math.floor(worldPos2Index[2]);
            worldPos2Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                this.isHandleOutsideImage = false;
                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    boundsIJK,
                    imageData,
                    returnPoints: this.configuration.storePointData,
                });
                pointsInsideVolume.push(pointsInShape);
            }
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        data.cachedStats.pointsInVolume = pointsInsideVolume;
        data.cachedStats.statistics = {
            Modality: metadata.Modality,
            area,
            mean: stats.mean?.value,
            stdDev: stats.stdDev?.value,
            max: stats.max?.value,
            statsArray: stats.array,
            areaUnit: measureInfo.areaUnit,
            modalityUnit,
        };
    }
    _calculateCachedStatsTool(annotation, enabledElement) {
        const data = annotation.data;
        const { viewport } = enabledElement;
        const { cachedStats } = data;
        const targetId = this.getTargetId(viewport);
        const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
        this._computeProjectionPoints(annotation, imageVolume);
        if (this.configuration.calculatePointsInsideVolume) {
            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
        }
        if (this.configuration.calculatePointsInsideVolume) {
            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
        }
        annotation.invalidated = false;
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__/* .triggerAnnotationModified */ .XF)(annotation, viewport.element);
        return cachedStats;
    }
    _getStartCoordinate(worldPos, viewPlaneNormal) {
        const startPos = worldPos;
        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
        return startCoord;
    }
    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const endPos = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);
        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
        return endCoord;
    }
    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
        const viewplaneNormalAbs = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
        return indexOfDirection;
    }
    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        return pos[indexOfDirection];
    }
}
function defaultGetTextLines(data) {
    const cachedVolumeStats = data.cachedStats.statistics;
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
RectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROIStartEndThresholdTool);


/***/ }),

/***/ 40336:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2076);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89578);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8056);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4010);










class RectangleROIThresholdTool extends _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const targetId = this.getTargetId(viewport);
            let referencedImageId, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                referencedImageId = targetId.split('imageId:')[1];
            }
            else {
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    enabledElement,
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                    volumeId,
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: null,
                            worldBoundingBox: null,
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    segmentationId: null,
                },
            };
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__/* .getAnnotations */ .Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__/* .triggerAnnotationModified */ .XF)(annotation, element);
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                });
                renderStatus = true;
            }
            return renderStatus;
        };
    }
}
RectangleROIThresholdTool.toolName = 'RectangleROIThreshold';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROIThresholdTool);


/***/ }),

/***/ 93126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ ContourWindingDirection)
/* harmony export */ });
var ContourWindingDirection;
(function (ContourWindingDirection) {
    ContourWindingDirection[ContourWindingDirection["CounterClockwise"] = -1] = "CounterClockwise";
    ContourWindingDirection[ContourWindingDirection["Unknown"] = 0] = "Unknown";
    ContourWindingDirection[ContourWindingDirection["Clockwise"] = 1] = "Clockwise";
})(ContourWindingDirection || (ContourWindingDirection = {}));


/***/ }),

/***/ 13369:
/***/ (() => {



/***/ }),

/***/ 64843:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addContourSegmentationAnnotation: () => (/* reexport safe */ _addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_2__.V),
/* harmony export */   areSameSegment: () => (/* reexport safe */ _areSameSegment__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   isContourSegmentationAnnotation: () => (/* reexport safe */ _isContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   removeContourSegmentationAnnotation: () => (/* reexport safe */ _removeContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_3__.M)
/* harmony export */ });
/* harmony import */ var _areSameSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62854);
/* harmony import */ var _isContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78130);
/* harmony import */ var _addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85263);
/* harmony import */ var _removeContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37354);






/***/ }),

/***/ 15295:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getViewportsForAnnotation)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);

const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function getViewportsForAnnotation(annotation) {
    const { metadata } = annotation;
    return (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElements)()
        .filter((enabledElement) => {
        if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {
            const viewport = enabledElement.viewport;
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            return (isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&
                (!metadata.viewUp || isEqual(viewUp, metadata.viewUp)));
        }
        return;
    })
        .map((enabledElement) => enabledElement.viewport);
}


/***/ }),

/***/ 23566:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  annotationFrameRange: () => (/* reexport */ annotationFrameRange/* default */.A),
  annotationHydration: () => (/* reexport */ annotationHydration/* annotationHydration */.i),
  boundingBox: () => (/* reexport */ boundingBox),
  calibrateImageSpacing: () => (/* reexport */ calibrateImageSpacing/* default */.A),
  cine: () => (/* reexport */ cine),
  contourSegmentation: () => (/* reexport */ contourSegmentation),
  contours: () => (/* reexport */ contours),
  debounce: () => (/* reexport */ debounce/* default */.A),
  drawing: () => (/* reexport */ drawing),
  dynamicVolume: () => (/* reexport */ dynamicVolume),
  getAnnotationNearPoint: () => (/* reexport */ getAnnotationNearPoint/* getAnnotationNearPoint */.S),
  getAnnotationNearPointOnEnabledElement: () => (/* reexport */ getAnnotationNearPoint/* getAnnotationNearPointOnEnabledElement */.s),
  getCalibratedAspect: () => (/* reexport */ getCalibratedUnits/* getCalibratedAspect */.CQ),
  getCalibratedLengthUnitsAndScale: () => (/* reexport */ getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op),
  getCalibratedProbeUnitsAndValue: () => (/* reexport */ getCalibratedUnits/* getCalibratedProbeUnitsAndValue */.Xw),
  getClosestImageIdForStackViewport: () => (/* reexport */ annotationHydration/* getClosestImageIdForStackViewport */.x),
  getSphereBoundsInfo: () => (/* reexport */ getSphereBoundsInfo/* getSphereBoundsInfo */.R),
  getViewportForAnnotation: () => (/* reexport */ getViewportForAnnotation/* default */.A),
  isObject: () => (/* reexport */ isObject/* default */.A),
  math: () => (/* reexport */ math),
  orientation: () => (/* reexport */ orientation_namespaceObject),
  planar: () => (/* reexport */ planar),
  planarFreehandROITool: () => (/* reexport */ planarFreehandROITool),
  pointInSurroundingSphereCallback: () => (/* reexport */ pointInSurroundingSphereCallback/* pointInSurroundingSphereCallback */.i),
  pointToString: () => (/* reexport */ pointToString/* pointToString */.l),
  polyDataUtils: () => (/* reexport */ utils),
  rectangleROITool: () => (/* reexport */ rectangleROITool),
  roundNumber: () => (/* binding */ roundNumber),
  segmentation: () => (/* reexport */ segmentation),
  stackContextPrefetch: () => (/* reexport */ stackPrefetch/* stackContextPrefetch */.N),
  stackPrefetch: () => (/* reexport */ stackPrefetch/* stackPrefetch */.S),
  throttle: () => (/* reexport */ throttle/* default */.A),
  touch: () => (/* reexport */ touch),
  triggerAnnotationRender: () => (/* reexport */ triggerAnnotationRender/* default */.A),
  triggerAnnotationRenderForToolGroupIds: () => (/* reexport */ triggerAnnotationRenderForToolGroupIds/* default */.A),
  triggerAnnotationRenderForViewportIds: () => (/* reexport */ triggerAnnotationRenderForViewportIds/* default */.A),
  triggerEvent: () => (/* reexport */ esm.triggerEvent),
  viewport: () => (/* reexport */ viewport),
  viewportFilters: () => (/* reexport */ viewportFilters),
  voi: () => (/* reexport */ voi)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/index.js
var orientation_namespaceObject = {};
__webpack_require__.r(orientation_namespaceObject);
__webpack_require__.d(orientation_namespaceObject, {
  getOrientationStringLPS: () => (getOrientationStringLPS/* default */.A),
  invertOrientationStringLPS: () => (invertOrientationStringLPS/* default */.A)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js
var esm = __webpack_require__(81985);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js
var getAnnotationNearPoint = __webpack_require__(41293);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js
var debounce = __webpack_require__(52905);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js
var throttle = __webpack_require__(27730);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js
var isObject = __webpack_require__(45217);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js
var calibrateImageSpacing = __webpack_require__(58271);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js
var getCalibratedUnits = __webpack_require__(4096);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js
var triggerAnnotationRenderForViewportIds = __webpack_require__(58640);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js
var triggerAnnotationRenderForToolGroupIds = __webpack_require__(94779);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js
var triggerAnnotationRender = __webpack_require__(56069);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js
var getSphereBoundsInfo = __webpack_require__(4296);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js
var pointToString = __webpack_require__(38726);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationFrameRange.js
var annotationFrameRange = __webpack_require__(73961);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js
var getViewportForAnnotation = __webpack_require__(62514);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js
var annotationHydration = __webpack_require__(64485);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js + 8 modules
var contours = __webpack_require__(54010);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js + 15 modules
var segmentation = __webpack_require__(67470);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js + 1 modules
var drawing = __webpack_require__(66990);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js
var math = __webpack_require__(95527);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js
var planar = __webpack_require__(13165);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js + 4 modules
var viewportFilters = __webpack_require__(8056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js
var getOrientationStringLPS = __webpack_require__(7193);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js
var invertOrientationStringLPS = __webpack_require__(2786);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/index.js




// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/index.js + 3 modules
var cine = __webpack_require__(43488);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js
var boundingBox = __webpack_require__(72282);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js + 1 modules
var planarFreehandROITool = __webpack_require__(66129);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/index.js
var rectangleROITool = __webpack_require__(74866);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/index.js + 4 modules
var stackPrefetch = __webpack_require__(4850);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/index.js
var viewport = __webpack_require__(19027);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js
var touch = __webpack_require__(76260);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/index.js + 2 modules
var dynamicVolume = __webpack_require__(74609);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js
var utils = __webpack_require__(32994);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/index.js + 4 modules
var voi = __webpack_require__(93575);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js
var contourSegmentation = __webpack_require__(64843);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js
var pointInSurroundingSphereCallback = __webpack_require__(10261);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js


































const roundNumber = esm.utilities.roundNumber;



/***/ }),

/***/ 95527:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicStatsCalculator: () => (/* reexport module object */ _basic__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   aabb: () => (/* reexport module object */ _aabb__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   ellipse: () => (/* reexport module object */ _ellipse__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   lineSegment: () => (/* reexport module object */ _line__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   point: () => (/* reexport module object */ _point__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   polyline: () => (/* reexport module object */ _polyline__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   rectangle: () => (/* reexport module object */ _rectangle__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   vec2: () => (/* reexport module object */ _vec2__WEBPACK_IMPORTED_MODULE_7__)
/* harmony export */ });
/* harmony import */ var _aabb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88638);
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79362);
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87009);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93258);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29614);
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(92984);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(92282);
/* harmony import */ var _vec2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(23324);











/***/ }),

/***/ 90554:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ findClosestPoint)
/* harmony export */ });
function findClosestPoint(sourcePoints, targetPoint) {
    let minPoint = [0, 0];
    let minDistance = Number.MAX_SAFE_INTEGER;
    sourcePoints.forEach(function (sourcePoint) {
        const distance = _distanceBetween(targetPoint, sourcePoint);
        if (distance < minDistance) {
            minDistance = distance;
            minPoint = [...sourcePoint];
        }
    });
    return minPoint;
}
function _distanceBetween(p1, p2) {
    const [x1, y1] = p1;
    const [x2, y2] = p2;
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}


/***/ }),

/***/ 25758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ getUniqueSegmentIndices)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64063);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33283);




function getUniqueSegmentIndices(segmentationId) {
    const cachedResult = (0,_utilities__WEBPACK_IMPORTED_MODULE_2__/* .getCachedSegmentIndices */ .R1)(segmentationId);
    if (cachedResult) {
        return cachedResult;
    }
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);
    }
    let indices;
    if (segmentation.representationData.Labelmap) {
        indices = handleLabelmapSegmentation(segmentation, segmentationId);
    }
    else if (segmentation.representationData.Contour) {
        indices = handleContourSegmentation(segmentation);
    }
    else if (segmentation.representationData.Surface) {
        indices = handleSurfaceSegmentation(segmentation);
    }
    else {
        throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);
    }
    (0,_utilities__WEBPACK_IMPORTED_MODULE_2__/* .setCachedSegmentIndices */ .Dm)(segmentationId, indices);
    return indices;
}
function handleLabelmapSegmentation(segmentation, segmentationId) {
    const labelmapData = segmentation.representationData[_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap];
    const keySet = new Set();
    if (labelmapData.imageIds) {
        addImageSegmentIndices(keySet, labelmapData.imageIds);
    }
    else {
        addVolumeSegmentIndices(keySet, segmentationId);
    }
    return Array.from(keySet)
        .map(Number)
        .sort((a, b) => a - b);
}
function addVolumeSegmentIndices(keySet, segmentationId) {
    const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationId);
    volume.voxelManager.forEach(({ value }) => {
        if (value !== 0) {
            keySet.add(value);
        }
    });
}
function addImageSegmentIndices(keySet, imageIds) {
    imageIds.forEach((segmentationImageId) => {
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
        const scalarData = image.voxelManager.getScalarData();
        scalarData.forEach((segmentIndex) => {
            if (segmentIndex !== 0) {
                keySet.add(segmentIndex);
            }
        });
    });
}
function handleContourSegmentation(segmentation) {
    const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};
    if (!geometryIds) {
        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);
    }
    const indices = new Set([...annotationUIDsMap.keys()]);
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        indices.add(geometry.data.segmentIndex);
    });
    return Array.from(indices).sort((a, b) => a - b);
}
function handleSurfaceSegmentation(segmentation) {
    const geometryIds = segmentation.representationData.Surface?.geometryIds ?? [];
    return Array.from(geometryIds.keys())
        .map(Number)
        .sort((a, b) => a - b);
}



/***/ }),

/***/ 35706:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ invalidateBrushCursor)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7754);
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14957);



function invalidateBrushCursor(toolGroupId) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__/* .getBrushToolInstances */ .n)(toolGroupId);
    brushBasedToolInstances.forEach((tool) => {
        tool.invalidateBrushCursor();
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
    if (!viewportsInfoArray.length) {
        return;
    }
    const viewportIds = toolGroup.getViewportIds();
    (0,_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewportIds);
}


/***/ }),

/***/ 64063:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dm: () => (/* binding */ setCachedSegmentIndices),
/* harmony export */   HM: () => (/* binding */ setSegmentationDirty),
/* harmony export */   Q5: () => (/* binding */ getVoxelOverlap),
/* harmony export */   R1: () => (/* binding */ getCachedSegmentIndices),
/* harmony export */   zf: () => (/* binding */ processVolumes)
/* harmony export */ });
/* unused harmony export setSegmentationClean */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87063);


const equalsCheck = (a, b) => {
    return JSON.stringify(a) === JSON.stringify(b);
};
function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {
    const halfSpacingX = voxelSpacing[0] / 2;
    const halfSpacingY = voxelSpacing[1] / 2;
    const halfSpacingZ = voxelSpacing[2] / 2;
    const voxelCornersIJK = new Array(8);
    voxelCornersIJK[0] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, [
        voxelCenter[0] - halfSpacingX,
        voxelCenter[1] - halfSpacingY,
        voxelCenter[2] - halfSpacingZ,
    ]);
    const offsets = [
        [1, -1, -1],
        [-1, 1, -1],
        [1, 1, -1],
        [-1, -1, 1],
        [1, -1, 1],
        [-1, 1, 1],
        [1, 1, 1],
    ];
    for (let i = 0; i < 7; i++) {
        const [xOff, yOff, zOff] = offsets[i];
        voxelCornersIJK[i + 1] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, [
            voxelCenter[0] + xOff * halfSpacingX,
            voxelCenter[1] + yOff * halfSpacingY,
            voxelCenter[2] + zOff * halfSpacingZ,
        ]);
    }
    return (0,_boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__/* .getBoundingBoxAroundShapeIJK */ .g)(voxelCornersIJK, dimensions);
}
function processVolumes(segmentationVolume, thresholdVolumeInformation) {
    const { spacing: segmentationSpacing } = segmentationVolume;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    const volumeInfoList = [];
    let baseVolumeIdx = 0;
    for (let i = 0; i < thresholdVolumeInformation.length; i++) {
        const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;
        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
        if (volumeSize === scalarDataLength &&
            equalsCheck(spacing, segmentationSpacing)) {
            baseVolumeIdx = i;
        }
        const lower = thresholdVolumeInformation[i].lower;
        const upper = thresholdVolumeInformation[i].upper;
        volumeInfoList.push({
            imageData,
            lower,
            upper,
            spacing,
            dimensions,
            volumeSize,
            voxelManager,
        });
    }
    return {
        volumeInfoList,
        baseVolumeIdx,
    };
}
const segmentIndicesCache = new Map();
const setSegmentationDirty = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = true;
    }
};
const setSegmentationClean = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = false;
    }
};
const getCachedSegmentIndices = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached && !cached.isDirty) {
        return cached.indices;
    }
    return null;
};
const setCachedSegmentIndices = (segmentationId, indices) => {
    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });
};


/***/ }),

/***/ 58640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   t: () => (/* binding */ triggerAnnotationRenderForViewportIds)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81985);
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56069);


function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {
    if (!viewportIdsToRender.length) {
        return;
    }
    viewportIdsToRender.forEach((viewportId) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            console.warn(`Viewport not available for ${viewportId}`);
            return;
        }
        const { viewport } = enabledElement;
        if (!viewport) {
            console.warn(`Viewport not available for ${viewportId}`);
            return;
        }
        const element = viewport.element;
        (0,_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(element);
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRenderForViewportIds);


/***/ }),

/***/ 28802:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Colorbar: () => (/* reexport safe */ _Colorbar__WEBPACK_IMPORTED_MODULE_1__.P),
/* harmony export */   Enums: () => (/* reexport module object */ _enums__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   ViewportColorbar: () => (/* reexport safe */ _ViewportColorbar__WEBPACK_IMPORTED_MODULE_2__.b)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51807);
/* harmony import */ var _Colorbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24605);
/* harmony import */ var _ViewportColorbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91008);






/***/ }),

/***/ 93008:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ })

}]);