(self["webpackChunk"] = self["webpackChunk"] || []).push([[8523],{

/***/ 46347:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33739);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction_ColorMaps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(660);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99341);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3823);
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49038);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19325);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(31749);
/* harmony import */ var _enums_ViewportType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(41864);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(10364);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(59693);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(69372);
/* harmony import */ var _utilities_colormap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(13859);
/* harmony import */ var _utilities_invertRgbTransferFunction__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(50134);
/* harmony import */ var _utilities_createSigmoidRGBTransferFunction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(40256);
/* harmony import */ var _utilities_transformWorldToIndex__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(38669);
/* harmony import */ var _utilities_transferFunctionUtils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(85745);
/* harmony import */ var _helpers_createVolumeActor__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(61640);
/* harmony import */ var _helpers_volumeNewImageEventDispatcher__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(90740);
/* harmony import */ var _Viewport__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(10056);
/* harmony import */ var _vtkClasses_vtkSlabCamera__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(17232);
/* harmony import */ var _utilities_getVolumeViewportScrollInfo__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(61375);
/* harmony import */ var _utilities_actorCheck__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(98039);
/* harmony import */ var _utilities_snapFocalPointToSlice__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(80500);
/* harmony import */ var _utilities_getVoiFromSigmoidRGBTransferFunction__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(70210);
/* harmony import */ var _utilities_isEqual__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(74638);
/* harmony import */ var _utilities_applyPreset__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(96833);
/* harmony import */ var _utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(39537);
/* harmony import */ var _utilities_uuidv4__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(80221);





























class BaseVolumeViewport extends _Viewport__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .A {
    constructor(props) {
        super(props);
        this.useCPURendering = false;
        this.perVolumeIdDefaultProperties = new Map();
        this.viewportProperties = {};
        this.volumeIds = new Set();
        this.setRotation = (rotation) => {
            const panFit = this.getPan(this.fitToCanvasCamera);
            const pan = this.getPan();
            const previousCamera = this.getCamera();
            const panSub = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.sub */ .Zc.sub([0, 0], panFit, pan);
            this.setPan(panSub, false);
            const { flipVertical } = this.getCamera();
            const initialViewUp = flipVertical
                ? gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate([0, 0, 0], this.initialViewUp)
                : this.initialViewUp;
            this.setCameraNoEvent({
                viewUp: initialViewUp,
            });
            this.rotateCamera(rotation);
            const afterPan = this.getPan();
            const afterPanFit = this.getPan(this.fitToCanvasCamera);
            const newCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.sub */ .Zc.sub([0, 0], afterPan, afterPanFit);
            const newOffset = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.add */ .Zc.add([0, 0], panFit, newCenter);
            this.setPan(newOffset, false);
            if (this._suppressCameraModifiedEvents) {
                return;
            }
            const camera = this.getCamera();
            const eventDetail = {
                previousCamera,
                camera,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.CAMERA_MODIFIED, eventDetail);
        };
        this.getDefaultProperties = (volumeId) => {
            let volumeProperties;
            if (volumeId !== undefined) {
                volumeProperties = this.perVolumeIdDefaultProperties.get(volumeId);
            }
            if (volumeProperties !== undefined) {
                return volumeProperties;
            }
            return {
                ...this.globalDefaultProperties,
            };
        };
        this.getProperties = (volumeId) => {
            const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
            if (!applicableVolumeActorInfo) {
                return;
            }
            const { colormap: latestColormap, VOILUTFunction, interpolationType, invert, slabThickness, preset, } = this.viewportProperties;
            volumeId ||= this.getVolumeId();
            const volume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeId);
            if (!volume) {
                return null;
            }
            const volumeActorEntry = this.getActors().find((actorEntry) => {
                return actorEntry.referencedId === volumeId;
            });
            if (!volumeActorEntry) {
                return;
            }
            const volumeActor = volumeActorEntry.actor;
            const cfun = volumeActor.getProperty().getRGBTransferFunction(0);
            const [lower, upper] = this.viewportProperties?.VOILUTFunction === 'SIGMOID'
                ? (0,_utilities_getVoiFromSigmoidRGBTransferFunction__WEBPACK_IMPORTED_MODULE_23__/* ["default"] */ .A)(cfun)
                : cfun.getRange();
            const voiRange = { lower, upper };
            const volumeColormap = this.getColormap(volumeId);
            const colormap = volumeId && volumeColormap ? volumeColormap : latestColormap;
            return {
                colormap: colormap,
                voiRange: voiRange,
                VOILUTFunction: VOILUTFunction,
                interpolationType: interpolationType,
                invert: invert,
                slabThickness: slabThickness,
                preset,
            };
        };
        this.getColormap = (volumeId) => {
            const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
            if (!applicableVolumeActorInfo) {
                return;
            }
            const { volumeActor } = applicableVolumeActorInfo;
            const cfun = this._getOrCreateColorTransferFunction(volumeId);
            const { nodes } = cfun.getState();
            const RGBPoints = nodes.reduce((acc, node) => {
                acc.push(node.x, node.r, node.g, node.b);
                return acc;
            }, []);
            const matchedColormap = (0,_utilities_colormap__WEBPACK_IMPORTED_MODULE_11__.findMatchingColormap)(RGBPoints, volumeActor);
            return matchedColormap;
        };
        this.getRotation = () => {
            const { viewUp: currentViewUp, viewPlaneNormal, flipVertical, } = this.getCameraNoRotation();
            const initialViewUp = flipVertical
                ? gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate([0, 0, 0], this.initialViewUp)
                : this.initialViewUp;
            if (!initialViewUp) {
                return 0;
            }
            const initialToCurrentViewUpAngle = (gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.angle */ .eR.angle(initialViewUp, currentViewUp) * 180) / Math.PI;
            const initialToCurrentViewUpCross = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.cross */ .eR.cross([0, 0, 0], initialViewUp, currentViewUp);
            const normalDot = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(initialToCurrentViewUpCross, viewPlaneNormal);
            const value = normalDot >= 0
                ? initialToCurrentViewUpAngle
                : (360 - initialToCurrentViewUpAngle) % 360;
            return value;
        };
        this.getFrameOfReferenceUID = () => {
            return this._FrameOfReferenceUID;
        };
        this.canvasToWorld = (canvasPos) => {
            const vtkCamera = this.getVtkActiveCamera();
            vtkCamera.setIsPerformingCoordinateTransformation?.(true);
            const renderer = this.getRenderer();
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasPosWithDPR = [
                canvasPos[0] * devicePixelRatio,
                canvasPos[1] * devicePixelRatio,
            ];
            const displayCoord = [
                canvasPosWithDPR[0] + this.sx,
                canvasPosWithDPR[1] + this.sy,
            ];
            displayCoord[1] = size[1] - displayCoord[1];
            const worldCoord = openGLRenderWindow.displayToWorld(displayCoord[0], displayCoord[1], 0, renderer);
            vtkCamera.setIsPerformingCoordinateTransformation?.(false);
            return [worldCoord[0], worldCoord[1], worldCoord[2]];
        };
        this.worldToCanvas = (worldPos) => {
            const vtkCamera = this.getVtkActiveCamera();
            vtkCamera.setIsPerformingCoordinateTransformation?.(true);
            const renderer = this.getRenderer();
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer);
            displayCoord[1] = size[1] - displayCoord[1];
            const canvasCoord = [
                displayCoord[0] - this.sx,
                displayCoord[1] - this.sy,
            ];
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasCoordWithDPR = [
                canvasCoord[0] / devicePixelRatio,
                canvasCoord[1] / devicePixelRatio,
            ];
            vtkCamera.setIsPerformingCoordinateTransformation(false);
            return canvasCoordWithDPR;
        };
        this.hasImageURI = (imageURI) => {
            const volumeActors = this.getActors().filter((actorEntry) => (0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_21__/* .actorIsA */ .N)(actorEntry, 'vtkVolume'));
            return volumeActors.some(({ uid, referencedId }) => {
                const volume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(referencedId || uid);
                if (!volume?.imageIds) {
                    return false;
                }
                const volumeImageURIs = volume.imageIds.map(_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_26__/* ["default"] */ .A);
                return volumeImageURIs.includes(imageURI);
            });
        };
        this.getImageIds = (volumeId) => {
            const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
            if (!applicableVolumeActorInfo) {
                throw new Error(`No actor found for the given volumeId: ${volumeId}`);
            }
            const volumeIdToUse = applicableVolumeActorInfo.volumeId;
            const imageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeIdToUse);
            if (!imageVolume) {
                throw new Error(`imageVolume with id: ${volumeIdToUse} does not exist in cache`);
            }
            return imageVolume.imageIds;
        };
        this.useCPURendering = (0,_init__WEBPACK_IMPORTED_MODULE_9__/* .getShouldUseCPURendering */ .LH)();
        if (this.useCPURendering) {
            throw new Error('VolumeViewports cannot be used whilst CPU Fallback Rendering is enabled.');
        }
        const renderer = this.getRenderer();
        const camera = _vtkClasses_vtkSlabCamera__WEBPACK_IMPORTED_MODULE_19__/* ["default"].newInstance */ .Ay.newInstance();
        renderer.setActiveCamera(camera);
        switch (this.type) {
            case _enums_ViewportType__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.ORTHOGRAPHIC:
                camera.setParallelProjection(true);
                break;
            case _enums_ViewportType__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.VOLUME_3D:
                camera.setParallelProjection(true);
                break;
            case _enums_ViewportType__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.PERSPECTIVE:
                camera.setParallelProjection(false);
                break;
            default:
                throw new Error(`Unrecognized viewport type: ${this.type}`);
        }
        this.initializeVolumeNewImageEventDispatcher();
    }
    static get useCustomRenderingPipeline() {
        return false;
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    applyViewOrientation(orientation, resetCamera = true) {
        const { viewPlaneNormal, viewUp } = this._getOrientationVectors(orientation);
        const camera = this.getVtkActiveCamera();
        camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        camera.setViewUpFrom(viewUp);
        this.initialViewUp = viewUp;
        if (resetCamera) {
            this.resetCamera();
        }
    }
    initializeVolumeNewImageEventDispatcher() {
        const volumeNewImageHandlerBound = volumeNewImageHandler.bind(this);
        const volumeNewImageCleanUpBound = volumeNewImageCleanUp.bind(this);
        function volumeNewImageHandler(cameraEvent) {
            const { viewportId } = cameraEvent.detail;
            if (viewportId !== this.id || this.isDisabled) {
                return;
            }
            const viewportImageData = this.getImageData();
            if (!viewportImageData) {
                return;
            }
            (0,_helpers_volumeNewImageEventDispatcher__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .A)(cameraEvent);
        }
        function volumeNewImageCleanUp(evt) {
            const { viewportId } = evt.detail;
            if (viewportId !== this.id) {
                return;
            }
            this.element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.CAMERA_MODIFIED, volumeNewImageHandlerBound);
            _eventTarget__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.ELEMENT_DISABLED, volumeNewImageCleanUpBound);
            (0,_helpers_volumeNewImageEventDispatcher__WEBPACK_IMPORTED_MODULE_17__/* .resetVolumeNewImageState */ .g)(viewportId);
        }
        this.element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.CAMERA_MODIFIED, volumeNewImageHandlerBound);
        this.element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.CAMERA_MODIFIED, volumeNewImageHandlerBound);
        _eventTarget__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.ELEMENT_DISABLED, volumeNewImageCleanUpBound);
    }
    setVOILUTFunction(voiLUTFunction, volumeId, suppressEvents) {
        if (!Object.values(_enums__WEBPACK_IMPORTED_MODULE_6__.VOILUTFunctionType).includes(voiLUTFunction)) {
            voiLUTFunction = _enums__WEBPACK_IMPORTED_MODULE_6__.VOILUTFunctionType.LINEAR;
        }
        const { voiRange } = this.getProperties();
        this.setVOI(voiRange, volumeId, suppressEvents);
        this.viewportProperties.VOILUTFunction = voiLUTFunction;
    }
    setColormap(colormap, volumeId, suppressEvents) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
        let colormapObj = _utilities_colormap__WEBPACK_IMPORTED_MODULE_11__.getColormap(colormap.name);
        const { name } = colormap;
        if (!colormapObj) {
            colormapObj = _kitware_vtk_js_Rendering_Core_ColorTransferFunction_ColorMaps__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.getPresetByName(name);
        }
        if (!colormapObj) {
            throw new Error(`Colormap ${colormap} not found`);
        }
        const range = volumeActor
            .getProperty()
            .getRGBTransferFunction(0)
            .getRange();
        cfun.applyColorMap(colormapObj);
        cfun.setMappingRange(range[0], range[1]);
        volumeActor.getProperty().setRGBTransferFunction(0, cfun);
        this.viewportProperties.colormap = colormap;
        if (!suppressEvents) {
            const eventDetail = {
                viewportId: this.id,
                colormap,
                volumeId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.VOI_MODIFIED, eventDetail);
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.COLORMAP_MODIFIED, eventDetail);
        }
    }
    setOpacity(colormap, volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const ofun = _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
        if (typeof colormap.opacity === 'number') {
            const range = volumeActor
                .getProperty()
                .getRGBTransferFunction(0)
                .getRange();
            ofun.addPoint(range[0], colormap.opacity);
            ofun.addPoint(range[1], colormap.opacity);
        }
        else {
            colormap.opacity.forEach(({ opacity, value }) => {
                ofun.addPoint(value, opacity);
            });
        }
        volumeActor.getProperty().setScalarOpacity(0, ofun);
        if (!this.viewportProperties.colormap) {
            this.viewportProperties.colormap = {};
        }
        this.viewportProperties.colormap.opacity = colormap.opacity;
    }
    setInvert(inverted, volumeId, suppressEvents) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const volumeIdToUse = applicableVolumeActorInfo.volumeId;
        const cfun = this._getOrCreateColorTransferFunction(volumeIdToUse);
        (0,_utilities_invertRgbTransferFunction__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(cfun);
        this.viewportProperties.invert = inverted;
        if (!suppressEvents) {
            const eventDetail = {
                ...this.getVOIModifiedEventDetail(volumeIdToUse),
                invertStateChanged: true,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.VOI_MODIFIED, eventDetail);
        }
    }
    getVOIModifiedEventDetail(volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            throw new Error(`No actor found for the given volumeId: ${volumeId}`);
        }
        const volumeActor = applicableVolumeActorInfo.volumeActor;
        const transferFunction = volumeActor
            .getProperty()
            .getRGBTransferFunction(0);
        const range = transferFunction.getMappingRange();
        const matchedColormap = this.getColormap(volumeId);
        const { VOILUTFunction, invert } = this.getProperties(volumeId);
        return {
            viewportId: this.id,
            range: {
                lower: range[0],
                upper: range[1],
            },
            volumeId: applicableVolumeActorInfo.volumeId,
            VOILUTFunction: VOILUTFunction,
            colormap: matchedColormap,
            invert,
        };
    }
    _getOrCreateColorTransferFunction(volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return null;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const rgbTransferFunction = volumeActor
            .getProperty()
            .getRGBTransferFunction(0);
        if (rgbTransferFunction) {
            return rgbTransferFunction;
        }
        const newRGBTransferFunction = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
        volumeActor.getProperty().setRGBTransferFunction(0, newRGBTransferFunction);
        return newRGBTransferFunction;
    }
    setInterpolationType(interpolationType, volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const volumeProperty = volumeActor.getProperty();
        volumeProperty.setInterpolationType(interpolationType);
        this.viewportProperties.interpolationType = interpolationType;
    }
    setVOI(voiRange, volumeId, suppressEvents = false) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const volumeIdToUse = applicableVolumeActorInfo.volumeId;
        const voiRangeToUse = voiRange;
        if (typeof voiRangeToUse === 'undefined') {
            throw new Error('voiRangeToUse is undefined, need to implement this in the new volume model');
        }
        const { VOILUTFunction } = this.getProperties(volumeIdToUse);
        if (VOILUTFunction === _enums__WEBPACK_IMPORTED_MODULE_6__.VOILUTFunctionType.SAMPLED_SIGMOID) {
            const cfun = (0,_utilities_createSigmoidRGBTransferFunction__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A)(voiRangeToUse);
            volumeActor.getProperty().setRGBTransferFunction(0, cfun);
        }
        else {
            const { lower, upper } = voiRangeToUse;
            volumeActor
                .getProperty()
                .getRGBTransferFunction(0)
                .setRange(lower, upper);
        }
        if (!suppressEvents) {
            const eventDetail = {
                ...this.getVOIModifiedEventDetail(volumeIdToUse),
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.VOI_MODIFIED, eventDetail);
        }
        this.viewportProperties.voiRange = voiRangeToUse;
    }
    rotateCamera(rotation) {
        const rotationToApply = rotation - this.getRotation();
        this.getVtkActiveCamera().roll(-rotationToApply);
    }
    setDefaultProperties(ViewportProperties, volumeId) {
        if (volumeId == null) {
            this.globalDefaultProperties = ViewportProperties;
        }
        else {
            this.perVolumeIdDefaultProperties.set(volumeId, ViewportProperties);
        }
    }
    clearDefaultProperties(volumeId) {
        if (volumeId == null) {
            this.globalDefaultProperties = {};
            this.resetProperties();
        }
        else {
            this.perVolumeIdDefaultProperties.delete(volumeId);
            this.resetToDefaultProperties(volumeId);
        }
    }
    getViewReference(viewRefSpecifier = {}) {
        const target = super.getViewReference(viewRefSpecifier);
        const volumeId = this.getVolumeId(viewRefSpecifier);
        if (viewRefSpecifier?.forFrameOfReference !== false) {
            target.volumeId = volumeId;
        }
        if (typeof viewRefSpecifier?.sliceIndex !== 'number') {
            return target;
        }
        const { viewPlaneNormal } = target;
        const delta = viewRefSpecifier?.sliceIndex - this.getSliceIndex();
        const { sliceRangeInfo } = (0,_utilities_getVolumeViewportScrollInfo__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .A)(this, volumeId, true);
        const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;
        const { focalPoint, position } = camera;
        const { newFocalPoint } = (0,_utilities_snapFocalPointToSlice__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
        target.cameraFocalPoint = newFocalPoint;
        return target;
    }
    isReferenceViewable(viewRef, options) {
        if (!viewRef.FrameOfReferenceUID) {
            return false;
        }
        if (!super.isReferenceViewable(viewRef, options)) {
            return false;
        }
        if (options?.withNavigation) {
            return true;
        }
        const currentSliceIndex = this.getSliceIndex();
        const { sliceIndex } = viewRef;
        if (Array.isArray(sliceIndex)) {
            return (sliceIndex[0] <= currentSliceIndex && currentSliceIndex <= sliceIndex[1]);
        }
        return sliceIndex === undefined || sliceIndex === currentSliceIndex;
    }
    scroll(delta = 1) {
        const volumeId = this.getVolumeId();
        const { sliceRangeInfo } = (0,_utilities_getVolumeViewportScrollInfo__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .A)(this, volumeId, true);
        if (!sliceRangeInfo) {
            return;
        }
        const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;
        const { focalPoint, viewPlaneNormal, position } = camera;
        const { newFocalPoint, newPosition } = (0,_utilities_snapFocalPointToSlice__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
        this.setCamera({
            focalPoint: newFocalPoint,
            position: newPosition,
        });
    }
    setViewReference(viewRef) {
        if (!viewRef) {
            return;
        }
        const volumeId = this.getVolumeId();
        const { viewPlaneNormal: refViewPlaneNormal, FrameOfReferenceUID: refFrameOfReference, cameraFocalPoint, viewUp, } = viewRef;
        let { sliceIndex } = viewRef;
        const { focalPoint, viewPlaneNormal, position } = this.getCamera();
        const isNegativeNormal = (0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_24__/* .isEqualNegative */ .WC)(viewPlaneNormal, refViewPlaneNormal);
        const isSameNormal = (0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Ay)(viewPlaneNormal, refViewPlaneNormal);
        if (typeof sliceIndex === 'number' &&
            viewRef.volumeId === volumeId &&
            (isNegativeNormal || isSameNormal)) {
            const { currentStepIndex, sliceRangeInfo, numScrollSteps } = (0,_utilities_getVolumeViewportScrollInfo__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .A)(this, volumeId, true);
            const { sliceRange, spacingInNormalDirection } = sliceRangeInfo;
            if (isNegativeNormal) {
                sliceIndex = numScrollSteps - sliceIndex - 1;
            }
            const delta = sliceIndex - currentStepIndex;
            const { newFocalPoint, newPosition } = (0,_utilities_snapFocalPointToSlice__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
            this.setCamera({ focalPoint: newFocalPoint, position: newPosition });
        }
        else if (refFrameOfReference === this.getFrameOfReferenceUID()) {
            if (refViewPlaneNormal && !isNegativeNormal && !isSameNormal) {
                this.setOrientation({ viewPlaneNormal: refViewPlaneNormal, viewUp });
                this.setViewReference(viewRef);
                return;
            }
            if (cameraFocalPoint) {
                const focalDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract([0, 0, 0], cameraFocalPoint, focalPoint);
                const useNormal = refViewPlaneNormal ?? viewPlaneNormal;
                const normalDot = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(focalDelta, useNormal);
                if (!(0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Ay)(normalDot, 0)) {
                    gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scale */ .eR.scale(focalDelta, useNormal, normalDot);
                }
                const newFocal = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.add */ .eR.add([0, 0, 0], focalPoint, focalDelta);
                const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.add */ .eR.add([0, 0, 0], position, focalDelta);
                this.setCamera({ focalPoint: newFocal, position: newPosition });
            }
        }
        else {
            throw new Error(`Incompatible view refs: ${refFrameOfReference}!==${this.getFrameOfReferenceUID()}`);
        }
    }
    setProperties({ voiRange, VOILUTFunction, invert, colormap, preset, interpolationType, slabThickness, } = {}, volumeId, suppressEvents = false) {
        if (this.globalDefaultProperties == null) {
            this.setDefaultProperties({
                voiRange,
                VOILUTFunction,
                invert,
                colormap,
                preset,
                slabThickness,
            });
        }
        if (invert !== undefined && this.viewportProperties.invert !== invert) {
            this.setInvert(invert, volumeId, suppressEvents);
        }
        if (colormap?.name) {
            this.setColormap(colormap, volumeId, suppressEvents);
        }
        if (colormap?.opacity != null) {
            this.setOpacity(colormap, volumeId);
        }
        if (voiRange !== undefined) {
            this.setVOI(voiRange, volumeId, suppressEvents);
        }
        if (typeof interpolationType !== 'undefined') {
            this.setInterpolationType(interpolationType);
        }
        if (VOILUTFunction !== undefined) {
            this.setVOILUTFunction(VOILUTFunction, volumeId, suppressEvents);
        }
        if (preset !== undefined) {
            this.setPreset(preset, volumeId, suppressEvents);
        }
        if (slabThickness !== undefined) {
            this.setSlabThickness(slabThickness);
            this.viewportProperties.slabThickness = slabThickness;
        }
    }
    resetToDefaultProperties(volumeId) {
        const properties = this.globalDefaultProperties;
        if (properties.colormap?.name) {
            this.setColormap(properties.colormap, volumeId);
        }
        if (properties.colormap?.opacity != null) {
            this.setOpacity(properties.colormap, volumeId);
        }
        if (properties.voiRange !== undefined) {
            this.setVOI(properties.voiRange, volumeId);
        }
        if (properties.VOILUTFunction !== undefined) {
            this.setVOILUTFunction(properties.VOILUTFunction, volumeId);
        }
        if (properties.invert !== undefined) {
            this.setInvert(properties.invert, volumeId);
        }
        if (properties.slabThickness !== undefined) {
            this.setSlabThickness(properties.slabThickness);
            this.viewportProperties.slabThickness = properties.slabThickness;
        }
        if (properties.preset !== undefined) {
            this.setPreset(properties.preset, volumeId, false);
        }
        if (properties.preset !== undefined) {
            this.setPreset(properties.preset, volumeId, false);
        }
        this.render();
    }
    setPreset(presetNameOrObj, volumeId, suppressEvents) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        let preset = presetNameOrObj;
        if (typeof preset === 'string') {
            preset = _constants__WEBPACK_IMPORTED_MODULE_5__.VIEWPORT_PRESETS.find((preset) => {
                return preset.name === presetNameOrObj;
            });
        }
        if (!preset) {
            return;
        }
        (0,_utilities_applyPreset__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .A)(volumeActor, preset);
        this.viewportProperties.preset = preset;
        this.render();
        if (!suppressEvents) {
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.PRESET_MODIFIED, {
                viewportId: this.id,
                volumeId: applicableVolumeActorInfo.volumeId,
                actor: volumeActor,
                presetName: preset.name,
            });
        }
    }
    async setVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
        const firstImageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeInputArray[0].volumeId);
        if (!firstImageVolume) {
            throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist, you need to create/allocate the volume first`);
        }
        const FrameOfReferenceUID = firstImageVolume.metadata.FrameOfReferenceUID;
        this._isValidVolumeInputArray(volumeInputArray, FrameOfReferenceUID);
        this._FrameOfReferenceUID = FrameOfReferenceUID;
        volumeInputArray.forEach((volumeInput) => {
            this._addVolumeId(volumeInput.volumeId);
        });
        const volumeActors = [];
        for (let i = 0; i < volumeInputArray.length; i++) {
            const { volumeId, actorUID, slabThickness, ...rest } = volumeInputArray[i];
            const actor = await (0,_helpers_createVolumeActor__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(volumeInputArray[i], this.element, this.id, suppressEvents);
            const uid = actorUID || (0,_utilities_uuidv4__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .A)();
            volumeActors.push({
                uid,
                actor,
                slabThickness,
                referencedId: volumeId,
                ...rest,
            });
        }
        this._setVolumeActors(volumeActors);
        this.viewportStatus = _enums__WEBPACK_IMPORTED_MODULE_6__.ViewportStatus.PRE_RENDER;
        this.initializeColorTransferFunction(volumeInputArray);
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.VOLUME_VIEWPORT_NEW_VOLUME, {
            viewportId: this.id,
            volumeActors,
        });
        if (immediate) {
            this.render();
        }
    }
    async addVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
        const firstImageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeInputArray[0].volumeId);
        if (!firstImageVolume) {
            throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
        }
        const volumeActors = [];
        this._isValidVolumeInputArray(volumeInputArray, this._FrameOfReferenceUID);
        volumeInputArray.forEach((volumeInput) => {
            this._addVolumeId(volumeInput.volumeId);
        });
        for (let i = 0; i < volumeInputArray.length; i++) {
            const { volumeId, visibility, actorUID, slabThickness, ...rest } = volumeInputArray[i];
            const actor = await (0,_helpers_createVolumeActor__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(volumeInputArray[i], this.element, this.id, suppressEvents);
            if (!visibility) {
                actor.setVisibility(false);
            }
            const uid = actorUID || (0,_utilities_uuidv4__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .A)();
            volumeActors.push({
                uid,
                actor,
                slabThickness,
                referencedId: volumeId,
                ...rest,
            });
        }
        this.addActors(volumeActors);
        this.initializeColorTransferFunction(volumeInputArray);
        if (immediate) {
            this.render();
        }
    }
    removeVolumeActors(actorUIDs, immediate = false) {
        this.removeActors(actorUIDs);
        if (immediate) {
            this.render();
        }
    }
    setOrientation(_orientation, _immediate = true) {
        console.warn('Method "setOrientation" needs implementation');
    }
    initializeColorTransferFunction(volumeInputArray) {
        const selectedVolumeId = volumeInputArray[0].volumeId;
        const colorTransferFunction = this._getOrCreateColorTransferFunction(selectedVolumeId);
        if (!this.initialTransferFunctionNodes && colorTransferFunction) {
            this.initialTransferFunctionNodes = (0,_utilities_transferFunctionUtils__WEBPACK_IMPORTED_MODULE_15__.getTransferFunctionNodes)(colorTransferFunction);
        }
    }
    _getApplicableVolumeActor(volumeId) {
        const actorEntries = this.getActors();
        if (!actorEntries?.length) {
            return;
        }
        if (volumeId) {
            const actorEntry = actorEntries.find((actor) => actor.referencedId === volumeId);
            if (!actorEntry) {
                return;
            }
            return {
                volumeActor: actorEntry.actor,
                volumeId,
                actorUID: actorEntry.uid,
            };
        }
        const defaultActorEntry = actorEntries[0];
        return {
            volumeActor: defaultActorEntry.actor,
            volumeId: defaultActorEntry.referencedId,
            actorUID: defaultActorEntry.uid,
        };
    }
    async _isValidVolumeInputArray(volumeInputArray, FrameOfReferenceUID) {
        const numVolumes = volumeInputArray.length;
        for (let i = 1; i < numVolumes; i++) {
            const imageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeInputArray[i].volumeId);
            if (FrameOfReferenceUID !== imageVolume.metadata.FrameOfReferenceUID) {
                throw new Error(`Volumes being added to viewport ${this.id} do not share the same FrameOfReferenceUID. This is not yet supported`);
            }
        }
        return true;
    }
    getBounds() {
        const renderer = this.getRenderer();
        const bounds = renderer.computeVisiblePropBounds();
        return bounds;
    }
    flip(flipDirection) {
        super.flip(flipDirection);
    }
    hasVolumeId(volumeId) {
        return this.volumeIds.has(volumeId);
    }
    hasVolumeURI(volumeURI) {
        for (const volumeId of this.volumeIds) {
            if (volumeId.includes(volumeURI)) {
                return true;
            }
        }
        return false;
    }
    getImageData(volumeId) {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        volumeId ||= this.getVolumeId();
        const actorEntry = this.getActors()?.find((actor) => actor.referencedId === volumeId);
        if (!(0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_21__/* .actorIsA */ .N)(actorEntry, 'vtkVolume')) {
            return;
        }
        const actor = actorEntry.actor;
        const volume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeId);
        const vtkImageData = actor.getMapper().getInputData();
        return {
            dimensions: vtkImageData.getDimensions(),
            spacing: vtkImageData.getSpacing(),
            origin: vtkImageData.getOrigin(),
            direction: vtkImageData.getDirection(),
            imageData: actor.getMapper().getInputData(),
            metadata: {
                Modality: volume?.metadata?.Modality,
                FrameOfReferenceUID: volume?.metadata?.FrameOfReferenceUID,
            },
            get scalarData() {
                return volume?.voxelManager?.getScalarData();
            },
            scaling: volume?.scaling,
            hasPixelSpacing: true,
            voxelManager: volume?.voxelManager,
        };
    }
    setCameraClippingRange() {
        throw new Error('Method not implemented.');
    }
    getSliceIndex() {
        throw new Error('Method not implemented.');
    }
    setCamera(cameraInterface, storeAsInitialCamera) {
        super.setCamera(cameraInterface, storeAsInitialCamera);
        this.setCameraClippingRange();
    }
    _setVolumeActors(volumeActorEntries) {
        for (let i = 0; i < volumeActorEntries.length; i++) {
            this.viewportProperties.invert = false;
        }
        this.setActors(volumeActorEntries);
    }
    _getOrientationVectors(orientation) {
        if (typeof orientation === 'object') {
            if (orientation.viewPlaneNormal && orientation.viewUp) {
                return orientation;
            }
            else {
                throw new Error('Invalid orientation object. It must contain viewPlaneNormal and viewUp');
            }
        }
        else if (typeof orientation === 'string' &&
            _constants__WEBPACK_IMPORTED_MODULE_5__.MPR_CAMERA_VALUES[orientation]) {
            this.viewportProperties.orientation = orientation;
            return _constants__WEBPACK_IMPORTED_MODULE_5__.MPR_CAMERA_VALUES[orientation];
        }
        else {
            throw new Error(`Invalid orientation: ${orientation}. Valid orientations are: ${Object.keys(_constants__WEBPACK_IMPORTED_MODULE_5__.MPR_CAMERA_VALUES).join(', ')}`);
        }
    }
    getSlabThickness() {
        const actors = this.getActors();
        let slabThickness = _constants__WEBPACK_IMPORTED_MODULE_5__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
        actors.forEach((actor) => {
            if (actor.slabThickness > slabThickness) {
                slabThickness = actor.slabThickness;
            }
        });
        return slabThickness;
    }
    getIntensityFromWorld(point) {
        const actorEntry = this.getDefaultActor();
        if (!(0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_21__/* .actorIsA */ .N)(actorEntry, 'vtkVolume')) {
            return;
        }
        const { actor } = actorEntry;
        const imageData = actor.getMapper().getInputData();
        const volume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(this.getVolumeId());
        const index = (0,_utilities_transformWorldToIndex__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(imageData, point);
        return volume.voxelManager.getAtIJKPoint(index);
    }
    getVolumeId(specifier) {
        const actorEntries = this.getActors();
        if (!actorEntries) {
            return;
        }
        if (!specifier?.volumeId) {
            const found = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume');
            return found?.referencedId || found?.uid;
        }
        const found = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume' &&
            actorEntry.referencedId === specifier?.volumeId);
        return found?.referencedId || found?.uid;
    }
    getViewReferenceId(specifier = {}) {
        let { volumeId, sliceIndex: sliceIndex } = specifier;
        if (!volumeId) {
            const actorEntries = this.getActors();
            if (!actorEntries) {
                return;
            }
            volumeId = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.referencedId;
        }
        const currentIndex = this.getSliceIndex();
        sliceIndex ??= currentIndex;
        const { viewPlaneNormal, focalPoint } = this.getCamera();
        const querySeparator = volumeId.includes('?') ? '&' : '?';
        return `volumeId:${volumeId}${querySeparator}sliceIndex=${sliceIndex}&viewPlaneNormal=${viewPlaneNormal.join(',')}&focalPoint=${focalPoint.join(',')}`;
    }
    _addVolumeId(volumeId) {
        this.volumeIds.add(volumeId);
    }
    getAllVolumeIds() {
        return Array.from(this.volumeIds);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseVolumeViewport);


/***/ }),

/***/ 58165:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ RenderingEngine_StackViewport)
});

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var ImageData = __webpack_require__(58498);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var Camera = __webpack_require__(26719);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js + 1 modules
var ColorTransferFunction = __webpack_require__(33739);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js + 1 modules
var ColorMaps = __webpack_require__(660);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var Constants = __webpack_require__(94520);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
var AbstractMapper3D = __webpack_require__(68076);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper.js




// ----------------------------------------------------------------------------
// vtkAbstractImageMapper methods
// ----------------------------------------------------------------------------

function vtkAbstractImageMapper(publicAPI, model) {
  model.classHierarchy.push('vtkAbstractImageMapper');
  publicAPI.getIsOpaque = () => true;
  publicAPI.getCurrentImage = () => null;
  publicAPI.getBoundsForSlice = () => {
    macros2.m.vtkErrorMacro('vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED');
    return (0,Core_Math.F)();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  slice: 0,
  customDisplayExtent: [0, 0, 0, 0, 0, 0],
  useCustomExtents: false,
  backgroundColor: [0, 0, 0, 1]
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  AbstractMapper3D/* default.extend */.A.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['slice', 'useCustomExtents']);
  macros2.m.setGetArray(publicAPI, model, ['customDisplayExtent'], 6);
  macros2.m.setGetArray(publicAPI, model, ['backgroundColor'], 4);
  vtkAbstractImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------
var vtkAbstractImageMapper$1 = {
  extend
};



// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js + 1 modules
var Plane = __webpack_require__(75127);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper/helper.js



/**
 * Perform plane-line intersection, where the line is defined by two points (p1, p2),
 * and the plane is defined by the imageData and slice number.
 *
 * @param {Vector3} p1
 * @param {Vector3} p2
 * @param {vtkImageMapper|vtkImageArrayMapper} mapper
 */
function doPicking(p1, p2, mapper) {
  const imageData = mapper.getCurrentImage();
  const extent = imageData.getExtent();

  // Slice origin
  const ijk = [extent[0], extent[2], extent[4]];
  const {
    ijkMode
  } = mapper.getClosestIJKAxis();
  let nSlice = mapper.isA('vtkImageArrayMapper') ? mapper.getSubSlice() : mapper.getSlice();
  if (ijkMode !== mapper.getSlicingMode()) {
    // If not IJK slicing, get the IJK slice from the XYZ position/slice
    nSlice = mapper.getSliceAtPosition(nSlice);
  }
  ijk[ijkMode] += nSlice;
  const worldOrigin = [0, 0, 0];
  imageData.indexToWorld(ijk, worldOrigin);

  // Normal computation
  ijk[ijkMode] += 1;
  const worldNormal = [0, 0, 0];
  imageData.indexToWorld(ijk, worldNormal);
  worldNormal[0] -= worldOrigin[0];
  worldNormal[1] -= worldOrigin[1];
  worldNormal[2] -= worldOrigin[2];
  esm/* vec3.normalize */.eR.normalize(worldNormal, worldNormal);
  const intersect = Plane/* default */.Ay.intersectWithLine(p1, p2, worldOrigin, worldNormal);
  if (intersect.intersection) {
    const point = intersect.x;
    const absoluteIJK = [0, 0, 0];
    imageData.worldToIndex(point, absoluteIJK);
    // `t` is the parametric position along the line
    // defined in Plane.intersectWithLine
    return {
      t: intersect.t,
      absoluteIJK
    };
  }
  return null;
}

/**
 * Implement point picking for image plane.
 * The plane is defined by the imageData and current slice number,
 * set in the input mapper.
 *
 * @param {Vector3} p1
 * @param {Vector3} p2
 * @param {vtkImageMapper|vtkImageArrayMapper} mapper
 */
function intersectWithLineForPointPicking(p1, p2, mapper) {
  const pickingData = doPicking(p1, p2, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();

    // Get closer integer ijk
    // NB: point picking means closest slice, means rounding
    const ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])];

    // Are we outside our actual extent
    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {
      return null;
    }
    return {
      t: pickingData.t,
      ijk
    };
  }
  return null;
}

/**
 * Implement cell picking for image plane.
 * The plane is defined by the imageData and current slice number,
 * set in the input mapper.
 *
 * @param {Vector3} p1
 * @param {Vector3} p2
 * @param {vtkImageMapper|vtkImageArrayMapper} mapper
 */
function intersectWithLineForCellPicking(p1, p2, mapper) {
  const pickingData = doPicking(p1, p2, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();
    const absIJK = pickingData.absoluteIJK;

    // Get closer integer ijk
    // NB: cell picking means closest voxel, means flooring
    const ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])];

    // Are we outside our actual extent
    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] ||
    // handle single-slice images
    ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {
      return null;
    }

    // Parametric coordinates within cell
    const pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];
    return {
      t: pickingData.t,
      ijk,
      pCoords
    };
  }
  return null;
}



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
var CoincidentTopologyHelper = __webpack_require__(57285);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js







const {
  staticOffsetAPI,
  otherStaticMethods
} = CoincidentTopologyHelper/* default */.Ay;
const {
  SlicingMode
} = Constants/* default */.A;

// ----------------------------------------------------------------------------
// vtkImageMapper methods
// ----------------------------------------------------------------------------

function vtkImageMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageMapper');
  publicAPI.getSliceAtPosition = pos => {
    const image = publicAPI.getCurrentImage();
    let pos3;
    if (pos.length === 3) {
      pos3 = pos;
    } else if (Number.isFinite(pos)) {
      const bds = image.getBounds();
      switch (model.slicingMode) {
        case SlicingMode.X:
          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode.Y:
          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode.Z:
          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];
          break;
      }
    }
    const ijk = [0, 0, 0];
    image.worldToIndex(pos3, ijk);
    const ex = image.getExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let slice = 0;
    switch (ijkMode) {
      case SlicingMode.I:
        slice = (0,Core_Math.C)(ijk[0], ex[0], ex[1]);
        break;
      case SlicingMode.J:
        slice = (0,Core_Math.C)(ijk[1], ex[2], ex[3]);
        break;
      case SlicingMode.K:
        slice = (0,Core_Math.C)(ijk[2], ex[4], ex[5]);
        break;
      default:
        return 0;
    }
    return slice;
  };
  publicAPI.setSliceFromCamera = cam => {
    const fp = cam.getFocalPoint();
    switch (model.slicingMode) {
      case SlicingMode.I:
      case SlicingMode.J:
      case SlicingMode.K:
        {
          const slice = publicAPI.getSliceAtPosition(fp);
          publicAPI.setSlice(slice);
        }
        break;
      case SlicingMode.X:
        publicAPI.setSlice(fp[0]);
        break;
      case SlicingMode.Y:
        publicAPI.setSlice(fp[1]);
        break;
      case SlicingMode.Z:
        publicAPI.setSlice(fp[2]);
        break;
    }
  };
  publicAPI.setXSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.X);
    publicAPI.setSlice(id);
  };
  publicAPI.setYSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.Y);
    publicAPI.setSlice(id);
  };
  publicAPI.setZSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.Z);
    publicAPI.setSlice(id);
  };
  publicAPI.setISlice = id => {
    publicAPI.setSlicingMode(SlicingMode.I);
    publicAPI.setSlice(id);
  };
  publicAPI.setJSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.J);
    publicAPI.setSlice(id);
  };
  publicAPI.setKSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.K);
    publicAPI.setSlice(id);
  };
  publicAPI.getSlicingModeNormal = () => {
    const out = [0, 0, 0];
    const mat3 = publicAPI.getCurrentImage().getDirection();
    switch (model.slicingMode) {
      case SlicingMode.X:
        out[0] = 1;
        break;
      case SlicingMode.Y:
        out[1] = 1;
        break;
      case SlicingMode.Z:
        out[2] = 1;
        break;
      case SlicingMode.I:
        (0,Core_Math.Q)(mat3, [1, 0, 0], out);
        break;
      case SlicingMode.J:
        (0,Core_Math.Q)(mat3, [0, 1, 0], out);
        break;
      case SlicingMode.K:
        (0,Core_Math.Q)(mat3, [0, 0, 1], out);
        break;
    }
    return out;
  };
  function computeClosestIJKAxis() {
    let xyzMode;
    switch (model.slicingMode) {
      case SlicingMode.X:
        xyzMode = 0;
        break;
      case SlicingMode.Y:
        xyzMode = 1;
        break;
      case SlicingMode.Z:
        xyzMode = 2;
        break;
      default:
        model.closestIJKAxis = {
          ijkMode: model.slicingMode,
          flip: false
        };
        return;
    }

    // The direction matrix in vtkImageData is the indexToWorld rotation matrix
    // with a column-major data layout since it is stored as a WebGL matrix.
    const direction = publicAPI.getCurrentImage().getDirection();
    const newMatrix = (0,Core_Math.R)(direction);
    // With {foo}Vector filled with 0s except at {foo}Mode position where it is 1
    // We have xyzVector = (+/-) newMatrix * ijkVector
    let ijkMode = 0;
    for (; ijkMode < 3; ++ijkMode) {
      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {
        break;
      }
    }
    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;
    model.closestIJKAxis = {
      ijkMode,
      flip
    };
  }
  publicAPI.setSlicingMode = mode => {
    if (model.slicingMode === mode) {
      return;
    }
    model.slicingMode = mode;
    if (publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    publicAPI.modified();
  };
  publicAPI.getClosestIJKAxis = () => {
    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    return model.closestIJKAxis;
  };
  publicAPI.getBounds = () => {
    const image = publicAPI.getCurrentImage();
    if (!image) {
      return (0,Core_Math.F)();
    }
    if (!model.useCustomExtents) {
      return image.getBounds();
    }
    const ex = model.customDisplayExtent.slice();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = model.slice;
    if (ijkMode !== model.slicingMode) {
      // If not IJK slicing, get the IJK slice from the XYZ position/slice
      nSlice = publicAPI.getSliceAtPosition(model.slice);
    }
    switch (ijkMode) {
      case SlicingMode.I:
        ex[0] = nSlice;
        ex[1] = nSlice;
        break;
      case SlicingMode.J:
        ex[2] = nSlice;
        ex[3] = nSlice;
        break;
      case SlicingMode.K:
        ex[4] = nSlice;
        ex[5] = nSlice;
        break;
    }
    return image.extentToBounds(ex);
  };
  publicAPI.getBoundsForSlice = function () {
    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;
    let halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const image = publicAPI.getCurrentImage();
    if (!image) {
      return (0,Core_Math.F)();
    }
    const extent = image.getSpatialExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = slice;
    if (ijkMode !== model.slicingMode) {
      // If not IJK slicing, get the IJK slice from the XYZ position/slice
      nSlice = publicAPI.getSliceAtPosition(slice);
    }
    switch (ijkMode) {
      case SlicingMode.I:
        extent[0] = nSlice - halfThickness;
        extent[1] = nSlice + halfThickness;
        break;
      case SlicingMode.J:
        extent[2] = nSlice - halfThickness;
        extent[3] = nSlice + halfThickness;
        break;
      case SlicingMode.K:
        extent[4] = nSlice - halfThickness;
        extent[5] = nSlice + halfThickness;
        break;
    }
    return image.extentToBounds(extent);
  };
  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);
  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);
  publicAPI.getCurrentImage = () => publicAPI.getInputData();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageMapper_DEFAULT_VALUES = {
  slicingMode: SlicingMode.NONE,
  closestIJKAxis: {
    ijkMode: SlicingMode.NONE,
    flip: false
  },
  renderToRectangle: false,
  sliceAtFocalPoint: false,
  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate
};

// ----------------------------------------------------------------------------

function ImageMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageMapper_DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtkAbstractImageMapper$1.extend(publicAPI, model, initialValues);
  macros2.m.get(publicAPI, model, ['slicingMode']);
  macros2.m.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);
  CoincidentTopologyHelper/* default */.Ay.implementCoincidentTopologyMethods(publicAPI, model);

  // Object methods
  vtkImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(ImageMapper_extend, 'vtkImageMapper');

// ----------------------------------------------------------------------------

var vtkImageMapper$1 = {
  newInstance,
  extend: ImageMapper_extend,
  ...staticOffsetAPI,
  ...otherStaticMethods,
  ...Constants/* default */.A
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var BoundingBox = __webpack_require__(21734);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var Prop3D = __webpack_require__(62502);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var ImageProperty_Constants = __webpack_require__(91732);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty.js



const {
  InterpolationType
} = ImageProperty_Constants/* default */.A;
const {
  vtkErrorMacro
} = macros2.m;
const VTK_MAX_VRCOMP = 4;

// ----------------------------------------------------------------------------
// vtkImageProperty methods
// ----------------------------------------------------------------------------

function vtkImageProperty(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageProperty');
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index = 0; index < VTK_MAX_VRCOMP; index++) {
      // Color MTimes
      if (model.componentData[index].rGBTransferFunction) {
        // time that RGB transfer function was last modified
        time = model.componentData[index].rGBTransferFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }

      // Piecewise function MTimes
      if (model.componentData[index].piecewiseFunction) {
        // time that weighting function was last modified
        time = model.componentData[index].piecewiseFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
    }
    return mTime;
  };

  // Set the color of a volume to an RGB transfer function
  publicAPI.setRGBTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    // backwards compatible call without the component index
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    if (model.componentData[idx].rGBTransferFunction !== transferFunc) {
      model.componentData[idx].rGBTransferFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };

  // Get the currently set RGB transfer function.
  publicAPI.getRGBTransferFunction = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.componentData[idx].rGBTransferFunction;
  };

  // Set the piecewise function
  publicAPI.setPiecewiseFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    if (model.componentData[idx].piecewiseFunction !== transferFunc) {
      model.componentData[idx].piecewiseFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };

  // Get the component weighting function.
  publicAPI.getPiecewiseFunction = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.componentData[idx].piecewiseFunction;
  };

  // Alias to set the piecewise function
  publicAPI.setScalarOpacity = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    // backwards compatible call without the component index
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    return publicAPI.setPiecewiseFunction(idx, transferFunc);
  };

  // Alias to get the piecewise function (backwards compatibility)
  publicAPI.getScalarOpacity = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return publicAPI.getPiecewiseFunction(idx);
  };
  publicAPI.setComponentWeight = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro('Invalid index');
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index].componentWeight !== val) {
      model.componentData[index].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro('Invalid index');
      return 0.0;
    }
    return model.componentData[index].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType.LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macros2.m.enumToString(InterpolationType, model.interpolationType);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const ImageProperty_DEFAULT_VALUES = {
  independentComponents: false,
  interpolationType: InterpolationType.LINEAR,
  colorWindow: 255,
  colorLevel: 127.5,
  ambient: 1.0,
  diffuse: 0.0,
  opacity: 1.0,
  useLookupTableScalarRange: false,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1.0
};

// ----------------------------------------------------------------------------

function ImageProperty_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageProperty_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i = 0; i < VTK_MAX_VRCOMP; i++) {
      model.componentData.push({
        rGBTransferFunction: null,
        piecewiseFunction: null,
        componentWeight: 1.0
      });
    }
  }
  macros2.m.setGet(publicAPI, model, ['independentComponents', 'interpolationType', 'colorWindow', 'colorLevel', 'ambient', 'diffuse', 'opacity', 'useLookupTableScalarRange', 'useLabelOutline', 'labelOutlineOpacity']);
  macros2.m.setGetArray(publicAPI, model, ['labelOutlineThickness']);

  // Object methods
  vtkImageProperty(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageProperty_newInstance = macros2.m.newInstance(ImageProperty_extend, 'vtkImageProperty');

// ----------------------------------------------------------------------------

var vtkImageProperty$1 = {
  newInstance: ImageProperty_newInstance,
  extend: ImageProperty_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js






const {
  vtkDebugMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkImageSlice methods
// ----------------------------------------------------------------------------

function vtkImageSlice(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageSlice');
  publicAPI.getActors = () => publicAPI;
  publicAPI.getImages = () => publicAPI;
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    // make sure we have a property
    if (!model.property) {
      // force creation of a property
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1.0;

    // are we using an opaque scalar array, if any?
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };

  // Always render during opaque pass, to keep the behavior
  // predictable and because depth-peeling kills alpha-blending.
  // In the future, the Renderer should render images in layers,
  // i.e. where each image will have a layer number assigned to it,
  // and the Renderer will do the images in their own pass.
  publicAPI.hasTranslucentPolygonalGeometry = () => false;
  publicAPI.makeProperty = vtkImageProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }

    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }

    // Check for the special case when the actor is empty.
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }

    // Check if we have cached values for these bounds - we cache the
    // values returned by model.mapper.getBounds() and we store the time
    // of caching. If the values returned this time are different, or
    // the modified time of this class is newer than the cached time,
    // then we need to rebuild.
    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro('Recomputing bounds...');
      model.mapperBounds = bds.map(x => x);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      esm/* mat4.transpose */.pB.transpose(tmp4, model.matrix);
      BoundingBox/* default.transformBounds */.Ay.transformBounds(bds, tmp4, model.bounds);
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getBoundsForSlice = (slice, thickness) => {
    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBoundsForSlice(slice, thickness);
    // Check for the special case when the actor is empty.
    if (!BoundingBox/* default.isValid */.Ay.isValid(bds)) {
      return bds;
    }
    publicAPI.computeMatrix();
    const tmp4 = new Float64Array(16);
    esm/* mat4.transpose */.pB.transpose(tmp4, model.matrix);
    const newBounds = BoundingBox/* default.transformBounds */.Ay.transformBounds(bds, tmp4);
    return newBounds;
  };

  //----------------------------------------------------------------------------
  // Get the minimum X bound
  publicAPI.getMinXBound = () => publicAPI.getBounds()[0];

  // Get the maximum X bound
  publicAPI.getMaxXBound = () => publicAPI.getBounds()[1];

  // Get the minimum Y bound
  publicAPI.getMinYBound = () => publicAPI.getBounds()[2];

  // Get the maximum Y bound
  publicAPI.getMaxYBound = () => publicAPI.getBounds()[3];

  // Get the minimum Z bound
  publicAPI.getMinZBound = () => publicAPI.getBounds()[4];

  // Get the maximum Z bound
  publicAPI.getMaxZBound = () => publicAPI.getBounds()[5];
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        // FIXME !!! getInputAlgorithm / getInput
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    if (model.property !== null) {
      let time = model.property.getMTime();
      mt = time > mt ? time : mt;
      if (model.property.getRGBTransferFunction() !== null) {
        time = model.property.getRGBTransferFunction().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageSlice_DEFAULT_VALUES = {
  mapper: null,
  property: null,
  bounds: [...BoundingBox/* default */.Ay.INIT_BOUNDS]
};

// ----------------------------------------------------------------------------

function ImageSlice_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageSlice_DEFAULT_VALUES, initialValues);

  // Inheritance
  Prop3D/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // vtkTimeStamp
  model.boundsMTime = {};
  macros2.m.obj(model.boundsMTime);

  // Build VTK API
  macros2.m.set(publicAPI, model, ['property']);
  macros2.m.setGet(publicAPI, model, ['mapper']);
  macros2.m.getArray(publicAPI, model, ['bounds'], 6);

  // Object methods
  vtkImageSlice(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageSlice_newInstance = macros2.m.newInstance(ImageSlice_extend, 'vtkImageSlice');

// ----------------------------------------------------------------------------

var vtkImageSlice$1 = {
  newInstance: ImageSlice_newInstance,
  extend: ImageSlice_extend
};



// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var metaData = __webpack_require__(74876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js
var actorCheck = __webpack_require__(98039);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js
var utilities_colormap = __webpack_require__(13859);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js
var transferFunctionUtils = __webpack_require__(85745);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js
var windowLevel = __webpack_require__(68136);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createLinearRGBTransferFunction.js
var createLinearRGBTransferFunction = __webpack_require__(74657);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSigmoidRGBTransferFunction.js
var createSigmoidRGBTransferFunction = __webpack_require__(40256);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updateVTKImageDataWithCornerstoneImage.js
var updateVTKImageDataWithCornerstoneImage = __webpack_require__(45278);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isEqual.js
var isEqual = __webpack_require__(74638);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/invertRgbTransferFunction.js
var invertRgbTransferFunction = __webpack_require__(50134);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageRetrieveMetadataProvider.js
var imageRetrieveMetadataProvider = __webpack_require__(17791);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js
var imageIdToURI = __webpack_require__(39537);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/Viewport.js
var Viewport = __webpack_require__(10056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/drawImageSync.js
var drawImageSync = __webpack_require__(5057);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 4 modules
var enums = __webpack_require__(31749);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var imageLoader = __webpack_require__(80068);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageLoadPoolManager.js
var imageLoadPoolManager = __webpack_require__(51159);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.js
var calculateTransform = __webpack_require__(7808);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getTransform.js

/* harmony default export */ function getTransform(enabledElement) {
    return (0,calculateTransform/* default */.A)(enabledElement);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/canvasToPixel.js

/* harmony default export */ function canvasToPixel(enabledElement, pt) {
    const transform = getTransform(enabledElement);
    transform.invert();
    return transform.transformPoint(pt);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.js
var getDefaultViewport = __webpack_require__(36931);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/pixelToCanvas.js

/* harmony default export */ function pixelToCanvas(enabledElement, pt) {
    const transform = getTransform(enabledElement);
    return transform.transformPoint(pt);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getImageFitScale.js
var getImageFitScale = __webpack_require__(57162);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/fitToWindow.js

/* harmony default export */ function fitToWindow(enabledElement) {
    const { image } = enabledElement;
    enabledElement.viewport.scale = (0,getImageFitScale/* default */.A)(enabledElement.canvas, image, enabledElement.viewport.rotation).scaleFactor;
    enabledElement.viewport.translation.x = 0;
    enabledElement.viewport.translation.y = 0;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getImageSize.js
var getImageSize = __webpack_require__(62596);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/resize.js


function setCanvasSize(enabledElement) {
    const { canvas } = enabledElement;
    const { clientWidth, clientHeight } = canvas;
    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
        canvas.width = clientWidth;
        canvas.height = clientHeight;
    }
}
function wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight) {
    const scale = enabledElement.viewport.scale;
    const imageSize = (0,getImageSize/* default */.A)(enabledElement.image, enabledElement.viewport.rotation);
    const imageWidth = Math.round(imageSize.width * scale);
    const imageHeight = Math.round(imageSize.height * scale);
    const x = enabledElement.viewport.translation.x;
    const y = enabledElement.viewport.translation.y;
    return ((imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight) ||
        (imageWidth <= oldCanvasWidth &&
            imageHeight === oldCanvasHeight &&
            x === 0 &&
            y === 0));
}
function relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight) {
    const scale = enabledElement.viewport.scale;
    const canvasWidth = enabledElement.canvas.width;
    const canvasHeight = enabledElement.canvas.height;
    const relWidthChange = canvasWidth / oldCanvasWidth;
    const relHeightChange = canvasHeight / oldCanvasHeight;
    const relChange = Math.sqrt(relWidthChange * relHeightChange);
    enabledElement.viewport.scale = relChange * scale;
}
/* harmony default export */ function resize(enabledElement, forceFitToWindow = false) {
    const oldCanvasWidth = enabledElement.canvas.width;
    const oldCanvasHeight = enabledElement.canvas.height;
    setCanvasSize(enabledElement);
    if (enabledElement.image === undefined) {
        return;
    }
    if (forceFitToWindow ||
        wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight)) {
        fitToWindow(enabledElement);
    }
    else {
        relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight);
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js + 1 modules
var init = __webpack_require__(59693);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/ProgressiveRetrieveImages.js + 4 modules
var ProgressiveRetrieveImages = __webpack_require__(36822);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/correctShift.js
/* harmony default export */ function correctShift(shift, viewportOrientation) {
    const { hflip, vflip, rotation } = viewportOrientation;
    shift.x *= hflip ? -1 : 1;
    shift.y *= vflip ? -1 : 1;
    if (rotation !== 0) {
        const angle = (rotation * Math.PI) / 180;
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const newX = shift.x * cosA - shift.y * sinA;
        const newY = shift.x * sinA + shift.y * cosA;
        shift.x = newX;
        shift.y = newY;
    }
    return shift;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/resetCamera.js

/* harmony default export */ function resetCamera(enabledElement, resetPan = true, resetZoom = true) {
    const { canvas, image, viewport } = enabledElement;
    const scale = (0,getImageFitScale/* default */.A)(canvas, image, 0).scaleFactor;
    viewport.vflip = false;
    viewport.hflip = false;
    if (resetPan) {
        viewport.translation.x = 0;
        viewport.translation.y = 0;
    }
    if (resetZoom) {
        viewport.displayedArea.tlhc.x = 1;
        viewport.displayedArea.tlhc.y = 1;
        viewport.displayedArea.brhc.x = image.columns;
        viewport.displayedArea.brhc.y = image.rows;
        viewport.scale = scale;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/transform.js
var transform = __webpack_require__(45354);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js
var getSpacingInNormalDirection = __webpack_require__(85008);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js
var getClosestImageId = __webpack_require__(88619);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/StackViewport.js









































const EPSILON = 1;
class StackViewport extends Viewport/* default */.A {
    constructor(props) {
        super(props);
        this.imagesLoader = this;
        this.globalDefaultProperties = {};
        this.perImageIdDefaultProperties = new Map();
        this.voiUpdatedWithSetProperties = false;
        this.invert = false;
        this.initialInvert = false;
        this.initialTransferFunctionNodes = null;
        this.stackInvalidated = false;
        this._publishCalibratedEvent = false;
        this.updateRenderingPipeline = () => {
            this._configureRenderingPipeline();
        };
        this.resize = () => {
            if (this.useCPURendering) {
                this._resizeCPU();
            }
        };
        this._resizeCPU = () => {
            if (this._cpuFallbackEnabledElement.viewport) {
                resize(this._cpuFallbackEnabledElement);
            }
        };
        this.getFrameOfReferenceUID = (sliceIndex) => this.getImagePlaneReferenceData(sliceIndex)?.FrameOfReferenceUID;
        this.getCornerstoneImage = () => this.csImage;
        this.createActorMapper = (imageData) => {
            const mapper = vtkImageMapper$1.newInstance();
            mapper.setInputData(imageData);
            const actor = vtkImageSlice$1.newInstance();
            actor.setMapper(mapper);
            const { preferSizeOverAccuracy } = (0,init/* getConfiguration */.D0)().rendering;
            if (preferSizeOverAccuracy) {
                mapper.setPreferSizeOverAccuracy(true);
            }
            if (imageData.getPointData().getScalars().getNumberOfComponents() > 1) {
                actor.getProperty().setIndependentComponents(false);
            }
            return actor;
        };
        this.getNumberOfSlices = () => {
            return this.imageIds.length;
        };
        this.getDefaultProperties = (imageId) => {
            let imageProperties;
            if (imageId !== undefined) {
                imageProperties = this.perImageIdDefaultProperties.get(imageId);
            }
            if (imageProperties !== undefined) {
                return imageProperties;
            }
            return {
                ...this.globalDefaultProperties,
            };
        };
        this.getProperties = () => {
            const { colormap, voiRange, VOILUTFunction, interpolationType, invert, voiUpdatedWithSetProperties, } = this;
            return {
                colormap,
                voiRange,
                VOILUTFunction,
                interpolationType,
                invert,
                isComputedVOI: !voiUpdatedWithSetProperties,
            };
        };
        this.resetCameraForResize = () => {
            return this.resetCamera({
                resetPan: true,
                resetZoom: true,
                resetToCenter: true,
                suppressEvents: true,
            });
        };
        this.getRotationCPU = () => {
            const { viewport } = this._cpuFallbackEnabledElement;
            return viewport.rotation;
        };
        this.getRotationGPU = () => {
            const { viewUp: currentViewUp, viewPlaneNormal, flipVertical, } = this.getCameraNoRotation();
            const initialViewUp = flipVertical
                ? esm/* vec3.negate */.eR.negate(esm/* vec3.create */.eR.create(), this.initialViewUp)
                : this.initialViewUp;
            const initialToCurrentViewUpAngle = (esm/* vec3.angle */.eR.angle(initialViewUp, currentViewUp) * 180) / Math.PI;
            const initialToCurrentViewUpCross = esm/* vec3.cross */.eR.cross(esm/* vec3.create */.eR.create(), initialViewUp, currentViewUp);
            const normalDot = esm/* vec3.dot */.eR.dot(initialToCurrentViewUpCross, viewPlaneNormal);
            return normalDot >= 0
                ? initialToCurrentViewUpAngle
                : (360 - initialToCurrentViewUpAngle) % 360;
        };
        this.setRotation = (rotation) => {
            const previousCamera = this.getCamera();
            if (this.useCPURendering) {
                this.setRotationCPU(rotation);
            }
            else {
                this.setRotationGPU(rotation);
            }
            if (this._suppressCameraModifiedEvents) {
                return;
            }
            const camera = this.getCamera();
            const eventDetail = {
                previousCamera,
                camera,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            (0,triggerEvent/* default */.A)(this.element, enums.Events.CAMERA_MODIFIED, eventDetail);
        };
        this.renderImageObject = (image) => {
            this._setCSImage(image);
            const renderFn = this.useCPURendering
                ? this._updateToDisplayImageCPU
                : this._updateActorToDisplayImageId;
            renderFn.call(this, image);
        };
        this._setCSImage = (image) => {
            image.isPreScaled = image.preScale?.scaled;
            this.csImage = image;
        };
        this.canvasToWorldCPU = (canvasPos, worldPos = [0, 0, 0]) => {
            if (!this._cpuFallbackEnabledElement.image) {
                return;
            }
            const [px, py] = canvasToPixel(this._cpuFallbackEnabledElement, canvasPos);
            const { origin, spacing, direction } = this.getImageData();
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(worldPos, origin, iVector, px * spacing[0]);
            esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(worldPos, worldPos, jVector, py * spacing[1]);
            return worldPos;
        };
        this.worldToCanvasCPU = (worldPos) => {
            const { spacing, direction, origin } = this.getImageData();
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            const diff = esm/* vec3.subtract */.eR.subtract(esm/* vec3.create */.eR.create(), worldPos, origin);
            const indexPoint = [
                esm/* vec3.dot */.eR.dot(diff, iVector) / spacing[0],
                esm/* vec3.dot */.eR.dot(diff, jVector) / spacing[1],
            ];
            const canvasPoint = pixelToCanvas(this._cpuFallbackEnabledElement, indexPoint);
            return canvasPoint;
        };
        this.canvasToWorldGPU = (canvasPos) => {
            const renderer = this.getRenderer();
            const vtkCamera = this.getVtkActiveCamera();
            const crange = vtkCamera.getClippingRange();
            const distance = vtkCamera.getDistance();
            vtkCamera.setClippingRange(distance, distance + 0.1);
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasPosWithDPR = [
                canvasPos[0] * devicePixelRatio,
                canvasPos[1] * devicePixelRatio,
            ];
            const displayCoord = [
                canvasPosWithDPR[0] + this.sx,
                canvasPosWithDPR[1] + this.sy,
            ];
            displayCoord[1] = size[1] - displayCoord[1];
            const worldCoord = openGLRenderWindow.displayToWorld(displayCoord[0], displayCoord[1], 0, renderer);
            vtkCamera.setClippingRange(crange[0], crange[1]);
            return [worldCoord[0], worldCoord[1], worldCoord[2]];
        };
        this.worldToCanvasGPU = (worldPos) => {
            const renderer = this.getRenderer();
            const vtkCamera = this.getVtkActiveCamera();
            const crange = vtkCamera.getClippingRange();
            const distance = vtkCamera.getDistance();
            vtkCamera.setClippingRange(distance, distance + 0.1);
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer);
            displayCoord[1] = size[1] - displayCoord[1];
            const canvasCoord = [
                displayCoord[0] - this.sx,
                displayCoord[1] - this.sy,
            ];
            vtkCamera.setClippingRange(crange[0], crange[1]);
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasCoordWithDPR = [
                canvasCoord[0] / devicePixelRatio,
                canvasCoord[1] / devicePixelRatio,
            ];
            return canvasCoordWithDPR;
        };
        this.getCurrentImageIdIndex = () => {
            return this.currentImageIdIndex;
        };
        this.getSliceIndex = () => {
            return this.currentImageIdIndex;
        };
        this.getTargetImageIdIndex = () => {
            return this.targetImageIdIndex;
        };
        this.getImageIds = () => {
            return this.imageIds;
        };
        this.getCurrentImageId = () => {
            return this.imageIds[this.currentImageIdIndex];
        };
        this.hasImageId = (imageId) => {
            return this.imageIds.includes(imageId);
        };
        this.hasImageURI = (imageURI) => {
            const imageIds = this.imageIds;
            for (let i = 0; i < imageIds.length; i++) {
                if ((0,imageIdToURI/* default */.A)(imageIds[i]) === imageURI) {
                    return true;
                }
            }
            return false;
        };
        this.customRenderViewportToCanvas = () => {
            if (!this.useCPURendering) {
                throw new Error('Custom cpu rendering pipeline should only be hit in CPU rendering mode');
            }
            if (this._cpuFallbackEnabledElement.image) {
                (0,drawImageSync/* default */.A)(this._cpuFallbackEnabledElement, this.cpuRenderingInvalidated);
                this.cpuRenderingInvalidated = false;
            }
            else {
                this.fillWithBackgroundColor();
            }
            return {
                canvas: this.canvas,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
                viewportStatus: this.viewportStatus,
            };
        };
        this.renderingPipelineFunctions = {
            getImageData: {
                cpu: this.getImageDataCPU,
                gpu: this.getImageDataGPU,
            },
            setColormap: {
                cpu: this.setColormapCPU,
                gpu: this.setColormapGPU,
            },
            getCamera: {
                cpu: this.getCameraCPU,
                gpu: super.getCamera,
            },
            setCamera: {
                cpu: this.setCameraCPU,
                gpu: super.setCamera,
            },
            getPan: {
                cpu: this.getPanCPU,
                gpu: super.getPan,
            },
            setPan: {
                cpu: this.setPanCPU,
                gpu: super.setPan,
            },
            getZoom: {
                cpu: this.getZoomCPU,
                gpu: super.getZoom,
            },
            setZoom: {
                cpu: this.setZoomCPU,
                gpu: super.setZoom,
            },
            setVOI: {
                cpu: this.setVOICPU,
                gpu: this.setVOIGPU,
            },
            getRotation: {
                cpu: this.getRotationCPU,
                gpu: this.getRotationGPU,
            },
            setInterpolationType: {
                cpu: this.setInterpolationTypeCPU,
                gpu: this.setInterpolationTypeGPU,
            },
            setInvertColor: {
                cpu: this.setInvertColorCPU,
                gpu: this.setInvertColorGPU,
            },
            resetCamera: {
                cpu: (options = {}) => {
                    const { resetPan = true, resetZoom = true } = options;
                    this.resetCameraCPU({ resetPan, resetZoom });
                    return true;
                },
                gpu: (options = {}) => {
                    const { resetPan = true, resetZoom = true } = options;
                    this.resetCameraGPU({ resetPan, resetZoom });
                    return true;
                },
            },
            canvasToWorld: {
                cpu: this.canvasToWorldCPU,
                gpu: this.canvasToWorldGPU,
            },
            worldToCanvas: {
                cpu: this.worldToCanvasCPU,
                gpu: this.worldToCanvasGPU,
            },
            getRenderer: {
                cpu: () => this.getCPUFallbackError('getRenderer'),
                gpu: super.getRenderer,
            },
            getDefaultActor: {
                cpu: () => this.getCPUFallbackError('getDefaultActor'),
                gpu: super.getDefaultActor,
            },
            getActors: {
                cpu: () => this.getCPUFallbackError('getActors'),
                gpu: super.getActors,
            },
            getActor: {
                cpu: () => this.getCPUFallbackError('getActor'),
                gpu: super.getActor,
            },
            setActors: {
                cpu: () => this.getCPUFallbackError('setActors'),
                gpu: super.setActors,
            },
            addActors: {
                cpu: () => this.getCPUFallbackError('addActors'),
                gpu: super.addActors,
            },
            addActor: {
                cpu: () => this.getCPUFallbackError('addActor'),
                gpu: super.addActor,
            },
            removeAllActors: {
                cpu: () => this.getCPUFallbackError('removeAllActors'),
                gpu: super.removeAllActors,
            },
            unsetColormap: {
                cpu: this.unsetColormapCPU,
                gpu: this.unsetColormapGPU,
            },
        };
        this.scaling = {};
        this.modality = null;
        this.useCPURendering = (0,init/* getShouldUseCPURendering */.LH)();
        this._configureRenderingPipeline();
        const result = this.useCPURendering
            ? this._resetCPUFallbackElement()
            : this._resetGPUViewport();
        this.imageIds = [];
        this.currentImageIdIndex = 0;
        this.targetImageIdIndex = 0;
        this.resetCamera();
        this.initializeElementDisabledHandler();
    }
    setUseCPURendering(value) {
        this.useCPURendering = value;
        this._configureRenderingPipeline(value);
    }
    static get useCustomRenderingPipeline() {
        return (0,init/* getShouldUseCPURendering */.LH)();
    }
    _configureRenderingPipeline(value) {
        this.useCPURendering = value ?? (0,init/* getShouldUseCPURendering */.LH)();
        for (const key in this.renderingPipelineFunctions) {
            if (Object.prototype.hasOwnProperty.call(this.renderingPipelineFunctions, key)) {
                const functions = this.renderingPipelineFunctions[key];
                this[key] = this.useCPURendering ? functions.cpu : functions.gpu;
            }
        }
        const result = this.useCPURendering
            ? this._resetCPUFallbackElement()
            : this._resetGPUViewport();
    }
    _resetCPUFallbackElement() {
        this._cpuFallbackEnabledElement = {
            canvas: this.canvas,
            renderingTools: {},
            transform: new transform/* Transform */.d(),
            viewport: { rotation: 0 },
        };
    }
    _resetGPUViewport() {
        const renderer = this.getRenderer();
        const camera = Camera/* default.newInstance */.Ay.newInstance();
        renderer.setActiveCamera(camera);
        const viewPlaneNormal = [0, 0, -1];
        this.initialViewUp = [0, -1, 0];
        camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        camera.setViewUp(...this.initialViewUp);
        camera.setParallelProjection(true);
        camera.setThicknessFromFocalPoint(0.1);
        camera.setFreezeFocalPoint(true);
    }
    initializeElementDisabledHandler() {
        eventTarget/* default */.A.addEventListener(enums.Events.ELEMENT_DISABLED, function elementDisabledHandler() {
            clearTimeout(this.debouncedTimeout);
            eventTarget/* default */.A.removeEventListener(enums.Events.ELEMENT_DISABLED, elementDisabledHandler);
        });
    }
    getImageDataGPU() {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        const { actor } = defaultActor;
        const vtkImageData = actor.getMapper().getInputData();
        const csImage = this.csImage;
        return {
            dimensions: vtkImageData.getDimensions(),
            spacing: vtkImageData.getSpacing(),
            origin: vtkImageData.getOrigin(),
            direction: vtkImageData.getDirection(),
            get scalarData() {
                return csImage?.voxelManager.getScalarData();
            },
            imageData: actor.getMapper().getInputData(),
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: this.getFrameOfReferenceUID(),
            },
            scaling: this.scaling,
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: { ...csImage?.calibration, ...this.calibration },
            preScale: {
                ...csImage?.preScale,
            },
            voxelManager: csImage?.voxelManager,
        };
    }
    getImageDataCPU() {
        const { metadata } = this._cpuFallbackEnabledElement;
        const spacing = metadata.spacing;
        const csImage = this.csImage;
        return {
            dimensions: metadata.dimensions,
            spacing,
            origin: metadata.origin,
            direction: metadata.direction,
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: this.getFrameOfReferenceUID(),
            },
            scaling: this.scaling,
            imageData: {
                getDirection: () => metadata.direction,
                getDimensions: () => metadata.dimensions,
                getScalarData: () => this.cpuImagePixelData,
                getSpacing: () => spacing,
                worldToIndex: (point) => {
                    const canvasPoint = this.worldToCanvasCPU(point);
                    const pixelCoord = canvasToPixel(this._cpuFallbackEnabledElement, canvasPoint);
                    return [pixelCoord[0], pixelCoord[1], 0];
                },
                indexToWorld: (point, destPoint) => {
                    const canvasPoint = pixelToCanvas(this._cpuFallbackEnabledElement, [
                        point[0],
                        point[1],
                    ]);
                    return this.canvasToWorldCPU(canvasPoint, destPoint);
                },
            },
            scalarData: this.cpuImagePixelData,
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: { ...csImage?.calibration, ...this.calibration },
            preScale: {
                ...csImage?.preScale,
            },
            voxelManager: csImage?.voxelManager,
        };
    }
    buildMetadata(image) {
        const imageId = image.imageId;
        const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = metaData.get('imagePixelModule', imageId);
        const { windowWidth, windowCenter, voiLUTFunction } = image;
        const { modality } = metaData.get('generalSeriesModule', imageId);
        const imageIdScalingFactor = metaData.get('scalingModule', imageId);
        const calibration = metaData.get(enums.MetadataModules.CALIBRATION, imageId);
        if (modality === 'PT' && imageIdScalingFactor) {
            this._addScalingToViewport(imageIdScalingFactor);
        }
        this.modality = modality;
        const voiLUTFunctionEnum = this._getValidVOILUTFunction(voiLUTFunction);
        this.VOILUTFunction = voiLUTFunctionEnum;
        this.calibration = calibration;
        let imagePlaneModule = this._getImagePlaneModule(imageId);
        if (!this.useCPURendering) {
            imagePlaneModule = this.calibrateIfNecessary(imageId, imagePlaneModule);
        }
        return {
            imagePlaneModule,
            imagePixelModule: {
                bitsAllocated,
                bitsStored,
                samplesPerPixel,
                highBit,
                photometricInterpretation,
                pixelRepresentation,
                windowWidth,
                windowCenter,
                modality,
                voiLUTFunction: voiLUTFunctionEnum,
            },
        };
    }
    calibrateIfNecessary(imageId, imagePlaneModule) {
        const calibration = metaData.get('calibratedPixelSpacing', imageId);
        const isUpdated = this.calibration !== calibration;
        const { scale } = calibration || {};
        this.hasPixelSpacing = scale > 0 || imagePlaneModule.rowPixelSpacing > 0;
        imagePlaneModule.calibration = calibration;
        if (!isUpdated) {
            return imagePlaneModule;
        }
        this.calibration = calibration;
        this._publishCalibratedEvent = true;
        this._calibrationEvent = {
            scale,
            calibration,
        };
        return imagePlaneModule;
    }
    setDefaultProperties(ViewportProperties, imageId) {
        if (imageId == null) {
            this.globalDefaultProperties = ViewportProperties;
        }
        else {
            this.perImageIdDefaultProperties.set(imageId, ViewportProperties);
            if (this.getCurrentImageId() === imageId) {
                this.setProperties(ViewportProperties);
            }
        }
    }
    clearDefaultProperties(imageId) {
        if (imageId == null) {
            this.globalDefaultProperties = {};
            this.resetProperties();
        }
        else {
            this.perImageIdDefaultProperties.delete(imageId);
            this.resetToDefaultProperties();
        }
    }
    setProperties({ colormap, voiRange, VOILUTFunction, invert, interpolationType, } = {}, suppressEvents = false) {
        this.viewportStatus = this.csImage
            ? enums.ViewportStatus.PRE_RENDER
            : enums.ViewportStatus.LOADING;
        this.globalDefaultProperties = {
            colormap: this.globalDefaultProperties.colormap ?? colormap,
            voiRange: this.globalDefaultProperties.voiRange ?? voiRange,
            VOILUTFunction: this.globalDefaultProperties.VOILUTFunction ?? VOILUTFunction,
            invert: this.globalDefaultProperties.invert ?? invert,
            interpolationType: this.globalDefaultProperties.interpolationType ?? interpolationType,
        };
        if (typeof colormap !== 'undefined') {
            this.setColormap(colormap);
        }
        if (typeof voiRange !== 'undefined') {
            const voiUpdatedWithSetProperties = true;
            this.setVOI(voiRange, { suppressEvents, voiUpdatedWithSetProperties });
        }
        if (typeof VOILUTFunction !== 'undefined') {
            this.setVOILUTFunction(VOILUTFunction, suppressEvents);
        }
        if (typeof invert !== 'undefined') {
            this.setInvertColor(invert);
        }
        if (typeof interpolationType !== 'undefined') {
            this.setInterpolationType(interpolationType);
        }
    }
    resetProperties() {
        this.cpuRenderingInvalidated = true;
        this.voiUpdatedWithSetProperties = false;
        this.viewportStatus = enums.ViewportStatus.PRE_RENDER;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
        }
        this._resetProperties();
        this.render();
    }
    _resetProperties() {
        let voiRange;
        if (this._isCurrentImagePTPrescaled()) {
            voiRange = this._getDefaultPTPrescaledVOIRange();
        }
        else {
            voiRange = this._getVOIRangeForCurrentImage();
        }
        this.setVOI(voiRange);
        this.setInvertColor(this.initialInvert);
        this.setInterpolationType(enums.InterpolationType.LINEAR);
        const transferFunction = this.getTransferFunction();
        (0,transferFunctionUtils.setTransferFunctionNodes)(transferFunction, this.initialTransferFunctionNodes);
        const nodes = (0,transferFunctionUtils.getTransferFunctionNodes)(transferFunction);
        const RGBPoints = nodes.reduce((acc, node) => {
            acc.push(node[0], node[1], node[2], node[3]);
            return acc;
        }, []);
        const defaultActor = this.getDefaultActor();
        const matchedColormap = utilities_colormap.findMatchingColormap(RGBPoints, defaultActor.actor);
        this.setColormap(matchedColormap);
    }
    resetToDefaultProperties() {
        this.cpuRenderingInvalidated = true;
        this.viewportStatus = enums.ViewportStatus.PRE_RENDER;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
        }
        const currentImageId = this.getCurrentImageId();
        const properties = this.perImageIdDefaultProperties.get(currentImageId) ||
            this.globalDefaultProperties;
        if (properties.colormap?.name) {
            this.setColormap(properties.colormap);
        }
        let voiRange;
        if (properties.voiRange == undefined) {
            voiRange = this._getVOIRangeForCurrentImage();
        }
        else {
            voiRange = properties.voiRange;
        }
        this.setVOI(voiRange);
        this.setInterpolationType(enums.InterpolationType.LINEAR);
        this.setInvertColor(false);
        this.render();
    }
    _getVOIFromCache() {
        let voiRange;
        if (this.voiUpdatedWithSetProperties) {
            voiRange = this.voiRange;
        }
        else if (this._isCurrentImagePTPrescaled()) {
            voiRange = this._getDefaultPTPrescaledVOIRange();
        }
        else {
            voiRange = this._getVOIRangeForCurrentImage() ?? this.voiRange;
        }
        return voiRange;
    }
    _setPropertiesFromCache() {
        const voiRange = this._getVOIFromCache();
        const { interpolationType, invert } = this;
        this.setVOI(voiRange);
        this.setInterpolationType(interpolationType);
        this.setInvertColor(invert);
    }
    getCameraCPU() {
        const { metadata, viewport } = this._cpuFallbackEnabledElement;
        const { direction } = metadata;
        const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
        let viewUp = direction.slice(3, 6).map((x) => -x);
        if (viewport.rotation) {
            const rotationMatrix = esm/* mat4.fromRotation */.pB.fromRotation(esm/* mat4.create */.pB.create(), (viewport.rotation * Math.PI) / 180, viewPlaneNormal);
            viewUp = esm/* vec3.transformMat4 */.eR.transformMat4(esm/* vec3.create */.eR.create(), viewUp, rotationMatrix);
        }
        const canvasCenter = [
            this.element.clientWidth / 2,
            this.element.clientHeight / 2,
        ];
        const canvasCenterWorld = this.canvasToWorld(canvasCenter);
        const topLeftWorld = this.canvasToWorld([0, 0]);
        const bottomLeftWorld = this.canvasToWorld([0, this.element.clientHeight]);
        const parallelScale = esm/* vec3.distance */.eR.distance(topLeftWorld, bottomLeftWorld) / 2;
        return {
            parallelProjection: true,
            focalPoint: canvasCenterWorld,
            position: [0, 0, 0],
            parallelScale,
            scale: viewport.scale,
            viewPlaneNormal: [
                viewPlaneNormal[0],
                viewPlaneNormal[1],
                viewPlaneNormal[2],
            ],
            viewUp: [viewUp[0], viewUp[1], viewUp[2]],
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
        };
    }
    setCameraCPU(cameraInterface) {
        const { viewport, image } = this._cpuFallbackEnabledElement;
        const previousCamera = this.getCameraCPU();
        const { focalPoint, parallelScale, scale, flipHorizontal, flipVertical } = cameraInterface;
        const { clientHeight } = this.element;
        if (focalPoint) {
            const focalPointCanvas = this.worldToCanvasCPU(focalPoint);
            const focalPointPixel = canvasToPixel(this._cpuFallbackEnabledElement, focalPointCanvas);
            const prevFocalPointCanvas = this.worldToCanvasCPU(previousCamera.focalPoint);
            const prevFocalPointPixel = canvasToPixel(this._cpuFallbackEnabledElement, prevFocalPointCanvas);
            const deltaPixel = esm/* vec2.create */.Zc.create();
            esm/* vec2.subtract */.Zc.subtract(deltaPixel, esm/* vec2.fromValues */.Zc.fromValues(focalPointPixel[0], focalPointPixel[1]), esm/* vec2.fromValues */.Zc.fromValues(prevFocalPointPixel[0], prevFocalPointPixel[1]));
            const shift = correctShift({ x: deltaPixel[0], y: deltaPixel[1] }, viewport);
            viewport.translation.x -= shift.x;
            viewport.translation.y -= shift.y;
        }
        if (parallelScale) {
            const { rowPixelSpacing } = image;
            const scale = (clientHeight * rowPixelSpacing * 0.5) / parallelScale;
            viewport.scale = scale;
            viewport.parallelScale = parallelScale;
        }
        if (scale) {
            const { rowPixelSpacing } = image;
            viewport.scale = scale;
            viewport.parallelScale = (clientHeight * rowPixelSpacing * 0.5) / scale;
        }
        if (flipHorizontal !== undefined || flipVertical !== undefined) {
            this.setFlipCPU({ flipHorizontal, flipVertical });
        }
        this._cpuFallbackEnabledElement.transform = (0,calculateTransform/* default */.A)(this._cpuFallbackEnabledElement);
        const eventDetail = {
            previousCamera,
            camera: this.getCamera(),
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.CAMERA_MODIFIED, eventDetail);
    }
    getPanCPU() {
        const { viewport } = this._cpuFallbackEnabledElement;
        return [viewport.translation.x, viewport.translation.y];
    }
    setPanCPU(pan) {
        const camera = this.getCameraCPU();
        this.setCameraCPU({
            ...camera,
            focalPoint: [...pan.map((p) => -p), 0],
        });
    }
    getZoomCPU() {
        const { viewport } = this._cpuFallbackEnabledElement;
        return viewport.scale;
    }
    setZoomCPU(zoom) {
        const camera = this.getCameraCPU();
        this.setCameraCPU({ ...camera, scale: zoom });
    }
    setFlipCPU({ flipHorizontal, flipVertical }) {
        const { viewport } = this._cpuFallbackEnabledElement;
        if (flipHorizontal !== undefined) {
            viewport.hflip = flipHorizontal;
            this.flipHorizontal = viewport.hflip;
        }
        if (flipVertical !== undefined) {
            viewport.vflip = flipVertical;
            this.flipVertical = viewport.vflip;
        }
    }
    setVOILUTFunction(voiLUTFunction, suppressEvents) {
        if (this.useCPURendering) {
            throw new Error('VOI LUT function is not supported in CPU rendering');
        }
        const newVOILUTFunction = this._getValidVOILUTFunction(voiLUTFunction);
        let forceRecreateLUTFunction = false;
        if (this.VOILUTFunction !== newVOILUTFunction) {
            forceRecreateLUTFunction = true;
        }
        this.VOILUTFunction = newVOILUTFunction;
        const { voiRange } = this.getProperties();
        this.setVOI(voiRange, { suppressEvents, forceRecreateLUTFunction });
    }
    setRotationCPU(rotation) {
        const { viewport } = this._cpuFallbackEnabledElement;
        viewport.rotation = rotation;
    }
    setRotationGPU(rotation) {
        const panFit = this.getPan(this.fitToCanvasCamera);
        const pan = this.getPan();
        const panSub = esm/* vec2.sub */.Zc.sub([0, 0], panFit, pan);
        this.setPan(panSub, false);
        const { flipVertical } = this.getCamera();
        const initialViewUp = flipVertical
            ? esm/* vec3.negate */.eR.negate(esm/* vec3.create */.eR.create(), this.initialViewUp)
            : this.initialViewUp;
        this.setCameraNoEvent({
            viewUp: initialViewUp,
        });
        this.getVtkActiveCamera().roll(-rotation);
        const afterPan = this.getPan();
        const afterPanFit = this.getPan(this.fitToCanvasCamera);
        const newCenter = esm/* vec2.sub */.Zc.sub([0, 0], afterPan, afterPanFit);
        const newOffset = esm/* vec2.add */.Zc.add([0, 0], panFit, newCenter);
        this.setPan(newOffset, false);
    }
    setInterpolationTypeGPU(interpolationType) {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        const { actor } = defaultActor;
        const volumeProperty = actor.getProperty();
        volumeProperty.setInterpolationType(interpolationType);
        this.interpolationType = interpolationType;
    }
    setInterpolationTypeCPU(interpolationType) {
        const { viewport } = this._cpuFallbackEnabledElement;
        viewport.pixelReplication =
            interpolationType === enums.InterpolationType.LINEAR ? false : true;
        this.interpolationType = interpolationType;
    }
    setInvertColorCPU(invert) {
        const { viewport } = this._cpuFallbackEnabledElement;
        if (!viewport) {
            return;
        }
        viewport.invert = invert;
        this.invert = invert;
    }
    setInvertColorGPU(invert) {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        if ((0,actorCheck/* actorIsA */.N)(defaultActor, 'vtkVolume')) {
            const volumeActor = defaultActor.actor;
            const tfunc = volumeActor.getProperty().getRGBTransferFunction(0);
            if ((!this.invert && invert) || (this.invert && !invert)) {
                (0,invertRgbTransferFunction/* default */.A)(tfunc);
            }
            this.invert = invert;
        }
        else if ((0,actorCheck/* actorIsA */.N)(defaultActor, 'vtkImageSlice')) {
            const imageSliceActor = defaultActor.actor;
            const tfunc = imageSliceActor.getProperty().getRGBTransferFunction(0);
            if ((!this.invert && invert) || (this.invert && !invert)) {
                (0,invertRgbTransferFunction/* default */.A)(tfunc);
            }
            this.invert = invert;
        }
    }
    setVOICPU(voiRange, options = {}) {
        const { suppressEvents = false } = options;
        const { viewport, image } = this._cpuFallbackEnabledElement;
        if (!viewport || !image) {
            return;
        }
        if (typeof voiRange === 'undefined') {
            const { windowWidth: ww, windowCenter: wc } = image;
            const wwToUse = Array.isArray(ww) ? ww[0] : ww;
            const wcToUse = Array.isArray(wc) ? wc[0] : wc;
            viewport.voi = {
                windowWidth: wwToUse,
                windowCenter: wcToUse,
            };
            const { lower, upper } = windowLevel.toLowHighRange(wwToUse, wcToUse);
            voiRange = { lower, upper };
        }
        else {
            const { lower, upper } = voiRange;
            const { windowCenter, windowWidth } = windowLevel.toWindowLevel(lower, upper);
            if (!viewport.voi) {
                viewport.voi = {
                    windowWidth: 0,
                    windowCenter: 0,
                };
            }
            viewport.voi.windowWidth = windowWidth;
            viewport.voi.windowCenter = windowCenter;
        }
        this.voiRange = voiRange;
        const eventDetail = {
            viewportId: this.id,
            range: voiRange,
        };
        if (!suppressEvents) {
            (0,triggerEvent/* default */.A)(this.element, enums.Events.VOI_MODIFIED, eventDetail);
        }
    }
    getTransferFunction() {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        const imageActor = defaultActor.actor;
        return imageActor.getProperty().getRGBTransferFunction(0);
    }
    setVOIGPU(voiRange, options = {}) {
        const { suppressEvents = false, forceRecreateLUTFunction = false, voiUpdatedWithSetProperties = false, } = options;
        if (voiRange &&
            this.voiRange &&
            this.voiRange.lower === voiRange.lower &&
            this.voiRange.upper === voiRange.upper &&
            !forceRecreateLUTFunction &&
            !this.stackInvalidated) {
            return;
        }
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        const imageActor = defaultActor.actor;
        let voiRangeToUse = voiRange;
        if (typeof voiRangeToUse === 'undefined') {
            const imageData = imageActor.getMapper().getInputData();
            const range = imageData.getPointData().getScalars().getRange();
            const maxVoiRange = { lower: range[0], upper: range[1] };
            voiRangeToUse = maxVoiRange;
        }
        imageActor.getProperty().setUseLookupTableScalarRange(true);
        let transferFunction = imageActor.getProperty().getRGBTransferFunction(0);
        const isSigmoidTFun = this.VOILUTFunction === enums.VOILUTFunctionType.SAMPLED_SIGMOID;
        if (isSigmoidTFun || !transferFunction || forceRecreateLUTFunction) {
            const transferFunctionCreator = isSigmoidTFun
                ? createSigmoidRGBTransferFunction/* default */.A
                : createLinearRGBTransferFunction/* default */.A;
            transferFunction = transferFunctionCreator(voiRangeToUse);
            if (this.invert) {
                (0,invertRgbTransferFunction/* default */.A)(transferFunction);
            }
            imageActor.getProperty().setRGBTransferFunction(0, transferFunction);
            this.initialTransferFunctionNodes =
                (0,transferFunctionUtils.getTransferFunctionNodes)(transferFunction);
        }
        if (!isSigmoidTFun) {
            transferFunction.setRange(voiRangeToUse.lower, voiRangeToUse.upper);
        }
        this.voiRange = voiRangeToUse;
        if (!this.voiUpdatedWithSetProperties) {
            this.voiUpdatedWithSetProperties = voiUpdatedWithSetProperties;
        }
        if (suppressEvents) {
            return;
        }
        const eventDetail = {
            viewportId: this.id,
            range: voiRangeToUse,
            VOILUTFunction: this.VOILUTFunction,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.VOI_MODIFIED, eventDetail);
    }
    _addScalingToViewport(imageIdScalingFactor) {
        if (this.scaling.PT) {
            return;
        }
        const { suvbw, suvlbm, suvbsa } = imageIdScalingFactor;
        const ptScaling = {};
        if (suvlbm) {
            ptScaling.suvbwToSuvlbm = suvlbm / suvbw;
        }
        if (suvbsa) {
            ptScaling.suvbwToSuvbsa = suvbsa / suvbw;
        }
        this.scaling.PT = ptScaling;
    }
    _getNumCompsFromPhotometricInterpretation(photometricInterpretation) {
        let numberOfComponents = 1;
        if (photometricInterpretation === 'RGB' ||
            photometricInterpretation.includes('YBR') ||
            photometricInterpretation === 'PALETTE COLOR') {
            numberOfComponents = 3;
        }
        return numberOfComponents;
    }
    getImageDataMetadata(image) {
        const { imagePlaneModule, imagePixelModule } = this.buildMetadata(image);
        let rowCosines, columnCosines;
        rowCosines = imagePlaneModule.rowCosines;
        columnCosines = imagePlaneModule.columnCosines;
        if (rowCosines == null || columnCosines == null) {
            rowCosines = [1, 0, 0];
            columnCosines = [0, 1, 0];
        }
        const rowCosineVec = esm/* vec3.fromValues */.eR.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
        const colCosineVec = esm/* vec3.fromValues */.eR.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
        const scanAxisNormal = esm/* vec3.create */.eR.create();
        esm/* vec3.cross */.eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
        let origin = imagePlaneModule.imagePositionPatient;
        if (origin == null) {
            origin = [0, 0, 0];
        }
        const xSpacing = imagePlaneModule.columnPixelSpacing || image.columnPixelSpacing;
        const ySpacing = imagePlaneModule.rowPixelSpacing || image.rowPixelSpacing;
        const xVoxels = image.columns;
        const yVoxels = image.rows;
        const zSpacing = EPSILON;
        const zVoxels = 1;
        const numberOfComponents = image.numberOfComponents ||
            this._getNumCompsFromPhotometricInterpretation(imagePixelModule.photometricInterpretation);
        return {
            bitsAllocated: imagePixelModule.bitsAllocated,
            numberOfComponents,
            origin,
            direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
            dimensions: [xVoxels, yVoxels, zVoxels],
            spacing: [xSpacing, ySpacing, zSpacing],
            numVoxels: xVoxels * yVoxels * zVoxels,
            imagePlaneModule,
            imagePixelModule,
        };
    }
    matchImagesForOverlay(currentImageId, targetOverlayImageId) {
        const matchImagesForOverlay = (targetImageId) => {
            const overlayImagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, targetOverlayImageId);
            const currentImagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, targetImageId);
            const overlayOrientation = overlayImagePlaneModule.imageOrientationPatient;
            const currentOrientation = currentImagePlaneModule.imageOrientationPatient;
            if (overlayOrientation && currentOrientation) {
                const closeEnough = (0,isEqual/* isEqual */.n4)(overlayImagePlaneModule.imageOrientationPatient, currentImagePlaneModule.imageOrientationPatient);
                if (closeEnough) {
                    const referencePosition = overlayImagePlaneModule.imagePositionPatient;
                    const currentPosition = currentImagePlaneModule.imagePositionPatient;
                    if (referencePosition && currentPosition) {
                        const closeEnough = (0,isEqual/* isEqual */.n4)(referencePosition, currentPosition);
                        if (closeEnough) {
                            const referenceRows = overlayImagePlaneModule.rows;
                            const referenceColumns = overlayImagePlaneModule.columns;
                            const currentRows = currentImagePlaneModule.rows;
                            const currentColumns = currentImagePlaneModule.columns;
                            if (referenceRows === currentRows &&
                                referenceColumns === currentColumns) {
                                return targetImageId;
                            }
                        }
                    }
                }
            }
            else {
                const referenceRows = overlayImagePlaneModule.rows;
                const referenceColumns = overlayImagePlaneModule.columns;
                const currentRows = currentImagePlaneModule.rows;
                const currentColumns = currentImagePlaneModule.columns;
                if (referenceRows === currentRows &&
                    referenceColumns === currentColumns) {
                    return targetImageId;
                }
            }
        };
        return matchImagesForOverlay(currentImageId);
    }
    getImagePlaneReferenceData(sliceIndex = this.getCurrentImageIdIndex()) {
        const imageId = this.imageIds[sliceIndex];
        if (!imageId) {
            return;
        }
        const imagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, imageId);
        if (!imagePlaneModule) {
            return;
        }
        const { imagePositionPatient, frameOfReferenceUID: FrameOfReferenceUID } = imagePlaneModule;
        let { rowCosines, columnCosines } = imagePlaneModule;
        rowCosines ||= [1, 0, 0];
        columnCosines ||= [0, 1, 0];
        const viewPlaneNormal = esm/* vec3.cross */.eR.cross([0, 0, 0], columnCosines, rowCosines);
        return {
            FrameOfReferenceUID,
            viewPlaneNormal,
            cameraFocalPoint: imagePositionPatient,
            referencedImageId: imageId,
            sliceIndex,
        };
    }
    _getCameraOrientation(imageDataDirection) {
        const viewPlaneNormal = imageDataDirection.slice(6, 9).map((x) => -x);
        const viewUp = imageDataDirection.slice(3, 6).map((x) => -x);
        return {
            viewPlaneNormal: [
                viewPlaneNormal[0],
                viewPlaneNormal[1],
                viewPlaneNormal[2],
            ],
            viewUp: [viewUp[0], viewUp[1], viewUp[2]],
        };
    }
    createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray, }) {
        const values = new pixelArray.constructor(pixelArray.length);
        const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
            name: 'Pixels',
            numberOfComponents: numberOfComponents,
            values: values,
        });
        const imageData = ImageData/* default.newInstance */.Ay.newInstance();
        imageData.setDimensions(dimensions);
        imageData.setSpacing(spacing);
        imageData.setDirection(direction);
        imageData.setOrigin(origin);
        imageData.getPointData().setScalars(scalarArray);
        return imageData;
    }
    _createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray, }) {
        try {
            this._imageData = this.createVTKImageData({
                origin,
                direction,
                dimensions,
                spacing,
                numberOfComponents,
                pixelArray,
            });
        }
        catch (e) {
            console.error(e);
        }
    }
    async setStack(imageIds, currentImageIdIndex = 0) {
        this._throwIfDestroyed();
        this.imageIds = imageIds;
        this.currentImageIdIndex = currentImageIdIndex;
        this.targetImageIdIndex = currentImageIdIndex;
        const imageRetrieveConfiguration = metaData.get(imageRetrieveMetadataProvider/* default */.A.IMAGE_RETRIEVE_CONFIGURATION, imageIds[currentImageIdIndex], 'stack');
        this.imagesLoader = imageRetrieveConfiguration
            ? (imageRetrieveConfiguration.create || ProgressiveRetrieveImages/* createProgressive */.Ke)(imageRetrieveConfiguration)
            : this;
        this.stackInvalidated = true;
        this.flipVertical = false;
        this.flipHorizontal = false;
        this.voiRange = null;
        this.interpolationType = enums.InterpolationType.LINEAR;
        this.invert = false;
        this.viewportStatus = enums.ViewportStatus.LOADING;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
            delete this._cpuFallbackEnabledElement.viewport.colormap;
        }
        const imageId = await this._setImageIdIndex(currentImageIdIndex);
        const eventDetail = {
            imageIds,
            viewportId: this.id,
            element: this.element,
            currentImageIdIndex: currentImageIdIndex,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.VIEWPORT_NEW_IMAGE_SET, eventDetail);
        return imageId;
    }
    _throwIfDestroyed() {
        if (this.isDisabled) {
            throw new Error('The stack viewport has been destroyed and is no longer usable. Renderings will not be performed. If you ' +
                'are using the same viewportId and have re-enabled the viewport, you need to grab the new viewport instance ' +
                'using renderingEngine.getViewport(viewportId), instead of using your lexical scoped reference to the viewport instance.');
        }
    }
    _checkVTKImageDataMatchesCornerstoneImage(image, imageData) {
        if (!imageData) {
            return false;
        }
        const [xSpacing, ySpacing] = imageData.getSpacing();
        const [xVoxels, yVoxels] = imageData.getDimensions();
        const imagePlaneModule = this._getImagePlaneModule(image.imageId);
        const direction = imageData.getDirection();
        const rowCosines = direction.slice(0, 3);
        const columnCosines = direction.slice(3, 6);
        const dataType = imageData.getPointData().getScalars().getDataType();
        const isSameXSpacing = (0,isEqual/* isEqual */.n4)(xSpacing, image.columnPixelSpacing);
        const isSameYSpacing = (0,isEqual/* isEqual */.n4)(ySpacing, image.rowPixelSpacing);
        const isXSpacingValid = isSameXSpacing || (image.columnPixelSpacing === null && xSpacing === 1.0);
        const isYSpacingValid = isSameYSpacing || (image.rowPixelSpacing === null && ySpacing === 1.0);
        const isXVoxelsMatching = xVoxels === image.columns;
        const isYVoxelsMatching = yVoxels === image.rows;
        const isRowCosinesMatching = (0,isEqual/* isEqual */.n4)(imagePlaneModule.rowCosines, rowCosines);
        const isColumnCosinesMatching = (0,isEqual/* isEqual */.n4)(imagePlaneModule.columnCosines, columnCosines);
        const isDataTypeMatching = dataType === image.voxelManager.getScalarData().constructor.name;
        const result = isXSpacingValid &&
            isYSpacingValid &&
            isXVoxelsMatching &&
            isYVoxelsMatching &&
            isRowCosinesMatching &&
            isColumnCosinesMatching &&
            isDataTypeMatching;
        return result;
    }
    _updateVTKImageDataFromCornerstoneImage(image) {
        const imagePlaneModule = this._getImagePlaneModule(image.imageId);
        let origin = imagePlaneModule.imagePositionPatient;
        if (origin == null) {
            origin = [0, 0, 0];
        }
        this._imageData.setOrigin(origin);
        (0,updateVTKImageDataWithCornerstoneImage/* updateVTKImageDataWithCornerstoneImage */.J)(this._imageData, image);
    }
    _loadAndDisplayImage(imageId, imageIdIndex) {
        return this.useCPURendering
            ? this._loadAndDisplayImageCPU(imageId, imageIdIndex)
            : this._loadAndDisplayImageGPU(imageId, imageIdIndex);
    }
    _loadAndDisplayImageCPU(imageId, imageIdIndex) {
        return new Promise((resolve, reject) => {
            function successCallback(image, imageIdIndex, imageId) {
                if (this.currentImageIdIndex !== imageIdIndex) {
                    return;
                }
                const pixelData = image.voxelManager.getScalarData();
                const preScale = image.preScale;
                const scalingParams = preScale?.scalingParameters;
                const scaledWithNonIntegers = (preScale?.scaled && scalingParams?.rescaleIntercept % 1 !== 0) ||
                    scalingParams?.rescaleSlope % 1 !== 0;
                if (pixelData instanceof Float32Array && scaledWithNonIntegers) {
                    const floatMinMax = {
                        min: image.maxPixelValue,
                        max: image.minPixelValue,
                    };
                    const floatRange = Math.abs(floatMinMax.max - floatMinMax.min);
                    const intRange = 65535;
                    const slope = floatRange / intRange;
                    const intercept = floatMinMax.min;
                    const numPixels = pixelData.length;
                    const intPixelData = new Uint16Array(numPixels);
                    let min = 65535;
                    let max = 0;
                    for (let i = 0; i < numPixels; i++) {
                        const rescaledPixel = Math.floor((pixelData[i] - intercept) / slope);
                        intPixelData[i] = rescaledPixel;
                        min = Math.min(min, rescaledPixel);
                        max = Math.max(max, rescaledPixel);
                    }
                    image.minPixelValue = min;
                    image.maxPixelValue = max;
                    image.slope = slope;
                    image.intercept = intercept;
                    image.getPixelData = () => intPixelData;
                    image.preScale = {
                        ...image.preScale,
                        scaled: false,
                    };
                }
                this._setCSImage(image);
                this.viewportStatus = enums.ViewportStatus.PRE_RENDER;
                const eventDetail = {
                    image,
                    imageId,
                    imageIdIndex,
                    viewportId: this.id,
                    renderingEngineId: this.renderingEngineId,
                };
                (0,triggerEvent/* default */.A)(this.element, enums.Events.STACK_NEW_IMAGE, eventDetail);
                this._updateToDisplayImageCPU(image);
                this.render();
                this.currentImageIdIndex = imageIdIndex;
                resolve(imageId);
            }
            function errorCallback(error, imageIdIndex, imageId) {
                const eventDetail = {
                    error,
                    imageIdIndex,
                    imageId,
                };
                if (!this.suppressEvents) {
                    (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.IMAGE_LOAD_ERROR, eventDetail);
                }
                reject(error);
            }
            function sendRequest(imageId, imageIdIndex, options) {
                return (0,imageLoader.loadAndCacheImage)(imageId, options).then((image) => {
                    successCallback.call(this, image, imageIdIndex, imageId);
                }, (error) => {
                    errorCallback.call(this, error, imageIdIndex, imageId);
                });
            }
            const priority = -5;
            const requestType = enums.RequestType.Interaction;
            const additionalDetails = { imageId, imageIdIndex };
            const options = {
                useRGBA: true,
                requestType,
            };
            const eventDetail = {
                imageId,
                imageIdIndex,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            (0,triggerEvent/* default */.A)(this.element, enums.Events.PRE_STACK_NEW_IMAGE, eventDetail);
            imageLoadPoolManager/* default */.A.addRequest(sendRequest.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
        });
    }
    successCallback(imageId, image) {
        const imageIdIndex = this.imageIds.indexOf(imageId);
        if (this.currentImageIdIndex !== imageIdIndex) {
            return;
        }
        const csImgFrame = this.csImage?.imageFrame;
        const imgFrame = image?.imageFrame;
        const photometricInterpretation = csImgFrame?.photometricInterpretation ||
            this.csImage?.photometricInterpretation;
        const newPhotometricInterpretation = imgFrame?.photometricInterpretation || image?.photometricInterpretation;
        if (photometricInterpretation !== newPhotometricInterpretation) {
            this.stackInvalidated = true;
        }
        this._setCSImage(image);
        const eventDetail = {
            image,
            imageId,
            imageIdIndex,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        this._updateActorToDisplayImageId(image);
        (0,triggerEvent/* default */.A)(this.element, enums.Events.STACK_NEW_IMAGE, eventDetail);
        this.render();
        this.currentImageIdIndex = imageIdIndex;
    }
    errorCallback(imageId, permanent, error) {
        if (!permanent) {
            return;
        }
        const imageIdIndex = this.imageIds.indexOf(imageId);
        const eventDetail = {
            error,
            imageIdIndex,
            imageId,
        };
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.IMAGE_LOAD_ERROR, eventDetail);
    }
    getLoaderImageOptions(imageId) {
        const imageIdIndex = this.imageIds.indexOf(imageId);
        const { transferSyntaxUID } = metaData.get('transferSyntax', imageId) || {};
        const options = {
            useRGBA: false,
            transferSyntaxUID,
            priority: 5,
            requestType: enums.RequestType.Interaction,
            additionalDetails: { imageId, imageIdIndex },
        };
        return options;
    }
    async loadImages(imageIds, listener) {
        const resultList = await Promise.allSettled(imageIds.map((imageId) => {
            const options = this.getLoaderImageOptions(imageId);
            return (0,imageLoader.loadAndCacheImage)(imageId, options).then((image) => {
                listener.successCallback(imageId, image);
                return imageId;
            }, (error) => {
                listener.errorCallback(imageId, true, error);
                return imageId;
            });
        }));
        const errorList = resultList.filter((item) => item.status === 'rejected');
        if (errorList && errorList.length) {
            const event = new CustomEvent(enums.Events.IMAGE_LOAD_ERROR, {
                detail: errorList,
                cancelable: true,
            });
            eventTarget/* default */.A.dispatchEvent(event);
        }
        return resultList;
    }
    _loadAndDisplayImageGPU(imageId, imageIdIndex) {
        const eventDetail = {
            imageId,
            imageIdIndex,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.PRE_STACK_NEW_IMAGE, eventDetail);
        return this.imagesLoader.loadImages([imageId], this).then((v) => {
            return imageId;
        });
    }
    _updateToDisplayImageCPU(image) {
        const metadata = this.getImageDataMetadata(image);
        const viewport = (0,getDefaultViewport/* default */.A)(this.canvas, image, this.modality, this._cpuFallbackEnabledElement.viewport.colormap);
        const { windowCenter, windowWidth } = viewport.voi;
        this.voiRange = windowLevel.toLowHighRange(windowWidth, windowCenter);
        this._cpuFallbackEnabledElement.image = image;
        this._cpuFallbackEnabledElement.metadata = {
            ...metadata,
        };
        this.cpuImagePixelData = image.voxelManager.getScalarData();
        const viewportSettingToUse = Object.assign({}, viewport, this._cpuFallbackEnabledElement.viewport);
        this._cpuFallbackEnabledElement.viewport = this.stackInvalidated
            ? viewport
            : viewportSettingToUse;
        this.stackInvalidated = false;
        this.cpuRenderingInvalidated = true;
        this._cpuFallbackEnabledElement.transform = (0,calculateTransform/* default */.A)(this._cpuFallbackEnabledElement);
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    addImages(stackInputs) {
        const actors = [];
        stackInputs.forEach((stackInput) => {
            const { imageId, ...rest } = stackInput;
            const image = cache/* default */.Ay.getImage(imageId);
            const { origin, dimensions, direction, spacing, numberOfComponents } = this.getImageDataMetadata(image);
            const imagedata = this.createVTKImageData({
                origin,
                dimensions,
                direction,
                spacing,
                numberOfComponents,
                pixelArray: image.voxelManager.getScalarData(),
            });
            const imageActor = this.createActorMapper(imagedata);
            if (imageActor) {
                actors.push({
                    uid: stackInput.actorUID ?? (0,uuidv4/* default */.A)(),
                    actor: imageActor,
                    referencedId: imageId,
                    ...rest,
                });
                if (stackInput.callback) {
                    stackInput.callback({ imageActor, imageId: stackInput.imageId });
                }
            }
        });
        this.addActors(actors);
    }
    _updateActorToDisplayImageId(image) {
        const sameImageData = this._checkVTKImageDataMatchesCornerstoneImage(image, this._imageData);
        const viewPresentation = this.getViewPresentation();
        if (sameImageData && !this.stackInvalidated) {
            this._updateVTKImageDataFromCornerstoneImage(image);
            this.resetCameraNoEvent();
            this.setViewPresentation(viewPresentation);
            this._setPropertiesFromCache();
            this.stackActorReInitialized = false;
            return;
        }
        const { origin, direction, dimensions, spacing, numberOfComponents, imagePixelModule, } = this.getImageDataMetadata(image);
        const pixelArray = image.voxelManager.getScalarData();
        this._createVTKImageData({
            origin,
            direction,
            dimensions,
            spacing,
            numberOfComponents,
            pixelArray,
        });
        this._updateVTKImageDataFromCornerstoneImage(image);
        const actor = this.createActorMapper(this._imageData);
        const oldActors = this.getActors();
        if (oldActors.length && oldActors[0].uid === this.id) {
            oldActors[0].actor = actor;
        }
        else {
            oldActors.unshift({ uid: this.id, actor });
        }
        this.setActors(oldActors);
        const { viewPlaneNormal, viewUp } = this._getCameraOrientation(direction);
        const previousCamera = this.getCamera();
        this.setCameraNoEvent({ viewUp, viewPlaneNormal });
        this.initialViewUp = viewUp;
        this.resetCameraNoEvent();
        this.setViewPresentation(viewPresentation);
        this.triggerCameraEvent(this.getCamera(), previousCamera);
        const monochrome1 = imagePixelModule.photometricInterpretation === 'MONOCHROME1';
        this.stackInvalidated = true;
        const voiRange = this._getInitialVOIRange(image);
        this.setVOI(voiRange, {
            forceRecreateLUTFunction: !!monochrome1,
        });
        this.initialInvert = !!monochrome1;
        this.setInvertColor(this.invert || this.initialInvert);
        this.stackInvalidated = false;
        this.stackActorReInitialized = true;
        if (this._publishCalibratedEvent) {
            this.triggerCalibrationEvent();
        }
    }
    _getInitialVOIRange(image) {
        if (this.voiRange && this.voiUpdatedWithSetProperties) {
            return this.globalDefaultProperties.voiRange;
        }
        const { windowCenter, windowWidth } = image;
        let voiRange = this._getVOIRangeFromWindowLevel(windowWidth, windowCenter);
        voiRange = this._getPTPreScaledRange() || voiRange;
        return voiRange;
    }
    _getPTPreScaledRange() {
        if (!this._isCurrentImagePTPrescaled()) {
            return undefined;
        }
        return this._getDefaultPTPrescaledVOIRange();
    }
    _isCurrentImagePTPrescaled() {
        if (this.modality !== 'PT' || !this.csImage.isPreScaled) {
            return false;
        }
        if (!this.csImage.preScale?.scalingParameters.suvbw) {
            return false;
        }
        return true;
    }
    _getDefaultPTPrescaledVOIRange() {
        return { lower: 0, upper: 5 };
    }
    _getVOIRangeFromWindowLevel(windowWidth, windowCenter) {
        let center, width;
        if (typeof windowCenter === 'number' && typeof windowWidth === 'number') {
            center = windowCenter;
            width = windowWidth;
        }
        else if (Array.isArray(windowCenter) && Array.isArray(windowWidth)) {
            center = windowCenter[0];
            width = windowWidth[0];
        }
        if (center !== undefined && width !== undefined) {
            return windowLevel.toLowHighRange(width, center);
        }
    }
    async _setImageIdIndex(imageIdIndex) {
        if (imageIdIndex >= this.imageIds.length) {
            throw new Error(`ImageIdIndex provided ${imageIdIndex} is invalid, the stack only has ${this.imageIds.length} elements`);
        }
        this.currentImageIdIndex = imageIdIndex;
        this.hasPixelSpacing = true;
        this.viewportStatus = enums.ViewportStatus.PRE_RENDER;
        const imageId = await this._loadAndDisplayImage(this.imageIds[imageIdIndex], imageIdIndex);
        if (this.perImageIdDefaultProperties.size >= 1) {
            const defaultProperties = this.perImageIdDefaultProperties.get(imageId);
            if (defaultProperties !== undefined) {
                this.setProperties(defaultProperties);
            }
            else if (this.globalDefaultProperties !== undefined) {
                this.setProperties(this.globalDefaultProperties);
            }
        }
        return imageId;
    }
    resetCameraCPU({ resetPan = true, resetZoom = true, }) {
        const { image } = this._cpuFallbackEnabledElement;
        if (!image) {
            return;
        }
        resetCamera(this._cpuFallbackEnabledElement, resetPan, resetZoom);
        const { scale } = this._cpuFallbackEnabledElement.viewport;
        const { clientWidth, clientHeight } = this.element;
        const center = [clientWidth / 2, clientHeight / 2];
        const centerWorld = this.canvasToWorldCPU(center);
        this.setCameraCPU({
            focalPoint: centerWorld,
            scale,
        });
    }
    resetCameraGPU({ resetPan, resetZoom }) {
        this.setCamera({
            flipHorizontal: false,
            flipVertical: false,
            viewUp: this.initialViewUp,
        });
        const resetToCenter = true;
        return super.resetCamera({ resetPan, resetZoom, resetToCenter });
    }
    scroll(delta, debounce = true, loop = false) {
        const imageIds = this.imageIds;
        const currentTargetImageIdIndex = this.targetImageIdIndex;
        const numberOfFrames = imageIds.length;
        let newTargetImageIdIndex = currentTargetImageIdIndex + delta;
        newTargetImageIdIndex = Math.max(0, newTargetImageIdIndex);
        if (loop) {
            newTargetImageIdIndex = newTargetImageIdIndex % numberOfFrames;
        }
        else {
            newTargetImageIdIndex = Math.min(numberOfFrames - 1, newTargetImageIdIndex);
        }
        this.targetImageIdIndex = newTargetImageIdIndex;
        const targetImageId = imageIds[newTargetImageIdIndex];
        const imageAlreadyLoaded = cache/* default */.Ay.isLoaded(targetImageId);
        if (imageAlreadyLoaded || !debounce) {
            this.setImageIdIndex(newTargetImageIdIndex);
        }
        else {
            clearTimeout(this.debouncedTimeout);
            this.debouncedTimeout = window.setTimeout(() => {
                this.setImageIdIndex(newTargetImageIdIndex);
            }, 40);
        }
        const eventData = {
            newImageIdIndex: newTargetImageIdIndex,
            imageId: targetImageId,
            direction: delta,
        };
        if (newTargetImageIdIndex !== currentTargetImageIdIndex) {
            (0,triggerEvent/* default */.A)(this.element, enums.Events.STACK_VIEWPORT_SCROLL, eventData);
        }
    }
    setImageIdIndex(imageIdIndex) {
        this._throwIfDestroyed();
        if (this.currentImageIdIndex === imageIdIndex) {
            return Promise.resolve(this.getCurrentImageId());
        }
        const imageIdPromise = this._setImageIdIndex(imageIdIndex);
        return imageIdPromise;
    }
    calibrateSpacing(imageId) {
        const imageIdIndex = this.getImageIds().indexOf(imageId);
        this.stackInvalidated = true;
        this._loadAndDisplayImage(imageId, imageIdIndex);
    }
    triggerCameraEvent(camera, previousCamera) {
        const eventDetail = {
            previousCamera,
            camera,
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        if (!this.suppressEvents) {
            (0,triggerEvent/* default */.A)(this.element, enums.Events.CAMERA_MODIFIED, eventDetail);
        }
    }
    triggerCalibrationEvent() {
        const { imageData } = this.getImageData();
        const eventDetail = {
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
            imageId: this.getCurrentImageId(),
            imageData: imageData,
            worldToIndex: imageData.getWorldToIndex(),
            ...this._calibrationEvent,
        };
        if (!this.suppressEvents) {
            (0,triggerEvent/* default */.A)(this.element, enums.Events.IMAGE_SPACING_CALIBRATED, eventDetail);
        }
        this._publishCalibratedEvent = false;
    }
    jumpToWorld(worldPos) {
        const imageIds = this.getImageIds();
        const imageData = this.getImageData();
        const { direction, spacing } = imageData;
        const imageId = (0,getClosestImageId/* default */.A)({ direction: direction, spacing, imageIds }, worldPos, this.getCamera().viewPlaneNormal);
        const index = imageIds.indexOf(imageId);
        if (index === -1) {
            return false;
        }
        this.setImageIdIndex(index);
        this.render();
        return true;
    }
    _getVOIRangeForCurrentImage() {
        const { windowCenter, windowWidth } = this.csImage;
        return this._getVOIRangeFromWindowLevel(windowWidth, windowCenter);
    }
    _getValidVOILUTFunction(voiLUTFunction) {
        if (!Object.values(enums.VOILUTFunctionType).includes(voiLUTFunction)) {
            return enums.VOILUTFunctionType.LINEAR;
        }
        return voiLUTFunction;
    }
    getSliceInfo() {
        const sliceIndex = this.getSliceIndex();
        const { dimensions } = this.getImageData();
        return {
            width: dimensions[0],
            height: dimensions[1],
            sliceIndex,
            slicePlane: 2,
        };
    }
    isReferenceViewable(viewRef, options = {}) {
        if (!super.isReferenceViewable(viewRef, options)) {
            return false;
        }
        const { referencedImageId, sliceIndex } = viewRef;
        if (viewRef.volumeId && !referencedImageId) {
            return options.asVolume;
        }
        let testIndex = this.getCurrentImageIdIndex();
        let currentImageId = this.imageIds[testIndex];
        if (options.withNavigation && typeof sliceIndex === 'number') {
            testIndex = sliceIndex;
            currentImageId = this.imageIds[testIndex];
        }
        if (!currentImageId) {
            return false;
        }
        if (options.asOverlay && referencedImageId) {
            const matchedImageId = this.matchImagesForOverlay(currentImageId, referencedImageId);
            if (matchedImageId) {
                return true;
            }
        }
        let { imageURI } = options;
        if (!imageURI) {
            imageURI = (0,imageIdToURI/* default */.A)(currentImageId);
        }
        const referencedImageURI = (0,imageIdToURI/* default */.A)(referencedImageId);
        const matches = referencedImageURI === imageURI;
        if (matches) {
            return matches;
        }
        const { cameraFocalPoint } = viewRef;
        if (options.asNearbyProjection && cameraFocalPoint) {
            const { spacing, direction, origin } = this.getImageData();
            const viewPlaneNormal = direction.slice(6, 9);
            const sliceThickness = (0,getSpacingInNormalDirection/* default */.A)({ direction, spacing }, viewPlaneNormal);
            const diff = esm/* vec3.subtract */.eR.subtract(esm/* vec3.create */.eR.create(), cameraFocalPoint, origin);
            const distanceToPlane = esm/* vec3.dot */.eR.dot(diff, viewPlaneNormal);
            const threshold = sliceThickness / 2;
            if (Math.abs(distanceToPlane) <= threshold) {
                return true;
            }
        }
        return false;
    }
    getViewReference(viewRefSpecifier = {}) {
        const { sliceIndex = this.getCurrentImageIdIndex() } = viewRefSpecifier;
        const reference = super.getViewReference(viewRefSpecifier);
        const referencedImageId = this.imageIds[sliceIndex];
        if (!referencedImageId) {
            return;
        }
        reference.referencedImageId = referencedImageId;
        if (this.getCurrentImageIdIndex() !== sliceIndex) {
            const referenceData = this.getImagePlaneReferenceData(sliceIndex);
            if (!referenceData) {
                return;
            }
            Object.assign(reference, referenceData);
        }
        return reference;
    }
    setViewReference(viewRef) {
        if (!viewRef) {
            return;
        }
        const { referencedImageId, sliceIndex } = viewRef;
        if (typeof sliceIndex === 'number' &&
            referencedImageId &&
            referencedImageId === this.imageIds[sliceIndex]) {
            this.scroll(sliceIndex - this.targetImageIdIndex);
        }
        else {
            const foundIndex = this.imageIds.indexOf(referencedImageId);
            if (foundIndex !== -1) {
                this.scroll(foundIndex - this.targetImageIdIndex);
            }
            else {
                throw new Error('Unsupported - referenced image id not found');
            }
        }
    }
    getViewReferenceId(specifier = {}) {
        const { sliceIndex: sliceIndex = this.currentImageIdIndex } = specifier;
        if (Array.isArray(sliceIndex)) {
            throw new Error('Use of slice ranges for stacks not supported');
        }
        return `imageId:${this.imageIds[sliceIndex]}`;
    }
    getCPUFallbackError(method) {
        return new Error(`method ${method} cannot be used during CPU Fallback mode`);
    }
    fillWithBackgroundColor() {
        const renderingEngine = this.getRenderingEngine();
        if (renderingEngine) {
            renderingEngine.fillCanvasWithBackgroundColor(this.canvas, this.options.background);
        }
    }
    unsetColormapCPU() {
        delete this._cpuFallbackEnabledElement.viewport.colormap;
        this._cpuFallbackEnabledElement.renderingTools = {};
        this.cpuRenderingInvalidated = true;
        this.fillWithBackgroundColor();
        this.render();
    }
    setColormapCPU(colormapData) {
        this.colormap = colormapData;
        const colormap = utilities_colormap.getColormap(colormapData.name);
        this._cpuFallbackEnabledElement.viewport.colormap = colormap;
        this._cpuFallbackEnabledElement.renderingTools = {};
        this.fillWithBackgroundColor();
        this.cpuRenderingInvalidated = true;
        this.render();
        const eventDetail = {
            viewportId: this.id,
            colormap: colormapData,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.COLORMAP_MODIFIED, eventDetail);
    }
    setColormapGPU(colormap) {
        const ActorEntry = this.getDefaultActor();
        const actor = ActorEntry.actor;
        const actorProp = actor.getProperty();
        const rgbTransferFunction = actorProp.getRGBTransferFunction();
        const colormapObj = utilities_colormap.getColormap(colormap.name) ||
            ColorMaps/* default */.A.getPresetByName(colormap.name);
        if (!rgbTransferFunction) {
            const cfun = ColorTransferFunction/* default.newInstance */.Ay.newInstance();
            cfun.applyColorMap(colormapObj);
            cfun.setMappingRange(this.voiRange.lower, this.voiRange.upper);
            actorProp.setRGBTransferFunction(0, cfun);
        }
        else {
            rgbTransferFunction.applyColorMap(colormapObj);
            rgbTransferFunction.setMappingRange(this.voiRange.lower, this.voiRange.upper);
            actorProp.setRGBTransferFunction(0, rgbTransferFunction);
        }
        this.colormap = colormap;
        this.render();
        const eventDetail = {
            viewportId: this.id,
            colormap,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.COLORMAP_MODIFIED, eventDetail);
    }
    unsetColormapGPU() {
        throw new Error('unsetColormapGPU not implemented.');
    }
    _getImagePlaneModule(imageId) {
        const imagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, imageId);
        this.hasPixelSpacing =
            !imagePlaneModule.usingDefaultValues || this.calibration?.scale > 0;
        this.calibration ||= imagePlaneModule.calibration;
        const newImagePlaneModule = {
            ...imagePlaneModule,
        };
        if (!newImagePlaneModule.columnPixelSpacing) {
            newImagePlaneModule.columnPixelSpacing = 1;
        }
        if (!newImagePlaneModule.rowPixelSpacing) {
            newImagePlaneModule.rowPixelSpacing = 1;
        }
        if (!newImagePlaneModule.columnCosines) {
            newImagePlaneModule.columnCosines = [0, 1, 0];
        }
        if (!newImagePlaneModule.rowCosines) {
            newImagePlaneModule.rowCosines = [1, 0, 0];
        }
        if (!newImagePlaneModule.imagePositionPatient) {
            newImagePlaneModule.imagePositionPatient = [0, 0, 0];
        }
        if (!newImagePlaneModule.imageOrientationPatient) {
            newImagePlaneModule.imageOrientationPatient = new Float32Array([
                1, 0, 0, 0, 1, 0,
            ]);
        }
        return newImagePlaneModule;
    }
}
/* harmony default export */ const RenderingEngine_StackViewport = (StackViewport);


/***/ }),

/***/ 32501:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ RenderingEngine_VideoViewport)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 4 modules
var enums = __webpack_require__(31749);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var metaData = __webpack_require__(74876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/transform.js
var rendering_transform = __webpack_require__(45354);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/Viewport.js
var Viewport = __webpack_require__(10056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js + 2 modules
var helpers = __webpack_require__(98834);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/CanvasProperties.js
class CanvasProperties {
    constructor(actor) {
        this.opacity = 0.4;
        this.outlineOpacity = 0.4;
        this.transferFunction = [];
        this.actor = actor;
    }
    setRGBTransferFunction(index, cfun) {
        this.transferFunction[index] = cfun;
    }
    setScalarOpacity(opacity) {
    }
    setInterpolationTypeToNearest() {
    }
    setUseLabelOutline() {
    }
    setLabelOutlineOpacity(opacity) {
        this.outlineOpacity = opacity;
    }
    setLabelOutlineThickness() {
    }
    getColor(index) {
        const cfun = this.transferFunction[0];
        const r = cfun.getRedValue(index);
        const g = cfun.getGreenValue(index);
        const b = cfun.getBlueValue(index);
        return [r, g, b, this.opacity];
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/CanvasMapper.js
class CanvasMapper {
    constructor(actor) {
        this.actor = actor;
    }
    getInputData() {
        return this.actor.getImage();
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/index.js


class CanvasActor {
    constructor(viewport, derivedImage) {
        this.canvasProperties = new CanvasProperties(this);
        this.visibility = false;
        this.mapper = new CanvasMapper(this);
        this.className = 'CanvasActor';
        this.derivedImage = derivedImage;
        this.viewport = viewport;
    }
    renderRLE(viewport, context, voxelManager) {
        const { width, height } = this.image;
        let { canvas } = this;
        if (!canvas || canvas.width !== width || canvas.height !== height) {
            this.canvas = canvas = new window.OffscreenCanvas(width, height);
        }
        const localContext = canvas.getContext('2d');
        const imageData = localContext.createImageData(width, height);
        const { data: imageArray } = imageData;
        imageArray.fill(0);
        const { map } = voxelManager;
        let dirtyX = Infinity;
        let dirtyY = Infinity;
        let dirtyX2 = -Infinity;
        let dirtyY2 = -Infinity;
        for (let y = 0; y < height; y++) {
            const row = map.getRun(y, 0);
            if (!row) {
                continue;
            }
            dirtyY = Math.min(dirtyY, y);
            dirtyY2 = Math.max(dirtyY2, y);
            const baseOffset = (y * width) << 2;
            let indicesToDelete;
            for (const run of row) {
                const { start, end, value: segmentIndex } = run;
                if (segmentIndex === 0) {
                    indicesToDelete ||= [];
                    indicesToDelete.push(row.indexOf(run));
                    continue;
                }
                dirtyX = Math.min(dirtyX, start);
                dirtyX2 = Math.max(dirtyX2, end);
                const rgb = this.canvasProperties
                    .getColor(segmentIndex)
                    .map((v) => v * 255);
                let startOffset = baseOffset + (start << 2);
                for (let i = start; i < end; i++) {
                    imageArray[startOffset++] = rgb[0];
                    imageArray[startOffset++] = rgb[1];
                    imageArray[startOffset++] = rgb[2];
                    imageArray[startOffset++] = rgb[3];
                }
            }
        }
        if (dirtyX > width) {
            return;
        }
        const dirtyWidth = dirtyX2 - dirtyX;
        const dirtyHeight = dirtyY2 - dirtyY;
        localContext.putImageData(imageData, 0, 0, dirtyX - 1, dirtyY - 1, dirtyWidth + 2, dirtyHeight + 2);
        context.drawImage(canvas, dirtyX, dirtyY, dirtyWidth, dirtyHeight, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    }
    render(viewport, context) {
        if (!this.visibility) {
            return;
        }
        const image = this.image || this.getImage();
        const { width, height } = image;
        const data = image.getScalarData();
        if (!data) {
            return;
        }
        const { voxelManager } = image;
        if (voxelManager) {
            if (voxelManager.map.getRun) {
                this.renderRLE(viewport, context, voxelManager);
                return;
            }
        }
        let { canvas } = this;
        if (!canvas || canvas.width !== width || canvas.height !== height) {
            this.canvas = canvas = new window.OffscreenCanvas(width, height);
        }
        const localContext = canvas.getContext('2d');
        const imageData = localContext.createImageData(width, height);
        const { data: imageArray } = imageData;
        let offset = 0;
        let destOffset = 0;
        let dirtyX = Infinity;
        let dirtyY = Infinity;
        let dirtyX2 = -Infinity;
        let dirtyY2 = -Infinity;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const segmentIndex = data[offset++];
                if (segmentIndex) {
                    dirtyX = Math.min(x, dirtyX);
                    dirtyY = Math.min(y, dirtyY);
                    dirtyX2 = Math.max(x, dirtyX2);
                    dirtyY2 = Math.max(y, dirtyY2);
                    const rgb = this.canvasProperties.getColor(segmentIndex);
                    imageArray[destOffset] = rgb[0] * 255;
                    imageArray[destOffset + 1] = rgb[1] * 255;
                    imageArray[destOffset + 2] = rgb[2] * 255;
                    imageArray[destOffset + 3] = 127;
                }
                destOffset += 4;
            }
        }
        if (dirtyX > width) {
            return;
        }
        const dirtyWidth = dirtyX2 - dirtyX + 1;
        const dirtyHeight = dirtyY2 - dirtyY + 1;
        localContext.putImageData(imageData, 0, 0, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
        context.drawImage(canvas, dirtyX, dirtyY, dirtyWidth, dirtyHeight, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    }
    getClassName() {
        return this.className;
    }
    getProperty() {
        return this.canvasProperties;
    }
    setVisibility(visibility) {
        this.visibility = visibility;
    }
    getMapper() {
        return this.mapper;
    }
    isA(actorType) {
        return actorType === this.className;
    }
    getImage() {
        if (this.image) {
            return this.image;
        }
        this.image = { ...this.derivedImage };
        const imageData = this.viewport.getImageData();
        Object.assign(this.image, {
            worldToIndex: (worldPos) => imageData.imageData.worldToIndex(worldPos),
            indexToWorld: (index, destPoint) => imageData.imageData.indexToWorld(index, destPoint),
            getDimensions: () => imageData.dimensions,
            getScalarData: () => this.derivedImage?.getPixelData(),
            getDirection: () => imageData.direction,
            getSpacing: () => imageData.spacing,
            setOrigin: () => null,
            setDerivedImage: (image) => {
                this.derivedImage = image;
                this.image = null;
            },
            modified: () => null,
        });
        return this.image;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js
var pointInShapeCallback = __webpack_require__(56577);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VideoViewport.js











class VideoViewport extends Viewport/* default */.A {
    static { this.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i; }
    constructor(props) {
        super({
            ...props,
            canvas: props.canvas || (0,helpers/* getOrCreateCanvas */.oI)(props.element),
        });
        this.videoWidth = 0;
        this.videoHeight = 0;
        this.loop = true;
        this.mute = true;
        this.isPlaying = false;
        this.scrollSpeed = 1;
        this.playbackRate = 1;
        this.frameRange = [0, 0];
        this.fps = 30;
        this.videoCamera = {
            panWorld: [0, 0],
            parallelScale: 1,
        };
        this.voiRange = {
            lower: 0,
            upper: 255,
        };
        this.getProperties = () => {
            return {
                loop: this.videoElement.loop,
                muted: this.videoElement.muted,
                playbackRate: this.playbackRate,
                scrollSpeed: this.scrollSpeed,
                voiRange: { ...this.voiRange },
            };
        };
        this.getMiddleSliceData = () => {
            throw new Error('Method not implemented.');
        };
        this.useCustomRenderingPipeline = true;
        this.resetCamera = () => {
            this.refreshRenderValues();
            this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);
            if (!this.isPlaying) {
                this.renderFrame();
            }
            return true;
        };
        this.getNumberOfSlices = () => {
            const computedSlices = Math.round((this.videoElement.duration * this.fps) / this.scrollSpeed);
            return isNaN(computedSlices) ? this.numberOfFrames : computedSlices;
        };
        this.getFrameOfReferenceUID = () => {
            return this.videoElement.src;
        };
        this.resize = () => {
            const canvas = this.canvas;
            const { clientWidth, clientHeight } = canvas;
            if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
                canvas.width = clientWidth;
                canvas.height = clientHeight;
            }
            this.refreshRenderValues();
            if (!this.isPlaying) {
                this.renderFrame();
            }
        };
        this.canvasToWorld = (canvasPos, destPos = [0, 0, 0]) => {
            const pan = this.videoCamera.panWorld;
            const worldToCanvasRatio = this.getWorldToCanvasRatio();
            const panOffsetCanvas = [
                pan[0] * worldToCanvasRatio,
                pan[1] * worldToCanvasRatio,
            ];
            const subCanvasPos = [
                canvasPos[0] - panOffsetCanvas[0],
                canvasPos[1] - panOffsetCanvas[1],
            ];
            destPos.splice(0, 2, subCanvasPos[0] / worldToCanvasRatio, subCanvasPos[1] / worldToCanvasRatio);
            return destPos;
        };
        this.worldToCanvas = (worldPos) => {
            const pan = this.videoCamera.panWorld;
            const worldToCanvasRatio = this.getWorldToCanvasRatio();
            const canvasPos = [
                (worldPos[0] + pan[0]) * worldToCanvasRatio,
                (worldPos[1] + pan[1]) * worldToCanvasRatio,
            ];
            return canvasPos;
        };
        this.getRotation = () => 0;
        this.canvasToIndex = (canvasPos) => {
            const transform = this.getTransform();
            transform.invert();
            return transform.transformPoint(canvasPos.map((it) => it * devicePixelRatio));
        };
        this.indexToCanvas = (indexPos) => {
            const transform = this.getTransform();
            return transform
                .transformPoint(indexPos)
                .map((it) => it / devicePixelRatio);
        };
        this.customRenderViewportToCanvas = () => {
            this.renderFrame();
        };
        this.renderFrame = () => {
            const dpr = window.devicePixelRatio || 1;
            const transform = this.getTransform();
            const transformationMatrix = transform.getMatrix();
            const ctx = this.canvasContext;
            ctx.resetTransform();
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            ctx.transform(transformationMatrix[0] / dpr, transformationMatrix[1] / dpr, transformationMatrix[2] / dpr, transformationMatrix[3] / dpr, transformationMatrix[4] / dpr, transformationMatrix[5] / dpr);
            ctx.drawImage(this.videoElement, 0, 0, this.videoWidth, this.videoHeight);
            for (const actor of this.getActors()) {
                actor.actor.render(this, this.canvasContext);
            }
            this.canvasContext.resetTransform();
            (0,triggerEvent/* default */.A)(this.element, enums.Events.STACK_NEW_IMAGE, {
                element: this.element,
                viewportId: this.id,
                viewport: this,
                renderingEngineId: this.renderingEngineId,
                time: this.videoElement.currentTime,
                duration: this.videoElement.duration,
            });
            (0,triggerEvent/* default */.A)(this.element, enums.Events.IMAGE_RENDERED, {
                element: this.element,
                viewportId: this.id,
                viewport: this,
                imageIndex: this.getCurrentImageIdIndex(),
                numberOfSlices: this.numberOfFrames,
                renderingEngineId: this.renderingEngineId,
                time: this.videoElement.currentTime,
                duration: this.videoElement.duration,
            });
            this.initialRender?.();
            const frame = this.getFrameNumber();
            if (this.isPlaying) {
                if (frame < this.frameRange[0]) {
                    this.setFrameNumber(this.frameRange[0]);
                }
                else if (frame > this.frameRange[1]) {
                    if (this.loop) {
                        this.setFrameNumber(this.frameRange[0]);
                    }
                    else {
                        this.pause();
                    }
                }
            }
        };
        this.renderWhilstPlaying = () => {
            this.renderFrame();
            if (this.isPlaying) {
                requestAnimationFrame(this.renderWhilstPlaying);
            }
        };
        this.canvasContext = this.canvas.getContext('2d');
        this.renderingEngineId = props.renderingEngineId;
        this.element.setAttribute('data-viewport-uid', this.id);
        this.element.setAttribute('data-rendering-engine-uid', this.renderingEngineId);
        this.videoElement = document.createElement('video');
        this.videoElement.muted = this.mute;
        this.videoElement.loop = this.loop;
        this.videoElement.autoplay = true;
        this.videoElement.crossOrigin = 'anonymous';
        this.addEventListeners();
        this.resize();
    }
    static get useCustomRenderingPipeline() {
        return true;
    }
    addEventListeners() {
        this.canvas.addEventListener(enums.Events.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    removeEventListeners() {
        this.canvas.removeEventListener(enums.Events.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    elementDisabledHandler() {
        this.removeEventListeners();
        this.videoElement.remove();
    }
    getImageDataMetadata(image) {
        const imageId = typeof image === 'string' ? image : image.imageId;
        const imagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, imageId);
        let rowCosines = imagePlaneModule.rowCosines;
        let columnCosines = imagePlaneModule.columnCosines;
        if (rowCosines == null || columnCosines == null) {
            rowCosines = [1, 0, 0];
            columnCosines = [0, 1, 0];
        }
        const rowCosineVec = esm/* vec3.fromValues */.eR.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
        const colCosineVec = esm/* vec3.fromValues */.eR.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
        const { rows, columns } = imagePlaneModule;
        const scanAxisNormal = esm/* vec3.create */.eR.create();
        esm/* vec3.cross */.eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
        let origin = imagePlaneModule.imagePositionPatient;
        if (origin == null) {
            origin = [0, 0, 0];
        }
        const xSpacing = imagePlaneModule.columnPixelSpacing || 1;
        const ySpacing = imagePlaneModule.rowPixelSpacing || 1;
        const xVoxels = imagePlaneModule.columns;
        const yVoxels = imagePlaneModule.rows;
        const zSpacing = 1;
        const zVoxels = 1;
        this.hasPixelSpacing = !!imagePlaneModule.columnPixelSpacing;
        return {
            bitsAllocated: 8,
            numberOfComponents: 3,
            origin,
            rows,
            columns,
            direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
            dimensions: [xVoxels, yVoxels, zVoxels],
            spacing: [xSpacing, ySpacing, zSpacing],
            hasPixelSpacing: this.hasPixelSpacing,
            numVoxels: xVoxels * yVoxels * zVoxels,
            imagePlaneModule,
        };
    }
    setDataIds(imageIds, options) {
        this.setVideo(imageIds[0], (options.viewReference?.sliceIndex || 0) + 1);
    }
    setVideo(imageId, frameNumber) {
        this.imageId = Array.isArray(imageId) ? imageId[0] : imageId;
        const imageUrlModule = metaData.get(enums.MetadataModules.IMAGE_URL, imageId);
        if (!imageUrlModule?.rendered) {
            throw new Error(`Video Image ID ${imageId} does not have a rendered video view`);
        }
        const { rendered } = imageUrlModule;
        const generalSeries = metaData.get(enums.MetadataModules.GENERAL_SERIES, imageId);
        this.modality = generalSeries?.Modality;
        this.metadata = this.getImageDataMetadata(imageId);
        let { cineRate, numberOfFrames } = metaData.get(enums.MetadataModules.CINE, imageId);
        this.numberOfFrames = numberOfFrames;
        return this.setVideoURL(rendered).then(() => {
            if (!numberOfFrames || numberOfFrames === 1) {
                numberOfFrames = Math.round(this.videoElement.duration * (cineRate || 30));
            }
            if (!cineRate) {
                cineRate = Math.round(numberOfFrames / this.videoElement.duration);
            }
            this.fps = cineRate;
            this.numberOfFrames = numberOfFrames;
            this.setFrameRange([1, numberOfFrames]);
            this.initialRender = () => {
                this.initialRender = null;
                this.pause();
                this.setFrameNumber(frameNumber || 1);
            };
            return new Promise((resolve) => {
                window.setTimeout(() => {
                    this.setFrameNumber(frameNumber || 1);
                    resolve(this);
                }, 25);
            });
        });
    }
    async setVideoURL(videoURL) {
        return new Promise((resolve) => {
            this.videoElement.src = videoURL;
            this.videoElement.preload = 'auto';
            const loadedMetadataEventHandler = () => {
                this.videoWidth = this.videoElement.videoWidth;
                this.videoHeight = this.videoElement.videoHeight;
                this.videoElement.removeEventListener('loadedmetadata', loadedMetadataEventHandler);
                this.refreshRenderValues();
                resolve(true);
            };
            this.videoElement.addEventListener('loadedmetadata', loadedMetadataEventHandler);
        });
    }
    getImageIds() {
        const imageIds = new Array(this.numberOfFrames);
        const baseImageId = this.imageId.replace(/[0-9]+$/, '');
        for (let i = 0; i < this.numberOfFrames; i++) {
            imageIds[i] = `${baseImageId}${i + 1}`;
        }
        return imageIds;
    }
    togglePlayPause() {
        if (this.isPlaying) {
            this.pause();
            return false;
        }
        else {
            this.play();
            return true;
        }
    }
    async play() {
        try {
            if (!this.isPlaying) {
                this.isPlaying = true;
                await this.videoElement.play();
                this.renderWhilstPlaying();
            }
        }
        catch (e) {
        }
    }
    pause() {
        try {
            this.isPlaying = false;
            this.videoElement.pause();
        }
        catch (e) {
        }
    }
    async scroll(delta = 1) {
        await this.pause();
        const videoElement = this.videoElement;
        const renderFrame = this.renderFrame;
        const currentTime = videoElement.currentTime;
        const newTime = currentTime + (delta * this.scrollSpeed) / this.fps;
        videoElement.currentTime = newTime;
        const seekEventListener = (evt) => {
            renderFrame();
            videoElement.removeEventListener('seeked', seekEventListener);
        };
        videoElement.addEventListener('seeked', seekEventListener);
    }
    async start() {
        const videoElement = this.videoElement;
        const renderFrame = this.renderFrame;
        videoElement.currentTime = 0;
        if (videoElement.paused) {
            const seekEventListener = (evt) => {
                renderFrame();
                videoElement.removeEventListener('seeked', seekEventListener);
            };
            videoElement.addEventListener('seeked', seekEventListener);
        }
    }
    async end() {
        const videoElement = this.videoElement;
        const renderFrame = this.renderFrame;
        videoElement.currentTime = videoElement.duration;
        if (videoElement.paused) {
            const seekEventListener = (evt) => {
                renderFrame();
                videoElement.removeEventListener('seeked', seekEventListener);
            };
            videoElement.addEventListener('seeked', seekEventListener);
        }
    }
    async setTime(timeInSeconds) {
        const videoElement = this.videoElement;
        const renderFrame = this.renderFrame;
        videoElement.currentTime = timeInSeconds;
        if (videoElement.paused) {
            const seekEventListener = (evt) => {
                renderFrame();
                videoElement.removeEventListener('seeked', seekEventListener);
            };
            videoElement.addEventListener('seeked', seekEventListener);
        }
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    async setFrameNumber(frame) {
        this.setTime((frame - 1) / this.fps);
    }
    setFrameRange(frameRange) {
        if (!frameRange) {
            this.frameRange = [1, this.numberOfFrames];
            return;
        }
        if (frameRange.length !== 2 || frameRange[0] === frameRange[1]) {
            return;
        }
        this.frameRange = [frameRange[0], frameRange[1]];
    }
    getFrameRange() {
        return this.frameRange;
    }
    setProperties(props) {
        if (props.loop !== undefined) {
            this.videoElement.loop = props.loop;
        }
        if (props.muted !== undefined) {
            this.videoElement.muted = props.muted;
        }
        if (props.playbackRate !== undefined) {
            this.setPlaybackRate(props.playbackRate);
        }
        if (props.scrollSpeed !== undefined) {
            this.setScrollSpeed(props.scrollSpeed);
        }
        if (props.voiRange) {
            this.setVOI(props.voiRange);
        }
    }
    setPlaybackRate(rate = 1) {
        this.playbackRate = rate;
        if (rate < 0.0625) {
            this.pause();
            return;
        }
        if (!this.videoElement) {
            return;
        }
        this.videoElement.playbackRate = rate;
        this.play();
    }
    setScrollSpeed(scrollSpeed = 1, unit = enums.VideoEnums.SpeedUnit.FRAME) {
        this.scrollSpeed =
            unit === enums.VideoEnums.SpeedUnit.SECOND
                ? scrollSpeed * this.fps
                : scrollSpeed;
    }
    resetProperties() {
        this.setProperties({
            loop: false,
            muted: true,
        });
    }
    getScalarData() {
        if (this.scalarData?.frameNumber === this.getFrameNumber()) {
            return this.scalarData;
        }
        if (!this.videoElement ||
            !this.videoElement.videoWidth ||
            !this.videoElement.videoHeight) {
            console.debug('Video not ready yet, returning empty scalar data');
            const emptyData = new Uint8ClampedArray();
            emptyData.getRange = () => [0, 255];
            emptyData.frameNumber = -1;
            return emptyData;
        }
        const canvas = document.createElement('canvas');
        canvas.width = this.videoElement.videoWidth;
        canvas.height = this.videoElement.videoHeight;
        const context = canvas.getContext('2d');
        context.drawImage(this.videoElement, 0, 0);
        const canvasData = context.getImageData(0, 0, canvas.width, canvas.height);
        const scalarData = canvasData.data;
        scalarData.getRange = () => [0, 255];
        scalarData.frameNumber = this.getFrameNumber();
        this.scalarData = scalarData;
        return scalarData;
    }
    getImageData() {
        const { metadata } = this;
        const spacing = metadata.spacing;
        const imageData = {
            getDirection: () => metadata.direction,
            getDimensions: () => metadata.dimensions,
            getRange: () => [0, 255],
            getScalarData: () => this.getScalarData(),
            getSpacing: () => metadata.spacing,
            worldToIndex: (point) => {
                const canvasPoint = this.worldToCanvas(point);
                const pixelCoord = this.canvasToIndex(canvasPoint);
                return [pixelCoord[0], pixelCoord[1], 0];
            },
            indexToWorld: (point, destPoint) => {
                const canvasPoint = this.indexToCanvas([point[0], point[1]]);
                return this.canvasToWorld(canvasPoint, destPoint);
            },
        };
        const imageDataForReturn = {
            dimensions: metadata.dimensions,
            spacing,
            origin: metadata.origin,
            direction: metadata.direction,
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: metadata.FrameOfReferenceUID,
            },
            getScalarData: () => this.getScalarData(),
            scalarData: this.getScalarData(),
            imageData,
            voxelManager: {
                forEach: (callback, options) => {
                    return (0,pointInShapeCallback/* pointInShapeCallback */.i)(options.imageData, {
                        pointInShapeFn: options.isInObject ?? (() => true),
                        callback: callback,
                        boundsIJK: options.boundsIJK,
                        returnPoints: options.returnPoints ?? false,
                    });
                },
            },
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: this.calibration,
            preScale: {
                scaled: false,
            },
        };
        Object.defineProperty(imageData, 'scalarData', {
            get: () => this.getScalarData(),
            enumerable: true,
        });
        return imageDataForReturn;
    }
    hasImageURI(imageURI) {
        const framesMatch = imageURI.match(VideoViewport.frameRangeExtractor);
        const testURI = framesMatch
            ? imageURI.substring(0, framesMatch.index)
            : imageURI;
        return this.imageId.includes(testURI);
    }
    setVOI(voiRange) {
        this.voiRange = voiRange;
        this.setColorTransform();
    }
    setWindowLevel(windowWidth = 256, windowCenter = 128) {
        const lower = windowCenter - windowWidth / 2;
        const upper = windowCenter + windowWidth / 2 - 1;
        this.setVOI({ lower, upper });
        this.setColorTransform();
    }
    setAverageWhite(averageWhite) {
        this.averageWhite = averageWhite;
        this.setColorTransform();
    }
    setColorTransform() {
        if (!this.voiRange && !this.averageWhite) {
            this.feFilter = null;
            return;
        }
        const white = this.averageWhite || [255, 255, 255];
        const maxWhite = Math.max(...white);
        const scaleWhite = white.map((c) => maxWhite / c);
        const { lower = 0, upper = 255 } = this.voiRange || {};
        const wlScale = (upper - lower + 1) / 255;
        const wlDelta = lower / 255;
        this.feFilter = `url('data:image/svg+xml,\
      <svg xmlns="http://www.w3.org/2000/svg">\
        <filter id="colour" color-interpolation-filters="linearRGB">\
        <feColorMatrix type="matrix" \
        values="\
          ${scaleWhite[0] * wlScale} 0 0 0 ${wlDelta} \
          0 ${scaleWhite[1] * wlScale} 0 0 ${wlDelta} \
          0 0 ${scaleWhite[2] * wlScale} 0 ${wlDelta} \
          0 0 0 1 0" />\
        </filter>\
      </svg>#colour')`;
        this.canvas.style.filter = this.feFilter;
    }
    setCamera(camera) {
        const { parallelScale, focalPoint } = camera;
        if (parallelScale) {
            this.videoCamera.parallelScale =
                this.element.clientHeight / 2 / parallelScale;
        }
        if (focalPoint !== undefined) {
            const focalPointCanvas = this.worldToCanvas(focalPoint);
            const canvasCenter = [
                this.element.clientWidth / 2,
                this.element.clientHeight / 2,
            ];
            const panWorldDelta = [
                (focalPointCanvas[0] - canvasCenter[0]) /
                    this.videoCamera.parallelScale,
                (focalPointCanvas[1] - canvasCenter[1]) /
                    this.videoCamera.parallelScale,
            ];
            this.videoCamera.panWorld = [
                this.videoCamera.panWorld[0] - panWorldDelta[0],
                this.videoCamera.panWorld[1] - panWorldDelta[1],
            ];
        }
        this.canvasContext.fillStyle = 'rgba(0,0,0,1)';
        this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);
        if (!this.isPlaying) {
            this.renderFrame();
        }
    }
    getCurrentImageId() {
        const current = this.imageId.replace('/frames/1', this.isPlaying
            ? `/frames/${this.frameRange[0]}-${this.frameRange[1]}`
            : `/frames/${this.getFrameNumber()}`);
        return current;
    }
    getViewReferenceId(specifier = {}) {
        const { sliceIndex: sliceIndex } = specifier;
        if (sliceIndex === undefined) {
            return `videoId:${this.getCurrentImageId()}`;
        }
        if (Array.isArray(sliceIndex)) {
            return `videoId:${this.imageId.substring(0, this.imageId.length - 1)}${sliceIndex[0] + 1}-${sliceIndex[1] + 1}`;
        }
        const baseTarget = this.imageId.replace('/frames/1', `/frames/${1 + sliceIndex}`);
        return `videoId:${baseTarget}`;
    }
    isReferenceViewable(viewRef, options = {}) {
        let { imageURI } = options;
        const { referencedImageId, sliceIndex: sliceIndex } = viewRef;
        if (!super.isReferenceViewable(viewRef)) {
            return false;
        }
        const imageId = this.getCurrentImageId();
        if (!imageURI) {
            const colonIndex = imageId.indexOf(':');
            imageURI = imageId.substring(colonIndex + 1, imageId.length - 1);
        }
        if (options.withNavigation) {
            return true;
        }
        const currentIndex = this.getSliceIndex();
        if (Array.isArray(sliceIndex)) {
            return currentIndex >= sliceIndex[0] && currentIndex <= sliceIndex[1];
        }
        if (sliceIndex !== undefined) {
            return currentIndex === sliceIndex;
        }
        if (!referencedImageId) {
            return false;
        }
        const match = referencedImageId.match(VideoViewport.frameRangeExtractor);
        if (!match[2]) {
            return true;
        }
        const range = match[2].split('-').map((it) => Number(it));
        const frame = currentIndex + 1;
        return range[0] <= frame && frame <= (range[1] ?? range[0]);
    }
    setViewReference(viewRef) {
        if (typeof viewRef.sliceIndex === 'number') {
            this.setFrameNumber(viewRef.sliceIndex + 1);
        }
        else if (Array.isArray(viewRef.sliceIndex)) {
            this.setFrameRange(viewRef.sliceIndex);
        }
    }
    getViewReference(viewRefSpecifier) {
        let sliceIndex = viewRefSpecifier?.sliceIndex ?? this.getSliceIndex();
        if (!sliceIndex) {
            sliceIndex = this.isPlaying
                ? [this.frameRange[0] - 1, this.frameRange[1] - 1]
                : this.getCurrentImageIdIndex();
        }
        return {
            ...super.getViewReference(viewRefSpecifier),
            referencedImageId: this.getViewReferenceId(viewRefSpecifier),
            sliceIndex: sliceIndex,
        };
    }
    getFrameNumber() {
        return 1 + this.getCurrentImageIdIndex();
    }
    getCurrentImageIdIndex() {
        return Math.round(this.videoElement.currentTime * this.fps);
    }
    getSliceIndex() {
        return this.getCurrentImageIdIndex() / this.scrollSpeed;
    }
    getCamera() {
        const { parallelScale } = this.videoCamera;
        const canvasCenter = [
            this.element.clientWidth / 2,
            this.element.clientHeight / 2,
        ];
        const canvasCenterWorld = this.canvasToWorld(canvasCenter);
        return {
            parallelProjection: true,
            focalPoint: canvasCenterWorld,
            position: [0, 0, 0],
            viewUp: [0, -1, 0],
            parallelScale: this.element.clientHeight / 2 / parallelScale,
            viewPlaneNormal: [0, 0, 1],
        };
    }
    getFrameRate() {
        return this.fps;
    }
    getPan() {
        const panWorld = this.videoCamera.panWorld;
        return [panWorld[0], panWorld[1]];
    }
    refreshRenderValues() {
        let worldToCanvasRatio = this.canvas.offsetWidth / this.videoWidth;
        if (this.videoHeight * worldToCanvasRatio > this.canvas.height) {
            worldToCanvasRatio = this.canvas.offsetHeight / this.videoHeight;
        }
        const drawWidth = Math.floor(this.videoWidth * worldToCanvasRatio);
        const drawHeight = Math.floor(this.videoHeight * worldToCanvasRatio);
        const xOffsetCanvas = (this.canvas.offsetWidth - drawWidth) / 2;
        const yOffsetCanvas = (this.canvas.offsetHeight - drawHeight) / 2;
        const xOffsetWorld = xOffsetCanvas / worldToCanvasRatio;
        const yOffsetWorld = yOffsetCanvas / worldToCanvasRatio;
        this.videoCamera.panWorld = [xOffsetWorld, yOffsetWorld];
        this.videoCamera.parallelScale = worldToCanvasRatio;
    }
    getWorldToCanvasRatio() {
        return this.videoCamera.parallelScale;
    }
    getCanvasToWorldRatio() {
        return 1.0 / this.videoCamera.parallelScale;
    }
    getTransform() {
        const panWorld = this.videoCamera.panWorld;
        const devicePixelRatio = window.devicePixelRatio || 1;
        const worldToCanvasRatio = this.getWorldToCanvasRatio();
        const canvasToWorldRatio = this.getCanvasToWorldRatio();
        const halfCanvas = [
            this.canvas.offsetWidth / 2,
            this.canvas.offsetHeight / 2,
        ];
        const halfCanvasWorldCoordinates = [
            halfCanvas[0] * canvasToWorldRatio,
            halfCanvas[1] * canvasToWorldRatio,
        ];
        const transform = new rendering_transform/* Transform */.d();
        transform.scale(devicePixelRatio, devicePixelRatio);
        transform.translate(halfCanvas[0], halfCanvas[1]);
        transform.scale(worldToCanvasRatio, worldToCanvasRatio);
        transform.translate(panWorld[0], panWorld[1]);
        transform.translate(-halfCanvasWorldCoordinates[0], -halfCanvasWorldCoordinates[1]);
        return transform;
    }
    updateCameraClippingPlanesAndRange() {
    }
    addImages(stackInputs) {
        const actors = this.getActors();
        stackInputs.forEach((stackInput) => {
            const image = cache/* default */.Ay.getImage(stackInput.imageId);
            const imageActor = this.createActorMapper(image);
            const uid = stackInput.actorUID ?? (0,uuidv4/* default */.A)();
            if (imageActor) {
                actors.push({ uid, actor: imageActor });
                if (stackInput.callback) {
                    stackInput.callback({
                        imageActor: imageActor,
                        imageId: stackInput.imageId,
                    });
                }
            }
        });
        this.setActors(actors);
    }
    createActorMapper(image) {
        return new CanvasActor(this, image);
    }
}
/* harmony default export */ const RenderingEngine_VideoViewport = (VideoViewport);


/***/ }),

/***/ 10056:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89265);
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84607);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75127);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3823);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32643);
/* harmony import */ var _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1814);
/* harmony import */ var _enums_ViewportType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(41864);
/* harmony import */ var _renderingEngineCache__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5862);
/* harmony import */ var _utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(98039);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(69372);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(52268);
/* harmony import */ var _utilities_isEqual__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(74638);
/* harmony import */ var _utilities_hasNaNValues__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(38883);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(19325);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(31749);
/* harmony import */ var _utilities_deepClone__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(99949);
















class Viewport {
    static { this.CameraViewPresentation = {
        rotation: true,
        pan: true,
        zoom: true,
        displayArea: true,
    }; }
    static { this.TransferViewPresentation = {
        windowLevel: true,
        paletteLut: true,
    }; }
    constructor(props) {
        this.insetImageMultiplier = 1.1;
        this.flipHorizontal = false;
        this.flipVertical = false;
        this.viewportStatus = _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.NO_DATA;
        this._suppressCameraModifiedEvents = false;
        this.hasPixelSpacing = true;
        this.getProperties = () => ({});
        this.setRotation = (_rotation) => {
        };
        this.viewportWidgets = new Map();
        this.addWidget = (widgetId, widget) => {
            this.viewportWidgets.set(widgetId, widget);
        };
        this.getWidget = (id) => {
            return this.viewportWidgets.get(id);
        };
        this.getWidgets = () => {
            return Array.from(this.viewportWidgets.values());
        };
        this.removeWidgets = () => {
            const widgets = this.getWidgets();
            widgets.forEach((widget) => {
                if (widget.getEnabled()) {
                    widget.setEnabled(false);
                }
                if (widget.getActor && widget.getRenderer) {
                    const actor = widget.getActor();
                    const renderer = widget.getRenderer();
                    if (renderer && actor) {
                        renderer.removeActor(actor);
                    }
                }
            });
        };
        this.id = props.id;
        this.renderingEngineId = props.renderingEngineId;
        this.type = props.type;
        this.element = props.element;
        this.canvas = props.canvas;
        this.sx = props.sx;
        this.sy = props.sy;
        this.sWidth = props.sWidth;
        this.sHeight = props.sHeight;
        this._actors = new Map();
        this.element.setAttribute('data-viewport-uid', this.id);
        this.element.setAttribute('data-rendering-engine-uid', this.renderingEngineId);
        this.defaultOptions = (0,_utilities_deepClone__WEBPACK_IMPORTED_MODULE_15__/* .deepClone */ .G)(props.defaultOptions);
        this.suppressEvents = props.defaultOptions.suppressEvents
            ? props.defaultOptions.suppressEvents
            : false;
        this.options = (0,_utilities_deepClone__WEBPACK_IMPORTED_MODULE_15__/* .deepClone */ .G)(props.defaultOptions);
        this.isDisabled = false;
    }
    static get useCustomRenderingPipeline() {
        return false;
    }
    setRendered() {
        if (this.viewportStatus === _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.NO_DATA ||
            this.viewportStatus === _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.LOADING) {
            return;
        }
        this.viewportStatus = _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.RENDERED;
    }
    getRenderingEngine() {
        return _renderingEngineCache__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.get(this.renderingEngineId);
    }
    getRenderer() {
        const renderingEngine = this.getRenderingEngine();
        if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
            throw new Error('Rendering engine has been destroyed');
        }
        return renderingEngine.offscreenMultiRenderWindow?.getRenderer(this.id);
    }
    render() {
        const renderingEngine = this.getRenderingEngine();
        renderingEngine.renderViewport(this.id);
    }
    setOptions(options, immediate = false) {
        this.options = structuredClone(options);
        if (this.options?.displayArea) {
            this.setDisplayArea(this.options?.displayArea);
        }
        if (immediate) {
            this.render();
        }
    }
    reset(immediate = false) {
        this.options = structuredClone(this.defaultOptions);
        if (immediate) {
            this.render();
        }
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    flip({ flipHorizontal, flipVertical }) {
        const imageData = this.getDefaultImageData();
        if (!imageData) {
            return;
        }
        const camera = this.getCamera();
        const { viewPlaneNormal, viewUp, focalPoint, position } = camera;
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewPlaneNormal, viewUp);
        let viewUpToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.copy */ .eR.copy(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewUp);
        const viewPlaneNormalToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewPlaneNormal);
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.distance */ .eR.distance(position, focalPoint);
        const dimensions = imageData.getDimensions();
        const middleIJK = dimensions.map((d) => Math.floor(d / 2));
        const idx = [middleIJK[0], middleIJK[1], middleIJK[2]];
        const centeredFocalPoint = imageData.indexToWorld(idx, gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create());
        const resetFocalPoint = this._getFocalPointForResetCamera(centeredFocalPoint, camera, { resetPan: true, resetToCenter: false });
        const panDir = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), focalPoint, resetFocalPoint);
        const panValue = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.length */ .eR.length(panDir);
        const getPanDir = (mirrorVec) => {
            const panDirMirror = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scale */ .eR.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), mirrorVec, 2 * gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(panDir, mirrorVec));
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(panDirMirror, panDirMirror, panDir);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.normalize */ .eR.normalize(panDirMirror, panDirMirror);
            return panDirMirror;
        };
        if (flipHorizontal) {
            const panDirMirror = getPanDir(viewUpToSet);
            const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), resetFocalPoint, panDirMirror, panValue);
            const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), newFocalPoint, viewPlaneNormalToSet, distance);
            this.setCamera({
                viewPlaneNormal: viewPlaneNormalToSet,
                position: newPosition,
                focalPoint: newFocalPoint,
            });
            this.flipHorizontal = !this.flipHorizontal;
        }
        if (flipVertical) {
            viewUpToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate(viewUpToSet, viewUp);
            const panDirMirror = getPanDir(viewRight);
            const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), resetFocalPoint, panDirMirror, panValue);
            const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), newFocalPoint, viewPlaneNormalToSet, distance);
            this.setCamera({
                focalPoint: newFocalPoint,
                viewPlaneNormal: viewPlaneNormalToSet,
                viewUp: viewUpToSet,
                position: newPosition,
            });
            this.flipVertical = !this.flipVertical;
        }
        this.render();
    }
    getDefaultImageData() {
        const actorEntry = this.getDefaultActor();
        if (actorEntry && (0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .isImageActor */ .e)(actorEntry)) {
            return actorEntry.actor.getMapper().getInputData();
        }
    }
    getDefaultActor() {
        return this.getActors()[0];
    }
    getActors() {
        return Array.from(this._actors.values());
    }
    getActorUIDs() {
        return Array.from(this._actors.keys());
    }
    getActor(actorUID) {
        return this._actors.get(actorUID);
    }
    getImageActor(volumeId) {
        const actorEntries = this.getActors();
        let actorEntry = actorEntries[0];
        if (volumeId) {
            actorEntry = actorEntries.find((a) => a.referencedId === volumeId);
        }
        if (!actorEntry || !(0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .isImageActor */ .e)(actorEntry)) {
            return null;
        }
        const actor = actorEntry.actor;
        return actor;
    }
    getActorUIDByIndex(index) {
        const actor = this.getActors()[index];
        if (actor) {
            return actor.uid;
        }
    }
    getActorByIndex(index) {
        return this.getActors()[index];
    }
    setActors(actors) {
        this.removeAllActors();
        this.addActors(actors, { resetCamera: true });
    }
    _removeActor(actorUID) {
        const actorEntry = this.getActor(actorUID);
        if (!actorEntry) {
            console.warn(`Actor ${actorUID} does not exist for this viewport`);
            return;
        }
        const renderer = this.getRenderer();
        renderer.removeViewProp(actorEntry.actor);
        this._actors.delete(actorUID);
    }
    removeActors(actorUIDs) {
        actorUIDs.forEach((actorUID) => {
            this._removeActor(actorUID);
        });
    }
    addActors(actors, options = {}) {
        const { resetCamera = false } = options;
        const renderingEngine = this.getRenderingEngine();
        if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
            console.warn('Viewport::addActors::Rendering engine has not been initialized or has been destroyed');
            return;
        }
        actors.forEach((actor) => {
            this.addActor(actor);
        });
        const prevViewPresentation = this.getViewPresentation();
        const prevViewRef = this.getViewReference();
        this.resetCamera();
        if (!resetCamera) {
            this.setViewReference(prevViewRef);
            this.setViewPresentation(prevViewPresentation);
        }
    }
    addActor(actorEntry) {
        const { uid: actorUID, actor } = actorEntry;
        const renderingEngine = this.getRenderingEngine();
        if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
            console.warn(`Cannot add actor UID of ${actorUID} Rendering Engine has been destroyed`);
            return;
        }
        if (!actorUID || !actor) {
            throw new Error('Actors should have uid and vtk Actor properties');
        }
        if (this.getActor(actorUID)) {
            console.warn(`Actor ${actorUID} already exists for this viewport`);
            return;
        }
        const renderer = this.getRenderer();
        renderer?.addActor(actor);
        this._actors.set(actorUID, Object.assign({}, actorEntry));
        this.updateCameraClippingPlanesAndRange();
    }
    removeAllActors() {
        this.getRenderer()?.removeAllViewProps();
        this._actors = new Map();
        return;
    }
    resetCameraNoEvent() {
        this._suppressCameraModifiedEvents = true;
        this.resetCamera();
        this._suppressCameraModifiedEvents = false;
    }
    setCameraNoEvent(camera) {
        this._suppressCameraModifiedEvents = true;
        this.setCamera(camera);
        this._suppressCameraModifiedEvents = false;
    }
    _getViewImageDataIntersections(imageData, focalPoint, normal) {
        const A = normal[0];
        const B = normal[1];
        const C = normal[2];
        const D = A * focalPoint[0] + B * focalPoint[1] + C * focalPoint[2];
        const bounds = imageData.getBounds();
        const edges = this._getEdges(bounds);
        const intersections = [];
        for (const edge of edges) {
            const [[x0, y0, z0], [x1, y1, z1]] = edge;
            if (A * (x1 - x0) + B * (y1 - y0) + C * (z1 - z0) === 0) {
                continue;
            }
            const intersectionPoint = _utilities_planar__WEBPACK_IMPORTED_MODULE_10__.linePlaneIntersection([x0, y0, z0], [x1, y1, z1], [A, B, C, D]);
            if (this._isInBounds(intersectionPoint, bounds)) {
                intersections.push(intersectionPoint);
            }
        }
        return intersections;
    }
    setInterpolationType(_interpolationType, _arg) {
    }
    setDisplayArea(displayArea, suppressEvents = false) {
        if (!displayArea) {
            return;
        }
        const { storeAsInitialCamera, type: areaType } = displayArea;
        if (storeAsInitialCamera) {
            this.options.displayArea = displayArea;
        }
        const { _suppressCameraModifiedEvents } = this;
        this._suppressCameraModifiedEvents = true;
        this.setCamera(this.fitToCanvasCamera);
        if (areaType === 'SCALE') {
            this.setDisplayAreaScale(displayArea);
        }
        else {
            this.setInterpolationType(this.getProperties()?.interpolationType ?? _enums__WEBPACK_IMPORTED_MODULE_14__.InterpolationType.LINEAR);
            this.setDisplayAreaFit(displayArea);
        }
        if (storeAsInitialCamera) {
            this.initialCamera = this.getCamera();
        }
        this._suppressCameraModifiedEvents = _suppressCameraModifiedEvents;
        if (!suppressEvents && !_suppressCameraModifiedEvents) {
            const eventDetail = {
                viewportId: this.id,
                displayArea: displayArea,
                storeAsInitialCamera: storeAsInitialCamera,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.DISPLAY_AREA_MODIFIED, eventDetail);
            this.setCamera(this.getCamera());
        }
    }
    setDisplayAreaScale(displayArea) {
        const { scale = 1 } = displayArea;
        const canvas = this.canvas;
        const height = canvas.height;
        const width = canvas.width;
        if (height < 8 || width < 8) {
            return;
        }
        const imageData = this.getDefaultImageData();
        const spacingWorld = imageData.getSpacing();
        const spacing = spacingWorld[1];
        this.setInterpolationType(_enums__WEBPACK_IMPORTED_MODULE_14__.InterpolationType.NEAREST);
        this.setCamera({ parallelScale: (height * spacing) / (2 * scale) });
        delete displayArea.imageArea;
        this.setDisplayAreaFit(displayArea);
        const { focalPoint, position, viewUp, viewPlaneNormal } = this.getCamera();
        const focalChange = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create();
        if (canvas.height % 2) {
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(focalChange, focalChange, viewUp, scale * 0.5 * spacing);
        }
        if (canvas.width % 2) {
            const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewUp, viewPlaneNormal);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(focalChange, focalChange, viewRight, scale * 0.5 * spacing);
        }
        if (!focalChange[0] && !focalChange[1] && !focalChange[2]) {
            return;
        }
        this.setCamera({
            focalPoint: gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), focalPoint, focalChange),
            position: gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), position, focalChange),
        });
    }
    setDisplayAreaFit(displayArea) {
        const { imageArea, imageCanvasPoint } = displayArea;
        const devicePixelRatio = window?.devicePixelRatio || 1;
        const imageData = this.getDefaultImageData();
        if (!imageData) {
            return;
        }
        const canvasWidth = this.sWidth / devicePixelRatio;
        const canvasHeight = this.sHeight / devicePixelRatio;
        const dimensions = imageData.getDimensions();
        const canvasZero = this.worldToCanvas(imageData.indexToWorld([0, 0, 0]));
        const canvasEdge = this.worldToCanvas(imageData.indexToWorld([
            dimensions[0] - 1,
            dimensions[1] - 1,
            dimensions[2],
        ]));
        const canvasImage = [
            Math.abs(canvasEdge[0] - canvasZero[0]),
            Math.abs(canvasEdge[1] - canvasZero[1]),
        ];
        const [imgWidth, imgHeight] = canvasImage;
        if (imageArea) {
            const [areaX, areaY] = imageArea;
            const requireX = Math.abs((areaX * imgWidth) / canvasWidth);
            const requireY = Math.abs((areaY * imgHeight) / canvasHeight);
            const initZoom = this.getZoom();
            const fitZoom = this.getZoom(this.fitToCanvasCamera);
            const absZoom = Math.min(1 / requireX, 1 / requireY);
            const applyZoom = (absZoom * initZoom) / fitZoom;
            this.setZoom(applyZoom, false);
        }
        if (imageCanvasPoint) {
            const { imagePoint, canvasPoint = imagePoint || [0.5, 0.5] } = imageCanvasPoint;
            const [canvasX, canvasY] = canvasPoint;
            const canvasPanX = canvasWidth * (canvasX - 0.5);
            const canvasPanY = canvasHeight * (canvasY - 0.5);
            const [imageX, imageY] = imagePoint || canvasPoint;
            const useZoom = 1;
            const imagePanX = useZoom * imgWidth * (0.5 - imageX);
            const imagePanY = useZoom * imgHeight * (0.5 - imageY);
            const newPositionX = imagePanX + canvasPanX;
            const newPositionY = imagePanY + canvasPanY;
            const deltaPoint2 = [newPositionX, newPositionY];
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.add */ .Zc.add(deltaPoint2, deltaPoint2, this.getPan());
            this.setPan(deltaPoint2, false);
        }
    }
    getDisplayArea() {
        return this.options?.displayArea;
    }
    resetCamera(options) {
        const { resetPan = true, resetZoom = true, resetToCenter = true, storeAsInitialCamera = true, } = options || {};
        const renderer = this.getRenderer();
        this.setCameraNoEvent({
            flipHorizontal: false,
            flipVertical: false,
        });
        const previousCamera = this.getCamera();
        const bounds = renderer.computeVisiblePropBounds();
        const focalPoint = [0, 0, 0];
        const imageData = this.getDefaultImageData();
        if (imageData) {
            const spc = imageData.getSpacing();
            bounds[0] = bounds[0] + spc[0] / 2;
            bounds[1] = bounds[1] - spc[0] / 2;
            bounds[2] = bounds[2] + spc[1] / 2;
            bounds[3] = bounds[3] - spc[1] / 2;
            bounds[4] = bounds[4] + spc[2] / 2;
            bounds[5] = bounds[5] - spc[2] / 2;
        }
        const activeCamera = this.getVtkActiveCamera();
        const viewPlaneNormal = activeCamera.getViewPlaneNormal();
        const viewUp = activeCamera.getViewUp();
        focalPoint[0] = (bounds[0] + bounds[1]) / 2.0;
        focalPoint[1] = (bounds[2] + bounds[3]) / 2.0;
        focalPoint[2] = (bounds[4] + bounds[5]) / 2.0;
        if (imageData) {
            const dimensions = imageData.getDimensions();
            const middleIJK = dimensions.map((d) => Math.floor(d / 2));
            const idx = [middleIJK[0], middleIJK[1], middleIJK[2]];
            imageData.indexToWorld(idx, focalPoint);
        }
        const { widthWorld, heightWorld } = this._getWorldDistanceViewUpAndViewRight(bounds, viewUp, viewPlaneNormal);
        const canvasSize = [this.sWidth, this.sHeight];
        const boundsAspectRatio = widthWorld / heightWorld;
        const canvasAspectRatio = canvasSize[0] / canvasSize[1];
        const scaleFactor = boundsAspectRatio / canvasAspectRatio;
        const parallelScale = scaleFactor < 1
            ? (this.insetImageMultiplier * heightWorld) / 2
            : (this.insetImageMultiplier * heightWorld * scaleFactor) / 2;
        const radius = Viewport.boundsRadius(bounds) *
            (this.type === _enums_ViewportType__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.VOLUME_3D ? 10 : 1);
        const distance = this.insetImageMultiplier * radius;
        const viewUpToSet = Math.abs(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Ay.dot(viewUp, viewPlaneNormal)) > 0.999
            ? [-viewUp[2], viewUp[0], viewUp[1]]
            : viewUp;
        const focalPointToSet = this._getFocalPointForResetCamera(focalPoint, previousCamera, { resetPan, resetToCenter });
        const positionToSet = [
            focalPointToSet[0] + distance * viewPlaneNormal[0],
            focalPointToSet[1] + distance * viewPlaneNormal[1],
            focalPointToSet[2] + distance * viewPlaneNormal[2],
        ];
        renderer.resetCameraClippingRange(bounds);
        const clippingRangeToUse = [
            -_constants__WEBPACK_IMPORTED_MODULE_13__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE,
            _constants__WEBPACK_IMPORTED_MODULE_13__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE,
        ];
        activeCamera.setPhysicalScale(radius);
        activeCamera.setPhysicalTranslation(-focalPointToSet[0], -focalPointToSet[1], -focalPointToSet[2]);
        this.setCamera({
            parallelScale: resetZoom ? parallelScale : previousCamera.parallelScale,
            focalPoint: focalPointToSet,
            position: positionToSet,
            viewAngle: 90,
            viewUp: viewUpToSet,
            clippingRange: clippingRangeToUse,
        });
        const modifiedCamera = this.getCamera();
        this.setFitToCanvasCamera(this.getCamera());
        if (storeAsInitialCamera) {
            this.setInitialCamera(modifiedCamera);
        }
        if (resetZoom) {
            this.setZoom(1, storeAsInitialCamera);
        }
        const RESET_CAMERA_EVENT = {
            type: 'ResetCameraEvent',
            renderer,
        };
        renderer.invokeEvent(RESET_CAMERA_EVENT);
        this.triggerCameraModifiedEventIfNecessary(previousCamera, modifiedCamera);
        if (imageData &&
            this.options.displayArea &&
            resetZoom &&
            resetPan &&
            resetToCenter) {
            this.setDisplayArea(this.options.displayArea);
        }
        return true;
    }
    setInitialCamera(camera) {
        this.initialCamera = camera;
    }
    setFitToCanvasCamera(camera) {
        this.fitToCanvasCamera = camera;
    }
    getPan(initialCamera = this.initialCamera) {
        if (!initialCamera) {
            return [0, 0];
        }
        const activeCamera = this.getVtkActiveCamera();
        const focalPoint = activeCamera.getFocalPoint();
        const zero3 = this.canvasToWorld([0, 0]);
        const initialCanvasFocal = this.worldToCanvas(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract([0, 0, 0], initialCamera.focalPoint, zero3));
        const currentCanvasFocal = this.worldToCanvas(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract([0, 0, 0], focalPoint, zero3));
        const result = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.subtract */ .Zc.subtract([0, 0], initialCanvasFocal, currentCanvasFocal);
        return result;
    }
    getCurrentImageIdIndex() {
        throw new Error('Not implemented');
    }
    getSliceIndex() {
        throw new Error('Not implemented');
    }
    getImageData() {
        throw new Error('Not implemented');
    }
    getViewReferenceId(_specifier) {
        return null;
    }
    setPan(pan, storeAsInitialCamera = false) {
        const previousCamera = this.getCamera();
        const { focalPoint, position } = previousCamera;
        const zero3 = this.canvasToWorld([0, 0]);
        const delta2 = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.subtract */ .Zc.subtract([0, 0], pan, this.getPan());
        if (Math.abs(delta2[0]) < 1 &&
            Math.abs(delta2[1]) < 1 &&
            !storeAsInitialCamera) {
            return;
        }
        const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), this.canvasToWorld(delta2), zero3);
        const newFocal = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), focalPoint, delta);
        const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), position, delta);
        this.setCamera({
            ...previousCamera,
            focalPoint: newFocal,
            position: newPosition,
        }, storeAsInitialCamera);
    }
    getZoom(compareCamera = this.initialCamera) {
        if (!compareCamera) {
            return 1;
        }
        const activeCamera = this.getVtkActiveCamera();
        const { parallelScale: initialParallelScale } = compareCamera;
        return initialParallelScale / activeCamera.getParallelScale();
    }
    setZoom(value, storeAsInitialCamera = false) {
        const camera = this.getCamera();
        const { parallelScale: initialParallelScale } = this.initialCamera;
        const parallelScale = initialParallelScale / value;
        if (camera.parallelScale === parallelScale && !storeAsInitialCamera) {
            return;
        }
        this.setCamera({
            ...camera,
            parallelScale,
        }, storeAsInitialCamera);
    }
    _getFocalPointForViewPlaneReset(imageData) {
        const { focalPoint, viewPlaneNormal: normal } = this.getCamera();
        const intersections = this._getViewImageDataIntersections(imageData, focalPoint, normal);
        let x = 0;
        let y = 0;
        let z = 0;
        intersections.forEach(([point_x, point_y, point_z]) => {
            x += point_x;
            y += point_y;
            z += point_z;
        });
        const newFocalPoint = [
            x / intersections.length,
            y / intersections.length,
            z / intersections.length,
        ];
        return newFocalPoint;
    }
    getCanvas() {
        return this.canvas;
    }
    getVtkActiveCamera() {
        const renderer = this.getRenderer();
        return renderer.getActiveCamera();
    }
    getCameraNoRotation() {
        const vtkCamera = this.getVtkActiveCamera();
        const sanitizeVector = (vector, defaultValue) => {
            return vector.some((v) => isNaN(v)) ? defaultValue : vector;
        };
        const viewUp = sanitizeVector([...vtkCamera.getViewUp()], [0, 1, 0]);
        const viewPlaneNormal = sanitizeVector([...vtkCamera.getViewPlaneNormal()], [0, 0, -1]);
        const position = sanitizeVector([...vtkCamera.getPosition()], [0, 0, 1]);
        const focalPoint = sanitizeVector([...vtkCamera.getFocalPoint()], [0, 0, 0]);
        return {
            viewUp,
            viewPlaneNormal,
            position,
            focalPoint,
            parallelProjection: vtkCamera.getParallelProjection(),
            parallelScale: vtkCamera.getParallelScale(),
            viewAngle: vtkCamera.getViewAngle(),
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
        };
    }
    getCamera() {
        const camera = this.getCameraNoRotation();
        return {
            ...camera,
            rotation: this.getRotation(),
        };
    }
    setCamera(cameraInterface, storeAsInitialCamera = false) {
        const vtkCamera = this.getVtkActiveCamera();
        const previousCamera = this.getCamera();
        const updatedCamera = Object.assign({}, previousCamera, cameraInterface);
        const { viewUp, viewPlaneNormal, position, focalPoint, parallelScale, viewAngle, flipHorizontal, flipVertical, clippingRange, } = cameraInterface;
        if (flipHorizontal !== undefined) {
            const flipH = (flipHorizontal && !this.flipHorizontal) ||
                (!flipHorizontal && this.flipHorizontal);
            if (flipH) {
                this.flip({ flipHorizontal: flipH });
            }
        }
        if (flipVertical !== undefined) {
            const flipV = (flipVertical && !this.flipVertical) ||
                (!flipVertical && this.flipVertical);
            if (flipV) {
                this.flip({ flipVertical: flipV });
            }
        }
        if (viewUp !== undefined) {
            vtkCamera.setViewUp(viewUp);
        }
        if (viewPlaneNormal !== undefined) {
            vtkCamera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        }
        if (position !== undefined) {
            vtkCamera.setPosition(...position);
        }
        if (focalPoint !== undefined) {
            vtkCamera.setFocalPoint(...focalPoint);
        }
        if (parallelScale !== undefined) {
            vtkCamera.setParallelScale(parallelScale);
        }
        if (viewAngle !== undefined) {
            vtkCamera.setViewAngle(viewAngle);
        }
        if (clippingRange !== undefined) {
            vtkCamera.setClippingRange(clippingRange);
        }
        const prevFocalPoint = previousCamera.focalPoint;
        const prevViewUp = previousCamera.viewUp;
        if ((prevFocalPoint && focalPoint) || (prevViewUp && viewUp)) {
            const currentViewPlaneNormal = vtkCamera.getViewPlaneNormal();
            const currentViewUp = vtkCamera.getViewUp();
            let cameraModifiedOutOfPlane = false;
            let viewUpHasChanged = false;
            if (focalPoint) {
                const deltaCamera = [
                    focalPoint[0] - prevFocalPoint[0],
                    focalPoint[1] - prevFocalPoint[1],
                    focalPoint[2] - prevFocalPoint[2],
                ];
                cameraModifiedOutOfPlane =
                    Math.abs(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Ay.dot(deltaCamera, currentViewPlaneNormal)) > 0;
            }
            if (viewUp) {
                viewUpHasChanged = !(0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Ay)(currentViewUp, prevViewUp);
            }
            if (cameraModifiedOutOfPlane || viewUpHasChanged) {
                const actorEntry = this.getDefaultActor();
                if (!actorEntry?.actor) {
                    return;
                }
                if (!(0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .actorIsA */ .N)(actorEntry, 'vtkActor')) {
                    this.updateClippingPlanesForActors(updatedCamera);
                }
                if ((0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .actorIsA */ .N)(actorEntry, 'vtkImageSlice') ||
                    this.type === _enums_ViewportType__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.VOLUME_3D) {
                    const renderer = this.getRenderer();
                    renderer.resetCameraClippingRange();
                }
            }
        }
        if (storeAsInitialCamera) {
            this.setInitialCamera(updatedCamera);
        }
        this.triggerCameraModifiedEventIfNecessary(previousCamera, this.getCamera());
    }
    triggerCameraModifiedEventIfNecessary(previousCamera, updatedCamera) {
        if (!this._suppressCameraModifiedEvents && !this.suppressEvents) {
            const eventDetail = {
                previousCamera,
                camera: updatedCamera,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.CAMERA_MODIFIED, eventDetail);
        }
    }
    updateCameraClippingPlanesAndRange() {
        const currentCamera = this.getCamera();
        this.updateClippingPlanesForActors(currentCamera);
        this.getRenderer().resetCameraClippingRange();
    }
    async updateClippingPlanesForActors(updatedCamera) {
        const actorEntries = this.getActors();
        actorEntries.map((actorEntry) => {
            if (!actorEntry.actor) {
                return;
            }
            const mapper = actorEntry.actor.getMapper();
            let vtkPlanes = actorEntry?.clippingFilter
                ? actorEntry?.clippingFilter.getClippingPlanes()
                : mapper.getClippingPlanes();
            if (vtkPlanes.length === 0 && actorEntry?.clippingFilter) {
                vtkPlanes = [_kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance(), _kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance()];
            }
            let slabThickness = _constants__WEBPACK_IMPORTED_MODULE_13__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            if (actorEntry.slabThickness) {
                slabThickness = actorEntry.slabThickness;
            }
            const { viewPlaneNormal, focalPoint } = updatedCamera;
            this.setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, focalPoint);
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.CLIPPING_PLANES_UPDATED, {
                actorEntry,
                focalPoint,
                vtkPlanes,
                viewport: this,
            });
        });
    }
    setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, focalPoint) {
        if (vtkPlanes.length < 2) {
            return;
        }
        const scaledDistance = [
            viewPlaneNormal[0],
            viewPlaneNormal[1],
            viewPlaneNormal[2],
        ];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyScalar */ .Ay.multiplyScalar(scaledDistance, slabThickness);
        vtkPlanes[0].setNormal(viewPlaneNormal);
        const newOrigin1 = [0, 0, 0];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Ay.subtract(focalPoint, scaledDistance, newOrigin1);
        vtkPlanes[0].setOrigin(newOrigin1);
        vtkPlanes[1].setNormal(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        const newOrigin2 = [0, 0, 0];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].add */ .Ay.add(focalPoint, scaledDistance, newOrigin2);
        vtkPlanes[1].setOrigin(newOrigin2);
    }
    getClippingPlanesForActor(actorEntry) {
        if (!actorEntry) {
            actorEntry = this.getDefaultActor();
        }
        if (!actorEntry.actor) {
            throw new Error('Invalid actor entry: Actor is undefined');
        }
        const mapper = actorEntry.actor.getMapper();
        let vtkPlanes = actorEntry?.clippingFilter
            ? actorEntry?.clippingFilter.getClippingPlanes()
            : mapper.getClippingPlanes();
        if (vtkPlanes.length === 0 && actorEntry?.clippingFilter) {
            vtkPlanes = [_kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance(), _kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance()];
        }
        return vtkPlanes;
    }
    _getWorldDistanceViewUpAndViewRight(bounds, viewUp, viewPlaneNormal) {
        const viewUpCorners = this._getCorners(bounds);
        const viewRightCorners = this._getCorners(bounds);
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewUp, viewPlaneNormal);
        let transform = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
            .buildFromDegree()
            .identity()
            .rotateFromDirections(viewUp, [1, 0, 0]);
        viewUpCorners.forEach((pt) => transform.apply(pt));
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < 8; i++) {
            const y = viewUpCorners[i][0];
            if (y > maxY) {
                maxY = y;
            }
            if (y < minY) {
                minY = y;
            }
        }
        transform = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
            .buildFromDegree()
            .identity()
            .rotateFromDirections([viewRight[0], viewRight[1], viewRight[2]], [1, 0, 0]);
        viewRightCorners.forEach((pt) => transform.apply(pt));
        let minX = Infinity;
        let maxX = -Infinity;
        for (let i = 0; i < 8; i++) {
            const x = viewRightCorners[i][0];
            if (x > maxX) {
                maxX = x;
            }
            if (x < minX) {
                minX = x;
            }
        }
        return { widthWorld: maxX - minX, heightWorld: maxY - minY };
    }
    getViewReference(viewRefSpecifier = {}) {
        const { focalPoint: cameraFocalPoint, viewPlaneNormal, viewUp, } = this.getCamera();
        const target = {
            FrameOfReferenceUID: this.getFrameOfReferenceUID(),
            cameraFocalPoint,
            viewPlaneNormal,
            viewUp,
            sliceIndex: viewRefSpecifier.sliceIndex ?? this.getSliceIndex(),
        };
        return target;
    }
    isReferenceViewable(viewRef, options) {
        if (viewRef.FrameOfReferenceUID &&
            viewRef.FrameOfReferenceUID !== this.getFrameOfReferenceUID()) {
            return false;
        }
        const { viewPlaneNormal } = viewRef;
        const camera = this.getCamera();
        if (viewPlaneNormal &&
            !(0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Ay)(viewPlaneNormal, camera.viewPlaneNormal) &&
            !(0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Ay)(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate(camera.viewPlaneNormal, camera.viewPlaneNormal), viewPlaneNormal)) {
            return options?.withOrientation;
        }
        return true;
    }
    getViewPresentation(viewPresSel = {
        rotation: true,
        displayArea: true,
        zoom: true,
        pan: true,
    }) {
        const target = {};
        const { rotation, displayArea, zoom, pan } = viewPresSel;
        if (rotation) {
            target.rotation = this.getRotation();
        }
        if (displayArea) {
            target.displayArea = this.getDisplayArea();
        }
        const initZoom = this.getZoom();
        if (zoom) {
            target.zoom = initZoom;
        }
        if (pan) {
            target.pan = this.getPan();
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.scale */ .Zc.scale(target.pan, target.pan, 1 / initZoom);
        }
        return target;
    }
    setViewReference(viewRef) {
    }
    setViewPresentation(viewPres) {
        if (!viewPres) {
            return;
        }
        const { displayArea, zoom = this.getZoom(), pan, rotation } = viewPres;
        if (displayArea !== this.getDisplayArea()) {
            this.setDisplayArea(displayArea);
        }
        this.setZoom(zoom);
        if (pan) {
            this.setPan(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.scale */ .Zc.scale([0, 0], pan, zoom));
        }
        if (rotation >= 0) {
            this.setRotation(rotation);
        }
    }
    _getCorners(bounds) {
        return [
            [bounds[0], bounds[2], bounds[4]],
            [bounds[0], bounds[2], bounds[5]],
            [bounds[0], bounds[3], bounds[4]],
            [bounds[0], bounds[3], bounds[5]],
            [bounds[1], bounds[2], bounds[4]],
            [bounds[1], bounds[2], bounds[5]],
            [bounds[1], bounds[3], bounds[4]],
            [bounds[1], bounds[3], bounds[5]],
        ];
    }
    _getFocalPointForResetCamera(centeredFocalPoint, previousCamera, { resetPan = true, resetToCenter = true }) {
        if (resetToCenter && resetPan) {
            return centeredFocalPoint;
        }
        if (resetToCenter && !resetPan) {
            return (0,_utilities_hasNaNValues__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(previousCamera.focalPoint)
                ? centeredFocalPoint
                : previousCamera.focalPoint;
        }
        if (!resetToCenter && resetPan) {
            const oldCamera = previousCamera;
            const oldFocalPoint = oldCamera.focalPoint;
            const oldViewPlaneNormal = oldCamera.viewPlaneNormal;
            const vectorFromOldFocalPointToCenteredFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), centeredFocalPoint, oldFocalPoint);
            const distanceFromOldFocalPointToCenteredFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(vectorFromOldFocalPointToCenteredFocalPoint, oldViewPlaneNormal);
            const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), centeredFocalPoint, oldViewPlaneNormal, -1 * distanceFromOldFocalPointToCenteredFocalPoint);
            return [newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]];
        }
        if (!resetPan && !resetToCenter) {
            return (0,_utilities_hasNaNValues__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(previousCamera.focalPoint)
                ? centeredFocalPoint
                : previousCamera.focalPoint;
        }
    }
    _isInBounds(point, bounds) {
        const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
        const [x, y, z] = point;
        if (x < xMin || x > xMax || y < yMin || y > yMax || z < zMin || z > zMax) {
            return false;
        }
        return true;
    }
    _getEdges(bounds) {
        const [p1, p2, p3, p4, p5, p6, p7, p8] = this._getCorners(bounds);
        return [
            [p1, p2],
            [p1, p5],
            [p1, p3],
            [p2, p4],
            [p2, p6],
            [p3, p4],
            [p3, p7],
            [p4, p8],
            [p5, p7],
            [p5, p6],
            [p6, p8],
            [p7, p8],
        ];
    }
    static boundsRadius(bounds) {
        const w1 = (bounds[1] - bounds[0]) ** 2;
        const w2 = (bounds[3] - bounds[2]) ** 2;
        const w3 = (bounds[5] - bounds[4]) ** 2;
        const radius = Math.sqrt(w1 + w2 + w3 || 1) * 0.5;
        return radius;
    }
    setDataIds(_imageIds, _options) {
        throw new Error('Unsupported operatoin setDataIds');
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Viewport);


/***/ }),

/***/ 94155:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ RenderingEngine_VolumeViewport)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js + 1 modules
var Plane = __webpack_require__(75127);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js + 6 modules
var constants = __webpack_require__(19325);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 4 modules
var enums = __webpack_require__(31749);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js
var actorCheck = __webpack_require__(98039);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js
var getClosestImageId = __webpack_require__(88619);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSliceRange.js
var getSliceRange = __webpack_require__(20537);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js
var getSpacingInNormalDirection = __webpack_require__(85008);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/snapFocalPointToSlice.js
var snapFocalPointToSlice = __webpack_require__(80500);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/BaseVolumeViewport.js
var BaseVolumeViewport = __webpack_require__(46347);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/setDefaultVolumeVOI.js
var setDefaultVolumeVOI = __webpack_require__(89821);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js
var transferFunctionUtils = __webpack_require__(85745);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageSliceDataForVolumeViewport.js
var getImageSliceDataForVolumeViewport = __webpack_require__(47476);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformCanvasToIJK.js
var transformCanvasToIJK = __webpack_require__(51919);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIndexToWorld.js
var transformIndexToWorld = __webpack_require__(94741);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIJKToCanvas.js

function transformIJKToCanvas(viewport, ijkPoint) {
    const { imageData: vtkImageData } = viewport.getImageData();
    const worldPoint = (0,transformIndexToWorld/* default */.A)(vtkImageData, ijkPoint);
    return viewport.worldToCanvas(worldPoint);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport.js

















class VolumeViewport extends BaseVolumeViewport/* default */.A {
    constructor(props) {
        super(props);
        this._useAcquisitionPlaneForViewPlane = false;
        this.getNumberOfSlices = () => {
            const { numberOfSlices } = (0,getImageSliceDataForVolumeViewport/* default */.A)(this) || {};
            return numberOfSlices;
        };
        this.resetCameraForResize = () => {
            return this.resetCamera({
                resetPan: true,
                resetZoom: true,
                resetToCenter: true,
                resetRotation: false,
                suppressEvents: true,
            });
        };
        this.getCurrentImageIdIndex = (volumeId) => {
            const { viewPlaneNormal, focalPoint } = this.getCamera();
            const imageData = this.getImageData(volumeId);
            if (!imageData) {
                return;
            }
            const { origin, direction, spacing } = imageData;
            const spacingInNormal = (0,getSpacingInNormalDirection/* default */.A)({ direction, spacing }, viewPlaneNormal);
            const sub = esm/* vec3.create */.eR.create();
            esm/* vec3.sub */.eR.sub(sub, focalPoint, origin);
            const distance = esm/* vec3.dot */.eR.dot(sub, viewPlaneNormal);
            return Math.round(Math.abs(distance) / spacingInNormal);
        };
        this.getSliceIndex = () => {
            const { imageIndex } = (0,getImageSliceDataForVolumeViewport/* default */.A)(this) || {};
            return imageIndex;
        };
        this.getCurrentImageId = () => {
            const actorEntry = this.getDefaultActor();
            if (!actorEntry || !(0,actorCheck/* actorIsA */.N)(actorEntry, 'vtkVolume')) {
                return;
            }
            const volume = cache/* default */.Ay.getVolume(this.getVolumeId());
            if (!volume) {
                return;
            }
            const { viewPlaneNormal, focalPoint } = this.getCamera();
            return (0,getClosestImageId/* default */.A)(volume, focalPoint, viewPlaneNormal);
        };
        this.getSlicePlaneCoordinates = () => {
            const actorEntry = this.getDefaultActor();
            if (!actorEntry?.actor) {
                console.warn('No image data found for calculating vtkPlanes.');
                return [];
            }
            const volumeId = this.getVolumeId();
            const imageVolume = cache/* default */.Ay.getVolume(volumeId);
            const camera = this.getCamera();
            const { focalPoint, position, viewPlaneNormal } = camera;
            const spacingInNormalDirection = (0,getSpacingInNormalDirection/* default */.A)(imageVolume, viewPlaneNormal);
            const sliceRange = (0,getSliceRange/* default */.A)(actorEntry.actor, viewPlaneNormal, focalPoint);
            const numSlicesBackward = Math.round((sliceRange.current - sliceRange.min) / spacingInNormalDirection);
            const numSlicesForward = Math.round((sliceRange.max - sliceRange.current) / spacingInNormalDirection);
            const currentSliceIndex = this.getSliceIndex();
            const focalPoints = [];
            for (let i = -numSlicesBackward; i <= numSlicesForward; i++) {
                const { newFocalPoint: point } = (0,snapFocalPointToSlice/* default */.A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, i);
                focalPoints.push({ sliceIndex: currentSliceIndex + i, point });
            }
            return focalPoints;
        };
        const { orientation } = this.options;
        if (orientation && orientation !== enums.OrientationAxis.ACQUISITION) {
            this.applyViewOrientation(orientation);
            return;
        }
        this._useAcquisitionPlaneForViewPlane = true;
    }
    async setVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
        const firstImageVolume = cache/* default */.Ay.getVolume(volumeInputArray[0].volumeId);
        if (!firstImageVolume) {
            throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
        }
        if (this._useAcquisitionPlaneForViewPlane) {
            this._setViewPlaneToAcquisitionPlane(firstImageVolume);
            this._useAcquisitionPlaneForViewPlane = false;
        }
        return super.setVolumes(volumeInputArray, immediate, suppressEvents);
    }
    async addVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
        const firstImageVolume = cache/* default */.Ay.getVolume(volumeInputArray[0].volumeId);
        if (!firstImageVolume) {
            throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
        }
        if (this._useAcquisitionPlaneForViewPlane) {
            this._setViewPlaneToAcquisitionPlane(firstImageVolume);
            this._useAcquisitionPlaneForViewPlane = false;
        }
        return super.addVolumes(volumeInputArray, immediate, suppressEvents);
    }
    jumpToWorld(worldPos) {
        const { focalPoint } = this.getCamera();
        const delta = [0, 0, 0];
        esm/* vec3.sub */.eR.sub(delta, worldPos, focalPoint);
        const camera = this.getCamera();
        const normal = camera.viewPlaneNormal;
        const dotProd = esm/* vec3.dot */.eR.dot(delta, normal);
        const projectedDelta = esm/* vec3.fromValues */.eR.fromValues(normal[0], normal[1], normal[2]);
        esm/* vec3.scale */.eR.scale(projectedDelta, projectedDelta, dotProd);
        if (Math.abs(projectedDelta[0]) > 1e-3 ||
            Math.abs(projectedDelta[1]) > 1e-3 ||
            Math.abs(projectedDelta[2]) > 1e-3) {
            const newFocalPoint = [0, 0, 0];
            const newPosition = [0, 0, 0];
            esm/* vec3.add */.eR.add(newFocalPoint, camera.focalPoint, projectedDelta);
            esm/* vec3.add */.eR.add(newPosition, camera.position, projectedDelta);
            this.setCamera({
                focalPoint: newFocalPoint,
                position: newPosition,
            });
            this.render();
        }
        return true;
    }
    setOrientation(orientation, immediate = true) {
        let viewPlaneNormal, viewUp;
        if (typeof orientation === 'string') {
            if (constants.MPR_CAMERA_VALUES[orientation]) {
                ({ viewPlaneNormal, viewUp } = constants.MPR_CAMERA_VALUES[orientation]);
            }
            else if (orientation === 'acquisition') {
                ({ viewPlaneNormal, viewUp } = this._getAcquisitionPlaneOrientation());
            }
            else {
                throw new Error(`Invalid orientation: ${orientation}. Use Enums.OrientationAxis instead.`);
            }
            this.setCamera({
                viewPlaneNormal,
                viewUp,
            });
            this.viewportProperties.orientation = orientation;
            this.resetCamera();
        }
        else {
            ({ viewPlaneNormal, viewUp } = orientation);
            this.applyViewOrientation(orientation);
        }
        if (immediate) {
            this.render();
        }
    }
    setCameraClippingRange() {
        const activeCamera = this.getVtkActiveCamera();
        if (activeCamera.getParallelProjection()) {
            activeCamera.setClippingRange(-constants.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE, constants.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
        else {
            activeCamera.setClippingRange(constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, constants.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
    }
    _getAcquisitionPlaneOrientation() {
        const actorEntry = this.getDefaultActor();
        if (!actorEntry) {
            return;
        }
        const volumeId = this.getVolumeId();
        const imageVolume = cache/* default */.Ay.getVolume(volumeId);
        if (!imageVolume) {
            throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
        }
        const { direction } = imageVolume;
        const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
        const viewUp = direction.slice(3, 6).map((x) => -x);
        return {
            viewPlaneNormal,
            viewUp,
        };
    }
    _setViewPlaneToAcquisitionPlane(imageVolume) {
        let viewPlaneNormal, viewUp;
        if (imageVolume) {
            const { direction } = imageVolume;
            viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
            viewUp = direction.slice(3, 6).map((x) => -x);
        }
        else {
            ({ viewPlaneNormal, viewUp } = this._getAcquisitionPlaneOrientation());
        }
        this.setCamera({
            viewPlaneNormal,
            viewUp,
        });
        this.initialViewUp = viewUp;
        this.resetCamera();
    }
    setBlendMode(blendMode, filterActorUIDs = [], immediate = false) {
        let actorEntries = this.getActors();
        if (filterActorUIDs && filterActorUIDs.length > 0) {
            actorEntries = actorEntries.filter((actorEntry) => {
                return filterActorUIDs.includes(actorEntry.uid);
            });
        }
        actorEntries.forEach((actorEntry) => {
            const { actor } = actorEntry;
            const mapper = actor.getMapper();
            mapper.setBlendMode?.(blendMode);
        });
        if (immediate) {
            this.render();
        }
    }
    resetCamera(options) {
        const { resetPan = true, resetZoom = true, resetRotation = true, resetToCenter = true, suppressEvents = false, resetOrientation = true, } = options || {};
        const { orientation } = this.viewportProperties;
        if (orientation && resetOrientation) {
            this.applyViewOrientation(orientation, false);
        }
        super.resetCamera({ resetPan, resetZoom, resetToCenter });
        const activeCamera = this.getVtkActiveCamera();
        const viewPlaneNormal = activeCamera.getViewPlaneNormal();
        const focalPoint = activeCamera.getFocalPoint();
        const actorEntries = this.getActors();
        actorEntries.forEach((actorEntry) => {
            if (!actorEntry.actor) {
                return;
            }
            const mapper = actorEntry.actor.getMapper();
            const vtkPlanes = mapper.getClippingPlanes();
            if (vtkPlanes.length === 0 && !actorEntry?.clippingFilter) {
                const clipPlane1 = Plane/* default.newInstance */.Ay.newInstance();
                const clipPlane2 = Plane/* default.newInstance */.Ay.newInstance();
                const newVtkPlanes = [clipPlane1, clipPlane2];
                let slabThickness = constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
                if (actorEntry.slabThickness) {
                    slabThickness = actorEntry.slabThickness;
                }
                this.setOrientationOfClippingPlanes(newVtkPlanes, slabThickness, viewPlaneNormal, focalPoint);
                mapper.addClippingPlane(clipPlane1);
                mapper.addClippingPlane(clipPlane2);
            }
        });
        if (resetRotation &&
            constants.MPR_CAMERA_VALUES[this.viewportProperties.orientation] !== undefined) {
            const viewToReset = constants.MPR_CAMERA_VALUES[this.viewportProperties.orientation];
            this.setCameraNoEvent({
                viewUp: viewToReset.viewUp,
                viewPlaneNormal: viewToReset.viewPlaneNormal,
            });
        }
        if (!suppressEvents) {
            const eventDetail = {
                viewportId: this.id,
                camera: this.getCamera(),
                renderingEngineId: this.renderingEngineId,
                element: this.element,
            };
            (0,triggerEvent/* default */.A)(this.element, enums.Events.CAMERA_RESET, eventDetail);
        }
        return true;
    }
    setSlabThickness(slabThickness, filterActorUIDs = []) {
        if (slabThickness < 0.1) {
            slabThickness = 0.1;
        }
        let actorEntries = this.getActors();
        if (filterActorUIDs && filterActorUIDs.length > 0) {
            actorEntries = actorEntries.filter((actorEntry) => {
                return filterActorUIDs.includes(actorEntry.uid);
            });
        }
        actorEntries.forEach((actorEntry) => {
            if ((0,actorCheck/* actorIsA */.N)(actorEntry, 'vtkVolume')) {
                actorEntry.slabThickness = slabThickness;
            }
        });
        const currentCamera = this.getCamera();
        this.updateClippingPlanesForActors(currentCamera);
        this.triggerCameraModifiedEventIfNecessary(currentCamera, currentCamera);
        this.viewportProperties.slabThickness = slabThickness;
    }
    resetSlabThickness() {
        const actorEntries = this.getActors();
        actorEntries.forEach((actorEntry) => {
            if ((0,actorCheck/* actorIsA */.N)(actorEntry, 'vtkVolume')) {
                actorEntry.slabThickness = constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            }
        });
        const currentCamera = this.getCamera();
        this.updateClippingPlanesForActors(currentCamera);
        this.triggerCameraModifiedEventIfNecessary(currentCamera, currentCamera);
        this.viewportProperties.slabThickness = undefined;
    }
    getSliceViewInfo() {
        const { width: canvasWidth, height: canvasHeight } = this.getCanvas();
        const ijkOriginPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [0, 0]);
        const ijkRowPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [canvasWidth - 1, 0]);
        const ijkColPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [0, canvasHeight - 1]);
        const ijkRowVec = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), ijkRowPoint, ijkOriginPoint);
        const ijkColVec = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), ijkColPoint, ijkOriginPoint);
        const ijkSliceVec = esm/* vec3.cross */.eR.cross(esm/* vec3.create */.eR.create(), ijkRowVec, ijkColVec);
        esm/* vec3.normalize */.eR.normalize(ijkRowVec, ijkRowVec);
        esm/* vec3.normalize */.eR.normalize(ijkColVec, ijkColVec);
        esm/* vec3.normalize */.eR.normalize(ijkSliceVec, ijkSliceVec);
        const { dimensions } = this.getImageData();
        const [sx, sy, sz] = dimensions;
        const ijkCorners = [
            [0, 0, 0],
            [sx - 1, 0, 0],
            [0, sy - 1, 0],
            [sx - 1, sy - 1, 0],
            [0, 0, sz - 1],
            [sx - 1, 0, sz - 1],
            [0, sy - 1, sz - 1],
            [sx - 1, sy - 1, sz - 1],
        ];
        const canvasCorners = ijkCorners.map((ijkCorner) => transformIJKToCanvas(this, ijkCorner));
        const canvasAABB = canvasCorners.reduce((aabb, canvasPoint) => {
            aabb.minX = Math.min(aabb.minX, canvasPoint[0]);
            aabb.minY = Math.min(aabb.minY, canvasPoint[1]);
            aabb.maxX = Math.max(aabb.maxX, canvasPoint[0]);
            aabb.maxY = Math.max(aabb.maxY, canvasPoint[1]);
            return aabb;
        }, { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
        const ijkTopLeft = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [
            canvasAABB.minX,
            canvasAABB.minY,
        ]);
        const sliceToIndexMatrix = esm/* mat4.fromValues */.pB.fromValues(ijkRowVec[0], ijkRowVec[1], ijkRowVec[2], 0, ijkColVec[0], ijkColVec[1], ijkColVec[2], 0, ijkSliceVec[0], ijkSliceVec[1], ijkSliceVec[2], 0, ijkTopLeft[0], ijkTopLeft[1], ijkTopLeft[2], 1);
        const ijkBottomRight = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [
            canvasAABB.maxX,
            canvasAABB.maxY,
        ]);
        const ijkDiagonal = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), ijkBottomRight, ijkTopLeft);
        const indexToSliceMatrix = esm/* mat4.invert */.pB.invert(esm/* mat4.create */.pB.create(), sliceToIndexMatrix);
        const { viewPlaneNormal } = this.getCamera();
        const isOblique = viewPlaneNormal.filter((component) => Math.abs(component) > constants.EPSILON)
            .length > 1;
        if (isOblique) {
            throw new Error('getSliceInfo is not supported for oblique views');
        }
        const sliceAxis = viewPlaneNormal.findIndex((component) => Math.abs(component) > 1 - constants.EPSILON);
        if (sliceAxis === -1) {
            throw new Error('Unable to determine slice axis');
        }
        const sliceWidth = esm/* vec3.dot */.eR.dot(ijkRowVec, ijkDiagonal) + 1;
        const sliceHeight = esm/* vec3.dot */.eR.dot(ijkColVec, ijkDiagonal) + 1;
        return {
            sliceIndex: this.getSliceIndex(),
            width: sliceWidth,
            height: sliceHeight,
            slicePlane: sliceAxis,
            sliceToIndexMatrix,
            indexToSliceMatrix,
        };
    }
    getCurrentSlicePixelData() {
        const { voxelManager } = this.getImageData();
        const sliceData = voxelManager.getSliceData(this.getSliceViewInfo());
        return sliceData;
    }
    getViewReference(viewRefSpecifier = {}) {
        const viewRef = super.getViewReference(viewRefSpecifier);
        if (!viewRef?.volumeId) {
            return;
        }
        const volume = cache/* default */.Ay.getVolume(viewRef.volumeId);
        viewRef.referencedImageId = (0,getClosestImageId/* default */.A)(volume, viewRef.cameraFocalPoint, viewRef.viewPlaneNormal);
        return viewRef;
    }
    resetProperties(volumeId) {
        this._resetProperties(volumeId);
    }
    _resetProperties(volumeId) {
        const volumeActor = volumeId
            ? this.getActor(volumeId)
            : this.getDefaultActor();
        if (!volumeActor) {
            throw new Error(`No actor found for the given volumeId: ${volumeId}`);
        }
        if (volumeActor.slabThickness) {
            volumeActor.slabThickness = constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            this.viewportProperties.slabThickness = undefined;
            this.updateClippingPlanesForActors(this.getCamera());
        }
        volumeId ||= this.getVolumeId();
        const imageVolume = cache/* default */.Ay.getVolume(volumeId);
        if (!imageVolume) {
            throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
        }
        (0,setDefaultVolumeVOI/* default */.A)(volumeActor.actor, imageVolume);
        if ((0,actorCheck/* isImageActor */.e)(volumeActor)) {
            const transferFunction = volumeActor.actor
                .getProperty()
                .getRGBTransferFunction(0);
            (0,transferFunctionUtils.setTransferFunctionNodes)(transferFunction, this.initialTransferFunctionNodes);
        }
        const eventDetails = {
            ...super.getVOIModifiedEventDetail(volumeId),
        };
        const resetPan = true;
        const resetZoom = true;
        const resetToCenter = true;
        const resetCameraRotation = true;
        this.resetCamera({
            resetPan,
            resetZoom,
            resetToCenter,
            resetCameraRotation,
        });
        (0,triggerEvent/* default */.A)(this.element, enums.Events.VOI_MODIFIED, eventDetails);
    }
    getSlicesClippingPlanes() {
        const focalPoints = this.getSlicePlaneCoordinates();
        const { viewPlaneNormal } = this.getCamera();
        const slabThickness = constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
        return focalPoints.map(({ point, sliceIndex }) => {
            const vtkPlanes = [Plane/* default.newInstance */.Ay.newInstance(), Plane/* default.newInstance */.Ay.newInstance()];
            this.setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, point);
            return {
                sliceIndex,
                planes: vtkPlanes.map((plane) => ({
                    normal: plane.getNormal(),
                    origin: plane.getOrigin(),
                })),
            };
        });
    }
}
/* harmony default export */ const RenderingEngine_VolumeViewport = (VolumeViewport);


/***/ }),

/***/ 40893:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19325);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31749);
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49038);
/* harmony import */ var _helpers_setDefaultVolumeVOI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89821);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(69372);
/* harmony import */ var _utilities_actorCheck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98039);
/* harmony import */ var _utilities_transferFunctionUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85745);
/* harmony import */ var _BaseVolumeViewport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(46347);








class VolumeViewport3D extends _BaseVolumeViewport__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A {
    constructor(props) {
        super(props);
        this.getNumberOfSlices = () => {
            return 1;
        };
        this.getRotation = () => 0;
        this.getCurrentImageIdIndex = () => {
            return 0;
        };
        this.getCurrentImageId = () => {
            return null;
        };
        this.resetCameraForResize = () => {
            return this.resetCamera({
                resetPan: true,
                resetZoom: true,
                resetToCenter: true,
            });
        };
        const { parallelProjection, orientation } = this.options;
        const activeCamera = this.getVtkActiveCamera();
        if (parallelProjection != null) {
            activeCamera.setParallelProjection(parallelProjection);
        }
        if (orientation && orientation !== _enums__WEBPACK_IMPORTED_MODULE_1__.OrientationAxis.ACQUISITION) {
            this.applyViewOrientation(orientation);
        }
    }
    resetCamera({ resetPan = true, resetZoom = true, resetToCenter = true, } = {}) {
        super.resetCamera({ resetPan, resetZoom, resetToCenter });
        const activeCamera = this.getVtkActiveCamera();
        if (activeCamera.getParallelProjection()) {
            activeCamera.setClippingRange(-_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE, _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
        else {
            activeCamera.setClippingRange(_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
        const renderer = this.getRenderer();
        renderer.resetCameraClippingRange();
        return true;
    }
    setSlabThickness(slabThickness, filterActorUIDs) {
        return null;
    }
    setBlendMode(blendMode, filterActorUIDs, immediate) {
        return null;
    }
    resetProperties(volumeId) {
        const volumeActor = volumeId
            ? this.getActor(volumeId)
            : this.getDefaultActor();
        if (!volumeActor) {
            throw new Error(`No actor found for the given volumeId: ${volumeId}`);
        }
        if (volumeActor.slabThickness) {
            volumeActor.slabThickness = _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            this.viewportProperties.slabThickness = undefined;
            this.updateClippingPlanesForActors(this.getCamera());
        }
        volumeId ||= this.getVolumeId();
        const imageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay.getVolume(volumeId);
        if (!imageVolume) {
            throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
        }
        (0,_helpers_setDefaultVolumeVOI__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(volumeActor.actor, imageVolume);
        if ((0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_5__/* .isImageActor */ .e)(volumeActor)) {
            const transferFunction = volumeActor.actor
                .getProperty()
                .getRGBTransferFunction(0);
            (0,_utilities_transferFunctionUtils__WEBPACK_IMPORTED_MODULE_6__.setTransferFunctionNodes)(transferFunction, this.initialTransferFunctionNodes);
        }
        this.setCamera(this.initialCamera);
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.VOI_MODIFIED, super.getVOIModifiedEventDetail(volumeId));
    }
    getSliceIndex() {
        return null;
    }
    setCamera(props) {
        super.setCamera(props);
        this.getRenderer().resetCameraClippingRange();
        this.render();
    }
    setCameraClippingRange() {
        const activeCamera = this.getVtkActiveCamera();
        if (activeCamera.getParallelProjection()) {
            activeCamera.setClippingRange(-_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE, _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
        else {
            activeCamera.setClippingRange(_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
    }
    resetSlabThickness() {
        return null;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VolumeViewport3D);


/***/ }),

/***/ 81466:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ RenderingEngine_WSIViewport)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 4 modules
var enums = __webpack_require__(31749);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var metaData = __webpack_require__(74876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/transform.js
var rendering_transform = __webpack_require__(45354);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/Viewport.js
var Viewport = __webpack_require__(10056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js + 2 modules
var helpers = __webpack_require__(98834);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js + 6 modules
var constants = __webpack_require__(19325);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js + 1 modules
var init = __webpack_require__(59693);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js
var pointInShapeCallback = __webpack_require__(56577);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/microscopyViewportCss.js
const microscopyViewportCss = `
.DicomMicroscopyViewer {
  --ol-partial-background-color: rgba(127, 127, 127, 0.7);
  --ol-foreground-color: #000000;
  --ol-subtle-foreground-color: #000;
  --ol-subtle-background-color: rgba(78, 78, 78, 0.5);
}

.DicomMicroscopyViewer .ol-box {
  box-sizing: border-box;
  border-radius: 2px;
  border: 1.5px solid var(--ol-background-color);
  background-color: var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-mouse-position {
  top: 8px;
  right: 8px;
  position: absolute;
}

.DicomMicroscopyViewer .ol-scale-line {
  background: var(--ol-partial-background-color);
  border-radius: 4px;
  bottom: 8px;
  left: 8px;
  padding: 2px;
  position: absolute;
}

.DicomMicroscopyViewer .ol-scale-line-inner {
  border: 1px solid var(--ol-subtle-foreground-color);
  border-top: none;
  color: var(--ol-foreground-color);
  font-size: 10px;
  text-align: center;
  margin: 1px;
  will-change: contents, width;
  transition: all 0.25s;
}

.DicomMicroscopyViewer .ol-scale-bar {
  position: absolute;
  bottom: 8px;
  left: 8px;
}

.DicomMicroscopyViewer .ol-scale-bar-inner {
  display: flex;
}

.DicomMicroscopyViewer .ol-scale-step-marker {
  width: 1px;
  height: 15px;
  background-color: var(--ol-foreground-color);
  float: right;
  z-index: 10;
}

.DicomMicroscopyViewer .ol-scale-step-text {
  position: absolute;
  bottom: -5px;
  font-size: 10px;
  z-index: 11;
  color: var(--ol-foreground-color);
  text-shadow:
    -1.5px 0 var(--ol-partial-background-color),
    0 1.5px var(--ol-partial-background-color),
    1.5px 0 var(--ol-partial-background-color),
    0 -1.5px var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-scale-text {
  position: absolute;
  font-size: 12px;
  text-align: center;
  bottom: 25px;
  color: var(--ol-foreground-color);
  text-shadow:
    -1.5px 0 var(--ol-partial-background-color),
    0 1.5px var(--ol-partial-background-color),
    1.5px 0 var(--ol-partial-background-color),
    0 -1.5px var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar {
  position: relative;
  height: 10px;
  z-index: 9;
  box-sizing: border-box;
  border: 1px solid var(--ol-foreground-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar-even {
  background-color: var(--ol-subtle-foreground-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar-odd {
  background-color: var(--ol-background-color);
}

.DicomMicroscopyViewer .ol-unsupported {
  display: none;
}

.DicomMicroscopyViewer .ol-viewport,
.DicomMicroscopyViewer .ol-unselectable {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.DicomMicroscopyViewer .ol-viewport canvas {
  all: unset;
}

.DicomMicroscopyViewer .ol-selectable {
  -webkit-touch-callout: default;
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

.DicomMicroscopyViewer .ol-grabbing {
  cursor: -webkit-grabbing;
  cursor: -moz-grabbing;
  cursor: grabbing;
}

.DicomMicroscopyViewer .ol-grab {
  cursor: move;
  cursor: -webkit-grab;
  cursor: -moz-grab;
  cursor: grab;
}

.DicomMicroscopyViewer .ol-control {
  position: absolute;
  background-color: var(--ol-subtle-background-color);
  border-radius: 4px;
}

.DicomMicroscopyViewer .ol-zoom {
  top: 0.5em;
  left: 0.5em;
}

.DicomMicroscopyViewer .ol-rotate {
  top: 0.5em;
  right: 0.5em;
  transition:
    opacity 0.25s linear,
    visibility 0s linear;
}

.DicomMicroscopyViewer .ol-rotate.ol-hidden {
  opacity: 0;
  visibility: hidden;
  transition:
    opacity 0.25s linear,
    visibility 0s linear 0.25s;
}

.DicomMicroscopyViewer .ol-zoom-extent {
  top: 4.643em;
  left: 0.5em;
}

.DicomMicroscopyViewer .ol-full-screen {
  right: 0.5em;
  top: 0.5em;
}

.DicomMicroscopyViewer .ol-control button {
  display: block;
  margin: 1px;
  padding: 0;
  color: var(--ol-subtle-foreground-color);
  font-weight: bold;
  text-decoration: none;
  font-size: inherit;
  text-align: center;
  height: 1.375em;
  width: 1.375em;
  line-height: 0.4em;
  background-color: var(--ol-background-color);
  border: none;
  border-radius: 2px;
}

.DicomMicroscopyViewer .ol-control button::-moz-focus-inner {
  border: none;
  padding: 0;
}

.DicomMicroscopyViewer .ol-zoom-extent button {
  line-height: 1.4em;
}

.DicomMicroscopyViewer .ol-compass {
  display: block;
  font-weight: normal;
  will-change: transform;
}

.DicomMicroscopyViewer .ol-touch .ol-control button {
  font-size: 1.5em;
}

.DicomMicroscopyViewer .ol-touch .ol-zoom-extent {
  top: 5.5em;
}

.DicomMicroscopyViewer .ol-control button:hover,
.DicomMicroscopyViewer .ol-control button:focus {
  text-decoration: none;
  outline: 1px solid var(--ol-subtle-foreground-color);
  color: var(--ol-foreground-color);
}

.DicomMicroscopyViewer .ol-zoom .ol-zoom-in {
  border-radius: 2px 2px 0 0;
}

.DicomMicroscopyViewer .ol-zoom .ol-zoom-out {
  border-radius: 0 0 2px 2px;
}

.DicomMicroscopyViewer .ol-attribution {
  text-align: right;
  bottom: 0.5em;
  right: 0.5em;
  max-width: calc(100% - 1.3em);
  display: flex;
  flex-flow: row-reverse;
  align-items: center;
}

.DicomMicroscopyViewer .ol-attribution a {
  color: var(--ol-subtle-foreground-color);
  text-decoration: none;
}

.DicomMicroscopyViewer .ol-attribution ul {
  margin: 0;
  padding: 1px 0.5em;
  color: var(--ol-foreground-color);
  text-shadow: 0 0 2px var(--ol-background-color);
  font-size: 12px;
}

.DicomMicroscopyViewer .ol-attribution li {
  display: inline;
  list-style: none;
}

.DicomMicroscopyViewer .ol-attribution li:not(:last-child):after {
  content: ' ';
}

.DicomMicroscopyViewer .ol-attribution img {
  max-height: 2em;
  max-width: inherit;
  vertical-align: middle;
}

.DicomMicroscopyViewer .ol-attribution button {
  flex-shrink: 0;
}

.DicomMicroscopyViewer .ol-attribution.ol-collapsed ul {
  display: none;
}

.DicomMicroscopyViewer .ol-attribution:not(.ol-collapsed) {
  background: var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible {
  bottom: 0;
  right: 0;
  border-radius: 4px 0 0;
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible img {
  margin-top: -0.2em;
  max-height: 1.6em;
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible button {
  display: none;
}

.DicomMicroscopyViewer .ol-zoomslider {
  top: 4.5em;
  left: 0.5em;
  height: 200px;
}

.DicomMicroscopyViewer .ol-zoomslider button {
  position: relative;
  height: 10px;
}

.DicomMicroscopyViewer .ol-touch .ol-zoomslider {
  top: 5.5em;
}

.DicomMicroscopyViewer .ol-overviewmap {
  left: 0.5em;
  bottom: 0.5em;
}

.DicomMicroscopyViewer .ol-overviewmap.ol-uncollapsible {
  bottom: 0;
  left: 0;
  border-radius: 0 4px 0 0;
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-map,
.DicomMicroscopyViewer .ol-overviewmap button {
  display: block;
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-map {
  border: 1px solid var(--ol-subtle-foreground-color);
  height: 150px;
  width: 150px;
}

.DicomMicroscopyViewer .ol-overviewmap:not(.ol-collapsed) button {
  bottom: 0;
  left: 0;
  position: absolute;
}

.DicomMicroscopyViewer .ol-overviewmap.ol-collapsed .ol-overviewmap-map,
.DicomMicroscopyViewer .ol-overviewmap.ol-uncollapsible button {
  display: none;
}

.DicomMicroscopyViewer .ol-overviewmap:not(.ol-collapsed) {
  background: var(--ol-subtle-background-color);
}

.DicomMicroscopyViewer .ol-overviewmap-box {
  border: 0.5px dotted var(--ol-subtle-foreground-color);
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-box:hover {
  cursor: move;
}

@layout-header-background: #007ea3;
@primary-color: #007ea3;
@processing-color: #8cb8c6;
@success-color: #3f9c35;
@warning-color: #eeaf30;
@error-color: #96172e;
@font-size-base: 14px;

.DicomMicroscopyViewer .ol-tooltip {
  font-size: 16px !important;
}
`;
/* harmony default export */ const constants_microscopyViewportCss = (microscopyViewportCss);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/WSIViewport.js












const _map = Symbol.for('map');
const EVENT_POSTRENDER = 'postrender';
class WSIViewport extends Viewport/* default */.A {
    constructor(props) {
        super({
            ...props,
            canvas: props.canvas || (0,helpers/* getOrCreateCanvas */.oI)(props.element),
        });
        this.internalCamera = {
            rotation: 0,
            centerIndex: [0, 0],
            extent: [0, -2, 1, -1],
            xSpacing: 1,
            ySpacing: 1,
            resolution: 1,
            zoom: 1,
        };
        this.voiRange = {
            lower: 0,
            upper: 255,
        };
        this.getProperties = () => {
            return {};
        };
        this.resetCamera = () => {
            return true;
        };
        this.getNumberOfSlices = () => {
            return 1;
        };
        this.getFrameOfReferenceUID = () => {
            return this.frameOfReferenceUID;
        };
        this.resize = () => {
            const canvas = this.canvas;
            const { clientWidth, clientHeight } = canvas;
            if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
                canvas.width = clientWidth;
                canvas.height = clientHeight;
            }
            this.refreshRenderValues();
        };
        this.canvasToWorld = (canvasPos) => {
            if (!this.metadata) {
                return;
            }
            const [px, py] = this.canvasToIndex(canvasPos);
            const { origin, spacing, direction } = this.getImageData();
            const worldPos = esm/* vec3.fromValues */.eR.fromValues(0, 0, 0);
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(worldPos, origin, iVector, px * spacing[0]);
            esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(worldPos, worldPos, jVector, py * spacing[1]);
            return [worldPos[0], worldPos[1], worldPos[2]];
        };
        this.worldToCanvas = (worldPos) => {
            if (!this.metadata) {
                return;
            }
            const { spacing, direction, origin } = this.metadata;
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            const diff = esm/* vec3.subtract */.eR.subtract([0, 0, 0], worldPos, origin);
            const indexPoint = [
                esm/* vec3.dot */.eR.dot(diff, iVector) / spacing[0],
                esm/* vec3.dot */.eR.dot(diff, jVector) / spacing[1],
            ];
            const canvasPoint = this.indexToCanvas(indexPoint);
            return canvasPoint;
        };
        this.postrender = () => {
            this.refreshRenderValues();
            (0,triggerEvent/* default */.A)(this.element, enums.Events.IMAGE_RENDERED, {
                element: this.element,
                viewportId: this.id,
                viewport: this,
                renderingEngineId: this.renderingEngineId,
            });
        };
        this.getRotation = () => 0;
        this.canvasToIndex = (canvasPos) => {
            const transform = this.getTransform();
            transform.invert();
            return transform.transformPoint(canvasPos);
        };
        this.indexToCanvas = (indexPos) => {
            const transform = this.getTransform();
            return transform.transformPoint(indexPos);
        };
        this.customRenderViewportToCanvas = () => {
        };
        this.getImageIds = () => {
            return [this.imageIds[0]];
        };
        this.renderingEngineId = props.renderingEngineId;
        this.element.setAttribute('data-viewport-uid', this.id);
        this.element.setAttribute('data-rendering-engine-uid', this.renderingEngineId);
        this.element.style.position = 'relative';
        this.microscopyElement = document.createElement('div');
        this.microscopyElement.setAttribute('class', 'DicomMicroscopyViewer');
        this.microscopyElement.id = (0,uuidv4/* default */.A)();
        this.microscopyElement.innerText = 'Initial';
        this.microscopyElement.style.background = 'grey';
        this.microscopyElement.style.width = '100%';
        this.microscopyElement.style.height = '100%';
        this.microscopyElement.style.position = 'absolute';
        this.microscopyElement.style.left = '0';
        this.microscopyElement.style.top = '0';
        const cs3dElement = this.element.firstElementChild;
        cs3dElement.insertBefore(this.microscopyElement, cs3dElement.childNodes[1]);
        this.addEventListeners();
        this.addWidget('DicomMicroscopyViewer', {
            getEnabled: () => !!this.viewer,
            setEnabled: () => {
                this.elementDisabledHandler();
            },
        });
        this.resize();
    }
    static get useCustomRenderingPipeline() {
        return true;
    }
    addEventListeners() {
        this.canvas.addEventListener(enums.Events.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    removeEventListeners() {
        this.canvas.removeEventListener(enums.Events.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    elementDisabledHandler() {
        this.removeEventListeners();
        this.viewer?.cleanup();
        this.viewer = null;
        const cs3dElement = this.element.firstElementChild;
        cs3dElement.removeChild(this.microscopyElement);
        this.microscopyElement = null;
    }
    getImageDataMetadata(imageIndex = 0) {
        const maxImage = this.metadataDicomweb.reduce((maxImage, image) => {
            return maxImage?.NumberOfFrames < image.NumberOfFrames ? image : maxImage;
        });
        const { TotalPixelMatrixColumns: columns, TotalPixelMatrixRows: rows, ImageOrientationSlide, ImagedVolumeWidth: width, ImagedVolumeHeight: height, ImagedVolumeDepth: depth, } = maxImage;
        const imagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, this.imageIds[imageIndex]);
        let rowCosines = ImageOrientationSlide.slice(0, 3);
        let columnCosines = ImageOrientationSlide.slice(3, 6);
        if (rowCosines == null || columnCosines == null) {
            rowCosines = [1, 0, 0];
            columnCosines = [0, 1, 0];
        }
        const rowCosineVec = esm/* vec3.fromValues */.eR.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
        const colCosineVec = esm/* vec3.fromValues */.eR.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
        const scanAxisNormal = esm/* vec3.create */.eR.create();
        esm/* vec3.cross */.eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
        const { XOffsetInSlideCoordinateSystem = 0, YOffsetInSlideCoordinateSystem = 0, ZOffsetInSlideCoordinateSystem = 0, } = maxImage.TotalPixelMatrixOriginSequence?.[0] || {};
        const origin = [
            XOffsetInSlideCoordinateSystem,
            YOffsetInSlideCoordinateSystem,
            ZOffsetInSlideCoordinateSystem,
        ];
        const xSpacing = width / columns;
        const ySpacing = height / rows;
        const xVoxels = columns;
        const yVoxels = rows;
        const zSpacing = depth;
        const zVoxels = 1;
        this.hasPixelSpacing = !!(width && height);
        return {
            bitsAllocated: 8,
            numberOfComponents: 3,
            origin,
            direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
            dimensions: [xVoxels, yVoxels, zVoxels],
            spacing: [xSpacing, ySpacing, zSpacing],
            hasPixelSpacing: this.hasPixelSpacing,
            numVoxels: xVoxels * yVoxels * zVoxels,
            imagePlaneModule,
        };
    }
    async setFrameNumber(frame) {
    }
    setProperties(props) {
    }
    resetProperties() {
        this.setProperties({});
    }
    getScalarData() {
        return null;
    }
    getImageData() {
        const { metadata } = this;
        if (!metadata) {
            return null;
        }
        const { spacing } = metadata;
        const imageData = {
            getDirection: () => metadata.direction,
            getDimensions: () => metadata.dimensions,
            getRange: () => [0, 255],
            getScalarData: () => this.getScalarData(),
            getSpacing: () => metadata.spacing,
            worldToIndex: (point) => {
                const canvasPoint = this.worldToCanvas(point);
                const pixelCoord = this.canvasToIndex(canvasPoint);
                return [pixelCoord[0], pixelCoord[1], 0];
            },
            indexToWorld: (point) => {
                const canvasPoint = this.indexToCanvas([point[0], point[1]]);
                return this.canvasToWorld(canvasPoint);
            },
        };
        const imageDataReturn = {
            dimensions: metadata.dimensions,
            spacing,
            numberOfComponents: 3,
            origin: metadata.origin,
            direction: metadata.direction,
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: this.frameOfReferenceUID,
            },
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: this.calibration,
            preScale: {
                scaled: false,
            },
            scalarData: this.getScalarData(),
            imageData,
            voxelManager: {
                forEach: (callback, options) => {
                    return (0,pointInShapeCallback/* pointInShapeCallback */.i)(options.imageData, {
                        pointInShapeFn: options.isInObject ?? (() => true),
                        callback: callback,
                        boundsIJK: options.boundsIJK,
                        returnPoints: options.returnPoints ?? false,
                    });
                },
            },
        };
        return imageDataReturn;
    }
    hasImageURI(imageURI) {
        return true;
    }
    setCamera(camera) {
        const previousCamera = this.getCamera();
        const { parallelScale, focalPoint } = camera;
        const view = this.getView();
        const { xSpacing } = this.internalCamera;
        if (parallelScale) {
            const worldToCanvasRatio = this.element.clientHeight / parallelScale;
            const resolution = 1 / xSpacing / worldToCanvasRatio;
            view.setResolution(resolution);
        }
        if (focalPoint) {
            const newCanvas = this.worldToCanvas(focalPoint);
            const newIndex = this.canvasToIndex(newCanvas);
            view.setCenter(newIndex);
        }
        const updatedCamera = this.getCamera();
        this.triggerCameraModifiedEventIfNecessary(previousCamera, updatedCamera);
    }
    getCurrentImageId() {
        return this.imageIds[0];
    }
    getFrameNumber() {
        return 1;
    }
    getCamera() {
        this.refreshRenderValues();
        const { resolution, xSpacing } = this.internalCamera;
        const canvasToWorldRatio = resolution * xSpacing;
        const canvasCenter = [
            this.element.clientWidth / 2,
            this.element.clientHeight / 2,
        ];
        const focalPoint = this.canvasToWorld(canvasCenter);
        return {
            parallelProjection: true,
            focalPoint,
            position: focalPoint,
            viewUp: [0, -1, 0],
            parallelScale: this.element.clientHeight * canvasToWorldRatio,
            viewPlaneNormal: [0, 0, 1],
        };
    }
    static { this.getDicomMicroscopyViewer = async () => {
        return (0,init/* peerImport */.a)('dicom-microscopy-viewer');
    }; }
    setDataIds(imageIds, options) {
        if (options?.miniNavigationOverlay !== false) {
            WSIViewport.addMiniNavigationOverlayCss();
        }
        const webClient = options?.webClient ||
            metaData.get(enums.MetadataModules.WADO_WEB_CLIENT, imageIds[0]);
        if (!webClient) {
            throw new Error(`To use setDataIds on WSI data, you must provide metaData.webClient for ${imageIds[0]}`);
        }
        return this.setWSI(imageIds, webClient);
    }
    async setWSI(imageIds, client) {
        this.microscopyElement.style.background = 'black';
        this.microscopyElement.innerText = 'Loading';
        this.imageIds = imageIds;
        const DicomMicroscopyViewer = await WSIViewport.getDicomMicroscopyViewer();
        this.frameOfReferenceUID = null;
        const metadataDicomweb = this.imageIds.map((imageId) => {
            const imageMetadata = client.getDICOMwebMetadata(imageId);
            Object.defineProperty(imageMetadata, 'isMultiframe', {
                value: imageMetadata.isMultiframe,
                enumerable: false,
            });
            Object.defineProperty(imageMetadata, 'frameNumber', {
                value: undefined,
                enumerable: false,
            });
            const imageType = imageMetadata['00080008']?.Value;
            if (imageType?.length === 1) {
                imageMetadata['00080008'].Value = imageType[0].split('\\');
            }
            const frameOfReference = imageMetadata['00200052']?.Value?.[0];
            if (!this.frameOfReferenceUID) {
                this.frameOfReferenceUID = frameOfReference;
            }
            else if (frameOfReference !== this.frameOfReferenceUID) {
                imageMetadata['00200052'].Value = [this.frameOfReferenceUID];
            }
            return imageMetadata;
        });
        const volumeImages = [];
        metadataDicomweb.forEach((m) => {
            const image = new DicomMicroscopyViewer.metadata.VLWholeSlideMicroscopyImage({
                metadata: m,
            });
            const imageFlavor = image.ImageType[2];
            if (imageFlavor === 'VOLUME' || imageFlavor === 'THUMBNAIL') {
                volumeImages.push(image);
            }
            else {
                console.log('Unknown image type', image.ImageType);
            }
        });
        this.metadataDicomweb = volumeImages;
        const viewer = new DicomMicroscopyViewer.viewer.VolumeImageViewer({
            client,
            metadata: volumeImages,
            controls: ['overview', 'position'],
            retrieveRendered: false,
            bindings: {},
        });
        viewer.render({ container: this.microscopyElement });
        this.metadata = this.getImageDataMetadata();
        viewer.deactivateDragPanInteraction();
        this.viewer = viewer;
        this.map = viewer[_map];
        this.map.on(EVENT_POSTRENDER, this.postrender);
        this.resize();
        this.microscopyElement.innerText = '';
        Object.assign(this.microscopyElement.style, {
            '--ol-partial-background-color': 'rgba(127, 127, 127, 0.7)',
            '--ol-foreground-color': '#000000',
            '--ol-subtle-foreground-color': '#000',
            '--ol-subtle-background-color': 'rgba(78, 78, 78, 0.5)',
            background: 'none',
        });
    }
    scroll(delta) {
        const camera = this.getCamera();
        this.setCamera({
            parallelScale: camera.parallelScale * (1 + 0.1 * delta),
        });
    }
    getSliceIndex() {
        return 0;
    }
    getView() {
        if (!this.viewer) {
            return;
        }
        const map = this.viewer[_map];
        const anyWindow = window;
        anyWindow.map = map;
        anyWindow.viewer = this.viewer;
        anyWindow.view = map?.getView();
        anyWindow.wsi = this;
        return map?.getView();
    }
    refreshRenderValues() {
        const view = this.getView();
        if (!view) {
            return;
        }
        const resolution = view.getResolution();
        if (!resolution || resolution < constants.EPSILON) {
            return;
        }
        const centerIndex = view.getCenter();
        const extent = view.getProjection().getExtent();
        const rotation = view.getRotation();
        const zoom = view.getZoom();
        const { metadata: { spacing: [xSpacing, ySpacing], }, } = this;
        const worldToCanvasRatio = 1 / resolution / xSpacing;
        Object.assign(this.internalCamera, {
            extent,
            centerIndex,
            worldToCanvasRatio,
            xSpacing,
            ySpacing,
            resolution,
            rotation,
            zoom,
        });
    }
    getZoom() {
        return this.getView()?.getZoom();
    }
    setZoom(zoom) {
        this.getView()?.setZoom(zoom);
    }
    getTransform() {
        this.refreshRenderValues();
        const { centerIndex: center, resolution, rotation } = this.internalCamera;
        const halfCanvas = [this.canvas.width / 2, this.canvas.height / 2];
        const transform = new rendering_transform/* Transform */.d();
        transform.translate(halfCanvas[0], halfCanvas[1]);
        transform.rotate(rotation);
        transform.scale(1 / resolution, -1 / resolution);
        transform.translate(-center[0], -center[1]);
        return transform;
    }
    getViewReferenceId() {
        return `imageId:${this.getCurrentImageId()}`;
    }
    getCurrentImageIdIndex() {
        return 0;
    }
    static { this.overlayCssId = 'overlayCss'; }
    static addMiniNavigationOverlayCss() {
        if (document.getElementById(this.overlayCssId)) {
            return;
        }
        const overlayCss = document.createElement('style');
        overlayCss.innerText = constants_microscopyViewportCss;
        overlayCss.setAttribute('id', this.overlayCssId);
        document.getElementsByTagName('head')[0].append(overlayCss);
    }
}
/* harmony default export */ const RenderingEngine_WSIViewport = (WSIViewport);


/***/ }),

/***/ 39536:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   lD: () => (/* binding */ getRenderingEngine),
/* harmony export */   qO: () => (/* binding */ getRenderingEngines)
/* harmony export */ });
/* harmony import */ var _renderingEngineCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5862);

function getRenderingEngine(id) {
    return _renderingEngineCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.get(id);
}
function getRenderingEngines() {
    return _renderingEngineCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getAll();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRenderingEngine);


/***/ }),

/***/ 12132:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ createViewport)
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setDefaultViewport.js
const state = {
    viewport: {},
};
/* harmony default export */ function setDefaultViewport(viewport) {
    state.viewport = viewport || {};
}


;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/createViewport.js

function createDefaultDisplayedArea() {
    return {
        tlhc: {
            x: 1,
            y: 1,
        },
        brhc: {
            x: 1,
            y: 1,
        },
        rowPixelSpacing: 1,
        columnPixelSpacing: 1,
        presentationSizeMode: 'NONE',
    };
}
function createViewport() {
    const displayedArea = createDefaultDisplayedArea();
    const initialDefaultViewport = {
        scale: 1,
        translation: {
            x: 0,
            y: 0,
        },
        voi: {
            windowWidth: undefined,
            windowCenter: undefined,
        },
        invert: false,
        pixelReplication: false,
        rotation: 0,
        hflip: false,
        vflip: false,
        modalityLUT: undefined,
        voiLUT: undefined,
        colormap: undefined,
        labelmap: false,
        displayedArea,
    };
    return Object.assign({}, initialDefaultViewport, state.viewport);
}


/***/ }),

/***/ 23681:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ doesImageNeedToBeRendered)
/* harmony export */ });
function doesImageNeedToBeRendered(enabledElement, image) {
    const lastRenderedImageId = enabledElement.renderingTools.lastRenderedImageId;
    const lastRenderedViewport = enabledElement.renderingTools.lastRenderedViewport;
    return (image.imageId !== lastRenderedImageId ||
        !lastRenderedViewport ||
        lastRenderedViewport.windowCenter !==
            enabledElement.viewport.voi.windowCenter ||
        lastRenderedViewport.windowWidth !==
            enabledElement.viewport.voi.windowWidth ||
        lastRenderedViewport.invert !== enabledElement.viewport.invert ||
        lastRenderedViewport.rotation !== enabledElement.viewport.rotation ||
        lastRenderedViewport.hflip !== enabledElement.viewport.hflip ||
        lastRenderedViewport.vflip !== enabledElement.viewport.vflip ||
        lastRenderedViewport.modalityLUT !== enabledElement.viewport.modalityLUT ||
        lastRenderedViewport.voiLUT !== enabledElement.viewport.voiLUT ||
        lastRenderedViewport.colormap !== enabledElement.viewport.colormap);
}


/***/ }),

/***/ 57162:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15528);
/* harmony import */ var _getImageSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62596);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(canvas, image, rotation = null) {
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(canvas, 'getImageScale: parameter canvas must not be undefined');
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(image, 'getImageScale: parameter image must not be undefined');
    const imageSize = (0,_getImageSize__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(image, rotation);
    const rowPixelSpacing = image.rowPixelSpacing || 1;
    const columnPixelSpacing = image.columnPixelSpacing || 1;
    let verticalRatio = 1;
    let horizontalRatio = 1;
    if (rowPixelSpacing < columnPixelSpacing) {
        horizontalRatio = columnPixelSpacing / rowPixelSpacing;
    }
    else {
        verticalRatio = rowPixelSpacing / columnPixelSpacing;
    }
    const verticalScale = canvas.height / imageSize.height / verticalRatio;
    const horizontalScale = canvas.width / imageSize.width / horizontalRatio;
    return {
        verticalScale,
        horizontalScale,
        scaleFactor: Math.min(horizontalScale, verticalScale),
    };
}


/***/ }),

/***/ 62596:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15528);

function isRotated(rotation) {
    return !(rotation === null ||
        rotation === undefined ||
        rotation === 0 ||
        rotation === 180);
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(image, rotation = null) {
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(image, 'getImageSize: parameter image must not be undefined');
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(image.width, 'getImageSize: parameter image must have width');
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(image.height, 'getImageSize: parameter image must have height');
    if (isRotated(rotation)) {
        return {
            height: image.width,
            width: image.height,
        };
    }
    return {
        width: image.width,
        height: image.height,
    };
}


/***/ }),

/***/ 19704:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ getLut)
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/computeAutoVoi.js
function computeAutoVoi(viewport, image) {
    if (hasVoi(viewport)) {
        return;
    }
    const maxVoi = image.maxPixelValue * image.slope + image.intercept;
    const minVoi = image.minPixelValue * image.slope + image.intercept;
    const ww = maxVoi - minVoi;
    const wc = (maxVoi + minVoi) / 2;
    if (viewport.voi === undefined) {
        viewport.voi = {
            windowWidth: ww,
            windowCenter: wc,
        };
    }
    else {
        viewport.voi.windowWidth = ww;
        viewport.voi.windowCenter = wc;
    }
}
function hasVoi(viewport) {
    const hasLut = viewport.voiLUT && viewport.voiLUT.lut && viewport.voiLUT.lut.length > 0;
    return (hasLut ||
        (viewport.voi.windowWidth !== undefined &&
            viewport.voi.windowCenter !== undefined));
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/lutMatches.js
function lutMatches(a, b) {
    if (!a && !b) {
        return true;
    }
    if (!a || !b) {
        return false;
    }
    return a.id === b.id;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getModalityLut.js
function generateLinearModalityLUT(slope, intercept) {
    return (storedPixelValue) => storedPixelValue * slope + intercept;
}
function generateNonLinearModalityLUT(modalityLUT) {
    const minValue = modalityLUT.lut[0];
    const maxValue = modalityLUT.lut[modalityLUT.lut.length - 1];
    const maxValueMapped = modalityLUT.firstValueMapped + modalityLUT.lut.length;
    return (storedPixelValue) => {
        if (storedPixelValue < modalityLUT.firstValueMapped) {
            return minValue;
        }
        else if (storedPixelValue >= maxValueMapped) {
            return maxValue;
        }
        return modalityLUT.lut[storedPixelValue];
    };
}
/* harmony default export */ function getModalityLut(slope, intercept, modalityLUT) {
    if (modalityLUT) {
        return generateNonLinearModalityLUT(modalityLUT);
    }
    return generateLinearModalityLUT(slope, intercept);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getVOILut.js
var getVOILut = __webpack_require__(44333);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/generateLut.js


/* harmony default export */ function generateLut(image, windowWidth, windowCenter, invert, modalityLUT, voiLUT) {
    const maxPixelValue = image.maxPixelValue;
    const minPixelValue = image.minPixelValue;
    const offset = Math.min(minPixelValue, 0);
    if (image.cachedLut === undefined) {
        const length = maxPixelValue - offset + 1;
        image.cachedLut = {};
        image.cachedLut.lutArray = new Uint8ClampedArray(length);
    }
    const lut = image.cachedLut.lutArray;
    const mlutfn = getModalityLut(image.slope, image.intercept, modalityLUT);
    const vlutfn = (0,getVOILut/* default */.A)(windowWidth, windowCenter, voiLUT);
    if (image.isPreScaled) {
        if (invert) {
            for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
                lut[storedValue + -offset] = 255 - vlutfn(storedValue);
            }
        }
        else {
            for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
                lut[storedValue + -offset] = vlutfn(storedValue);
            }
        }
    }
    else {
        if (invert) {
            for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
                lut[storedValue + -offset] = 255 - vlutfn(mlutfn(storedValue));
            }
        }
        else {
            for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
                lut[storedValue + -offset] = vlutfn(mlutfn(storedValue));
            }
        }
    }
    return lut;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getLut.js



/* harmony default export */ function getLut(image, viewport, invalidated) {
    if (image.cachedLut !== undefined &&
        image.cachedLut.windowCenter === viewport.voi.windowCenter &&
        image.cachedLut.windowWidth === viewport.voi.windowWidth &&
        lutMatches(image.cachedLut.modalityLUT, viewport.modalityLUT) &&
        lutMatches(image.cachedLut.voiLUT, viewport.voiLUT) &&
        image.cachedLut.invert === viewport.invert &&
        !invalidated) {
        return image.cachedLut.lutArray;
    }
    computeAutoVoi(viewport, image);
    generateLut(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert, viewport.modalityLUT, viewport.voiLUT);
    image.cachedLut.windowWidth = viewport.voi.windowWidth;
    image.cachedLut.windowCenter = viewport.voi.windowCenter;
    image.cachedLut.invert = viewport.invert;
    image.cachedLut.voiLUT = viewport.voiLUT;
    image.cachedLut.modalityLUT = viewport.modalityLUT;
    return image.cachedLut.lutArray;
}


/***/ }),

/***/ 44333:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function generateLinearVOILUT(windowWidth, windowCenter) {
    return function (modalityLutValue) {
        const value = ((modalityLutValue - (windowCenter - 0.5)) / (windowWidth - 1) + 0.5) *
            255.0;
        return Math.min(Math.max(value, 0), 255);
    };
}
function generateNonLinearVOILUT(voiLUT) {
    const bitsPerEntry = Math.max(...voiLUT.lut).toString(2).length;
    const shift = bitsPerEntry - 8;
    const minValue = voiLUT.lut[0] >> shift;
    const maxValue = voiLUT.lut[voiLUT.lut.length - 1] >> shift;
    const maxValueMapped = voiLUT.firstValueMapped + voiLUT.lut.length - 1;
    return function (modalityLutValue) {
        if (modalityLutValue < voiLUT.firstValueMapped) {
            return minValue;
        }
        else if (modalityLutValue >= maxValueMapped) {
            return maxValue;
        }
        return voiLUT.lut[modalityLutValue - voiLUT.firstValueMapped] >> shift;
    };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(windowWidth, windowCenter, voiLUT) {
    if (voiLUT) {
        return generateNonLinearVOILUT(voiLUT);
    }
    return generateLinearVOILUT(windowWidth, windowCenter);
}


/***/ }),

/***/ 27810:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(enabledElement, image) {
    const renderCanvas = enabledElement.renderingTools.renderCanvas;
    renderCanvas.width = image.width;
    renderCanvas.height = image.height;
    const canvasContext = renderCanvas.getContext('2d');
    canvasContext.fillStyle = 'white';
    canvasContext.fillRect(0, 0, renderCanvas.width, renderCanvas.height);
    const renderCanvasData = canvasContext.getImageData(0, 0, image.width, image.height);
    enabledElement.renderingTools.renderCanvasContext = canvasContext;
    enabledElement.renderingTools.renderCanvasData = renderCanvasData;
}


/***/ }),

/***/ 53586:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
    if (window.performance) {
        return performance.now();
    }
    return Date.now();
}


/***/ }),

/***/ 48080:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ renderColorImage)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/now.js
var now = __webpack_require__(53586);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getVOILut.js
var getVOILut = __webpack_require__(44333);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/generateColorLUT.js

function generateColorLUT(image, windowWidth, windowCenter, invert, voiLUT) {
    const maxPixelValue = image.maxPixelValue;
    const minPixelValue = image.minPixelValue;
    const offset = Math.min(minPixelValue, 0);
    if (image.cachedLut === undefined) {
        const length = maxPixelValue - offset + 1;
        image.cachedLut = {};
        image.cachedLut.lutArray = new Uint8ClampedArray(length);
    }
    const lut = image.cachedLut.lutArray;
    const vlutfn = (0,getVOILut/* default */.A)(Array.isArray(windowWidth) ? windowWidth[0] : windowWidth, Array.isArray(windowCenter) ? windowCenter[0] : windowCenter, voiLUT);
    if (invert) {
        for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
            lut[storedValue + -offset] = 255 - vlutfn(storedValue);
        }
    }
    else {
        for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
            lut[storedValue + -offset] = vlutfn(storedValue);
        }
    }
    return lut;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedColorPixelDataToCanvasImageData.js

/* harmony default export */ function storedColorPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    const numPixels = pixelData.length;
    start = (0,now/* default */.A)();
    if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex] =
                lut[pixelData[storedPixelDataIndex] + -minPixelValue];
            storedPixelDataIndex += 2;
            canvasImageDataIndex += 2;
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex] =
                lut[pixelData[storedPixelDataIndex]];
            storedPixelDataIndex += 2;
            canvasImageDataIndex += 2;
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedRGBAPixelDataToCanvasImageData.js

/* harmony default export */ function storedRGBAPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    const numPixels = pixelData.length;
    start = (0,now/* default */.A)();
    if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                pixelData[storedPixelDataIndex++];
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                pixelData[storedPixelDataIndex++];
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setToPixelCoordinateSystem.js
var setToPixelCoordinateSystem = __webpack_require__(79280);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/doesImageNeedToBeRendered.js
var doesImageNeedToBeRendered = __webpack_require__(23681);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/initializeRenderCanvas.js
var initializeRenderCanvas = __webpack_require__(27810);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/saveLastRendered.js
var saveLastRendered = __webpack_require__(81064);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderColorImage.js








function getLut(image, viewport) {
    if (image.cachedLut !== undefined &&
        image.cachedLut.windowCenter === viewport.voi.windowCenter &&
        image.cachedLut.windowWidth === viewport.voi.windowWidth &&
        image.cachedLut.invert === viewport.invert) {
        return image.cachedLut.lutArray;
    }
    generateColorLUT(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert);
    image.cachedLut.windowWidth = viewport.voi.windowWidth;
    image.cachedLut.windowCenter = viewport.voi.windowCenter;
    image.cachedLut.invert = viewport.invert;
    return image.cachedLut.lutArray;
}
function getRenderCanvas(enabledElement, image, invalidated) {
    const canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor;
    if (!enabledElement.renderingTools.renderCanvas || !canvasWasColor) {
        enabledElement.renderingTools.renderCanvas =
            document.createElement('canvas');
    }
    const renderCanvas = enabledElement.renderingTools.renderCanvas;
    const { windowWidth, windowCenter } = enabledElement.viewport.voi;
    if ((windowWidth === 256 || windowWidth === 255) &&
        (windowCenter === 128 || windowCenter === 127) &&
        !enabledElement.viewport.invert &&
        image.getCanvas &&
        image.getCanvas()) {
        return image.getCanvas();
    }
    if (!(0,doesImageNeedToBeRendered/* default */.A)(enabledElement, image) && !invalidated) {
        return renderCanvas;
    }
    if (renderCanvas.width !== image.width ||
        renderCanvas.height !== image.height) {
        (0,initializeRenderCanvas/* default */.A)(enabledElement, image);
    }
    let start = (0,now/* default */.A)();
    const colorLUT = getLut(image, enabledElement.viewport);
    image.stats = image.stats || {};
    image.stats.lastLutGenerateTime = (0,now/* default */.A)() - start;
    const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
    const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
    if (image.rgba) {
        storedRGBAPixelDataToCanvasImageData(image, colorLUT, renderCanvasData.data);
    }
    else {
        storedColorPixelDataToCanvasImageData(image, colorLUT, renderCanvasData.data);
    }
    start = (0,now/* default */.A)();
    renderCanvasContext.putImageData(renderCanvasData, 0, 0);
    image.stats.lastPutImageDataTime = (0,now/* default */.A)() - start;
    return renderCanvas;
}
function renderColorImage(enabledElement, invalidated) {
    if (enabledElement === undefined) {
        throw new Error('renderColorImage: enabledElement parameter must not be undefined');
    }
    const image = enabledElement.image;
    if (image === undefined) {
        throw new Error('renderColorImage: image must be loaded before it can be drawn');
    }
    const context = enabledElement.canvas.getContext('2d');
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.fillStyle = 'black';
    context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
    context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
    (0,setToPixelCoordinateSystem/* default */.A)(enabledElement, context);
    const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
    const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
    const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
    const width = enabledElement.viewport.displayedArea.brhc.x - sx;
    const height = enabledElement.viewport.displayedArea.brhc.y - sy;
    context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
    enabledElement.renderingTools = (0,saveLastRendered/* default */.A)(enabledElement);
}


/***/ }),

/***/ 92885:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  j: () => (/* binding */ renderGrayscaleImage)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/now.js
var now = __webpack_require__(53586);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageData.js

/* harmony default export */ function storedPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 3;
    let storedPixelDataIndex = 0;
    start = (0,now/* default */.A)();
    if (pixelData instanceof Int16Array) {
        if (minPixelValue < 0) {
            while (storedPixelDataIndex < numPixels) {
                canvasImageDataData[canvasImageDataIndex] =
                    lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
                canvasImageDataIndex += 4;
            }
        }
        else {
            while (storedPixelDataIndex < numPixels) {
                canvasImageDataData[canvasImageDataIndex] =
                    lut[pixelData[storedPixelDataIndex++]];
                canvasImageDataIndex += 4;
            }
        }
    }
    else if (pixelData instanceof Uint16Array) {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataIndex += 4;
        }
    }
    else if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataIndex += 4;
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataIndex += 4;
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPET.js

/* harmony default export */ function storedPixelDataToCanvasImageDataPET(image, lutFunction, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    let canvasImageDataIndex = 3;
    let storedPixelDataIndex = 0;
    start = (0,now/* default */.A)();
    while (storedPixelDataIndex < numPixels) {
        canvasImageDataData[canvasImageDataIndex] = lutFunction(pixelData[storedPixelDataIndex++]);
        canvasImageDataIndex += 4;
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataRGBA.js

/* harmony default export */ function storedPixelDataToCanvasImageDataRGBA(image, lut, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    let pixelValue;
    start = (0,now/* default */.A)();
    if (pixelData instanceof Int16Array) {
        if (minPixelValue < 0) {
            while (storedPixelDataIndex < numPixels) {
                pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = 255;
            }
        }
        else {
            while (storedPixelDataIndex < numPixels) {
                pixelValue = lut[pixelData[storedPixelDataIndex++]];
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = 255;
            }
        }
    }
    else if (pixelData instanceof Uint16Array) {
        while (storedPixelDataIndex < numPixels) {
            pixelValue = lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = 255;
        }
    }
    else if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = 255;
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            pixelValue = lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = 255;
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setToPixelCoordinateSystem.js
var setToPixelCoordinateSystem = __webpack_require__(79280);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getLut.js + 4 modules
var getLut = __webpack_require__(19704);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/doesImageNeedToBeRendered.js
var doesImageNeedToBeRendered = __webpack_require__(23681);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/initializeRenderCanvas.js
var initializeRenderCanvas = __webpack_require__(27810);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/saveLastRendered.js
var saveLastRendered = __webpack_require__(81064);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderGrayscaleImage.js









function getRenderCanvas(enabledElement, image, invalidated, useAlphaChannel = true) {
    const canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor;
    if (!enabledElement.renderingTools.renderCanvas || canvasWasColor) {
        enabledElement.renderingTools.renderCanvas =
            document.createElement('canvas');
        (0,initializeRenderCanvas/* default */.A)(enabledElement, image);
    }
    const renderCanvas = enabledElement.renderingTools.renderCanvas;
    if (!(0,doesImageNeedToBeRendered/* default */.A)(enabledElement, image) && !invalidated) {
        return renderCanvas;
    }
    if (renderCanvas.width !== image.width ||
        renderCanvas.height !== image.height) {
        (0,initializeRenderCanvas/* default */.A)(enabledElement, image);
    }
    image.stats = image.stats || {};
    const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
    const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
    let start = (0,now/* default */.A)();
    image.stats.lastLutGenerateTime = (0,now/* default */.A)() - start;
    const { viewport } = enabledElement;
    if (viewport.modality === 'PT' && image.isPreScaled) {
        const { windowWidth, windowCenter } = viewport.voi;
        const minimum = windowCenter - windowWidth / 2;
        const maximum = windowCenter + windowWidth / 2;
        const range = maximum - minimum;
        const collectedMultiplierTerms = 255.0 / range;
        let petVOILutFunction;
        if (viewport.invert) {
            petVOILutFunction = (value) => 255 - (value - minimum) * collectedMultiplierTerms;
        }
        else {
            petVOILutFunction = (value) => (value - minimum) * collectedMultiplierTerms;
        }
        storedPixelDataToCanvasImageDataPET(image, petVOILutFunction, renderCanvasData.data);
    }
    else {
        const lut = (0,getLut/* default */.A)(image, viewport, invalidated);
        if (useAlphaChannel) {
            storedPixelDataToCanvasImageData(image, lut, renderCanvasData.data);
        }
        else {
            storedPixelDataToCanvasImageDataRGBA(image, lut, renderCanvasData.data);
        }
    }
    start = (0,now/* default */.A)();
    renderCanvasContext.putImageData(renderCanvasData, 0, 0);
    image.stats.lastPutImageDataTime = (0,now/* default */.A)() - start;
    return renderCanvas;
}
function renderGrayscaleImage(enabledElement, invalidated) {
    if (enabledElement === undefined) {
        throw new Error('drawImage: enabledElement parameter must not be undefined');
    }
    const image = enabledElement.image;
    if (image === undefined) {
        throw new Error('drawImage: image must be loaded before it can be drawn');
    }
    const context = enabledElement.canvas.getContext('2d');
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.fillStyle = 'black';
    context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
    context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
    (0,setToPixelCoordinateSystem/* default */.A)(enabledElement, context);
    const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
    const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
    const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
    const width = enabledElement.viewport.displayedArea.brhc.x - sx;
    const height = enabledElement.viewport.displayedArea.brhc.y - sy;
    context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
    enabledElement.renderingTools = (0,saveLastRendered/* default */.A)(enabledElement);
}


/***/ }),

/***/ 71209:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  l: () => (/* binding */ renderPseudoColorImage)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setToPixelCoordinateSystem.js
var setToPixelCoordinateSystem = __webpack_require__(79280);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/now.js
var now = __webpack_require__(53586);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/initializeRenderCanvas.js
var initializeRenderCanvas = __webpack_require__(27810);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getLut.js + 4 modules
var getLut = __webpack_require__(19704);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/saveLastRendered.js
var saveLastRendered = __webpack_require__(81064);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/doesImageNeedToBeRendered.js
var doesImageNeedToBeRendered = __webpack_require__(23681);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/colors/lookupTable.js
const BELOW_RANGE_COLOR_INDEX = 0;
const ABOVE_RANGE_COLOR_INDEX = 1;
const NAN_COLOR_INDEX = 2;
function HSVToRGB(hue, sat, val) {
    if (hue > 1) {
        throw new Error('HSVToRGB expects hue < 1');
    }
    const rgb = [];
    if (sat === 0) {
        rgb[0] = val;
        rgb[1] = val;
        rgb[2] = val;
        return rgb;
    }
    const hueCase = Math.floor(hue * 6);
    const frac = 6 * hue - hueCase;
    const lx = val * (1 - sat);
    const ly = val * (1 - sat * frac);
    const lz = val * (1 - sat * (1 - frac));
    switch (hueCase) {
        case 0:
        case 6:
            rgb[0] = val;
            rgb[1] = lz;
            rgb[2] = lx;
            break;
        case 1:
            rgb[0] = ly;
            rgb[1] = val;
            rgb[2] = lx;
            break;
        case 2:
            rgb[0] = lx;
            rgb[1] = val;
            rgb[2] = lz;
            break;
        case 3:
            rgb[0] = lx;
            rgb[1] = ly;
            rgb[2] = val;
            break;
        case 4:
            rgb[0] = lz;
            rgb[1] = lx;
            rgb[2] = val;
            break;
        case 5:
            rgb[0] = val;
            rgb[1] = lx;
            rgb[2] = ly;
            break;
    }
    return rgb;
}
function linearIndexLookupMain(v, p) {
    let dIndex;
    if (v < p.Range[0]) {
        dIndex = p.MaxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    }
    else if (v > p.Range[1]) {
        dIndex = p.MaxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    }
    else {
        dIndex = (v + p.Shift) * p.Scale;
    }
    return Math.floor(dIndex);
}
class LookupTable {
    constructor() {
        this.NumberOfColors = 256;
        this.Ramp = 'linear';
        this.TableRange = [0, 255];
        this.HueRange = [0, 0.66667];
        this.SaturationRange = [1, 1];
        this.ValueRange = [1, 1];
        this.AlphaRange = [1, 1];
        this.NaNColor = [128, 0, 0, 255];
        this.BelowRangeColor = [0, 0, 0, 255];
        this.UseBelowRangeColor = true;
        this.AboveRangeColor = [255, 255, 255, 255];
        this.UseAboveRangeColor = true;
        this.InputRange = [0, 255];
        this.Table = [];
    }
    setNumberOfTableValues(number) {
        this.NumberOfColors = number;
    }
    setRamp(ramp) {
        this.Ramp = ramp;
    }
    setTableRange(start, end) {
        this.TableRange[0] = start;
        this.TableRange[1] = end;
    }
    setHueRange(start, end) {
        this.HueRange[0] = start;
        this.HueRange[1] = end;
    }
    setSaturationRange(start, end) {
        this.SaturationRange[0] = start;
        this.SaturationRange[1] = end;
    }
    setValueRange(start, end) {
        this.ValueRange[0] = start;
        this.ValueRange[1] = end;
    }
    setRange(start, end) {
        this.InputRange[0] = start;
        this.InputRange[1] = end;
    }
    setAlphaRange(start, end) {
        this.AlphaRange[0] = start;
        this.AlphaRange[1] = end;
    }
    getColor(scalar) {
        return this.mapValue(scalar);
    }
    build(force) {
        if (this.Table.length > 1 && !force) {
            return;
        }
        this.Table = [];
        const maxIndex = this.NumberOfColors - 1;
        let hinc, sinc, vinc, ainc;
        if (maxIndex) {
            hinc = (this.HueRange[1] - this.HueRange[0]) / maxIndex;
            sinc = (this.SaturationRange[1] - this.SaturationRange[0]) / maxIndex;
            vinc = (this.ValueRange[1] - this.ValueRange[0]) / maxIndex;
            ainc = (this.AlphaRange[1] - this.AlphaRange[0]) / maxIndex;
        }
        else {
            hinc = sinc = vinc = ainc = 0.0;
        }
        for (let i = 0; i <= maxIndex; i++) {
            const hue = this.HueRange[0] + i * hinc;
            const sat = this.SaturationRange[0] + i * sinc;
            const val = this.ValueRange[0] + i * vinc;
            const alpha = this.AlphaRange[0] + i * ainc;
            const rgb = HSVToRGB(hue, sat, val);
            const c_rgba = [0, 0, 0, 0];
            switch (this.Ramp) {
                case 'scurve':
                    c_rgba[0] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[0]) * Math.PI)));
                    c_rgba[1] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[1]) * Math.PI)));
                    c_rgba[2] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[2]) * Math.PI)));
                    c_rgba[3] = Math.floor(alpha * 255);
                    break;
                case 'linear':
                    c_rgba[0] = Math.floor(rgb[0] * 255 + 0.5);
                    c_rgba[1] = Math.floor(rgb[1] * 255 + 0.5);
                    c_rgba[2] = Math.floor(rgb[2] * 255 + 0.5);
                    c_rgba[3] = Math.floor(alpha * 255 + 0.5);
                    break;
                case 'sqrt':
                    c_rgba[0] = Math.floor(Math.sqrt(rgb[0]) * 255 + 0.5);
                    c_rgba[1] = Math.floor(Math.sqrt(rgb[1]) * 255 + 0.5);
                    c_rgba[2] = Math.floor(Math.sqrt(rgb[2]) * 255 + 0.5);
                    c_rgba[3] = Math.floor(Math.sqrt(alpha) * 255 + 0.5);
                    break;
                default:
                    throw new Error(`Invalid Ramp value (${this.Ramp})`);
            }
            this.Table.push(c_rgba);
        }
        this.buildSpecialColors();
    }
    buildSpecialColors() {
        const numberOfColors = this.NumberOfColors;
        const belowRangeColorIndex = numberOfColors + BELOW_RANGE_COLOR_INDEX;
        const aboveRangeColorIndex = numberOfColors + ABOVE_RANGE_COLOR_INDEX;
        const nanColorIndex = numberOfColors + NAN_COLOR_INDEX;
        if (this.UseBelowRangeColor || numberOfColors === 0) {
            this.Table[belowRangeColorIndex] = this.BelowRangeColor;
        }
        else {
            this.Table[belowRangeColorIndex] = this.Table[0];
        }
        if (this.UseAboveRangeColor || numberOfColors === 0) {
            this.Table[aboveRangeColorIndex] = this.AboveRangeColor;
        }
        else {
            this.Table[aboveRangeColorIndex] = this.Table[numberOfColors - 1];
        }
        this.Table[nanColorIndex] = this.NaNColor;
    }
    mapValue(v) {
        const index = this.getIndex(v);
        if (index < 0) {
            return this.NaNColor;
        }
        else if (index === 0) {
            if (this.UseBelowRangeColor && v < this.TableRange[0]) {
                return this.BelowRangeColor;
            }
        }
        else if (index === this.NumberOfColors - 1) {
            if (this.UseAboveRangeColor && v > this.TableRange[1]) {
                return this.AboveRangeColor;
            }
        }
        return this.Table[index];
    }
    getIndex(v) {
        const p = {
            Range: [],
            MaxIndex: this.NumberOfColors - 1,
            Shift: -this.TableRange[0],
            Scale: 1,
        };
        if (this.TableRange[1] <= this.TableRange[0]) {
            p.Scale = Number.MAX_VALUE;
        }
        else {
            p.Scale = p.MaxIndex / (this.TableRange[1] - this.TableRange[0]);
        }
        p.Range[0] = this.TableRange[0];
        p.Range[1] = this.TableRange[1];
        if (isNaN(v)) {
            return -1;
        }
        let index = linearIndexLookupMain(v, p);
        if (index === this.NumberOfColors + BELOW_RANGE_COLOR_INDEX) {
            index = 0;
        }
        else if (index === this.NumberOfColors + ABOVE_RANGE_COLOR_INDEX) {
            index = this.NumberOfColors - 1;
        }
        return index;
    }
    setTableValue(index, rgba, g, b, a) {
        let colorArray;
        if (typeof rgba === 'number' &&
            g !== undefined &&
            b !== undefined &&
            a !== undefined) {
            colorArray = [rgba, g, b, a];
        }
        else if (Array.isArray(rgba)) {
            colorArray = rgba;
        }
        else {
            throw new Error('Invalid arguments for setTableValue');
        }
        if (index < 0) {
            throw new Error(`Can't set the table value for negative index (${index})`);
        }
        if (index >= this.NumberOfColors) {
            throw new Error(`Index ${index} is greater than the number of colors ${this.NumberOfColors}`);
        }
        this.Table[index] = colorArray;
        if (index === 0 || index === this.NumberOfColors - 1) {
            this.buildSpecialColors();
        }
    }
}
/* harmony default export */ const lookupTable = (LookupTable);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/cpuColormaps.js
var cpuColormaps = __webpack_require__(21093);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/colors/colormap.js


const COLOR_TRANSPARENT = [0, 0, 0, 0];
function linspace(a, b, n) {
    n = n === null ? 100 : n;
    const increment = (b - a) / (n - 1);
    const vector = [];
    while (n-- > 0) {
        vector.push(a);
        a += increment;
    }
    vector[vector.length - 1] = b;
    return vector;
}
function getRank(array, elem) {
    let left = 0;
    let right = array.length - 1;
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        const midElem = array[mid];
        if (midElem === elem) {
            return mid;
        }
        else if (elem < midElem) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    return left;
}
function searchSorted(inputArray, values) {
    let i;
    const indexes = [];
    const len = values.length;
    inputArray.sort(function (a, b) {
        return a - b;
    });
    for (i = 0; i < len; i++) {
        indexes[i] = getRank(inputArray, values[i]);
    }
    return indexes;
}
function makeMappingArray(N, data, gamma) {
    let i;
    const x = [];
    const y0 = [];
    const y1 = [];
    const lut = [];
    gamma = gamma === null ? 1 : gamma;
    for (i = 0; i < data.length; i++) {
        const element = data[i];
        x.push((N - 1) * element[0]);
        y0.push(element[1]);
        y1.push(element[1]);
    }
    const xLinSpace = linspace(0, 1, N);
    for (i = 0; i < N; i++) {
        xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);
    }
    const xLinSpaceIndexes = searchSorted(x, xLinSpace);
    for (i = 1; i < N - 1; i++) {
        const index = xLinSpaceIndexes[i];
        const colorPercent = (xLinSpace[i] - x[index - 1]) / (x[index] - x[index - 1]);
        const colorDelta = y0[index] - y1[index - 1];
        lut[i] = colorPercent * colorDelta + y1[index - 1];
    }
    lut[0] = y1[0];
    lut[N - 1] = y0[data.length - 1];
    return lut;
}
function createLinearSegmentedColormap(segmentedData, N, gamma) {
    let i;
    const lut = [];
    N = N === null ? 256 : N;
    gamma = gamma === null ? 1 : gamma;
    const redLut = makeMappingArray(N, segmentedData.red, gamma);
    const greenLut = makeMappingArray(N, segmentedData.green, gamma);
    const blueLut = makeMappingArray(N, segmentedData.blue, gamma);
    for (i = 0; i < N; i++) {
        const red = Math.round(redLut[i] * 255);
        const green = Math.round(greenLut[i] * 255);
        const blue = Math.round(blueLut[i] * 255);
        const rgba = [red, green, blue, 255];
        lut.push(rgba);
    }
    return lut;
}
function getColormapsList() {
    const colormaps = [];
    const keys = Object.keys(CPU_COLORMAPS);
    keys.forEach(function (key) {
        if (Object.prototype.hasOwnProperty.call(CPU_COLORMAPS, key)) {
            const colormap = CPU_COLORMAPS[key];
            colormaps.push({
                id: key,
                name: colormap.name,
            });
        }
    });
    colormaps.sort(function (a, b) {
        const aName = a.name.toLowerCase();
        const bName = b.name.toLowerCase();
        if (aName === bName) {
            return 0;
        }
        return aName < bName ? -1 : 1;
    });
    return colormaps;
}
function getColormap(id, colormapData) {
    let colormap = cpuColormaps/* default */.A[id];
    if (!colormap) {
        colormap = cpuColormaps/* default */.A[id] = colormapData || {
            name: '',
            colors: [],
        };
    }
    if (!colormap.colors && colormap.segmentedData) {
        colormap.colors = createLinearSegmentedColormap(colormap.segmentedData, colormap.numColors, colormap.gamma);
    }
    const cpuFallbackColormap = {
        getId() {
            return id;
        },
        getColorSchemeName() {
            return colormap.name;
        },
        setColorSchemeName(name) {
            colormap.name = name;
        },
        getNumberOfColors() {
            return colormap.colors.length;
        },
        setNumberOfColors(numColors) {
            while (colormap.colors.length < numColors) {
                colormap.colors.push(COLOR_TRANSPARENT);
            }
            colormap.colors.length = numColors;
        },
        getColor(index) {
            if (this.isValidIndex(index)) {
                return colormap.colors[index];
            }
            return COLOR_TRANSPARENT;
        },
        getColorRepeating(index) {
            const numColors = colormap.colors.length;
            index = numColors ? index % numColors : 0;
            return this.getColor(index);
        },
        setColor(index, rgba) {
            if (this.isValidIndex(index)) {
                colormap.colors[index] = rgba;
            }
        },
        addColor(rgba) {
            colormap.colors.push(rgba);
        },
        insertColor(index, rgba) {
            if (this.isValidIndex(index)) {
                colormap.colors.splice(index, 1, rgba);
            }
        },
        removeColor(index) {
            if (this.isValidIndex(index)) {
                colormap.colors.splice(index, 1);
            }
        },
        clearColors() {
            colormap.colors = [];
        },
        buildLookupTable(lut) {
            if (!lut) {
                return;
            }
            const numColors = colormap.colors.length;
            lut.setNumberOfTableValues(numColors);
            for (let i = 0; i < numColors; i++) {
                lut.setTableValue(i, colormap.colors[i]);
            }
        },
        createLookupTable() {
            const lut = new lookupTable();
            this.buildLookupTable(lut);
            return lut;
        },
        isValidIndex(index) {
            return index >= 0 && index < colormap.colors.length;
        },
    };
    return cpuFallbackColormap;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/colors/index.js




;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPseudocolorLUT.js


function storedPixelDataToCanvasImageDataPseudocolorLUT(image, grayscaleLut, colorLUT, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    let grayscale;
    let rgba;
    let clut;
    start = (0,now/* default */.A)();
    if (colorLUT instanceof lookupTable) {
        clut = colorLUT.Table;
    }
    else {
        clut = colorLUT;
    }
    if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            grayscale =
                grayscaleLut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            rgba = clut[grayscale];
            canvasImageDataData[canvasImageDataIndex++] = rgba[0];
            canvasImageDataData[canvasImageDataIndex++] = rgba[1];
            canvasImageDataData[canvasImageDataIndex++] = rgba[2];
            canvasImageDataData[canvasImageDataIndex++] = rgba[3];
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            grayscale = grayscaleLut[pixelData[storedPixelDataIndex++]];
            rgba = clut[grayscale];
            canvasImageDataData[canvasImageDataIndex++] = rgba[0];
            canvasImageDataData[canvasImageDataIndex++] = rgba[1];
            canvasImageDataData[canvasImageDataIndex++] = rgba[2];
            canvasImageDataData[canvasImageDataIndex++] = rgba[3];
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}
/* harmony default export */ const rendering_storedPixelDataToCanvasImageDataPseudocolorLUT = (storedPixelDataToCanvasImageDataPseudocolorLUT);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPseudocolorLUTPET.js


function storedPixelDataToCanvasImageDataPseudocolorLUTPET(image, lutFunction, colorLUT, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    let grayscale;
    let rgba;
    let clut;
    start = (0,now/* default */.A)();
    if (colorLUT instanceof lookupTable) {
        clut = colorLUT.Table;
    }
    else {
        clut = colorLUT;
    }
    if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            grayscale = lutFunction(pixelData[storedPixelDataIndex++] + -minPixelValue);
            rgba = clut[grayscale];
            canvasImageDataData[canvasImageDataIndex++] = rgba[0];
            canvasImageDataData[canvasImageDataIndex++] = rgba[1];
            canvasImageDataData[canvasImageDataIndex++] = rgba[2];
            canvasImageDataData[canvasImageDataIndex++] = rgba[3];
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            grayscale = lutFunction(pixelData[storedPixelDataIndex++]);
            rgba = clut[grayscale];
            canvasImageDataData[canvasImageDataIndex++] = rgba[0];
            canvasImageDataData[canvasImageDataIndex++] = rgba[1];
            canvasImageDataData[canvasImageDataIndex++] = rgba[2];
            canvasImageDataData[canvasImageDataIndex++] = rgba[3];
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}
/* harmony default export */ const rendering_storedPixelDataToCanvasImageDataPseudocolorLUTPET = (storedPixelDataToCanvasImageDataPseudocolorLUTPET);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clamp.js
var clamp = __webpack_require__(84061);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderPseudoColorImage.js










function getRenderCanvas(enabledElement, image, invalidated) {
    if (!enabledElement.renderingTools.renderCanvas) {
        enabledElement.renderingTools.renderCanvas =
            document.createElement('canvas');
    }
    const renderCanvas = enabledElement.renderingTools.renderCanvas;
    let colormap = enabledElement.viewport.colormap || enabledElement.options.colormap;
    if (enabledElement.options && enabledElement.options.colormap) {
        console.warn('enabledElement.options.colormap is deprecated. Use enabledElement.viewport.colormap instead');
    }
    if (colormap && typeof colormap === 'string') {
        colormap = getColormap(colormap);
    }
    if (!colormap) {
        throw new Error('renderPseudoColorImage: colormap not found.');
    }
    const colormapId = colormap.getId();
    if (!(0,doesImageNeedToBeRendered/* default */.A)(enabledElement, image) &&
        !invalidated &&
        enabledElement.renderingTools.colormapId === colormapId) {
        return renderCanvas;
    }
    if (renderCanvas.width !== image.width ||
        renderCanvas.height !== image.height) {
        (0,initializeRenderCanvas/* default */.A)(enabledElement, image);
    }
    let start = (0,now/* default */.A)();
    if (!enabledElement.renderingTools.colorLUT ||
        invalidated ||
        enabledElement.renderingTools.colormapId !== colormapId) {
        colormap.setNumberOfColors(256);
        enabledElement.renderingTools.colorLUT = colormap.createLookupTable();
        enabledElement.renderingTools.colormapId = colormapId;
    }
    const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
    const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
    const { viewport } = enabledElement;
    const colorLUT = enabledElement.renderingTools.colorLUT;
    if (viewport.modality === 'PT') {
        const { windowWidth, windowCenter } = viewport.voi;
        const minimum = windowCenter - windowWidth / 2;
        const maximum = windowCenter + windowWidth / 2;
        const range = maximum - minimum;
        const collectedMultiplierTerms = 255.0 / range;
        let petVOILutFunction;
        if (viewport.invert) {
            petVOILutFunction = (value) => {
                return (0,clamp/* clamp */.q)(Math.floor(255 - (value - minimum) * collectedMultiplierTerms), 0, 255);
            };
        }
        else {
            petVOILutFunction = (value) => {
                return (0,clamp/* clamp */.q)(Math.floor((value - minimum) * collectedMultiplierTerms), 0, 255);
            };
        }
        rendering_storedPixelDataToCanvasImageDataPseudocolorLUTPET(image, petVOILutFunction, colorLUT, renderCanvasData.data);
    }
    else {
        const lut = (0,getLut/* default */.A)(image, enabledElement.viewport, invalidated);
        image.stats = image.stats || {};
        image.stats.lastLutGenerateTime = (0,now/* default */.A)() - start;
        rendering_storedPixelDataToCanvasImageDataPseudocolorLUT(image, lut, colorLUT, renderCanvasData.data);
    }
    start = (0,now/* default */.A)();
    renderCanvasContext.putImageData(renderCanvasData, 0, 0);
    image.stats.lastPutImageDataTime = (0,now/* default */.A)() - start;
    return renderCanvas;
}
function renderPseudoColorImage(enabledElement, invalidated) {
    if (enabledElement === undefined) {
        throw new Error('drawImage: enabledElement parameter must not be undefined');
    }
    const image = enabledElement.image;
    if (image === undefined) {
        throw new Error('drawImage: image must be loaded before it can be drawn');
    }
    const context = enabledElement.canvas.getContext('2d');
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.fillStyle = 'black';
    context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
    context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
    (0,setToPixelCoordinateSystem/* default */.A)(enabledElement, context);
    const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
    const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
    const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
    const width = enabledElement.viewport.displayedArea.brhc.x - sx;
    const height = enabledElement.viewport.displayedArea.brhc.y - sy;
    context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
    enabledElement.renderingTools = (0,saveLastRendered/* default */.A)(enabledElement);
}


/***/ }),

/***/ 81064:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(enabledElement) {
    const imageId = enabledElement.image.imageId;
    const viewport = enabledElement.viewport;
    const isColor = enabledElement.image.color;
    enabledElement.renderingTools.lastRenderedImageId = imageId;
    enabledElement.renderingTools.lastRenderedIsColor = isColor;
    enabledElement.renderingTools.lastRenderedViewport = {
        windowCenter: viewport.voi.windowCenter,
        windowWidth: viewport.voi.windowWidth,
        invert: viewport.invert,
        rotation: viewport.rotation,
        hflip: viewport.hflip,
        vflip: viewport.vflip,
        modalityLUT: viewport.modalityLUT,
        voiLUT: viewport.voiLUT,
        colormap: viewport.colormap,
    };
    return enabledElement.renderingTools;
}


/***/ }),

/***/ 79280:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _calculateTransform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7808);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(enabledElement, context, scale) {
    if (enabledElement === undefined) {
        throw new Error('setToPixelCoordinateSystem: parameter enabledElement must not be undefined');
    }
    if (context === undefined) {
        throw new Error('setToPixelCoordinateSystem: parameter context must not be undefined');
    }
    const transform = (0,_calculateTransform__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(enabledElement, scale);
    const m = transform.getMatrix();
    context.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);
}


/***/ }),

/***/ 45354:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ Transform)
/* harmony export */ });
class Transform {
    constructor() {
        this.reset();
    }
    getMatrix() {
        return this.m;
    }
    reset() {
        this.m = [1, 0, 0, 1, 0, 0];
    }
    clone() {
        const transform = new Transform();
        transform.m[0] = this.m[0];
        transform.m[1] = this.m[1];
        transform.m[2] = this.m[2];
        transform.m[3] = this.m[3];
        transform.m[4] = this.m[4];
        transform.m[5] = this.m[5];
        return transform;
    }
    multiply(matrix) {
        const m11 = this.m[0] * matrix[0] + this.m[2] * matrix[1];
        const m12 = this.m[1] * matrix[0] + this.m[3] * matrix[1];
        const m21 = this.m[0] * matrix[2] + this.m[2] * matrix[3];
        const m22 = this.m[1] * matrix[2] + this.m[3] * matrix[3];
        const dx = this.m[0] * matrix[4] + this.m[2] * matrix[5] + this.m[4];
        const dy = this.m[1] * matrix[4] + this.m[3] * matrix[5] + this.m[5];
        this.m[0] = m11;
        this.m[1] = m12;
        this.m[2] = m21;
        this.m[3] = m22;
        this.m[4] = dx;
        this.m[5] = dy;
    }
    invert() {
        const d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
        const m0 = this.m[3] * d;
        const m1 = -this.m[1] * d;
        const m2 = -this.m[2] * d;
        const m3 = this.m[0] * d;
        const m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
        const m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
        this.m[0] = m0;
        this.m[1] = m1;
        this.m[2] = m2;
        this.m[3] = m3;
        this.m[4] = m4;
        this.m[5] = m5;
    }
    rotate(rad) {
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        const m11 = this.m[0] * c + this.m[2] * s;
        const m12 = this.m[1] * c + this.m[3] * s;
        const m21 = this.m[0] * -s + this.m[2] * c;
        const m22 = this.m[1] * -s + this.m[3] * c;
        this.m[0] = m11;
        this.m[1] = m12;
        this.m[2] = m21;
        this.m[3] = m22;
    }
    translate(x, y) {
        this.m[4] += this.m[0] * x + this.m[2] * y;
        this.m[5] += this.m[1] * x + this.m[3] * y;
    }
    scale(sx, sy) {
        this.m[0] *= sx;
        this.m[1] *= sx;
        this.m[2] *= sy;
        this.m[3] *= sy;
    }
    transformPoint(point) {
        const x = point[0];
        const y = point[1];
        return [
            x * this.m[0] + y * this.m[2] + this.m[4],
            x * this.m[1] + y * this.m[3] + this.m[5],
        ];
    }
}


/***/ }),

/***/ 15528:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ validateParameterUndefinedOrNull)
/* harmony export */ });
/* unused harmony export validateParameterUndefined */
function validateParameterUndefined(checkParam, errorMsg) {
    if (checkParam === undefined) {
        throw new Error(errorMsg);
    }
}
function validateParameterUndefinedOrNull(checkParam, errorMsg) {
    if (checkParam === undefined || checkParam === null) {
        throw new Error(errorMsg);
    }
}


/***/ }),

/***/ 61640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ helpers_createVolumeActor)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var BoundingBox = __webpack_require__(21734);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var Prop3D = __webpack_require__(62502);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js + 1 modules
var ColorTransferFunction = __webpack_require__(33739);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js
var PiecewiseFunction = __webpack_require__(99341);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js
var Constants = __webpack_require__(20433);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty.js





const {
  InterpolationType,
  OpacityMode
} = Constants/* default */.Ay;
const {
  vtkErrorMacro
} = macros2.m;
const VTK_MAX_VRCOMP = 4;

// ----------------------------------------------------------------------------
// vtkVolumeProperty methods
// ----------------------------------------------------------------------------

function vtkVolumeProperty(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkVolumeProperty');
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index = 0; index < VTK_MAX_VRCOMP; index++) {
      // Color MTimes
      if (model.componentData[index].colorChannels === 1) {
        if (model.componentData[index].grayTransferFunction) {
          // time that Gray transfer function was last modified
          time = model.componentData[index].grayTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      } else if (model.componentData[index].colorChannels === 3) {
        if (model.componentData[index].rGBTransferFunction) {
          // time that RGB transfer function was last modified
          time = model.componentData[index].rGBTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }

      // Opacity MTimes
      if (model.componentData[index].scalarOpacity) {
        // time that Scalar opacity transfer function was last modified
        time = model.componentData[index].scalarOpacity.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index].gradientOpacity) {
        if (!model.componentData[index].disableGradientOpacity) {
          // time that Gradient opacity transfer function was last modified
          time = model.componentData[index].gradientOpacity.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
    }
    return mTime;
  };
  publicAPI.getColorChannels = index => {
    if (index < 0 || index > 3) {
      vtkErrorMacro('Bad index - must be between 0 and 3');
      return 0;
    }
    return model.componentData[index].colorChannels;
  };

  // Set the color of a volume to a gray transfer function
  publicAPI.setGrayTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let modified = false;
    if (model.componentData[index].grayTransferFunction !== func) {
      model.componentData[index].grayTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index].colorChannels !== 1) {
      model.componentData[index].colorChannels = 1;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };

  // Get the currently set gray transfer function. Create one if none set.
  publicAPI.getGrayTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index].grayTransferFunction === null) {
      model.componentData[index].grayTransferFunction = PiecewiseFunction/* default.newInstance */.Ay.newInstance();
      model.componentData[index].grayTransferFunction.addPoint(0, 0.0);
      model.componentData[index].grayTransferFunction.addPoint(1024, 1.0);
      if (model.componentData[index].colorChannels !== 1) {
        model.componentData[index].colorChannels = 1;
      }
      publicAPI.modified();
    }
    return model.componentData[index].grayTransferFunction;
  };

  // Set the color of a volume to an RGB transfer function
  publicAPI.setRGBTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let modified = false;
    if (model.componentData[index].rGBTransferFunction !== func) {
      model.componentData[index].rGBTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index].colorChannels !== 3) {
      model.componentData[index].colorChannels = 3;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };

  // Get the currently set RGB transfer function. Create one if none set.
  publicAPI.getRGBTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index].rGBTransferFunction === null) {
      model.componentData[index].rGBTransferFunction = ColorTransferFunction/* default.newInstance */.Ay.newInstance();
      model.componentData[index].rGBTransferFunction.addRGBPoint(0, 0.0, 0.0, 0.0);
      model.componentData[index].rGBTransferFunction.addRGBPoint(1024, 1.0, 1.0, 1.0);
      if (model.componentData[index].colorChannels !== 3) {
        model.componentData[index].colorChannels = 3;
      }
      publicAPI.modified();
    }
    return model.componentData[index].rGBTransferFunction;
  };

  // Set the scalar opacity of a volume to a transfer function
  publicAPI.setScalarOpacity = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.componentData[index].scalarOpacity !== func) {
      model.componentData[index].scalarOpacity = func;
      publicAPI.modified();
      return true;
    }
    return false;
  };

  // Get the scalar opacity transfer function. Create one if none set.
  publicAPI.getScalarOpacity = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index].scalarOpacity === null) {
      model.componentData[index].scalarOpacity = PiecewiseFunction/* default.newInstance */.Ay.newInstance();
      model.componentData[index].scalarOpacity.addPoint(0, 1.0);
      model.componentData[index].scalarOpacity.addPoint(1024, 1.0);
      publicAPI.modified();
    }
    return model.componentData[index].scalarOpacity;
  };
  publicAPI.setComponentWeight = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro('Invalid index');
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index].componentWeight !== val) {
      model.componentData[index].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro('Invalid index');
      return 0.0;
    }
    return model.componentData[index].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType.LINEAR);
  publicAPI.setInterpolationTypeToFastLinear = () => publicAPI.setInterpolationType(InterpolationType.FAST_LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macros2.m.enumToString(InterpolationType, model.interpolationType);
  const sets = ['useGradientOpacity', 'scalarOpacityUnitDistance', 'gradientOpacityMinimumValue', 'gradientOpacityMinimumOpacity', 'gradientOpacityMaximumValue', 'gradientOpacityMaximumOpacity', 'opacityMode', 'forceNearestInterpolation'];
  sets.forEach(val => {
    const cap = macros2.m.capitalize(val);
    publicAPI[`set${cap}`] = (index, value) => {
      if (model.componentData[index][`${val}`] !== value) {
        model.componentData[index][`${val}`] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  });
  const gets = ['useGradientOpacity', 'scalarOpacityUnitDistance', 'gradientOpacityMinimumValue', 'gradientOpacityMinimumOpacity', 'gradientOpacityMaximumValue', 'gradientOpacityMaximumOpacity', 'opacityMode', 'forceNearestInterpolation'];
  gets.forEach(val => {
    const cap = macros2.m.capitalize(val);
    publicAPI[`get${cap}`] = index => model.componentData[index][`${val}`];
  });
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  colorMixPreset: null,
  independentComponents: true,
  interpolationType: InterpolationType.FAST_LINEAR,
  shade: false,
  ambient: 0.1,
  diffuse: 0.7,
  specular: 0.2,
  specularPower: 10.0,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1.0
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i = 0; i < VTK_MAX_VRCOMP; ++i) {
      model.componentData.push({
        colorChannels: 1,
        grayTransferFunction: null,
        rGBTransferFunction: null,
        scalarOpacity: null,
        scalarOpacityUnitDistance: 1.0,
        opacityMode: OpacityMode.FRACTIONAL,
        gradientOpacityMinimumValue: 0,
        gradientOpacityMinimumOpacity: 0.0,
        gradientOpacityMaximumValue: 1.0,
        gradientOpacityMaximumOpacity: 1.0,
        useGradientOpacity: false,
        componentWeight: 1.0,
        forceNearestInterpolation: false
      });
    }
  }
  macros2.m.setGet(publicAPI, model, ['colorMixPreset', 'independentComponents', 'interpolationType', 'shade', 'ambient', 'diffuse', 'specular', 'specularPower', 'useLabelOutline', 'labelOutlineOpacity']);
  macros2.m.setGetArray(publicAPI, model, ['labelOutlineThickness']);

  // Object methods
  vtkVolumeProperty(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkVolumeProperty');

// ----------------------------------------------------------------------------

var vtkVolumeProperty$1 = {
  newInstance,
  extend,
  ...Constants/* default */.Ay
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Volume.js






const {
  vtkDebugMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkVolume methods
// ----------------------------------------------------------------------------

function vtkVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkVolume');
  publicAPI.getVolumes = () => publicAPI;
  publicAPI.makeProperty = vtkVolumeProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }

    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }

    // Check for the special case when the actor is empty.
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }

    // Check if we have cached values for these bounds - we cache the
    // values returned by model.mapper.getBounds() and we store the time
    // of caching. If the values returned this time are different, or
    // the modified time of this class is newer than the cached time,
    // then we need to rebuild.
    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro('Recomputing bounds...');
      model.mapperBounds = bds.map(x => x);
      const bbox = [];
      BoundingBox/* default.getCorners */.Ay.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      esm/* mat4.transpose */.pB.transpose(tmp4, model.matrix);
      bbox.forEach(pt => esm/* vec3.transformMat4 */.eR.transformMat4(pt, pt, tmp4));

      /* eslint-disable no-multi-assign */
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      /* eslint-enable no-multi-assign */
      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        // FIXME !!! getInputAlgorithm / getInput
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Volume_DEFAULT_VALUES = {
  mapper: null,
  property: null,
  bounds: [1, -1, 1, -1, 1, -1]
};

// ----------------------------------------------------------------------------

function Volume_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Volume_DEFAULT_VALUES, initialValues);

  // Inheritance
  Prop3D/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // vtkTimeStamp
  model.boundsMTime = {};
  macros2.m.obj(model.boundsMTime);

  // Build VTK API
  macros2.m.set(publicAPI, model, ['property']);
  macros2.m.setGet(publicAPI, model, ['mapper']);
  macros2.m.getArray(publicAPI, model, ['bounds'], 6);

  // Object methods
  vtkVolume(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Volume_newInstance = macros2.m.newInstance(Volume_extend, 'vtkVolume');

// ----------------------------------------------------------------------------

var vtkVolume$1 = {
  newInstance: Volume_newInstance,
  extend: Volume_extend
};



// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/volumeLoader.js
var volumeLoader = __webpack_require__(39561);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeMapper.js
var createVolumeMapper = __webpack_require__(92099);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 4 modules
var enums = __webpack_require__(31749);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/setDefaultVolumeVOI.js
var setDefaultVolumeVOI = __webpack_require__(89821);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeActor.js






async function createVolumeActor(props, element, viewportId, suppressEvents = false) {
    const { volumeId, callback, blendMode } = props;
    const imageVolume = await (0,volumeLoader.loadVolume)(volumeId);
    if (!imageVolume) {
        throw new Error(`imageVolume with id: ${imageVolume.volumeId} does not exist`);
    }
    const { imageData, vtkOpenGLTexture } = imageVolume;
    const volumeMapper = (0,createVolumeMapper/* default */.A)(imageData, vtkOpenGLTexture);
    if (blendMode) {
        volumeMapper.setBlendMode(blendMode);
    }
    const volumeActor = vtkVolume$1.newInstance();
    volumeActor.setMapper(volumeMapper);
    const { numberOfComponents } = imageData.get('numberOfComponents');
    const volumeProperty = volumeActor.getProperty();
    volumeProperty.set({ viewportId: viewportId });
    if (numberOfComponents === 3) {
        volumeActor.getProperty().setIndependentComponents(false);
    }
    await (0,setDefaultVolumeVOI/* default */.A)(volumeActor, imageVolume);
    if (callback) {
        callback({ volumeActor, volumeId });
    }
    if (!suppressEvents) {
        triggerVOIModified(element, viewportId, volumeActor, volumeId);
    }
    return volumeActor;
}
function triggerVOIModified(element, viewportId, volumeActor, volumeId) {
    const voiRange = volumeActor
        .getProperty()
        .getRGBTransferFunction(0)
        .getRange();
    const voiModifiedEventDetail = {
        viewportId,
        range: {
            lower: voiRange[0],
            upper: voiRange[1],
        },
        volumeId,
    };
    (0,triggerEvent/* default */.A)(element, enums.Events.VOI_MODIFIED, voiModifiedEventDetail);
}
/* harmony default export */ const helpers_createVolumeActor = (createVolumeActor);


/***/ }),

/***/ 92099:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createVolumeMapper)
/* harmony export */ });
/* harmony import */ var _vtkClasses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96097);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59693);


function createVolumeMapper(imageData, vtkOpenGLTexture) {
    const volumeMapper = _vtkClasses__WEBPACK_IMPORTED_MODULE_0__/* .vtkSharedVolumeMapper */ .wu.newInstance();
    if ((0,_init__WEBPACK_IMPORTED_MODULE_1__/* .getConfiguration */ .D0)().rendering.preferSizeOverAccuracy) {
        volumeMapper.setPreferSizeOverAccuracy(true);
    }
    volumeMapper.setInputData(imageData);
    const spacing = imageData.getSpacing();
    const sampleDistance = (spacing[0] + spacing[1] + spacing[2]) / 6;
    volumeMapper.setMaximumSamplesPerRay(4000);
    volumeMapper.setSampleDistance(sampleDistance);
    volumeMapper.setScalarTexture(vtkOpenGLTexture);
    return volumeMapper;
}


/***/ }),

/***/ 30135:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ getOrCreateCanvas),
/* harmony export */   p8: () => (/* binding */ EPSILON)
/* harmony export */ });
/* unused harmony export createViewportElement */
const VIEWPORT_ELEMENT = 'viewport-element';
const CANVAS_CSS_CLASS = 'cornerstone-canvas';
const EPSILON = 1e-4;
function createCanvas(element) {
    const canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.imageRendering = 'pixelated';
    canvas.classList.add(CANVAS_CSS_CLASS);
    element.appendChild(canvas);
    return canvas;
}
function createViewportElement(element) {
    const div = document.createElement('div');
    div.style.position = 'relative';
    div.style.width = '100%';
    div.style.height = '100%';
    div.style.overflow = 'hidden';
    div.classList.add(VIEWPORT_ELEMENT);
    element.appendChild(div);
    return div;
}
function getOrCreateCanvas(element) {
    const canvasSelector = `canvas.${CANVAS_CSS_CLASS}`;
    const viewportElement = `div.${VIEWPORT_ELEMENT}`;
    const internalDiv = element.querySelector(viewportElement) || createViewportElement(element);
    const existingCanvas = internalDiv.querySelector(canvasSelector);
    if (existingCanvas) {
        return existingCanvas;
    }
    const canvas = createCanvas(internalDiv);
    const rect = internalDiv.getBoundingClientRect();
    const devicePixelRatio = window.devicePixelRatio || 1;
    const width = Math.ceil(rect.width * devicePixelRatio);
    const height = Math.ceil(rect.height * devicePixelRatio);
    canvas.width = width;
    canvas.height = height;
    return canvas;
}


/***/ }),

/***/ 89821:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _loaders_imageLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80068);
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74876);
/* harmony import */ var _utilities_getMinMax__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25308);
/* harmony import */ var _utilities_windowLevel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68136);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31749);
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(49038);






const PRIORITY = 0;
const REQUEST_TYPE = _enums__WEBPACK_IMPORTED_MODULE_4__.RequestType.Prefetch;
async function setDefaultVolumeVOI(volumeActor, imageVolume) {
    let voi = getVOIFromMetadata(imageVolume);
    if (!voi && imageVolume.imageIds.length) {
        voi = await getVOIFromMiddleSliceMinMax(imageVolume);
        voi = handlePreScaledVolume(imageVolume, voi);
    }
    if ((voi.lower === 0 && voi.upper === 0) ||
        voi.lower === undefined ||
        voi.upper === undefined) {
        return;
    }
    volumeActor
        .getProperty()
        .getRGBTransferFunction(0)
        .setMappingRange(voi.lower, voi.upper);
}
function handlePreScaledVolume(imageVolume, voi) {
    const imageIds = imageVolume.imageIds;
    const imageIdIndex = Math.floor(imageIds.length / 2);
    const imageId = imageIds[imageIdIndex];
    const generalSeriesModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('generalSeriesModule', imageId) || {};
    if (_isCurrentImagePTPrescaled(generalSeriesModule.modality, imageVolume)) {
        return {
            lower: 0,
            upper: 5,
        };
    }
    return voi;
}
function getVOIFromMetadata(imageVolume) {
    const { imageIds, metadata } = imageVolume;
    let voi;
    if (imageIds.length) {
        const imageIdIndex = Math.floor(imageIds.length / 2);
        const imageId = imageIds[imageIdIndex];
        const voiLutModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('voiLutModule', imageId);
        if (voiLutModule?.windowWidth && voiLutModule.windowCenter) {
            const { windowWidth, windowCenter } = voiLutModule;
            const width = Array.isArray(windowWidth) ? windowWidth[0] : windowWidth;
            const center = Array.isArray(windowCenter)
                ? windowCenter[0]
                : windowCenter;
            if (width !== 0) {
                voi = { windowWidth: width, windowCenter: center };
            }
        }
    }
    else {
        voi = metadata.voiLut[0];
    }
    if (voi && (voi.windowWidth !== 0 || voi.windowCenter !== 0)) {
        const { lower, upper } = _utilities_windowLevel__WEBPACK_IMPORTED_MODULE_3__.toLowHighRange(Number(voi.windowWidth), Number(voi.windowCenter));
        return { lower, upper };
    }
    return undefined;
}
async function getVOIFromMiddleSliceMinMax(imageVolume) {
    const { imageIds } = imageVolume;
    const imageIdIndex = Math.floor(imageIds.length / 2);
    const imageId = imageVolume.imageIds[imageIdIndex];
    const generalSeriesModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('generalSeriesModule', imageId) || {};
    const { modality } = generalSeriesModule;
    const modalityLutModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('modalityLutModule', imageId) || {};
    const scalingParameters = {
        rescaleSlope: modalityLutModule.rescaleSlope,
        rescaleIntercept: modalityLutModule.rescaleIntercept,
        modality,
    };
    let scalingParametersToUse;
    if (modality === 'PT') {
        const suvFactor = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('scalingModule', imageId);
        if (suvFactor) {
            scalingParametersToUse = {
                ...scalingParameters,
                suvbw: suvFactor.suvbw,
            };
        }
    }
    const options = {
        priority: PRIORITY,
        requestType: REQUEST_TYPE,
        preScale: {
            scalingParameters: scalingParametersToUse,
        },
    };
    let image = _cache_cache__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Ay.getImage(imageId);
    if (!imageVolume.referencedImageIds?.length) {
        image = await (0,_loaders_imageLoader__WEBPACK_IMPORTED_MODULE_0__.loadAndCacheImage)(imageId, { ...options, ignoreCache: true });
    }
    const imageScalarData = image.getPixelData();
    const { min, max } = (0,_utilities_getMinMax__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(imageScalarData);
    return {
        lower: min,
        upper: max,
    };
}
function _isCurrentImagePTPrescaled(modality, imageVolume) {
    if (modality !== 'PT' || !imageVolume.isPreScaled) {
        return false;
    }
    if (!imageVolume.scaling?.PT.suvbw) {
        return false;
    }
    return true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setDefaultVolumeVOI);


/***/ }),

/***/ 10809:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseVolumeViewport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46347);

async function setVolumesForViewports(renderingEngine, volumeInputs, viewportIds, immediateRender = false, suppressEvents = false) {
    viewportIds.forEach((viewportId) => {
        const viewport = renderingEngine.getViewport(viewportId);
        if (!viewport) {
            throw new Error(`Viewport with Id ${viewportId} does not exist`);
        }
        if (!(viewport instanceof _BaseVolumeViewport__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)) {
            throw new Error('setVolumesForViewports only supports VolumeViewport and VolumeViewport3D');
        }
    });
    const setVolumePromises = viewportIds.map(async (viewportId) => {
        const viewport = renderingEngine.getViewport(viewportId);
        await viewport.setVolumes(volumeInputs, immediateRender, suppressEvents);
    });
    await Promise.all(setVolumePromises);
    return;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setVolumesForViewports);


/***/ }),

/***/ 90740:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   g: () => (/* binding */ resetVolumeNewImageState)
/* harmony export */ });
/* harmony import */ var _utilities_getImageSliceDataForVolumeViewport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47476);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69372);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31749);
/* harmony import */ var _getRenderingEngine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39536);




const state = {};
function resetVolumeNewImageState(viewportId) {
    if (state[viewportId] !== undefined) {
        delete state[viewportId];
    }
}
function volumeNewImageEventDispatcher(cameraEvent) {
    const { renderingEngineId, viewportId } = cameraEvent.detail;
    const renderingEngine = (0,_getRenderingEngine__WEBPACK_IMPORTED_MODULE_3__/* .getRenderingEngine */ .lD)(renderingEngineId);
    const viewport = renderingEngine.getViewport(viewportId);
    if (!('setVolumes' in viewport)) {
        throw new Error(`volumeNewImageEventDispatcher: viewport does not have setVolumes method`);
    }
    if (state[viewport.id] === undefined) {
        state[viewport.id] = 0;
    }
    const sliceData = (0,_utilities_getImageSliceDataForVolumeViewport__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(viewport);
    if (!sliceData) {
        console.warn(`volumeNewImageEventDispatcher: sliceData is undefined for viewport ${viewport.id}`);
        return;
    }
    const { numberOfSlices, imageIndex } = sliceData;
    if (state[viewport.id] === imageIndex) {
        return;
    }
    state[viewport.id] = imageIndex;
    const eventDetail = {
        imageIndex,
        viewportId,
        renderingEngineId,
        numberOfSlices,
    };
    (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport.element, _enums__WEBPACK_IMPORTED_MODULE_2__.Events.VOLUME_NEW_IMAGE, eventDetail);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (volumeNewImageEventDispatcher);


/***/ }),

/***/ 56706:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  hS: () => (/* reexport */ StackViewport/* default */.A),
  PX: () => (/* reexport */ VolumeViewport/* default */.A),
  Ay: () => (/* binding */ esm_RenderingEngine)
});

// UNUSED EXPORTS: RenderingEngine, VolumeViewport3D, createVolumeActor, createVolumeMapper, getOrCreateCanvas, getRenderingEngine

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/Events.js
var Events = __webpack_require__(32643);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/renderingEngineCache.js
var renderingEngineCache = __webpack_require__(5862);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/index.js + 27 modules
var vtkClasses = __webpack_require__(96097);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/ViewportType.js
var ViewportType = __webpack_require__(41864);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport.js + 1 modules
var VolumeViewport = __webpack_require__(94155);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/BaseVolumeViewport.js
var BaseVolumeViewport = __webpack_require__(46347);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/StackViewport.js + 12 modules
var StackViewport = __webpack_require__(58165);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport3D.js
var VolumeViewport3D = __webpack_require__(40893);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VideoViewport.js + 3 modules
var VideoViewport = __webpack_require__(32501);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/WSIViewport.js + 1 modules
var WSIViewport = __webpack_require__(81466);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/viewportTypeToViewportClass.js






const viewportTypeToViewportClass = {
    [ViewportType/* default */.A.ORTHOGRAPHIC]: VolumeViewport/* default */.A,
    [ViewportType/* default */.A.PERSPECTIVE]: VolumeViewport/* default */.A,
    [ViewportType/* default */.A.STACK]: StackViewport/* default */.A,
    [ViewportType/* default */.A.VOLUME_3D]: VolumeViewport3D/* default */.A,
    [ViewportType/* default */.A.VIDEO]: VideoViewport/* default */.A,
    [ViewportType/* default */.A.WHOLE_SLIDE]: WSIViewport/* default */.A,
};
/* harmony default export */ const helpers_viewportTypeToViewportClass = (viewportTypeToViewportClass);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/viewportTypeUsesCustomRenderingPipeline.js

function viewportTypeUsesCustomRenderingPipeline(viewportType) {
    return helpers_viewportTypeToViewportClass[viewportType].useCustomRenderingPipeline;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var getOrCreateCanvas = __webpack_require__(30135);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js + 1 modules
var init = __webpack_require__(59693);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 4 modules
var enums = __webpack_require__(31749);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/RenderingEngine.js
















const VIEWPORT_MIN_SIZE = 2;
class RenderingEngine {
    constructor(id) {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this.renderFrameOfReference = (FrameOfReferenceUID) => {
            const viewports = this._getViewportsAsArray();
            const viewportIdsWithSameFrameOfReferenceUID = viewports.map((vp) => {
                if (vp.getFrameOfReferenceUID() === FrameOfReferenceUID) {
                    return vp.id;
                }
            });
            this.renderViewports(viewportIdsWithSameFrameOfReferenceUID);
        };
        this._renderFlaggedViewports = () => {
            this._throwIfDestroyed();
            if (!this.useCPURendering) {
                this.performVtkDrawCall();
            }
            const viewports = this._getViewportsAsArray();
            const eventDetailArray = [];
            for (let i = 0; i < viewports.length; i++) {
                const viewport = viewports[i];
                if (this._needsRender.has(viewport.id)) {
                    const eventDetail = this.renderViewportUsingCustomOrVtkPipeline(viewport);
                    eventDetailArray.push(eventDetail);
                    viewport.setRendered();
                    this._needsRender.delete(viewport.id);
                    if (this._needsRender.size === 0) {
                        break;
                    }
                }
            }
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
            eventDetailArray.forEach((eventDetail) => {
                if (!eventDetail?.element) {
                    return;
                }
                (0,triggerEvent/* default */.A)(eventDetail.element, Events/* default */.A.IMAGE_RENDERED, eventDetail);
            });
        };
        this.id = id ? id : (0,uuidv4/* default */.A)();
        this.useCPURendering = (0,init/* getShouldUseCPURendering */.LH)();
        renderingEngineCache/* default */.A.set(this);
        if (!(0,init/* isCornerstoneInitialized */.Dh)()) {
            throw new Error('@cornerstonejs/core is not initialized, run init() first');
        }
        if (!this.useCPURendering) {
            this.offscreenMultiRenderWindow =
                vtkClasses/* vtkOffscreenMultiRenderWindow */.Ig.newInstance();
            this.offScreenCanvasContainer = document.createElement('div');
            this.offscreenMultiRenderWindow.setContainer(this.offScreenCanvasContainer);
        }
        this._viewports = new Map();
        this.hasBeenDestroyed = false;
    }
    enableElement(viewportInputEntry) {
        const viewportInput = this._normalizeViewportInputEntry(viewportInputEntry);
        this._throwIfDestroyed();
        const { element, viewportId } = viewportInput;
        if (!element) {
            throw new Error('No element provided');
        }
        const viewport = this.getViewport(viewportId);
        if (viewport) {
            this.disableElement(viewportId);
        }
        const { type } = viewportInput;
        const viewportUsesCustomRenderingPipeline = viewportTypeUsesCustomRenderingPipeline(type);
        if (!this.useCPURendering && !viewportUsesCustomRenderingPipeline) {
            this.enableVTKjsDrivenViewport(viewportInput);
        }
        else {
            this.addCustomViewport(viewportInput);
        }
        const canvas = (0,getOrCreateCanvas/* default */.Ay)(element);
        const { background } = viewportInput.defaultOptions;
        this.fillCanvasWithBackgroundColor(canvas, background);
    }
    disableElement(viewportId) {
        this._throwIfDestroyed();
        const viewport = this.getViewport(viewportId);
        if (!viewport) {
            console.warn(`viewport ${viewportId} does not exist`);
            return;
        }
        this._resetViewport(viewport);
        if (!viewportTypeUsesCustomRenderingPipeline(viewport.type) &&
            !this.useCPURendering) {
            this.offscreenMultiRenderWindow.removeRenderer(viewportId);
        }
        this._removeViewport(viewportId);
        viewport.isDisabled = true;
        this._needsRender.delete(viewportId);
        const viewports = this.getViewports();
        if (!viewports.length) {
            this._clearAnimationFrame();
        }
    }
    setViewports(publicViewportInputEntries) {
        const viewportInputEntries = this._normalizeViewportInputEntries(publicViewportInputEntries);
        this._throwIfDestroyed();
        this._reset();
        const vtkDrivenViewportInputEntries = [];
        const customRenderingViewportInputEntries = [];
        viewportInputEntries.forEach((vpie) => {
            if (!this.useCPURendering &&
                !viewportTypeUsesCustomRenderingPipeline(vpie.type)) {
                vtkDrivenViewportInputEntries.push(vpie);
            }
            else {
                customRenderingViewportInputEntries.push(vpie);
            }
        });
        this.setVtkjsDrivenViewports(vtkDrivenViewportInputEntries);
        this.setCustomViewports(customRenderingViewportInputEntries);
        viewportInputEntries.forEach((vp) => {
            const canvas = (0,getOrCreateCanvas/* default */.Ay)(vp.element);
            const { background } = vp.defaultOptions;
            this.fillCanvasWithBackgroundColor(canvas, background);
        });
    }
    resize(immediate = true, keepCamera = true) {
        this._throwIfDestroyed();
        const viewports = this._getViewportsAsArray();
        const vtkDrivenViewports = [];
        const customRenderingViewports = [];
        viewports.forEach((vpie) => {
            if (!viewportTypeUsesCustomRenderingPipeline(vpie.type)) {
                vtkDrivenViewports.push(vpie);
            }
            else {
                customRenderingViewports.push(vpie);
            }
        });
        if (vtkDrivenViewports.length) {
            this._resizeVTKViewports(vtkDrivenViewports, keepCamera, immediate);
        }
        if (customRenderingViewports.length) {
            this._resizeUsingCustomResizeHandler(customRenderingViewports, keepCamera, immediate);
        }
    }
    getViewport(viewportId) {
        return this._viewports.get(viewportId);
    }
    getViewports() {
        this._throwIfDestroyed();
        return this._getViewportsAsArray();
    }
    getStackViewport(viewportId) {
        this._throwIfDestroyed();
        const viewport = this.getViewport(viewportId);
        if (!viewport) {
            throw new Error(`Viewport with Id ${viewportId} does not exist`);
        }
        if (!(viewport instanceof StackViewport/* default */.A)) {
            throw new Error(`Viewport with Id ${viewportId} is not a StackViewport.`);
        }
        return viewport;
    }
    getStackViewports() {
        this._throwIfDestroyed();
        const viewports = this.getViewports();
        return viewports.filter((vp) => vp instanceof StackViewport/* default */.A);
    }
    getVolumeViewports() {
        this._throwIfDestroyed();
        const viewports = this.getViewports();
        const isVolumeViewport = (viewport) => {
            return viewport instanceof BaseVolumeViewport/* default */.A;
        };
        return viewports.filter(isVolumeViewport);
    }
    render() {
        const viewports = this.getViewports();
        const viewportIds = viewports.map((vp) => vp.id);
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    renderViewports(viewportIds) {
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    renderViewport(viewportId) {
        this._setViewportsToBeRenderedNextFrame([viewportId]);
    }
    destroy() {
        if (this.hasBeenDestroyed) {
            return;
        }
        if (!this.useCPURendering) {
            const viewports = this._getViewportsAsArray();
            viewports.forEach((vp) => {
                this.offscreenMultiRenderWindow.removeRenderer(vp.id);
            });
            this.offscreenMultiRenderWindow.delete();
            delete this.offscreenMultiRenderWindow;
        }
        this._reset();
        renderingEngineCache/* default */.A.delete(this.id);
        this.hasBeenDestroyed = true;
    }
    fillCanvasWithBackgroundColor(canvas, backgroundColor) {
        const ctx = canvas.getContext('2d');
        let fillStyle;
        if (backgroundColor) {
            const rgb = backgroundColor.map((f) => Math.floor(255 * f));
            fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        }
        else {
            fillStyle = 'black';
        }
        ctx.fillStyle = fillStyle;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    _normalizeViewportInputEntry(viewportInputEntry) {
        const { type, defaultOptions } = viewportInputEntry;
        let options = defaultOptions;
        if (!options || Object.keys(options).length === 0) {
            options = {
                background: [0, 0, 0],
                orientation: null,
                displayArea: null,
            };
            if (type === ViewportType/* default */.A.ORTHOGRAPHIC) {
                options = {
                    ...options,
                    orientation: enums.OrientationAxis.AXIAL,
                };
            }
        }
        return {
            ...viewportInputEntry,
            defaultOptions: options,
        };
    }
    _normalizeViewportInputEntries(viewportInputEntries) {
        const normalizedViewportInputs = [];
        viewportInputEntries.forEach((viewportInput) => {
            normalizedViewportInputs.push(this._normalizeViewportInputEntry(viewportInput));
        });
        return normalizedViewportInputs;
    }
    _resizeUsingCustomResizeHandler(customRenderingViewports, keepCamera = true, immediate = true) {
        customRenderingViewports.forEach((vp) => {
            if (typeof vp.resize === 'function') {
                vp.resize();
            }
        });
        customRenderingViewports.forEach((vp) => {
            const prevCamera = vp.getCamera();
            vp.resetCamera();
            if (keepCamera) {
                vp.setCamera(prevCamera);
            }
        });
        if (immediate) {
            this.render();
        }
    }
    _resizeVTKViewports(vtkDrivenViewports, keepCamera = true, immediate = true) {
        const canvasesDrivenByVtkJs = vtkDrivenViewports.map((vp) => {
            return (0,getOrCreateCanvas/* default */.Ay)(vp.element);
        });
        canvasesDrivenByVtkJs.forEach((canvas) => {
            const devicePixelRatio = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * devicePixelRatio;
            canvas.height = canvas.clientHeight * devicePixelRatio;
        });
        if (canvasesDrivenByVtkJs.length) {
            const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(canvasesDrivenByVtkJs);
            this._resize(vtkDrivenViewports, offScreenCanvasWidth, offScreenCanvasHeight);
        }
        vtkDrivenViewports.forEach((vp) => {
            const prevCamera = vp.getCamera();
            const rotation = vp.getRotation();
            const { flipHorizontal } = prevCamera;
            vp.resetCameraForResize();
            const displayArea = vp.getDisplayArea();
            if (keepCamera) {
                if (displayArea) {
                    if (flipHorizontal) {
                        vp.setCamera({ flipHorizontal });
                    }
                    if (rotation) {
                        vp.setViewPresentation({ rotation });
                    }
                }
                else {
                    vp.setCamera(prevCamera);
                }
            }
        });
        if (immediate) {
            this.render();
        }
    }
    enableVTKjsDrivenViewport(viewportInputEntry) {
        const viewports = this._getViewportsAsArray();
        const viewportsDrivenByVtkJs = viewports.filter((vp) => viewportTypeUsesCustomRenderingPipeline(vp.type) === false);
        const canvasesDrivenByVtkJs = viewportsDrivenByVtkJs.map((vp) => vp.canvas);
        const canvas = (0,getOrCreateCanvas/* default */.Ay)(viewportInputEntry.element);
        canvasesDrivenByVtkJs.push(canvas);
        const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(canvasesDrivenByVtkJs);
        const xOffset = this._resize(viewportsDrivenByVtkJs, offScreenCanvasWidth, offScreenCanvasHeight);
        const internalViewportEntry = { ...viewportInputEntry, canvas };
        this.addVtkjsDrivenViewport(internalViewportEntry, {
            offScreenCanvasWidth,
            offScreenCanvasHeight,
            xOffset,
        });
    }
    _removeViewport(viewportId) {
        const viewport = this.getViewport(viewportId);
        if (!viewport) {
            console.warn(`viewport ${viewportId} does not exist`);
            return;
        }
        this._viewports.delete(viewportId);
    }
    addVtkjsDrivenViewport(viewportInputEntry, offscreenCanvasProperties) {
        const { element, canvas, viewportId, type, defaultOptions } = viewportInputEntry;
        element.tabIndex = -1;
        const { offScreenCanvasWidth, offScreenCanvasHeight, xOffset } = offscreenCanvasProperties;
        const { sxStartDisplayCoords, syStartDisplayCoords, sxEndDisplayCoords, syEndDisplayCoords, sx, sy, sWidth, sHeight, } = this._getViewportCoordsOnOffScreenCanvas(viewportInputEntry, offScreenCanvasWidth, offScreenCanvasHeight, xOffset);
        this.offscreenMultiRenderWindow.addRenderer({
            viewport: [
                sxStartDisplayCoords,
                syStartDisplayCoords,
                sxEndDisplayCoords,
                syEndDisplayCoords,
            ],
            id: viewportId,
            background: defaultOptions.background
                ? defaultOptions.background
                : [0, 0, 0],
        });
        const viewportInput = {
            id: viewportId,
            element,
            renderingEngineId: this.id,
            type,
            canvas,
            sx,
            sy,
            sWidth,
            sHeight,
            defaultOptions: defaultOptions || {},
        };
        let viewport;
        if (type === ViewportType/* default */.A.STACK) {
            viewport = new StackViewport/* default */.A(viewportInput);
        }
        else if (type === ViewportType/* default */.A.ORTHOGRAPHIC ||
            type === ViewportType/* default */.A.PERSPECTIVE) {
            viewport = new VolumeViewport/* default */.A(viewportInput);
        }
        else if (type === ViewportType/* default */.A.VOLUME_3D) {
            viewport = new VolumeViewport3D/* default */.A(viewportInput);
        }
        else {
            throw new Error(`Viewport Type ${type} is not supported`);
        }
        this._viewports.set(viewportId, viewport);
        const eventDetail = {
            element,
            viewportId,
            renderingEngineId: this.id,
        };
        if (!viewport.suppressEvents) {
            (0,triggerEvent/* default */.A)(eventTarget/* default */.A, Events/* default */.A.ELEMENT_ENABLED, eventDetail);
        }
    }
    addCustomViewport(viewportInputEntry) {
        const { element, viewportId, type, defaultOptions } = viewportInputEntry;
        element.tabIndex = -1;
        const canvas = (0,getOrCreateCanvas/* default */.Ay)(element);
        const { clientWidth, clientHeight } = canvas;
        if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
            canvas.width = clientWidth;
            canvas.height = clientHeight;
        }
        const viewportInput = {
            id: viewportId,
            renderingEngineId: this.id,
            element,
            type,
            canvas,
            sx: 0,
            sy: 0,
            sWidth: clientWidth,
            sHeight: clientHeight,
            defaultOptions: defaultOptions || {},
        };
        const ViewportType = helpers_viewportTypeToViewportClass[type];
        const viewport = new ViewportType(viewportInput);
        this._viewports.set(viewportId, viewport);
        const eventDetail = {
            element,
            viewportId,
            renderingEngineId: this.id,
        };
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, Events/* default */.A.ELEMENT_ENABLED, eventDetail);
    }
    setCustomViewports(viewportInputEntries) {
        viewportInputEntries.forEach((vpie) => {
            this.addCustomViewport(vpie);
        });
    }
    setVtkjsDrivenViewports(viewportInputEntries) {
        if (viewportInputEntries.length) {
            const vtkDrivenCanvases = viewportInputEntries.map((vp) => (0,getOrCreateCanvas/* default */.Ay)(vp.element));
            vtkDrivenCanvases.forEach((canvas) => {
                const devicePixelRatio = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * devicePixelRatio;
                canvas.height = rect.height * devicePixelRatio;
            });
            const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(vtkDrivenCanvases);
            let xOffset = 0;
            for (let i = 0; i < viewportInputEntries.length; i++) {
                const vtkDrivenViewportInputEntry = viewportInputEntries[i];
                const canvas = vtkDrivenCanvases[i];
                const internalViewportEntry = {
                    ...vtkDrivenViewportInputEntry,
                    canvas,
                };
                this.addVtkjsDrivenViewport(internalViewportEntry, {
                    offScreenCanvasWidth,
                    offScreenCanvasHeight,
                    xOffset,
                });
                xOffset += canvas.width;
            }
        }
    }
    _resizeOffScreenCanvas(canvasesDrivenByVtkJs) {
        const { offScreenCanvasContainer, offscreenMultiRenderWindow } = this;
        const offScreenCanvasHeight = Math.max(...canvasesDrivenByVtkJs.map((canvas) => canvas.height));
        let offScreenCanvasWidth = 0;
        canvasesDrivenByVtkJs.forEach((canvas) => {
            offScreenCanvasWidth += canvas.width;
        });
        offScreenCanvasContainer.width = offScreenCanvasWidth;
        offScreenCanvasContainer.height = offScreenCanvasHeight;
        offscreenMultiRenderWindow.resize();
        return { offScreenCanvasWidth, offScreenCanvasHeight };
    }
    _resize(viewportsDrivenByVtkJs, offScreenCanvasWidth, offScreenCanvasHeight) {
        let _xOffset = 0;
        for (let i = 0; i < viewportsDrivenByVtkJs.length; i++) {
            const viewport = viewportsDrivenByVtkJs[i];
            const { sxStartDisplayCoords, syStartDisplayCoords, sxEndDisplayCoords, syEndDisplayCoords, sx, sy, sWidth, sHeight, } = this._getViewportCoordsOnOffScreenCanvas(viewport, offScreenCanvasWidth, offScreenCanvasHeight, _xOffset);
            _xOffset += viewport.canvas.width;
            viewport.sx = sx;
            viewport.sy = sy;
            viewport.sWidth = sWidth;
            viewport.sHeight = sHeight;
            const renderer = this.offscreenMultiRenderWindow.getRenderer(viewport.id);
            renderer.setViewport([
                sxStartDisplayCoords,
                syStartDisplayCoords,
                sxEndDisplayCoords,
                syEndDisplayCoords,
            ]);
        }
        return _xOffset;
    }
    _getViewportCoordsOnOffScreenCanvas(viewport, offScreenCanvasWidth, offScreenCanvasHeight, _xOffset) {
        const { canvas } = viewport;
        const { width: sWidth, height: sHeight } = canvas;
        const sx = _xOffset;
        const sy = 0;
        const sxStartDisplayCoords = sx / offScreenCanvasWidth;
        const syStartDisplayCoords = sy + (offScreenCanvasHeight - sHeight) / offScreenCanvasHeight;
        const sWidthDisplayCoords = sWidth / offScreenCanvasWidth;
        const sHeightDisplayCoords = sHeight / offScreenCanvasHeight;
        return {
            sxStartDisplayCoords,
            syStartDisplayCoords,
            sxEndDisplayCoords: sxStartDisplayCoords + sWidthDisplayCoords,
            syEndDisplayCoords: syStartDisplayCoords + sHeightDisplayCoords,
            sx,
            sy,
            sWidth,
            sHeight,
        };
    }
    _getViewportsAsArray() {
        return Array.from(this._viewports.values());
    }
    _setViewportsToBeRenderedNextFrame(viewportIds) {
        viewportIds.forEach((viewportId) => {
            this._needsRender.add(viewportId);
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && !this._animationFrameSet) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
            this._animationFrameSet = true;
        }
    }
    performVtkDrawCall() {
        const { offscreenMultiRenderWindow } = this;
        const renderWindow = offscreenMultiRenderWindow.getRenderWindow();
        const renderers = offscreenMultiRenderWindow.getRenderers();
        if (!renderers.length) {
            return;
        }
        for (let i = 0; i < renderers.length; i++) {
            const { renderer, id } = renderers[i];
            if (this._needsRender.has(id)) {
                renderer.setDraw(true);
            }
            else {
                renderer.setDraw(false);
            }
        }
        renderWindow.render();
        for (let i = 0; i < renderers.length; i++) {
            renderers[i].renderer.setDraw(false);
        }
    }
    renderViewportUsingCustomOrVtkPipeline(viewport) {
        let eventDetail;
        if (viewport.sWidth < VIEWPORT_MIN_SIZE ||
            viewport.sHeight < VIEWPORT_MIN_SIZE) {
            console.warn('Viewport is too small', viewport.sWidth, viewport.sHeight);
            return;
        }
        if (viewportTypeUsesCustomRenderingPipeline(viewport.type) === true) {
            eventDetail =
                viewport.customRenderViewportToCanvas();
        }
        else {
            if (this.useCPURendering) {
                throw new Error('GPU not available, and using a viewport with no custom render pipeline.');
            }
            const { offscreenMultiRenderWindow } = this;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const context = openGLRenderWindow.get3DContext();
            const offScreenCanvas = context.canvas;
            eventDetail = this._renderViewportFromVtkCanvasToOnscreenCanvas(viewport, offScreenCanvas);
        }
        return eventDetail;
    }
    _renderViewportFromVtkCanvasToOnscreenCanvas(viewport, offScreenCanvas) {
        const { element, canvas, sx, sy, sWidth, sHeight, id: viewportId, renderingEngineId, suppressEvents, } = viewport;
        const { width: dWidth, height: dHeight } = canvas;
        const onScreenContext = canvas.getContext('2d');
        onScreenContext.drawImage(offScreenCanvas, sx, sy, sWidth, sHeight, 0, 0, dWidth, dHeight);
        return {
            element,
            suppressEvents,
            viewportId,
            renderingEngineId,
            viewportStatus: viewport.viewportStatus,
        };
    }
    _resetViewport(viewport) {
        const renderingEngineId = this.id;
        const { element, canvas, id: viewportId } = viewport;
        const eventDetail = {
            element,
            viewportId,
            renderingEngineId,
        };
        viewport.removeWidgets();
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, Events/* default */.A.ELEMENT_DISABLED, eventDetail);
        element.removeAttribute('data-viewport-uid');
        element.removeAttribute('data-rendering-engine-uid');
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
    }
    _clearAnimationFrame() {
        window.cancelAnimationFrame(this._animationFrameHandle);
        this._needsRender.clear();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
    }
    _reset() {
        const viewports = this._getViewportsAsArray();
        viewports.forEach((viewport) => {
            this._resetViewport(viewport);
        });
        this._clearAnimationFrame();
        this._viewports = new Map();
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _downloadOffScreenCanvas() {
        const dataURL = this._debugRender();
        _TEMPDownloadURI(dataURL);
    }
    _debugRender() {
        const { offscreenMultiRenderWindow } = this;
        const renderWindow = offscreenMultiRenderWindow.getRenderWindow();
        const renderers = offscreenMultiRenderWindow.getRenderers();
        for (let i = 0; i < renderers.length; i++) {
            renderers[i].renderer.setDraw(true);
        }
        renderWindow.render();
        const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
        const context = openGLRenderWindow.get3DContext();
        const offScreenCanvas = context.canvas;
        const dataURL = offScreenCanvas.toDataURL();
        this._getViewportsAsArray().forEach((viewport) => {
            const { sx, sy, sWidth, sHeight } = viewport;
            const canvas = viewport.canvas;
            const { width: dWidth, height: dHeight } = canvas;
            const onScreenContext = canvas.getContext('2d');
            onScreenContext.drawImage(offScreenCanvas, sx, sy, sWidth, sHeight, 0, 0, dWidth, dHeight);
        });
        return dataURL;
    }
}
/* harmony default export */ const RenderingEngine_RenderingEngine = (RenderingEngine);
function _TEMPDownloadURI(uri) {
    const link = document.createElement('a');
    link.download = 'viewport.png';
    link.href = uri;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/getRenderingEngine.js
var getRenderingEngine = __webpack_require__(39536);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js + 2 modules
var helpers = __webpack_require__(98834);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/index.js







/* harmony default export */ const esm_RenderingEngine = (RenderingEngine_RenderingEngine);


/***/ }),

/***/ 5862:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const cache = {};
const renderingEngineCache = {
    get: (id) => {
        return cache[id];
    },
    set: (re) => {
        const renderingEngineId = re.id;
        cache[renderingEngineId] = re;
    },
    delete: (id) => {
        return delete cache[id];
    },
    getAll: () => {
        const renderingEngineIds = Object.keys(cache);
        const renderingEngines = renderingEngineIds.map((id) => cache[id]);
        renderingEngines.sort((a, b) => {
            if (a.id[0] === '_' && b.id[0] !== '_') {
                return 1;
            }
            else if (a.id[0] !== '_' && b.id[0] === '_') {
                return -1;
            }
            else {
                return 0;
            }
        });
        return renderingEngines;
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (renderingEngineCache);


/***/ }),

/***/ 96097:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ig: () => (/* reexport */ vtkClasses_vtkOffscreenMultiRenderWindow),
  wu: () => (/* reexport */ vtkClasses_vtkSharedVolumeMapper),
  uT: () => (/* reexport */ vtkClasses_vtkStreamingOpenGLTexture)
});

// UNUSED EXPORTS: vtkSlabCamera

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros.js
var macros = __webpack_require__(37290);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var Constants = __webpack_require__(28914);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindow.js


const DEFAULT_VIEW_API = 'WebGL';
const VIEW_CONSTRUCTORS = Object.create(null);

// ----------------------------------------------------------------------------
// static methods
// ----------------------------------------------------------------------------

function registerViewConstructor(name, constructor) {
  VIEW_CONSTRUCTORS[name] = constructor;
}
function listViewAPIs() {
  return Object.keys(VIEW_CONSTRUCTORS);
}
function newAPISpecificView(name) {
  let initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return VIEW_CONSTRUCTORS[name] && VIEW_CONSTRUCTORS[name](initialValues);
}

// ----------------------------------------------------------------------------
// vtkRenderWindow methods
// ----------------------------------------------------------------------------

function vtkRenderWindow(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderWindow');

  // Add renderer
  publicAPI.addRenderer = renderer => {
    if (publicAPI.hasRenderer(renderer)) {
      return;
    }
    renderer.setRenderWindow(publicAPI);
    model.renderers.push(renderer);

    // for (this->Renderers->InitTraversal(rsit);
    //      (aren = this->Renderers->GetNextRenderer(rsit)); )
    //   {
    //   aren->SetAllocatedRenderTime
    //     (1.0/(this->DesiredUpdateRate*this->Renderers->GetNumberOfItems()));
    //   }

    publicAPI.modified();
  };

  // Remove renderer
  publicAPI.removeRenderer = renderer => {
    model.renderers = model.renderers.filter(r => r !== renderer);
    publicAPI.modified();
  };
  publicAPI.hasRenderer = ren => model.renderers.indexOf(ren) !== -1;

  // get an API specific view of this data
  publicAPI.newAPISpecificView = function (name) {
    let initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return newAPISpecificView(name || model.defaultViewAPI, initialValues);
  };

  // Add renderer
  publicAPI.addView = view => {
    if (publicAPI.hasView(view)) {
      return;
    }
    view.setRenderable(publicAPI);
    model._views.push(view);
    publicAPI.modified();
  };

  // Remove renderer
  publicAPI.removeView = view => {
    model._views = model._views.filter(r => r !== view);
    publicAPI.modified();
  };
  publicAPI.hasView = view => model._views.indexOf(view) !== -1;

  // handle any pre render initializations
  publicAPI.preRender = () => {
    model.renderers.forEach(ren => {
      // make sure we have a camera
      if (!ren.isActiveCameraCreated()) {
        ren.resetCamera();
      }
    });
  };
  publicAPI.render = () => {
    publicAPI.preRender();
    if (model.interactor) {
      model.interactor.render();
    } else {
      model._views.forEach(view => view.traverseAllPasses());
    }
  };
  publicAPI.getStatistics = () => {
    const results = {
      propCount: 0,
      invisiblePropCount: 0,
      gpuMemoryMB: 0
    };
    model._views.forEach(v => {
      if (v.getGraphicsMemoryInfo) results.gpuMemoryMB += v.getGraphicsMemoryInfo() / 1e6;
    });
    model.renderers.forEach(ren => {
      const props = ren.getViewProps();
      const gren = model._views[0].getViewNodeFor(ren);
      props.forEach(prop => {
        if (prop.getVisibility()) {
          results.propCount += 1;
          const mpr = prop.getMapper && prop.getMapper();
          if (mpr && mpr.getPrimitiveCount) {
            const gmpr = gren.getViewNodeFor(mpr);
            if (gmpr) {
              if (gmpr.getAllocatedGPUMemoryInBytes) {
                results.gpuMemoryMB += gmpr.getAllocatedGPUMemoryInBytes() / 1e6;
              }
              const pcount = mpr.getPrimitiveCount();
              Object.keys(pcount).forEach(keyName => {
                if (!results[keyName]) {
                  results[keyName] = 0;
                }
                results[keyName] += pcount[keyName];
              });
            }
          }
        } else {
          results.invisiblePropCount += 1;
        }
      });
    });
    results.str = Object.keys(results).map(keyName => `${keyName}: ${results[keyName]}`).join('\n');
    return results;
  };
  publicAPI.captureImages = function () {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    macros2.m.setImmediate(publicAPI.render);
    return model._views.map(view => view.captureNextImage ? view.captureNextImage(format, opts) : undefined).filter(i => !!i);
  };
  publicAPI.addRenderWindow = child => {
    if (model.childRenderWindows.includes(child)) {
      return false;
    }
    model.childRenderWindows.push(child);
    publicAPI.modified();
    return true;
  };
  publicAPI.removeRenderWindow = child => {
    const childIndex = model.childRenderWindows.findIndex(x => x === child);
    if (childIndex < 0) {
      return false;
    }
    model.childRenderWindows.splice(childIndex, 1);
    publicAPI.modified();
    return true;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  defaultViewAPI: DEFAULT_VIEW_API,
  renderers: [],
  views: [],
  interactor: null,
  neverRendered: true,
  numberOfLayers: 1,
  childRenderWindows: []
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['interactor', 'numberOfLayers', '_views', 'defaultViewAPI']);
  macros2.m.get(publicAPI, model, ['neverRendered']);
  macros2.m.getArray(publicAPI, model, ['renderers', 'childRenderWindows']);
  macros2.m.moveToProtected(publicAPI, model, ['views']);
  macros2.m.event(publicAPI, model, 'completion');

  // Object methods
  vtkRenderWindow(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkRenderWindow');

// ----------------------------------------------------------------------------

var vtkRenderWindow$1 = {
  newInstance,
  extend,
  registerViewConstructor,
  listViewAPIs,
  newAPISpecificView
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
var Framebuffer = __webpack_require__(32821);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js


// ----------------------------------------------------------------------------

function vtkRenderPass(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderPass');
  publicAPI.getOperation = () => model.currentOperation;
  publicAPI.setCurrentOperation = val => {
    model.currentOperation = val;
    model.currentTraverseOperation = `traverse${macros2.m.capitalize(model.currentOperation)}`;
  };
  publicAPI.getTraverseOperation = () => model.currentTraverseOperation;

  // by default this class will traverse all of its
  // preDelegateOperations, then call its delegate render passes
  // the traverse all of its postDelegateOperations
  // any of those three arrays can be empty
  publicAPI.traverse = function (viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.deleted) {
      return;
    }

    // we just render our delegates in order
    model._currentParent = parent;
    model.preDelegateOperations.forEach(val => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
    model.delegates.forEach(val => {
      val.traverse(viewNode, publicAPI);
    });
    model.postDelegateOperations.forEach(val => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const RenderPass_DEFAULT_VALUES = {
  delegates: [],
  currentOperation: null,
  preDelegateOperations: [],
  postDelegateOperations: [],
  currentParent: null
};

// ----------------------------------------------------------------------------

function RenderPass_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, RenderPass_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['currentOperation']);
  macros2.m.setGet(publicAPI, model, ['delegates', '_currentParent', 'preDelegateOperations', 'postDelegateOperations']);
  macros2.m.moveToProtected(publicAPI, model, ['currentParent']);

  // Object methods
  vtkRenderPass(publicAPI, model);
}

// ----------------------------------------------------------------------------

const RenderPass_newInstance = macros2.m.newInstance(RenderPass_extend, 'vtkRenderPass');

// ----------------------------------------------------------------------------

var vtkRenderPass$1 = {
  newInstance: RenderPass_newInstance,
  extend: RenderPass_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var Texture = __webpack_require__(1013);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var Property = __webpack_require__(89585);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
var VertexArrayObject = __webpack_require__(13926);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js










const {
  Representation
} = Property/* default */.Ay;
const {
  vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------

function translucentShaderReplacement(shaders) {
  const substituteRes = ShaderProgram/* default.substitute */.A.substitute(shaders.Fragment, '//VTK::RenderPassFragmentShader::Impl', `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, false);
  shaders.Fragment = substituteRes.result;
}
const oitpFragTemplate = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLOrderIndependentTranslucentPass');

  // build vertices etc
  publicAPI.createVertexBuffer = () => {
    // 4 corner points in clipping space in order (x, y, z) where z is always set to -1
    // prettier-ignore
    const ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);

    // 4 corresponding corner points in texture space in order (x, y)
    const tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);

    // a square defined as cell relation ship in order (cell_size, v1, v2, v3, v4)
    const cellArray = new Uint16Array([4, 0, 1, 3, 2]);
    const points = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 3,
      values: ptsArray
    });
    points.setName('points');
    const tcoords = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 2,
      values: tcoordArray
    });
    tcoords.setName('tcoords');
    const cells = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 1,
      values: cellArray
    });
    model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {
      points,
      tcoords,
      cellOffset: 0
    });
    model.VBOBuildTime.modified();
  };
  publicAPI.createFramebuffer = viewNode => {
    const size = viewNode.getSize();
    const gl = viewNode.getContext();
    model.framebuffer = Framebuffer/* default.newInstance */.Ay.newInstance();
    model.framebuffer.setOpenGLRenderWindow(viewNode);
    model.framebuffer.create(...size);
    model.framebuffer.saveCurrentBindingsAndBuffers();
    model.framebuffer.bind();
    model.translucentRGBATexture = Texture/* default.newInstance */.Ay.newInstance();
    model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
    model.translucentRGBATexture.setFormat(gl.RGBA);
    model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
    model.translucentRGBATexture.create2DFromRaw(size[0], size[1], 4, 'Float32Array', null);
    model.translucentRTexture = Texture/* default.newInstance */.Ay.newInstance();
    model.translucentRTexture.setInternalFormat(gl.R16F);
    model.translucentRTexture.setFormat(gl.RED);
    model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRTexture.setOpenGLRenderWindow(viewNode);
    model.translucentRTexture.create2DFromRaw(size[0], size[1], 1, 'Float32Array', null);
    model.translucentZTexture = Texture/* default.newInstance */.Ay.newInstance();
    model.translucentZTexture.setOpenGLRenderWindow(viewNode);
    model.translucentZTexture.createDepthFromRaw(size[0], size[1], 'Float32Array', null);
    model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
    model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
    model.framebuffer.setDepthBuffer(model.translucentZTexture);
  };
  publicAPI.createCopyShader = viewNode => {
    model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'attribute vec2 tcoordTC;', 'varying vec2 tcoord;', 'void main() { tcoord = tcoordTC; gl_Position = vertexDC; }'].join('\n'), oitpFragTemplate, '');
  };
  publicAPI.createVBO = viewNode => {
    const gl = viewNode.getContext();
    model.tris.setOpenGLRenderWindow(viewNode);
    publicAPI.createVertexBuffer();
    const program = model.copyShader;
    // prepare the vertex and triangle data for the image plane to render to

    model.tris.getCABO().bind();
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
      vtkErrorMacro('Error setting vertexDC in copy shader VAO.');
    }
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'tcoordTC', model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
      vtkErrorMacro('Error setting vertexDC in copy shader VAO.');
    }
  };
  publicAPI.traverse = (viewNode, renNode, forwardPass) => {
    if (model.deleted) {
      return;
    }
    const size = viewNode.getSize();
    const gl = viewNode.getContext();

    // if we lack the webgl2 and half floatsupport just do
    // basic alpha blending
    model._supported = false;
    if (renNode.getSelector() || !gl || !viewNode.getWebgl2() || !gl.getExtension('EXT_color_buffer_half_float') && !gl.getExtension('EXT_color_buffer_float')) {
      publicAPI.setCurrentOperation('translucentPass');
      renNode.traverse(publicAPI);
      return;
    }
    model._supported = true;

    // prepare framebuffer // allocate framebuffer if needed and bind it
    if (model.framebuffer === null) {
      publicAPI.createFramebuffer(viewNode);
    } else {
      const fbSize = model.framebuffer.getSize();
      if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.releaseGraphicsResources();
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        publicAPI.createFramebuffer(viewNode);
      } else {
        // store framebuffer bindings to restore them later
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.bind();
      }
    }
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
    gl.clearBufferfv(gl.DEPTH, 0, [1.0]);
    gl.colorMask(false, false, false, false);

    // rerender the opaque pass to set the depth buffer
    // TODO remove when webgl1 is deprecated and instead
    // have the forward pass use a texture backed zbuffer
    if (forwardPass.getOpaqueActorCount() > 0) {
      // Don't use zBufferPass as it will also render the depth of translucent actors
      forwardPass.setCurrentOperation('opaqueZBufferPass');
      renNode.traverse(forwardPass);
    }
    gl.colorMask(true, true, true, true);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);

    // make sure to clear the entire framebuffer as we will
    // be blitting the entire thing all of it needs good initial values
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
    gl.clearBufferfv(gl.COLOR, 1, [0.0, 0.0, 0.0, 0.0]);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);

    // basic gist is we accumulate color into RGB We compute final opacity
    // into A We store accumulated opacity into R of the R texture.
    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);

    // now do the translucent rendering
    publicAPI.setCurrentOperation('translucentPass');
    renNode.traverse(publicAPI);
    gl.drawBuffers([gl.NONE]);
    model.framebuffer.restorePreviousBindingsAndBuffers();
    // gl.drawBuffers([gl.BACK]);

    // make sure the copy shader is ready
    if (model.copyShader === null) {
      publicAPI.createCopyShader(viewNode);
    } else {
      viewNode.getShaderCache().readyShaderProgram(model.copyShader);
    }

    // make sure we have a VAO
    if (!model.copyVAO) {
      model.copyVAO = VertexArrayObject/* default.newInstance */.Ay.newInstance();
      model.copyVAO.setOpenGLRenderWindow(viewNode);
    }
    model.copyVAO.bind();

    // make sure the VBO is up to date
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
      publicAPI.createVBO(viewNode);
    }
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    gl.depthFunc(gl.ALWAYS);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);

    // activate texture
    model.translucentRGBATexture.activate();
    model.copyShader.setUniformi('translucentRGBATexture', model.translucentRGBATexture.getTextureUnit());
    model.translucentRTexture.activate();
    model.copyShader.setUniformi('translucentRTexture', model.translucentRTexture.getTextureUnit());

    // render quad
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    model.translucentRGBATexture.deactivate();
    model.translucentRTexture.deactivate();

    // restore scissor + viewport from renderer
    const ts = renNode.getTiledSizeAndOrigin();
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
  };
  publicAPI.getShaderReplacement = () => {
    if (model._supported) {
      return translucentShaderReplacement;
    }
    return null;
  };
  publicAPI.releaseGraphicsResources = viewNode => {
    if (model.framebuffer) {
      model.framebuffer.releaseGraphicsResources(viewNode);
      model.framebuffer = null;
    }
    if (model.translucentRGBATexture) {
      model.translucentRGBATexture.releaseGraphicsResources(viewNode);
      model.translucentRGBATexture = null;
    }
    if (model.translucentRTexture) {
      model.translucentRTexture.releaseGraphicsResources(viewNode);
      model.translucentRTexture = null;
    }
    if (model.translucentZTexture) {
      model.translucentZTexture.releaseGraphicsResources(viewNode);
      model.translucentZTexture = null;
    }
    if (model.copyVAO) {
      model.copyVAO.releaseGraphicsResources(viewNode);
      model.copyVAO = null;
    }
    if (model.copyShader) {
      model.copyShader.releaseGraphicsResources(viewNode);
      model.copyShader = null;
    }
    if (model.tris) {
      model.tris.releaseGraphicsResources(viewNode);
      model.tris = null;
    }
    publicAPI.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const OrderIndependentTranslucentPass_DEFAULT_VALUES = {
  framebuffer: null,
  copyShader: null,
  tris: null
};

// ----------------------------------------------------------------------------

function OrderIndependentTranslucentPass_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, OrderIndependentTranslucentPass_DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  macros2.m.obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = Helper/* default.newInstance */.Ay.newInstance();
  macros2.m.get(publicAPI, model, ['framebuffer']);

  // Object methods
  vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
}

// ----------------------------------------------------------------------------

const OrderIndependentTranslucentPass_newInstance = macros2.m.newInstance(OrderIndependentTranslucentPass_extend, 'vtkOpenGLOrderIndependentTranslucentPass');

// ----------------------------------------------------------------------------

var vtkOpenGLOrderIndependentTranslucentPass$1 = {
  newInstance: OrderIndependentTranslucentPass_newInstance,
  extend: OrderIndependentTranslucentPass_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js





// ----------------------------------------------------------------------------

function vtkForwardPass(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkForwardPass');

  // this pass implements a forward rendering pipeline
  // if both volumes and opaque geometry are present
  // it will mix the two together by capturing a zbuffer
  // first
  publicAPI.traverse = function (viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.deleted) {
      return;
    }

    // we just render our delegates in order
    model._currentParent = parent;

    // build
    publicAPI.setCurrentOperation('buildPass');
    viewNode.traverse(publicAPI);
    const numlayers = viewNode.getRenderable().getNumberOfLayers();

    // iterate over renderers
    const renderers = viewNode.getRenderable().getRenderersByReference();
    for (let i = 0; i < numlayers; i++) {
      for (let index = 0; index < renderers.length; index++) {
        const ren = renderers[index];
        const renNode = viewNode.getViewNodeFor(ren);
        if (ren.getDraw() && ren.getLayer() === i) {
          // check for both opaque and volume actors
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumeCount = 0;
          model.overlayActorCount = 0;
          publicAPI.setCurrentOperation('queryPass');
          renNode.traverse(publicAPI);

          // do we need to capture a zbuffer?
          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {
            const size = viewNode.getFramebufferSize();
            // make sure the framebuffer is setup
            if (model.framebuffer === null) {
              model.framebuffer = Framebuffer/* default.newInstance */.Ay.newInstance();
            }
            model.framebuffer.setOpenGLRenderWindow(viewNode);
            model.framebuffer.saveCurrentBindingsAndBuffers();
            const fbSize = model.framebuffer.getSize();
            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
              model.framebuffer.create(size[0], size[1]);
              model.framebuffer.populateFramebuffer();
            }
            model.framebuffer.bind();
            // opaqueZBufferPass only renders opaque actors
            // zBufferPass renders both translucent and opaque actors
            // we want to be able to pick translucent actors
            publicAPI.setCurrentOperation('zBufferPass');
            renNode.traverse(publicAPI);
            model.framebuffer.restorePreviousBindingsAndBuffers();

            // reset now that we have done it
            model.depthRequested = false;
          }
          publicAPI.setCurrentOperation('cameraPass');
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0) {
            publicAPI.setCurrentOperation('opaquePass');
            renNode.traverse(publicAPI);
          }
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
            }
            model.translucentPass.traverse(viewNode, renNode, publicAPI);
          }
          if (model.volumeCount > 0) {
            publicAPI.setCurrentOperation('volumePass');
            renNode.traverse(publicAPI);
          }
          if (model.overlayActorCount > 0) {
            publicAPI.setCurrentOperation('overlayPass');
            renNode.traverse(publicAPI);
          }
        }
      }
    }
  };
  publicAPI.getZBufferTexture = () => {
    if (model.framebuffer) {
      return model.framebuffer.getColorTexture();
    }
    return null;
  };
  publicAPI.requestDepth = () => {
    model.depthRequested = true;
  };
  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
  publicAPI.incrementVolumeCount = () => model.volumeCount++;
  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ForwardPass_DEFAULT_VALUES = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumeCount: 0,
  overlayActorCount: 0,
  framebuffer: null,
  depthRequested: false
};

// ----------------------------------------------------------------------------

function ForwardPass_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ForwardPass_DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macros2.m.get(publicAPI, model, ['framebuffer', 'opaqueActorCount', 'translucentActorCount', 'volumeCount']);

  // Object methods
  vtkForwardPass(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ForwardPass_newInstance = macros2.m.newInstance(ForwardPass_extend, 'vtkForwardPass');

// ----------------------------------------------------------------------------

var vtkForwardPass$1 = {
  newInstance: ForwardPass_newInstance,
  extend: ForwardPass_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js
var HardwareSelector_Constants = __webpack_require__(57703);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js + 3 modules
var DataSet = __webpack_require__(69147);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js



const {
  FieldAssociations
} = DataSet/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkHardwareSelector methods
// ----------------------------------------------------------------------------

function vtkHardwareSelector(publicAPI, model) {
  model.classHierarchy.push('vtkHardwareSelector');

  // get the source data that is used for generating a selection. This
  // must be called at least once before calling generateSelection. In
  // raster based backends this method will capture the buffers. You can
  // call this once and then make multiple calls to generateSelection.
  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {};
  publicAPI.selectAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    const srcData = await publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
    if (srcData) {
      return srcData.generateSelection(fx1, fy1, fx2, fy2);
    }
    return [];
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const HardwareSelector_DEFAULT_VALUES = {
  fieldAssociation: FieldAssociations.FIELD_ASSOCIATION_CELLS,
  captureZValues: false
};

// ----------------------------------------------------------------------------

function HardwareSelector_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, HardwareSelector_DEFAULT_VALUES, initialValues);

  // Inheritance
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['fieldAssociation', 'captureZValues']);

  // Object methods
  vtkHardwareSelector(publicAPI, model);
}

// ----------------------------------------------------------------------------

const HardwareSelector_newInstance = macros2.m.newInstance(HardwareSelector_extend, 'vtkHardwareSelector');

// ----------------------------------------------------------------------------

var vtkHardwareSelector$1 = {
  newInstance: HardwareSelector_newInstance,
  extend: HardwareSelector_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js
/**
 * The (primary) property that describes the content of a selection
 * node's data. Other auxiliary description properties follow.
 * GLOBALIDS means that the selection list contains values from the
 * vtkDataSetAttribute array of the same name.
 * PEDIGREEIDS means that the selection list contains values from the
 * vtkDataSetAttribute array of the same name.
 * VALUES means the the selection list contains values from an
 * arbitrary attribute array (ignores any globalids attribute)
 * INDICES means that the selection list contains indexes into the
 * cell or point arrays.
 * FRUSTUM means the set of points and cells inside a frustum
 * LOCATIONS means the set of points and cells near a set of positions
 * THRESHOLDS means the points and cells with values within a set of ranges
 * getContentType() returns -1 if the content type is not set.
 */

// Specify how data arrays can be used by data objects
const SelectionContent = {
  GLOBALIDS: 0,
  PEDIGREEIDS: 1,
  VALUES: 2,
  INDICES: 3,
  FRUSTUM: 4,
  LOCATIONS: 5,
  THRESHOLDS: 6,
  BLOCKS: 7,
  QUERY: 8
};
const SelectionField = {
  CELL: 0,
  POINT: 1,
  FIELD: 2,
  VERTEX: 3,
  EDGE: 4,
  ROW: 5
};
var Constants_Constants = {
  SelectionContent,
  SelectionField
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js



// ----------------------------------------------------------------------------
// vtkSelectionNode methods
// ----------------------------------------------------------------------------

function vtkSelectionNode(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkSelectionNode');
  publicAPI.getBounds = () => model.points.getBounds();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const SelectionNode_DEFAULT_VALUES = {
  contentType: -1,
  fieldType: -1,
  properties: null,
  selectionList: []
};

// ----------------------------------------------------------------------------

function SelectionNode_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, SelectionNode_DEFAULT_VALUES, initialValues);

  // Inheritance
  macros2.m.obj(publicAPI, model);
  model.properties = {};
  macros2.m.setGet(publicAPI, model, ['contentType', 'fieldType', 'properties', 'selectionList']);

  // Object specific methods
  vtkSelectionNode(publicAPI, model);
}

// ----------------------------------------------------------------------------

const SelectionNode_newInstance = macros2.m.newInstance(SelectionNode_extend, 'vtkSelectionNode');

// ----------------------------------------------------------------------------

var vtkSelectionNode$1 = {
  newInstance: SelectionNode_newInstance,
  extend: SelectionNode_extend,
  ...Constants_Constants
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js







const {
  PassTypes
} = HardwareSelector_Constants/* default */.A;
const {
  SelectionContent: HardwareSelector_SelectionContent,
  SelectionField: HardwareSelector_SelectionField
} = vtkSelectionNode$1;
const {
  FieldAssociations: HardwareSelector_FieldAssociations
} = DataSet/* default */.Ay;
const {
  vtkErrorMacro: HardwareSelector_vtkErrorMacro
} = macros2.m;
const idOffset = 1;
function getInfoHash(info) {
  return `${info.propID} ${info.compositeID}`;
}
function getAlpha(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  return pb[offset + 3];
}
function convert(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  const r = pb[offset];
  const g = pb[offset + 1];
  const b = pb[offset + 2];
  return (b * 256 + g) * 256 + r;
}
function getID(low24, high8) {
  /* eslint-disable no-bitwise */
  let val = high8;
  val <<= 24;
  val |= low24;
  return val;
  /* eslint-enable no-bitwise */
}

function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  // Base case
  const maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
      return null;
    }

    // offset inDisplayPosition based on the lower-left-corner of the Area.
    const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
    const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ACTOR_PASS], buffdata.area);
    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
      // the pixel did not hit any actor.
      return null;
    }
    const info = {};
    info.valid = true;
    info.propID = actorid - idOffset;
    info.prop = buffdata.props[info.propID];
    let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], buffdata.area);
    if (compositeID < 0 || compositeID > 0xffffff) {
      compositeID = 0;
    }
    info.compositeID = compositeID - idOffset;
    if (buffdata.captureZValues) {
      const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
      info.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535.0;
      info.displayPosition = inDisplayPosition;
    }
    if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {
      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area) === 0.0) {
        return info;
      }
    }
    const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area);
    const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_HIGH24], buffdata.area);
    info.attributeID = getID(low24, high24);
    return info;
  }

  // Iterate over successively growing boxes.
  // They recursively call the base case to handle single pixels.
  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  const curPos = [0, 0];
  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info && info.valid) {
    return info;
  }
  for (let dist = 1; dist < maxDist; ++dist) {
    // Vertical sides of box.
    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
      curPos[1] = y;
      if (dispPos[0] >= dist) {
        curPos[0] = dispPos[0] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
    // Horizontal sides of box.
    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
      curPos[0] = x;
      if (dispPos[1] >= dist) {
        curPos[1] = dispPos[1] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
  }

  // nothing hit.
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}

//-----------------------------------------------------------------------------
function convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
  const sel = [];
  let count = 0;
  dataMap.forEach((value, key) => {
    const child = vtkSelectionNode$1.newInstance();
    child.setContentType(HardwareSelector_SelectionContent.INDICES);
    switch (fieldassociation) {
      case HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(HardwareSelector_SelectionField.CELL);
        break;
      case HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(HardwareSelector_SelectionField.POINT);
        break;
      default:
        HardwareSelector_vtkErrorMacro('Unknown field association');
    }
    child.getProperties().propID = value.info.propID;
    child.getProperties().prop = value.info.prop;
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().attributeID = value.info.attributeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}

//----------------------------------------------------------------------------
function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
  const x1 = Math.floor(fx1);
  const y1 = Math.floor(fy1);
  const x2 = Math.floor(fx2);
  const y2 = Math.floor(fy2);
  const dataMap = new Map();
  const outSelectedPosition = [0, 0];
  for (let yy = y1; yy <= y2; yy++) {
    for (let xx = x1; xx <= x2; xx++) {
      const pos = [xx, yy];
      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
      if (info && info.valid) {
        const hash = getInfoHash(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          const dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
}

// ----------------------------------------------------------------------------
// vtkOpenGLHardwareSelector methods
// ----------------------------------------------------------------------------

function vtkOpenGLHardwareSelector(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLHardwareSelector');

  //----------------------------------------------------------------------------
  publicAPI.releasePixBuffers = () => {
    model.rawPixBuffer = [];
    model.pixBuffer = [];
    model.zBuffer = null;
  };

  //----------------------------------------------------------------------------
  publicAPI.beginSelection = () => {
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
    model.maxAttributeId = 0;
    const size = model._openGLRenderWindow.getSize();
    if (!model.framebuffer) {
      model.framebuffer = Framebuffer/* default.newInstance */.Ay.newInstance();
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.create(size[0], size[1]);
      // this calls model.framebuffer.bind()
      model.framebuffer.populateFramebuffer();
    } else {
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      const fbSize = model.framebuffer.getSize();
      if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.create(size[0], size[1]);
        // this calls model.framebuffer.bind()
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.bind();
      }
    }
    model._openGLRenderer.clear();
    model._openGLRenderer.setSelector(publicAPI);
    model.hitProps = {};
    model.propPixels = {};
    model.props = [];
    publicAPI.releasePixBuffers();
    if (model.fieldAssociation === HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      const gl = model._openGLRenderWindow.getContext();
      const originalBlending = gl.isEnabled(gl.BLEND);
      gl.disable(gl.BLEND);
      model._openGLRenderWindow.traverseAllPasses();
      if (originalBlending) {
        gl.enable(gl.BLEND);
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.endSelection = () => {
    model.hitProps = {};
    model._openGLRenderer.setSelector(null);
    model.framebuffer.restorePreviousBindingsAndBuffers();
  };
  publicAPI.preCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    // Disable blending
    model.originalBlending = gl.isEnabled(gl.BLEND);
    gl.disable(gl.BLEND);
  };
  publicAPI.postCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    // Restore blending if it was enabled prior to the capture
    if (model.originalBlending) {
      gl.enable(gl.BLEND);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.select = () => {
    let sel = null;
    if (publicAPI.captureBuffers()) {
      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
      publicAPI.releasePixBuffers();
    }
    return sel;
  };
  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    // assign the renderer
    model._renderer = renderer;

    // set area to all if no arguments provided
    if (fx1 === undefined) {
      const size = model._openGLRenderWindow.getSize();
      publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);
    } else {
      publicAPI.setArea(fx1, fy1, fx2, fy2);
    }
    // just do capture buffers and package up the result
    if (!publicAPI.captureBuffers()) {
      return false;
    }
    const result = {
      area: [...model.area],
      pixBuffer: [...model.pixBuffer],
      captureZValues: model.captureZValues,
      zBuffer: model.zBuffer,
      props: [...model.props],
      fieldAssociation: model.fieldAssociation,
      renderer,
      openGLRenderWindow: model._openGLRenderWindow
    };
    result.generateSelection = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return generateSelectionWithData(result, ...args);
    };
    return result;
  };

  //----------------------------------------------------------------------------
  publicAPI.captureBuffers = () => {
    if (!model._renderer || !model._openGLRenderWindow) {
      HardwareSelector_vtkErrorMacro('Renderer and view must be set before calling Select.');
      return false;
    }
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);

    // todo revisit making selection part of core
    // then we can do this in core
    model._openGLRenderWindow.getRenderable().preRender();

    // int rgba[4];
    // rwin.getColorBufferSizes(rgba);
    // if (rgba[0] < 8 || rgba[1] < 8 || rgba[2] < 8) {
    //   vtkErrorMacro("Color buffer depth must be at least 8 bit. "
    //     "Currently: " << rgba[0] << ", " << rgba[1] << ", " <<rgba[2]);
    //   return false;
    // }
    publicAPI.invokeEvent({
      type: 'StartEvent'
    });

    // Initialize renderer for selection.
    // change the renderer's background to black, which will indicate a miss
    model.originalBackground = model._renderer.getBackgroundByReference();
    model._renderer.setBackground(0.0, 0.0, 0.0, 0.0);
    const rpasses = model._openGLRenderWindow.getRenderPasses();
    publicAPI.beginSelection();
    const pixelBufferSavedPasses = [];
    for (model.currentPass = PassTypes.MIN_KNOWN_PASS; model.currentPass <= PassTypes.MAX_KNOWN_PASS; model.currentPass++) {
      if (publicAPI.passRequired(model.currentPass)) {
        publicAPI.preCapturePass(model.currentPass);
        if (model.captureZValues && model.currentPass === PassTypes.ACTOR_PASS && typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {
          rpasses[0].requestDepth();
          model._openGLRenderWindow.traverseAllPasses();
        } else {
          model._openGLRenderWindow.traverseAllPasses();
        }
        publicAPI.postCapturePass(model.currentPass);
        publicAPI.savePixelBuffer(model.currentPass);
        pixelBufferSavedPasses.push(model.currentPass);
      }
    }

    // Process pixel buffers
    pixelBufferSavedPasses.forEach(pass => {
      model.currentPass = pass;
      publicAPI.processPixelBuffers();
    });
    model.currentPass = PassTypes.MAX_KNOWN_PASS;
    publicAPI.endSelection();

    // restore original background
    model._renderer.setBackground(model.originalBackground);
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });

    // restore image, not needed?
    // model._openGLRenderWindow.traverseAllPasses();
    return true;
  };
  publicAPI.processPixelBuffers = () => {
    model.props.forEach((prop, index) => {
      if (publicAPI.isPropHit(index)) {
        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);
      }
    });
  };

  //----------------------------------------------------------------------------
  publicAPI.passRequired = pass => {
    if (pass === PassTypes.ID_HIGH24) {
      if (model.fieldAssociation === HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_POINTS) {
        return model.maximumPointId > 0x00ffffff;
      }
      if (model.fieldAssociation === HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_CELLS) {
        return model.maximumCellId > 0x00ffffff;
      }
    }
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.savePixelBuffer = passNo => {
    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
    if (!model.rawPixBuffer[passNo]) {
      const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;
      model.rawPixBuffer[passNo] = new Uint8Array(size);
      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);
    }
    if (passNo === PassTypes.ACTOR_PASS) {
      if (model.captureZValues) {
        const rpasses = model._openGLRenderWindow.getRenderPasses();
        if (typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {
          const fb = rpasses[0].getFramebuffer();
          fb.saveCurrentBindingsAndBuffers();
          fb.bind();
          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
          fb.restorePreviousBindingsAndBuffers();
        }
      }
      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.buildPropHitList = pixelbuffer => {
    let offset = 0;
    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
        let val = convert(xx, yy, pixelbuffer, model.area);
        if (val > 0) {
          val--;
          if (!(val in model.hitProps)) {
            model.hitProps[val] = true;
            model.propPixels[val] = [];
          }
          model.propPixels[val].push(offset * 4);
        }
        ++offset;
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.renderProp = prop => {
    if (model.currentPass === PassTypes.ACTOR_PASS) {
      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
      model.props.push(prop);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.renderCompositeIndex = index => {
    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {
      publicAPI.setPropColorValueFromInt(index + idOffset);
    }
  };

  //----------------------------------------------------------------------------
  // TODO: make inline
  publicAPI.renderAttributeId = attribid => {
    if (attribid < 0) {
      // negative attribid is valid. It happens when rendering higher order
      // elements where new points are added for rendering smooth surfaces.
      return;
    }
    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;

    // if (model.currentPass < PassTypes.ID_LOW24) {
    //   return; // useless...
    // }
  };

  //----------------------------------------------------------------------------
  publicAPI.passTypeToString = type => macros2.m.enumToString(PassTypes, type);

  //----------------------------------------------------------------------------
  publicAPI.isPropHit = id => Boolean(model.hitProps[id]);
  publicAPI.setPropColorValueFromInt = val => {
    model.propColorValue[0] = val % 256 / 255.0;
    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255.0;
    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255.0;
  };

  // info has
  //   valid
  //   propId
  //   prop
  //   compositeID
  //   attributeID

  //----------------------------------------------------------------------------
  publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {
    // Base case
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
        return null;
      }

      // offset inDisplayPosition based on the lower-left-corner of the Area.
      const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
      const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ACTOR_PASS], model.area);
      if (actorid <= 0 || actorid - idOffset >= model.props.length) {
        // the pixel did not hit any actor.
        return null;
      }
      const info = {};
      info.valid = true;
      info.propID = actorid - idOffset;
      info.prop = model.props[info.propID];
      let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], model.area);
      if (compositeID < 0 || compositeID > 0xffffff) {
        compositeID = 0;
      }
      info.compositeID = compositeID - idOffset;
      if (model.captureZValues) {
        const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
        info.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535.0;
        info.displayPosition = inDisplayPosition;
      }

      // Skip attribute ids if alpha is zero (missed)
      if (model.pixBuffer[PassTypes.ID_LOW24]) {
        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area) === 0.0) {
          return info;
        }
      }
      const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area);
      const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_HIGH24], model.area);
      info.attributeID = getID(low24, high24);
      return info;
    }

    // Iterate over successively growing boxes.
    // They recursively call the base case to handle single pixels.
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (let dist = 1; dist < maxDist; ++dist) {
      // Vertical sides of box.
      for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist) {
          curPos[0] = dispPos[0] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      // Horizontal sides of box.
      for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist) {
          curPos[1] = dispPos[1] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }

    // nothing hit.
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  };

  //----------------------------------------------------------------------------
  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y2 = Math.floor(fy2);
    const dataMap = new Map();
    const outSelectedPosition = [0, 0];
    for (let yy = y1; yy <= y2; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
        if (info && info.valid) {
          const hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (model.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);
  };
  publicAPI.getRawPixelBuffer = passNo => model.rawPixBuffer[passNo];
  publicAPI.getPixelBuffer = passNo => model.pixBuffer[passNo];

  //----------------------------------------------------------------------------

  publicAPI.attach = (openGLRenderWindow, renderer) => {
    model._openGLRenderWindow = openGLRenderWindow;
    model._renderer = renderer;
  };

  // override
  const superSetArea = publicAPI.setArea;
  publicAPI.setArea = function () {
    if (superSetArea(...arguments)) {
      model.area[0] = Math.floor(model.area[0]);
      model.area[1] = Math.floor(model.area[1]);
      model.area[2] = Math.floor(model.area[2]);
      model.area[3] = Math.floor(model.area[3]);
      return true;
    }
    return false;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const OpenGL_HardwareSelector_DEFAULT_VALUES = {
  area: undefined,
  // _renderer: null,
  // _openGLRenderWindow: null,
  // _openGLRenderer: null,
  currentPass: -1,
  propColorValue: null,
  props: null,
  maximumPointId: 0,
  maximumCellId: 0,
  idOffset: 1
};

// ----------------------------------------------------------------------------

function OpenGL_HardwareSelector_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, OpenGL_HardwareSelector_DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model.propColorValue = [0, 0, 0];
  model.props = [];
  if (!model.area) {
    model.area = [0, 0, 0, 0];
  }
  macros2.m.setGetArray(publicAPI, model, ['area'], 4);
  macros2.m.setGet(publicAPI, model, ['_renderer', 'currentPass', '_openGLRenderWindow', 'maximumPointId', 'maximumCellId']);
  macros2.m.setGetArray(publicAPI, model, ['propColorValue'], 3);
  macros2.m.moveToProtected(publicAPI, model, ['renderer', 'openGLRenderWindow']);
  macros2.m.event(publicAPI, model, 'event');

  // Object methods
  vtkOpenGLHardwareSelector(publicAPI, model);
}

// ----------------------------------------------------------------------------

const OpenGL_HardwareSelector_newInstance = macros2.m.newInstance(OpenGL_HardwareSelector_extend, 'vtkOpenGLHardwareSelector');

// ----------------------------------------------------------------------------

var HardwareSelector_vtkHardwareSelector = {
  newInstance: OpenGL_HardwareSelector_newInstance,
  extend: OpenGL_HardwareSelector_extend,
  ...HardwareSelector_Constants/* default */.A
};



// EXTERNAL MODULE: ../../../node_modules/spark-md5/spark-md5.js
var spark_md5 = __webpack_require__(10989);
var spark_md5_default = /*#__PURE__*/__webpack_require__.n(spark_md5);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js




// ----------------------------------------------------------------------------

const SET_GET_FIELDS = ['lastShaderProgramBound', 'context', '_openGLRenderWindow'];

// ----------------------------------------------------------------------------
// vtkShaderCache methods
// ----------------------------------------------------------------------------

function vtkShaderCache(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShaderCache');
  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {
    // first handle renaming any Fragment shader inputs
    // if we have a geometry shader. By default fragment shaders
    // assume their inputs come from a Vertex Shader. When we
    // have a Geometry shader we rename the frament shader inputs
    // to come from the geometry shader

    let nFSSource = FSSource;
    if (GSSource.length > 0) {
      nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, 'VSOut', 'GSOut').result;
    }
    const gl2 = model._openGLRenderWindow.getWebgl2();
    let fragDepthString = '\n';
    let version = '#version 100\n';
    if (gl2) {
      version = '#version 300 es\n' + '#define attribute in\n' + '#define textureCube texture\n' + '#define texture2D texture\n' + '#define textureCubeLod textureLod\n' + '#define texture2DLod textureLod\n';
    } else {
      model.context.getExtension('OES_standard_derivatives');
      if (model.context.getExtension('EXT_frag_depth')) {
        fragDepthString = '#extension GL_EXT_frag_depth : enable\n';
      }
      if (model.context.getExtension('EXT_shader_texture_lod')) {
        fragDepthString += '#extension GL_EXT_shader_texture_lod : enable\n' + '#define textureCubeLod textureCubeLodEXT\n' + '#define texture2DLod texture2DLodEXT';
      }
    }
    nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, '//VTK::System::Dec', [`${version}\n`, gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\n', fragDepthString, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;
    let nVSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::System::Dec', [`${version}\n`, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;
    if (gl2) {
      nVSSource = ShaderProgram/* default.substitute */.A.substitute(nVSSource, 'varying', 'out').result;
      nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, 'varying', 'in').result;
      let shaderOutputs = '';
      let outputCount = 0;
      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {
        nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, `gl_FragData\\[${outputCount}\\]`, `fragOutput${outputCount}`).result;
        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};\n`;
        outputCount++;
      }
      nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, '//VTK::Output::Dec', shaderOutputs).result;
    }

    // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\[0\\]',
    //   'gl_FragColor').result;

    const nGSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::System::Dec', version).result;
    return {
      VSSource: nVSSource,
      FSSource: nFSSource,
      GSSource: nGSSource
    };
  };

  // return NULL if there is an issue
  publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {
    const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
    const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
    return publicAPI.readyShaderProgram(shaderProgram);
  };
  publicAPI.readyShaderProgram = program => {
    if (!program) {
      return null;
    }

    // compile if needed
    if (!program.getCompiled() && !program.compileShader()) {
      return null;
    }

    // bind if needed
    if (!publicAPI.bindShaderProgram(program)) {
      return null;
    }
    return program;
  };
  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {
    // compute the MD5 and the check the map
    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;
    const result = spark_md5_default().hash(hashInput);

    // does it already exist?
    if (!(result in model.shaderPrograms)) {
      // create one
      const sps = ShaderProgram/* default */.A.newInstance();
      sps.setContext(model.context);
      sps.getVertexShader().setSource(vertexCode);
      sps.getFragmentShader().setSource(fragmentCode);
      if (geometryCode) {
        sps.getGeometryShader().setSource(geometryCode);
      }
      sps.setMd5Hash(result);
      model.shaderPrograms[result] = sps;
      return sps;
    }
    return model.shaderPrograms[result];
  };
  publicAPI.releaseGraphicsResources = win => {
    // NOTE:
    // In the current implementation as of October 26th, if a shader
    // program is created by ShaderCache then it should make sure
    // that it releases the graphics resources used by these programs.
    // It is not wisely for callers to do that since then they would
    // have to loop over all the programs were in use and invoke
    // release graphics resources individually.

    publicAPI.releaseCurrentShaderProgram();
    Object.keys(model.shaderPrograms).map(key => model.shaderPrograms[key]).forEach(sp => sp.cleanup());
    model.shaderPrograms = {};
  };
  publicAPI.releaseCurrentShaderProgram = () => {
    // release prior shader
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.cleanup();
      model.lastShaderProgramBound = null;
    }
  };
  publicAPI.bindShaderProgram = program => {
    if (model.lastShaderProgramBound === program) {
      return 1;
    }

    // release prior program
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.release();
    }
    program.bind();
    model.lastShaderProgramBound = program;
    return 1;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ShaderCache_DEFAULT_VALUES = {
  lastShaderProgramBound: null,
  shaderPrograms: null,
  context: null
  // _openGLRenderWindow: null,
};

// ----------------------------------------------------------------------------

function ShaderCache_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ShaderCache_DEFAULT_VALUES, initialValues);

  // Internal objects
  model.shaderPrograms = {};

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, SET_GET_FIELDS);
  macros2.m.moveToProtected(publicAPI, model, ['openGLRenderWindow']);

  // Object methods
  vtkShaderCache(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ShaderCache_newInstance = macros2.m.newInstance(ShaderCache_extend, 'vtkShaderCache');

// ----------------------------------------------------------------------------

var vtkShaderCache$1 = {
  newInstance: ShaderCache_newInstance,
  extend: ShaderCache_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js


const {
  vtkErrorMacro: TextureUnitManager_vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkOpenGLTextureUnitManager methods
// ----------------------------------------------------------------------------

function vtkOpenGLTextureUnitManager(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLTextureUnitManager');

  // ----------------------------------------------------------------------------
  // Description:
  // Delete the allocation table and check if it is not called before
  // all the texture units have been released.
  publicAPI.deleteTable = () => {
    for (let i = 0; i < model.numberOfTextureUnits; ++i) {
      if (model.textureUnits[i] === true) {
        TextureUnitManager_vtkErrorMacro('some texture units  were not properly released');
      }
    }
    model.textureUnits = [];
    model.numberOfTextureUnits = 0;
  };

  // ----------------------------------------------------------------------------
  publicAPI.setContext = ctx => {
    if (model.context !== ctx) {
      if (model.context !== 0) {
        publicAPI.deleteTable();
      }
      model.context = ctx;
      if (model.context) {
        model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
        for (let i = 0; i < model.numberOfTextureUnits; ++i) {
          model.textureUnits[i] = false;
        }
      }
      publicAPI.modified();
    }
  };

  // ----------------------------------------------------------------------------
  // Description:
  // Reserve a texture unit. It returns its number.
  // It returns -1 if the allocation failed (because there are no more
  // texture units left).
  // \post valid_result: result==-1 || result>=0 && result<this->GetNumberOfTextureUnits())
  // \post allocated: result==-1 || this->IsAllocated(result)
  publicAPI.allocate = () => {
    for (let i = 0; i < model.numberOfTextureUnits; i++) {
      if (!publicAPI.isAllocated(i)) {
        model.textureUnits[i] = true;
        return i;
      }
    }
    return -1;
  };
  publicAPI.allocateUnit = unit => {
    if (publicAPI.isAllocated(unit)) {
      return -1;
    }
    model.textureUnits[unit] = true;
    return unit;
  };

  // ----------------------------------------------------------------------------
  // Description:
  // Tell if texture unit `textureUnitId' is already allocated.
  // \pre valid_id_range : textureUnitId>=0 && textureUnitId<this->GetNumberOfTextureUnits()
  publicAPI.isAllocated = textureUnitId => model.textureUnits[textureUnitId];

  // ----------------------------------------------------------------------------
  // Description:
  // Release a texture unit.
  // \pre valid_id: textureUnitId>=0 && textureUnitId<this->GetNumberOfTextureUnits()
  // \pre allocated_id: this->IsAllocated(textureUnitId)
  publicAPI.free = val => {
    model.textureUnits[val] = false;
  };
  publicAPI.freeAll = () => {
    for (let i = 0; i < model.numberOfTextureUnits; ++i) {
      model.textureUnits[i] = false;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const TextureUnitManager_DEFAULT_VALUES = {
  context: null,
  numberOfTextureUnits: 0,
  textureUnits: 0
};

// ----------------------------------------------------------------------------

function TextureUnitManager_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, TextureUnitManager_DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  model.textureUnits = [];

  // Build VTK API
  macros2.m.get(publicAPI, model, ['numberOfTextureUnits']);
  macros2.m.setGet(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLTextureUnitManager(publicAPI, model);
}

// ----------------------------------------------------------------------------

const TextureUnitManager_newInstance = macros2.m.newInstance(TextureUnitManager_extend, 'vtkOpenGLTextureUnitManager');

// ----------------------------------------------------------------------------

var vtkTextureUnitManager = {
  newInstance: TextureUnitManager_newInstance,
  extend: TextureUnitManager_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js



// ----------------------------------------------------------------------------
// vtkRenderWindowViewNode is intended to be a superclass for all api specific
// RenderWindows. It is intended to define a common API that can be invoked
// upon an api specific render window and provide some common method
// implementations. If your application requires communicating with an api specific
// view try to limit such interactions to methods defined in this class.
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkRenderWindowViewNode methods
// ----------------------------------------------------------------------------

function vtkRenderWindowViewNode(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderWindowViewNode');
  publicAPI.getViewNodeFactory = () => null;
  publicAPI.getAspectRatio = () => model.size[0] / model.size[1];
  publicAPI.getAspectRatioForRenderer = renderer => {
    const viewport = renderer.getViewportByReference();
    return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
  };
  publicAPI.isInViewport = (x, y, viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    if (vCoords[0] * size[0] <= x && vCoords[2] * size[0] >= x && vCoords[1] * size[1] <= y && vCoords[3] * size[1] >= y) {
      return true;
    }
    return false;
  };
  publicAPI.getViewportSize = viewport => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    return [(vCoords[2] - vCoords[0]) * size[0], (vCoords[3] - vCoords[1]) * size[1]];
  };
  publicAPI.getViewportCenter = viewport => {
    const size = publicAPI.getViewportSize(viewport);
    return [size[0] * 0.5, size[1] * 0.5];
  };
  publicAPI.displayToNormalizedDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x / size[0], y / size[1], z];
  };
  publicAPI.normalizedDisplayToDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x * size[0], y * size[1], z];
  };
  publicAPI.worldToView = (x, y, z, renderer) => renderer.worldToView(x, y, z);
  publicAPI.viewToWorld = (x, y, z, renderer) => renderer.viewToWorld(x, y, z);
  publicAPI.worldToDisplay = (x, y, z, renderer) => {
    const val = renderer.worldToView(x, y, z);
    const dims = publicAPI.getViewportSize(renderer);
    const val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
    const val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
    return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
  };
  publicAPI.displayToWorld = (x, y, z, renderer) => {
    const val = publicAPI.displayToNormalizedDisplay(x, y, z);
    const val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
    const dims = publicAPI.getViewportSize(renderer);
    const val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
    return renderer.viewToWorld(val3[0], val3[1], val3[2]);
  };
  publicAPI.normalizedDisplayToViewport = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0.0);
    const coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
    return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
  };
  publicAPI.viewportToNormalizedViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    if (size && size[0] !== 0 && size[1] !== 0) {
      return [x / (size[0] - 1.0), y / (size[1] - 1.0), z];
    }
    return [x, y, z];
  };
  publicAPI.normalizedViewportToViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    return [x * (size[0] - 1.0), y * (size[1] - 1.0), z];
  };
  publicAPI.displayToLocalDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x, size[1] - y - 1, z];
  };
  publicAPI.viewportToNormalizedDisplay = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0.0);
    const x2 = x + vCoords[0] + 0.5;
    const y2 = y + vCoords[1] + 0.5;
    return publicAPI.displayToNormalizedDisplay(x2, y2, z);
  };
  publicAPI.getComputedDevicePixelRatio = () => model.size[0] / publicAPI.getContainerSize()[0];
  publicAPI.getContainerSize = () => {
    macros2.m.vtkErrorMacro('not implemented');
  };
  publicAPI.getPixelData = (x1, y1, x2, y2) => {
    macros2.m.vtkErrorMacro('not implemented');
  };
  publicAPI.createSelector = () => {
    macros2.m.vtkErrorMacro('not implemented');
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const RenderWindowViewNode_DEFAULT_VALUES = {
  size: undefined,
  selector: undefined
};

// ----------------------------------------------------------------------------

function RenderWindowViewNode_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, RenderWindowViewNode_DEFAULT_VALUES, initialValues);
  if (!model.size) {
    model.size = [300, 300];
  }
  macros2.m.getArray(publicAPI, model, ['size'], 2);
  macros2.m.get(publicAPI, model, ['selector']);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);

  // Object methods
  vtkRenderWindowViewNode(publicAPI, model);
}

// ----------------------------------------------------------------------------

const RenderWindowViewNode_newInstance = macros2.m.newInstance(RenderWindowViewNode_extend, 'vtkRenderWindowViewNode');

// ----------------------------------------------------------------------------

var vtkRenderWindowViewNode$1 = {
  newInstance: RenderWindowViewNode_newInstance,
  extend: RenderWindowViewNode_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/ContextProxy.js
// This is used to access the underlying 3D context
const GET_UNDERLYING_CONTEXT = '__getUnderlyingContext';
function createContextProxyHandler() {
  const cache = new Map();
  const getParameterHandler = {
    apply(target, gl, args) {
      if (cache.has(args[0])) {
        return cache.get(args[0]);
      }
      return target.apply(gl, args);
    }
  };

  // only supports single-value setters
  function cachedSetterHandler(key) {
    return {
      apply(target, gl, args) {
        cache.set(key, args[0]);
        return target.apply(gl, args);
      }
    };
  }

  // When a property is accessed on the webgl context proxy,
  // it's accessed is intercepted. If the property name matches
  // any of the keys of `propHandlers`, then that handler is called
  // with the following arguments: (gl, prop, receiver, propValue)
  // - gl (WebGL2RenderingContext): the underlying webgl context
  // - propName (string): the property name
  // - receiver (Proxy): the webgl context proxy
  // - propValue (unknown): the value of `gl[propName]`

  const propHandlers = Object.create(null);

  // Sets getParameter(property) as a cached getter proxy.
  // propValue.bind(gl) is to avoid Illegal Invocation errors.
  propHandlers.getParameter = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), getParameterHandler);

  // Sets depthMask(flag) as a cached setter proxy.
  propHandlers.depthMask = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));
  return {
    get(gl, prop, receiver) {
      if (prop === GET_UNDERLYING_CONTEXT) return () => gl;
      let value = Reflect.get(gl, prop, gl);
      if (value instanceof Function) {
        // prevents Illegal Invocation errors
        value = value.bind(gl);
      }
      const propHandler = propHandlers[prop];
      if (propHandler) {
        return propHandler(gl, prop, receiver, value);
      }
      return value;
    }
  };
}
var ContextProxy = {
  createContextProxyHandler
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js












const {
  vtkDebugMacro,
  vtkErrorMacro: RenderWindow_vtkErrorMacro
} = macros2.m;
const SCREENSHOT_PLACEHOLDER = {
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%',
  height: '100%'
};
const parentMethodsToProxy = ['activateTexture', 'deactivateTexture', 'disableCullFace', 'enableCullFace', 'get3DContext', 'getActiveFramebuffer', 'getContext', 'getDefaultTextureByteSize', 'getDefaultTextureInternalFormat', 'getDefaultToWebgl2', 'getGLInformations', 'getGraphicsMemoryInfo', 'getGraphicsResourceForObject', 'getHardwareMaximumLineWidth', 'getPixelData', 'getShaderCache', 'getTextureUnitForTexture', 'getTextureUnitManager', 'getWebgl2', 'makeCurrent', 'releaseGraphicsResources', 'registerGraphicsResourceUser', 'unregisterGraphicsResourceUser', 'restoreContext', 'setActiveFramebuffer', 'setContext', 'setDefaultToWebgl2', 'setGraphicsResourceForObject'];
function checkRenderTargetSupport(gl, format, type) {
  // create temporary frame buffer and texture
  const framebuffer = gl.createFramebuffer();
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

  // check frame buffer status
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

  // clean up
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return status === gl.FRAMEBUFFER_COMPLETE;
}

// ----------------------------------------------------------------------------
// Monitor the usage of GL context across vtkOpenGLRenderWindow instances
// ----------------------------------------------------------------------------

let GL_CONTEXT_COUNT = 0;
const GL_CONTEXT_LISTENERS = [];
function createGLContext() {
  GL_CONTEXT_COUNT++;
  GL_CONTEXT_LISTENERS.forEach(cb => cb(GL_CONTEXT_COUNT));
}
function deleteGLContext() {
  GL_CONTEXT_COUNT--;
  GL_CONTEXT_LISTENERS.forEach(cb => cb(GL_CONTEXT_COUNT));
}
function pushMonitorGLContextCount(cb) {
  GL_CONTEXT_LISTENERS.push(cb);
}
function popMonitorGLContextCount(cb) {
  return GL_CONTEXT_LISTENERS.pop();
}
function _preventDefault(e) {
  e.preventDefault();
}

// ----------------------------------------------------------------------------
// vtkOpenGLRenderWindow methods
// ----------------------------------------------------------------------------

function vtkOpenGLRenderWindow(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLRenderWindow');

  // Only create a cachingContextHandler if needed
  let cachingContextHandler;
  function getCachingContextHandler() {
    if (!cachingContextHandler) {
      cachingContextHandler = createContextProxyHandler();
    }
    return cachingContextHandler;
  }
  publicAPI.getViewNodeFactory = () => model.myFactory;

  // prevent default context lost handler
  model.canvas.addEventListener('webglcontextlost', _preventDefault, false);
  model.canvas.addEventListener('webglcontextrestored', publicAPI.restoreContext, false);

  // Auto update style
  const previousSize = [0, 0];
  function updateWindow() {
    // Canvas size
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute('width', model.size[0]);
        model.canvas.setAttribute('height', model.size[1]);
      }
    }

    // ImageStream size
    if (model.viewStream) {
      // If same size that's a NoOp
      model.viewStream.setSize(model.size[0], model.size[1]);
    }

    // Offscreen ?
    model.canvas.style.display = model.useOffScreen ? 'none' : 'block';

    // Cursor type
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : 'none';
    }

    // Invalidate cached DOM container size
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.addMissingNodes(model.renderable.getChildRenderWindowsByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
      model.children.forEach(child => {
        // Children can be openGl renderer or openGl render windows
        // Only openGl renderers have a method setOpenGLRenderWindow
        child.setOpenGLRenderWindow?.(publicAPI);
      });
    }
  };
  publicAPI.initialize = () => {
    if (!model.initialized) {
      // Set root parent if there is one
      // Some methods of the root parent are proxied (see parentMethodsToProxy)
      model.rootOpenGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (model.rootOpenGLRenderWindow) {
        // Initialize a 2D context that will copy the content of the root parent
        model.context2D = publicAPI.get2DContext();
      } else {
        // Initialize a 3D context that may be used by child render windows
        model.context = publicAPI.get3DContext();
        publicAPI.resizeFromChildRenderWindows();
        if (model.context) {
          createGLContext();
        }
        model.textureUnitManager = vtkTextureUnitManager.newInstance();
        model.textureUnitManager.setContext(model.context);
        model.shaderCache.setContext(model.context);
        // initialize blending for transparency
        const gl = model.context;
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.BLEND);
      }
      model.initialized = true;
    }
  };
  publicAPI.makeCurrent = () => {
    model.context.makeCurrent();
  };
  publicAPI.setContainer = el => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        RenderWindow_vtkErrorMacro('Error: canvas parent node does not match container');
      }

      // Remove canvas from previous container
      model.el.removeChild(model.canvas);

      // If the renderer has previously added
      // a background image, remove it from the DOM.
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);

        // If the renderer is set to use a background
        // image, attach it to the DOM.
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }

      // Trigger modified()
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = () => model.el;
  publicAPI.getContainerSize = () => {
    if (!model.containerSize && model.el) {
      const {
        width,
        height
      } = model.el.getBoundingClientRect();
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = () => {
    const fbSize = model.activeFramebuffer?.getSize();
    return fbSize || model.size;
  };
  publicAPI.getPixelData = (x1, y1, x2, y2) => {
    const pixels = new Uint8Array((x2 - x1 + 1) * (y2 - y1 + 1) * 4);
    model.context.readPixels(x1, y1, x2 - x1 + 1, y2 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
    return pixels;
  };
  publicAPI.get3DContext = function () {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      preserveDrawingBuffer: false,
      depth: true,
      alpha: true,
      powerPreference: 'high-performance'
    };
    let result = null;
    const webgl2Supported = typeof WebGL2RenderingContext !== 'undefined';
    model.webgl2 = false;
    if (model.defaultToWebgl2 && webgl2Supported) {
      result = model.canvas.getContext('webgl2', options);
      if (result) {
        model.webgl2 = true;
        vtkDebugMacro('using webgl2');
      }
    }
    if (!result) {
      vtkDebugMacro('using webgl1');
      result = model.canvas.getContext('webgl', options) || model.canvas.getContext('experimental-webgl', options);
    }
    return new Proxy(result, getCachingContextHandler());
  };
  publicAPI.get2DContext = function () {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return model.canvas.getContext('2d', options);
  };
  publicAPI.restoreContext = () => {
    const rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation('Release');
    rp.traverse(publicAPI, null);
  };
  publicAPI.activateTexture = texture => {
    // Only add if it isn't already there
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      model.context.activeTexture(model.context.TEXTURE0 + result);
      return;
    }
    const activeUnit = publicAPI.getTextureUnitManager().allocate();
    if (activeUnit < 0) {
      RenderWindow_vtkErrorMacro('Hardware does not support the number of textures defined.');
      return;
    }
    model._textureResourceIds.set(texture, activeUnit);
    model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
  };
  publicAPI.deactivateTexture = texture => {
    // Only deactivate if it isn't already there
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      publicAPI.getTextureUnitManager().free(result);
      model._textureResourceIds.delete(texture);
    }
  };
  publicAPI.getTextureUnitForTexture = texture => {
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      return result;
    }
    return -1;
  };
  publicAPI.getDefaultTextureByteSize = function (vtkType) {
    let oglNorm16Ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let useHalfFloat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (model.webgl2) {
      switch (vtkType) {
        case Constants/* VtkDataTypes */.JA.CHAR:
        case Constants/* VtkDataTypes */.JA.SIGNED_CHAR:
        case Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR:
          return 1;
        case oglNorm16Ext:
        case useHalfFloat:
        case Constants/* VtkDataTypes */.JA.UNSIGNED_SHORT:
        case Constants/* VtkDataTypes */.JA.SHORT:
        case Constants/* VtkDataTypes */.JA.VOID:
          // Used for unsigned int depth
          return 2;
        default:
          // For all other cases, assume float
          return 4;
      }
    }

    // webgl1 type support is limited to 1 byte
    return 1;
  };
  publicAPI.getDefaultTextureInternalFormat = function (vtktype, numComps) {
    let oglNorm16Ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let useHalfFloat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (model.webgl2) {
      switch (vtktype) {
        case Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR:
          switch (numComps) {
            case 1:
              return model.context.R8;
            case 2:
              return model.context.RG8;
            case 3:
              return model.context.RGB8;
            case 4:
            default:
              return model.context.RGBA8;
          }
        case oglNorm16Ext && !useHalfFloat && Constants/* VtkDataTypes */.JA.UNSIGNED_SHORT:
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_EXT;
            case 2:
              return oglNorm16Ext.RG16_EXT;
            case 3:
              return oglNorm16Ext.RGB16_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_EXT;
          }
        // prioritize norm16 over float
        case oglNorm16Ext && !useHalfFloat && Constants/* VtkDataTypes */.JA.SHORT:
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_SNORM_EXT;
            case 2:
              return oglNorm16Ext.RG16_SNORM_EXT;
            case 3:
              return oglNorm16Ext.RGB16_SNORM_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_SNORM_EXT;
          }
        case Constants/* VtkDataTypes */.JA.UNSIGNED_SHORT:
        case Constants/* VtkDataTypes */.JA.SHORT:
        case Constants/* VtkDataTypes */.JA.FLOAT:
        default:
          // useHalfFloat tells us if the texture can be accurately
          // rendered with 16 bits or not.
          switch (numComps) {
            case 1:
              return useHalfFloat ? model.context.R16F : model.context.R32F;
            case 2:
              return useHalfFloat ? model.context.RG16F : model.context.RG32F;
            case 3:
              return useHalfFloat ? model.context.RGB16F : model.context.RGB32F;
            case 4:
            default:
              return useHalfFloat ? model.context.RGBA16F : model.context.RGBA32F;
          }
      }
    }

    // webgl1 only supports four types
    switch (numComps) {
      case 1:
        return model.context.LUMINANCE;
      case 2:
        return model.context.LUMINANCE_ALPHA;
      case 3:
        return model.context.RGB;
      case 4:
      default:
        return model.context.RGBA;
    }
  };
  publicAPI.setBackgroundImage = img => {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = value => {
    model.useBackgroundImage = value;

    // Add or remove the background image from the
    // DOM as specified.
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.imageFormat;
    // Copy current canvas to not modify the original
    const temporaryCanvas = document.createElement('canvas');
    const temporaryContext = temporaryCanvas.getContext('2d');
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    temporaryContext.drawImage(model.canvas, 0, 0);

    // Get current client rect to place canvas
    const mainBoundingClientRect = model.canvas.getBoundingClientRect();
    const renderWindow = model.renderable;
    const renderers = renderWindow.getRenderers();
    renderers.forEach(renderer => {
      const viewProps = renderer.getViewProps();
      viewProps.forEach(viewProp => {
        // Check if the prop has a container that should have canvas
        if (viewProp.getContainer) {
          const container = viewProp.getContainer();
          const canvasList = container.getElementsByTagName('canvas');
          // Go throughout all canvas and copy it into temporary main canvas
          for (let i = 0; i < canvasList.length; i++) {
            const currentCanvas = canvasList[i];
            const boundingClientRect = currentCanvas.getBoundingClientRect();
            const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
            const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
          }
        }
      });
    });
    const screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }
  publicAPI.captureNextImage = function () {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';
    let {
      resetCamera = false,
      size = null,
      scale = 1
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    const previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size || scale !== 1 ? size || model.size.map(val => val * scale) : null
    };
    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onImageReady(imageURL => {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            // resize the main canvas back to its original size and show it
            model.size = model._screenshot.originalSize;

            // process the resize
            publicAPI.modified();

            // restore the saved camera parameters, if applicable
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach(_ref => {
                let {
                  restoreParamsFn,
                  arg
                } = _ref;
                return restoreParamsFn(arg);
              });
            }

            // Trigger a render at the original size
            publicAPI.traverseAllPasses();

            // Remove and clean up the placeholder, revealing the original
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          // Create a placeholder image overlay while we resize and render
          const tmpImg = document.createElement('img');
          tmpImg.style = SCREENSHOT_PLACEHOLDER;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);

          // hide the main canvas
          model.canvas.style.display = 'none';

          // remember the main canvas original size, then resize it
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model._screenshot.size = null;

          // process the resize
          publicAPI.modified();
          if (resetCamera) {
            const isUserResetCamera = resetCamera !== true;

            // If resetCamera was requested, we first save camera parameters
            // from all the renderers, so we can restore them later
            model._screenshot.cameras = model.renderable.getRenderers().map(renderer => {
              const camera = renderer.getActiveCamera();
              const params = camera.get('focalPoint', 'position', 'parallelScale');
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : undefined,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                // "clone" the params so we don't keep refs to properties
                arg: JSON.parse(JSON.stringify(params))
              };
            });

            // Perform the resetCamera() on each renderer only after capturing
            // the params from all active cameras, in case there happen to be
            // linked cameras among the renderers.
            model._screenshot.cameras.forEach(_ref2 => {
              let {
                resetCameraFn,
                resetCameraArgs
              } = _ref2;
              return resetCameraFn(resetCameraArgs);
            });
          }

          // Trigger a render at the custom size
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  let hardwareMaximumLineWidth;
  publicAPI.getHardwareMaximumLineWidth = () => {
    // We cache the result of this function because `getParameter` is slow
    if (hardwareMaximumLineWidth != null) {
      return hardwareMaximumLineWidth;
    }
    const gl = publicAPI.get3DContext();
    const lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
    hardwareMaximumLineWidth = lineWidthRange[1];
    return lineWidthRange[1];
  };
  publicAPI.getGLInformations = () => {
    if (model._glInformation) {
      return model._glInformation;
    }
    const gl = publicAPI.get3DContext();
    const glTextureFloat = gl.getExtension('OES_texture_float');
    const glTextureHalfFloat = gl.getExtension('OES_texture_half_float');
    const glDebugRendererInfo = gl.getExtension('WEBGL_debug_renderer_info');
    const glDrawBuffers = gl.getExtension('WEBGL_draw_buffers');
    const glAnisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
    const params = [['Max Vertex Attributes', 'MAX_VERTEX_ATTRIBS', gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ['Max Varying Vectors', 'MAX_VARYING_VECTORS', gl.getParameter(gl.MAX_VARYING_VECTORS)], ['Max Vertex Uniform Vectors', 'MAX_VERTEX_UNIFORM_VECTORS', gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ['Max Fragment Uniform Vectors', 'MAX_FRAGMENT_UNIFORM_VECTORS', gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ['Max Fragment Texture Image Units', 'MAX_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ['Max Vertex Texture Image Units', 'MAX_VERTEX_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ['Max Combined Texture Image Units', 'MAX_COMBINED_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ['Max 2D Texture Size', 'MAX_TEXTURE_SIZE', gl.getParameter(gl.MAX_TEXTURE_SIZE)], ['Max Cube Texture Size', 'MAX_CUBE_MAP_TEXTURE_SIZE', gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ['Max Texture Anisotropy', 'MAX_TEXTURE_MAX_ANISOTROPY_EXT', glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ['Point Size Range', 'ALIASED_POINT_SIZE_RANGE', gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(' - ')], ['Line Width Range', 'ALIASED_LINE_WIDTH_RANGE', gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(' - ')], ['Max Viewport Dimensions', 'MAX_VIEWPORT_DIMS', gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(' - ')], ['Max Renderbuffer Size', 'MAX_RENDERBUFFER_SIZE', gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ['Framebuffer Red Bits', 'RED_BITS', gl.getParameter(gl.RED_BITS)], ['Framebuffer Green Bits', 'GREEN_BITS', gl.getParameter(gl.GREEN_BITS)], ['Framebuffer Blue Bits', 'BLUE_BITS', gl.getParameter(gl.BLUE_BITS)], ['Framebuffer Alpha Bits', 'ALPHA_BITS', gl.getParameter(gl.ALPHA_BITS)], ['Framebuffer Depth Bits', 'DEPTH_BITS', gl.getParameter(gl.DEPTH_BITS)], ['Framebuffer Stencil Bits', 'STENCIL_BITS', gl.getParameter(gl.STENCIL_BITS)], ['Framebuffer Subpixel Bits', 'SUBPIXEL_BITS', gl.getParameter(gl.SUBPIXEL_BITS)], ['MSAA Samples', 'SAMPLES', gl.getParameter(gl.SAMPLES)], ['MSAA Sample Buffers', 'SAMPLE_BUFFERS', gl.getParameter(gl.SAMPLE_BUFFERS)], ['Supported Formats for UByte Render Targets     ', 'UNSIGNED_BYTE RENDER TARGET FORMATS', [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? 'RGBA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? 'RGB' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? 'LUMINANCE' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? 'ALPHA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Supported Formats for Half Float Render Targets', 'HALF FLOAT RENDER TARGET FORMATS', [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'RGBA' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? 'RGB' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? 'LUMINANCE' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'ALPHA' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Supported Formats for Full Float Render Targets', 'FLOAT RENDER TARGET FORMATS', [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? 'RGBA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? 'RGB' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? 'LUMINANCE' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? 'ALPHA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Max Multiple Render Targets Buffers', 'MAX_DRAW_BUFFERS_WEBGL', glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ['High Float Precision in Vertex Shader', 'HIGH_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, '</sup>)'].join('')], ['Medium Float Precision in Vertex Shader', 'MEDIUM_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, '</sup>)'].join('')], ['Low Float Precision in Vertex Shader', 'LOW_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, '</sup>)'].join('')], ['High Float Precision in Fragment Shader', 'HIGH_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, '</sup>)'].join('')], ['Medium Float Precision in Fragment Shader', 'MEDIUM_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, '</sup>)'].join('')], ['Low Float Precision in Fragment Shader', 'LOW_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, '</sup>)'].join('')], ['High Int Precision in Vertex Shader', 'HIGH_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, '</sup>)'].join('')], ['Medium Int Precision in Vertex Shader', 'MEDIUM_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, '</sup>)'].join('')], ['Low Int Precision in Vertex Shader', 'LOW_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, '</sup>)'].join('')], ['High Int Precision in Fragment Shader', 'HIGH_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, '</sup>)'].join('')], ['Medium Int Precision in Fragment Shader', 'MEDIUM_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, '</sup>)'].join('')], ['Low Int Precision in Fragment Shader', 'LOW_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, '</sup>)'].join('')], ['Supported Extensions', 'EXTENSIONS', gl.getSupportedExtensions().join('<br/>\t\t\t\t\t    ')], ['WebGL Renderer', 'RENDERER', gl.getParameter(gl.RENDERER)], ['WebGL Vendor', 'VENDOR', gl.getParameter(gl.VENDOR)], ['WebGL Version', 'VERSION', gl.getParameter(gl.VERSION)], ['Shading Language Version', 'SHADING_LANGUAGE_VERSION', gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ['Unmasked Renderer', 'UNMASKED_RENDERER', glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ['Unmasked Vendor', 'UNMASKED_VENDOR', glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ['WebGL Version', 'WEBGL_VERSION', model.webgl2 ? 2 : 1]];
    const result = {};
    while (params.length) {
      const [label, key, value] = params.pop();
      if (key) {
        result[key] = {
          label,
          value
        };
      }
    }
    model._glInformation = result;
    return result;
  };
  publicAPI.traverseAllPasses = () => {
    if (model.renderPasses) {
      for (let index = 0; index < model.renderPasses.length; ++index) {
        model.renderPasses[index].traverse(publicAPI, null);
      }
    }
    if (model.notifyStartCaptureImage) {
      getCanvasDataURL();
    }
    publicAPI.copyParentContent();
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    for (let i = 0; i < childrenRW.length; ++i) {
      publicAPI.getViewNodeFor(childrenRW[i])?.traverseAllPasses();
    }
  };
  publicAPI.copyParentContent = () => {
    const rootParent = model.rootOpenGLRenderWindow;
    if (!rootParent || !model.context2D || model.children.some(oglRenderer => !!oglRenderer.getSelector?.())) {
      return;
    }
    const parentCanvas = rootParent.getCanvas();
    const selfCanvas = model.canvas;
    model.context2D.drawImage(parentCanvas, 0, parentCanvas.height - selfCanvas.height,
    // source y axis is inverted
    selfCanvas.width, selfCanvas.height, 0, 0, selfCanvas.width, selfCanvas.height);
  };
  publicAPI.resizeFromChildRenderWindows = () => {
    // Adapt the size of the parent render window to the child render windows
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    if (childrenRW.length > 0) {
      const maxSize = [0, 0];
      for (let i = 0; i < childrenRW.length; ++i) {
        const childSize = publicAPI.getViewNodeFor(childrenRW[i])?.getSize();
        if (childSize) {
          maxSize[0] = childSize[0] > maxSize[0] ? childSize[0] : maxSize[0];
          maxSize[1] = childSize[1] > maxSize[1] ? childSize[1] : maxSize[1];
        }
      }
      publicAPI.setSize(...maxSize);
    }
  };
  publicAPI.disableCullFace = () => {
    if (model.cullFaceEnabled) {
      model.context.disable(model.context.CULL_FACE);
      model.cullFaceEnabled = false;
    }
  };
  publicAPI.enableCullFace = () => {
    if (!model.cullFaceEnabled) {
      model.context.enable(model.context.CULL_FACE);
      model.cullFaceEnabled = true;
    }
  };
  publicAPI.setViewStream = stream => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      // Force background to be transparent + render
      const mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;

      // Enable display of the background image
      publicAPI.setUseBackgroundImage(true);

      // Bind to remote stream
      model.subscription = model.viewStream.onImageReady(e => publicAPI.setBackgroundImage(e.image));
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.createSelector = () => {
    const ret = HardwareSelector_vtkHardwareSelector.newInstance();
    ret.setOpenGLRenderWindow(publicAPI);
    return ret;
  };
  function clearEvents() {
    model.canvas.removeEventListener('webglcontextlost', _preventDefault);
    model.canvas.removeEventListener('webglcontextrestored', publicAPI.restoreContext);
  }
  publicAPI.delete = macros2.m.chain(() => {
    if (model.context) {
      deleteGLContext();
    }
    publicAPI.setContainer();
    publicAPI.setViewStream();
  }, clearEvents, publicAPI.delete);

  // Do not trigger modified for performance reasons
  publicAPI.setActiveFramebuffer = newActiveFramebuffer => {
    model.activeFramebuffer = newActiveFramebuffer;
  };
  const superSetSize = publicAPI.setSize;
  publicAPI.setSize = (width, height) => {
    const modified = superSetSize(width, height);
    if (modified) {
      publicAPI.invokeWindowResizeEvent({
        width,
        height
      });
    }
    return modified;
  };
  publicAPI.registerGraphicsResourceUser = (coreObject, newUser) => {
    // Try to create the graphics resource if it doesn't exist
    if (!model._graphicsResources.has(coreObject)) {
      publicAPI.setGraphicsResourceForObject(coreObject, null, null);
    }
    // Add newUser to the set of users
    const sharedResource = model._graphicsResources.get(coreObject);
    sharedResource?.users.add(newUser);
  };
  publicAPI.unregisterGraphicsResourceUser = (coreObject, oldUser) => {
    const sharedResource = model._graphicsResources.get(coreObject);
    if (!sharedResource) {
      return;
    }
    sharedResource.users.delete(oldUser);
    // Release graphics resources when the number of users reaches 0
    if (!sharedResource.users.size) {
      sharedResource.oglObject?.releaseGraphicsResources(publicAPI);
      model._graphicsResources.delete(coreObject);
    }
  };
  publicAPI.getGraphicsResourceForObject = coreObject => model._graphicsResources.get(coreObject);
  publicAPI.setGraphicsResourceForObject = (coreObject, oglObject, hash) => {
    if (!coreObject) {
      return;
    }
    const sharedResource = model._graphicsResources.get(coreObject);
    // Release the old resource
    sharedResource?.oglObject?.releaseGraphicsResources(publicAPI);
    // Keep the same users that have registered for this coreObject
    model._graphicsResources.set(coreObject, {
      coreObject,
      oglObject,
      hash,
      users: sharedResource?.users ?? new Set()
    });
  };
  publicAPI.getGraphicsMemoryInfo = () => {
    let memUsed = 0;
    model._graphicsResources.forEach(_ref3 => {
      let {
        oglObject
      } = _ref3;
      memUsed += oglObject.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
  publicAPI.releaseGraphicsResources = () => {
    // Clear the shader cache
    if (model.shaderCache !== null) {
      model.shaderCache.releaseGraphicsResources(publicAPI);
    }
    // Free cached graphics resources at the context level
    model._graphicsResources.forEach(_ref4 => {
      let {
        oglObject
      } = _ref4;
      oglObject.releaseGraphicsResources(publicAPI);
    });
    model._graphicsResources.clear();
    if (model.textureUnitManager !== null) {
      model.textureUnitManager.freeAll();
    }
    // Finally, ask the renderers to release prop resources
    model.renderable.getRenderersByReference().forEach(ren => {
      const glRen = publicAPI.getViewNodeFor(ren);
      glRen?.releaseGraphicsResources();
    });
  };

  // Proxy some methods if needed
  const publicAPIBeforeProxy = {
    ...publicAPI
  };
  parentMethodsToProxy.forEach(methodName => {
    publicAPI[methodName] = function () {
      if (model.rootOpenGLRenderWindow) {
        // Proxy only methods when the render window has a parent
        return model.rootOpenGLRenderWindow[methodName](...arguments);
      }
      return publicAPIBeforeProxy[methodName](...arguments);
    };
  });
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const RenderWindow_DEFAULT_VALUES = {
  cullFaceEnabled: false,
  shaderCache: null,
  initialized: false,
  context: null,
  context2D: null,
  canvas: null,
  cursorVisibility: true,
  cursor: 'pointer',
  textureUnitManager: null,
  textureResourceIds: null,
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  webgl2: false,
  defaultToWebgl2: true,
  // attempt webgl2 on by default
  activeFramebuffer: null,
  imageFormat: 'image/png',
  useOffScreen: false,
  useBackgroundImage: false
};

// ----------------------------------------------------------------------------

function RenderWindow_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, RenderWindow_DEFAULT_VALUES, initialValues);

  // Inheritance
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);

  // Create internal instances
  if (!model.canvas) {
    model.canvas = document.createElement('canvas');
    model.canvas.style.width = '100%';
  }
  if (!model.selector) {
    model.selector = HardwareSelector_vtkHardwareSelector.newInstance();
    model.selector.setOpenGLRenderWindow(publicAPI);
  }

  // Create internal bgImage
  model.bgImage = new Image();
  model.bgImage.style.position = 'absolute';
  model.bgImage.style.left = '0';
  model.bgImage.style.top = '0';
  model.bgImage.style.width = '100%';
  model.bgImage.style.height = '100%';
  model.bgImage.style.zIndex = '-1';
  model._textureResourceIds = new Map();
  model._graphicsResources = new Map();
  model._glInformation = null;
  model.myFactory = ViewNodeFactory/* default.newInstance */.Ay.newInstance();
  model.shaderCache = vtkShaderCache$1.newInstance();
  model.shaderCache.setOpenGLRenderWindow(publicAPI);

  // setup default forward pass rendering
  model.renderPasses[0] = vtkForwardPass$1.newInstance();

  // Build VTK API
  macros2.m.get(publicAPI, model, ['shaderCache', 'textureUnitManager', 'webgl2', 'useBackgroundImage', 'activeFramebuffer', 'rootOpenGLRenderWindow']);
  macros2.m.setGet(publicAPI, model, ['initialized', 'context', 'context2D', 'canvas', 'renderPasses', 'notifyStartCaptureImage', 'defaultToWebgl2', 'cursor', 'useOffScreen']);
  macros2.m.setGetArray(publicAPI, model, ['size'], 2);
  macros2.m.event(publicAPI, model, 'imageReady');
  macros2.m.event(publicAPI, model, 'windowResizeEvent');

  // Object methods
  vtkOpenGLRenderWindow(publicAPI, model);
}

// ----------------------------------------------------------------------------

const RenderWindow_newInstance = macros2.m.newInstance(RenderWindow_extend, 'vtkOpenGLRenderWindow');

// ----------------------------------------------------------------------------
// Register API specific RenderWindow implementation
// ----------------------------------------------------------------------------

registerViewConstructor('WebGL', RenderWindow_newInstance);

// ----------------------------------------------------------------------------

var RenderWindow_vtkRenderWindow = {
  newInstance: RenderWindow_newInstance,
  extend: RenderWindow_extend,
  pushMonitorGLContextCount,
  popMonitorGLContextCount
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkRenderWindow', RenderWindow_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
var Actor = __webpack_require__(80639);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
var Actor2D = __webpack_require__(58601);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
var Camera = __webpack_require__(38475);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
var BufferObject = __webpack_require__(21081);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
var PolyDataMapper = __webpack_require__(62939);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper.js









const {
  vtkErrorMacro: Glyph3DMapper_vtkErrorMacro
} = macros2.c;
const {
  Representation: Glyph3DMapper_Representation
} = Property/* default */.Ay;
const {
  ObjectType
} = BufferObject/* default */.Ay;
const {
  PassTypes: Glyph3DMapper_PassTypes
} = HardwareSelector_vtkHardwareSelector;
const StartEvent = {
  type: 'StartEvent'
};
const EndEvent = {
  type: 'EndEvent'
};

// ----------------------------------------------------------------------------
// vtkOpenGLSphereMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLGlyph3DMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLGlyph3DMapper');

  // Capture 'parentClass' api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData(1);
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      Glyph3DMapper_vtkErrorMacro('No input!');
      return;
    }

    // if there are no points then we are done
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }

    // apply faceCulling
    const gl = model.context;
    if (model._openGLRenderWindow.getWebgl2()) {
      model.hardwareSupport = true;
      model.extension = null;
    } else if (!model.extension) {
      model.extension = model.context.getExtension('ANGLE_instanced_arrays');
      model.hardwareSupport = !!model.extension;
    }
    // to test without extension support uncomment the next two lines
    // model.extension = null;
    // model.hardwareSupport = !!model.extension;

    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.multiply4x4WithOffset = (out, a, b, off) => {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];

    // Cache only the current line of the second matrix
    let b0 = b[off];
    let b1 = b[off + 1];
    let b2 = b[off + 2];
    let b3 = b[off + 3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 4];
    b1 = b[off + 5];
    b2 = b[off + 6];
    b3 = b[off + 7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 8];
    b1 = b[off + 9];
    b2 = b[off + 10];
    b3 = b[off + 11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 12];
    b1 = b[off + 13];
    b2 = b[off + 14];
    b3 = b[off + 15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (lastLightComplexity > 0) {
        let VSSource = shaders.Vertex;
        if (model.lastBoundBO.getCABO().getNormalOffset()) {
          VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'attribute mat3 gNormal;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;
          VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * gNormal * normalMC;']).result;
        }
        shaders.Vertex = VSSource;
      }
    }
    superClass.replaceShaderNormal(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    if (model.hardwareSupport && model.renderable.getColorArray()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');

      // create the material/color property declarations, and VS implementation
      // these are always defined
      let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity'];
      // add more for specular
      if (lastLightComplexity) {
        colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);
      }

      // now handle the more complex fragment shader implementation
      // the following are always defined variables.  We start
      // by assigning a default value from the uniform
      let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);
      }
      colorImpl = colorImpl.concat(['  opacity = opacityUniform;']);
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);
      }
      if (!model.drawingEdges) {
        colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 gColor;', 'varying vec4 vertexColorVSOutput;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput = gColor;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;
        colorImpl = colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;']);
      }
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
    superClass.replaceShaderColor(shaders, ren, actor);
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let VSSource = shaders.Vertex;

      // do we need the vertex in the shader in View Coordinates
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (lastLightComplexity > 0) {
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['vec4 gVertexMC = gMatrix * vertexMC;', 'vertexVCVSOutput = MCVCMatrix * gVertexMC;', '  gl_Position = MCPCMatrix * gVertexMC;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['attribute mat4 gMatrix;', 'uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;
      } else {
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['attribute mat4 gMatrix;', 'uniform mat4 MCPCMatrix;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['vec4 gVertexMC = gMatrix * vertexMC;', '  gl_Position = MCPCMatrix * gVertexMC;']).result;
      }
      shaders.Vertex = VSSource;
    }
    superClass.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let FSSource = shaders.Fragment;
      let VSSource = shaders.Vertex;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Picking::Dec', ['attribute vec3 mapperIndexVS;', 'varying vec3 mapperIndexVSOutput;']).result;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Picking::Impl', '  mapperIndexVSOutput = mapperIndexVS;').result;
      shaders.Vertex = VSSource;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Picking::Dec', ['varying vec3 mapperIndexVSOutput;', 'uniform vec3 mapperIndex;', 'uniform int picking;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Picking::Impl', ['  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);', '  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];']).result;
      shaders.Fragment = FSSource;
    } else {
      superClass.replaceShaderPicking(shaders, ren, actor);
    }
  };
  publicAPI.updateGlyphShaderParameters = (normalMatrixUsed, mcvcMatrixUsed, cellBO, carray, garray, narray, p, selector) => {
    const program = cellBO.getProgram();
    if (normalMatrixUsed) {
      const a = model.normalMatrix;
      const b = narray;
      const ofs = p * 9;
      const out = model.tmpMat3;
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a10 = a[3];
      const a11 = a[4];
      const a12 = a[5];
      const a20 = a[6];
      const a21 = a[7];
      const a22 = a[8];
      const b00 = b[ofs];
      const b01 = b[ofs + 1];
      const b02 = b[ofs + 2];
      const b10 = b[ofs + 3];
      const b11 = b[ofs + 4];
      const b12 = b[ofs + 5];
      const b20 = b[ofs + 6];
      const b21 = b[ofs + 7];
      const b22 = b[ofs + 8];
      out[0] = b00 * a00 + b01 * a10 + b02 * a20;
      out[1] = b00 * a01 + b01 * a11 + b02 * a21;
      out[2] = b00 * a02 + b01 * a12 + b02 * a22;
      out[3] = b10 * a00 + b11 * a10 + b12 * a20;
      out[4] = b10 * a01 + b11 * a11 + b12 * a21;
      out[5] = b10 * a02 + b11 * a12 + b12 * a22;
      out[6] = b20 * a00 + b21 * a10 + b22 * a20;
      out[7] = b20 * a01 + b21 * a11 + b22 * a21;
      out[8] = b20 * a02 + b21 * a12 + b22 * a22;
      program.setUniformMatrix3x3('normalMatrix', model.tmpMat3);
    }
    publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcpcMatrix, garray, p * 16);
    program.setUniformMatrix('MCPCMatrix', model.tmpMat4);
    if (mcvcMatrixUsed) {
      publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcvcMatrix, garray, p * 16);
      program.setUniformMatrix('MCVCMatrix', model.tmpMat4);
    }

    // set color
    if (carray) {
      const cdata = carray.getData();
      model.tmpColor[0] = cdata[p * 4] / 255.0;
      model.tmpColor[1] = cdata[p * 4 + 1] / 255.0;
      model.tmpColor[2] = cdata[p * 4 + 2] / 255.0;
      program.setUniform3fArray('ambientColorUniform', model.tmpColor);
      program.setUniform3fArray('diffuseColorUniform', model.tmpColor);
    }
    if (selector) {
      program.setUniform3fArray('mapperIndex', selector.getPropColorValue());
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Glyph3DMapper_Representation.SURFACE;

    // [WMVP]C == {world, model, view, projection} coordinates
    // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLActor.getKeyMatrices();

    // precompute the actor+camera mats once
    esm/* mat3.multiply */.w0.multiply(model.normalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    esm/* mat4.multiply */.pB.multiply(model.mcpcMatrix, keyMats.wcpc, actMats.mcwc);
    esm/* mat4.multiply */.pB.multiply(model.mcvcMatrix, keyMats.wcvc, actMats.mcwc);
    const garray = model.renderable.getMatrixArray();
    const narray = model.renderable.getNormalArray();
    const carray = model.renderable.getColorArray();
    const numPts = garray.length / 16;
    let compositePass = false;
    if (model._openGLRenderer.getSelector()) {
      if (model._openGLRenderer.getSelector().getCurrentPass() === Glyph3DMapper_PassTypes.COMPOSITE_INDEX_PASS) {
        compositePass = true;
      }
    }

    // for every primitive type
    for (let i = model.primTypes.Start; i < model.primTypes.End; i++) {
      // if there are entries
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        // are we drawing edges
        model.drawingEdges = drawSurfaceWithEdges && (i === model.primTypes.TrisEdges || i === model.primTypes.TriStripsEdges);
        model.lastBoundBO = model.primitives[i];
        model.primitives[i].updateShaders(ren, actor, publicAPI);
        const program = model.primitives[i].getProgram();
        const mode = model.primitives[i].getOpenGLMode(representation);
        const normalMatrixUsed = program.isUniformUsed('normalMatrix');
        const mcvcMatrixUsed = program.isUniformUsed('MCVCMatrix');
        if (model.hardwareSupport) {
          if (model.extension) {
            model.extension.drawArraysInstancedANGLE(mode, 0, cabo.getElementCount(), numPts);
          } else {
            gl.drawArraysInstanced(mode, 0, cabo.getElementCount(), numPts);
          }
        } else {
          // draw the array multiple times with different cam matrix
          for (let p = 0; p < numPts; ++p) {
            if (compositePass) {
              model._openGLRenderer.getSelector().renderCompositeIndex(p);
            }
            publicAPI.updateGlyphShaderParameters(normalMatrixUsed, mcvcMatrixUsed, model.primitives[i], carray, garray, narray, p, compositePass ? model._openGLRenderer.getSelector() : null);
            gl.drawArrays(mode, 0, cabo.getElementCount());
          }
        }
      }
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.glyphBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed('gMatrix')) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.matrixBuffer, 'gMatrix', 0, 64, model.context.FLOAT, 4, false, 1)) {
          Glyph3DMapper_vtkErrorMacro('Error setting gMatrix in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gMatrix');
      }
      if (cellBO.getProgram().isAttributeUsed('gNormal')) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.normalBuffer, 'gNormal', 0, 36, model.context.FLOAT, 3, false, 1)) {
          Glyph3DMapper_vtkErrorMacro('Error setting gNormal in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gNormal');
      }
      if (cellBO.getProgram().isAttributeUsed('gColor')) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.colorBuffer, 'gColor', 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          Glyph3DMapper_vtkErrorMacro('Error setting gColor in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gColor');
      }
      if (cellBO.getProgram().isAttributeUsed('mapperIndexVS')) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.pickBuffer, 'mapperIndexVS', 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          Glyph3DMapper_vtkErrorMacro('Error setting mapperIndexVS in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('mapperIndexVS');
      }
      superClass.setMapperShaderParameters(cellBO, ren, actor);
      cellBO.getAttributeUpdateTime().modified();
      return;
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    model.renderable.buildArrays();

    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < model.renderable.getBuildTime().getMTime()) {
      return true;
    }
    return superClass.getNeedToRebuildBufferObjects(ren, actor);
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    if (superClass.getNeedToRebuildShaders(cellBO, ren, actor) || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    if (model.hardwareSupport) {
      // update the buffer objects if needed
      const garray = model.renderable.getMatrixArray();
      const narray = model.renderable.getNormalArray();
      const carray = model.renderable.getColorArray();
      if (!model.matrixBuffer) {
        model.matrixBuffer = BufferObject/* default.newInstance */.Ay.newInstance();
        model.matrixBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.normalBuffer = BufferObject/* default.newInstance */.Ay.newInstance();
        model.normalBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.colorBuffer = BufferObject/* default.newInstance */.Ay.newInstance();
        model.colorBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.pickBuffer = BufferObject/* default.newInstance */.Ay.newInstance();
        model.pickBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (model.renderable.getBuildTime().getMTime() > model.glyphBOBuildTime.getMTime()) {
        model.matrixBuffer.upload(garray, ObjectType.ARRAY_BUFFER);
        model.normalBuffer.upload(narray, ObjectType.ARRAY_BUFFER);
        if (carray) {
          model.colorBuffer.upload(carray.getData(), ObjectType.ARRAY_BUFFER);
        } else {
          model.colorBuffer.releaseGraphicsResources();
        }
        const numPts = garray.length / 16;
        const parray = new Uint8Array(4 * numPts);
        for (let i = 0; i < numPts; ++i) {
          let value = i + 1;
          const offset = i * 4;
          parray[offset] = value % 256;
          value -= parray[offset];
          value /= 256;
          parray[offset + 1] = value % 256;
          value -= parray[offset + 1];
          value /= 256;
          parray[offset + 2] = value % 256;
          parray[offset + 3] = 255;
        }
        model.pickBuffer.upload(parray, ObjectType.ARRAY_BUFFER);
        model.glyphBOBuildTime.modified();
      }
    }
    return superClass.buildBufferObjects(ren, actor);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Glyph3DMapper_DEFAULT_VALUES = {
  normalMatrix: null,
  mcpcMatrix: null,
  mcwcMatrix: null
};

// ----------------------------------------------------------------------------

function Glyph3DMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Glyph3DMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  PolyDataMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  model.tmpMat3 = esm/* mat3.identity */.w0.identity(new Float64Array(9));
  model.normalMatrix = esm/* mat3.identity */.w0.identity(new Float64Array(9));
  model.mcpcMatrix = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.mcvcMatrix = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.tmpColor = [];
  model.glyphBOBuildTime = {};
  (0,macros2.o)(model.glyphBOBuildTime, {
    mtime: 0
  });

  // Object methods
  vtkOpenGLGlyph3DMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Glyph3DMapper_newInstance = (0,macros2.n)(Glyph3DMapper_extend, 'vtkOpenGLGlyph3DMapper');

// ----------------------------------------------------------------------------

var vtkGlyph3DMapper = {
  newInstance: Glyph3DMapper_newInstance,
  extend: Glyph3DMapper_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkGlyph3DMapper', Glyph3DMapper_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var ImageMapper = __webpack_require__(6814);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
var ImageSlice = __webpack_require__(64501);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var PixelSpaceCallbackMapper = __webpack_require__(68464);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var Renderer = __webpack_require__(63819);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
var Skybox = __webpack_require__(92530);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var BufferObject_Constants = __webpack_require__(60003);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl.js
var vtkSphereMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n";



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS_glsl = __webpack_require__(23159);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/SphereMapper.js











const {
  vtkErrorMacro: SphereMapper_vtkErrorMacro
} = macros2.c;

// ----------------------------------------------------------------------------
// vtkOpenGLSphereMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLSphereMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLSphereMapper');

  // Capture 'parentClass' api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkSphereMapperVS;
    shaders.Fragment = vtkPolyDataFS_glsl.v;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\n', 'uniform mat4 MCVCMatrix;']).result;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;

    // we create vertexVC below, so turn off the default
    // implementation
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;\n']).result;

    // for lights kit and positional the VCPC matrix is already defined
    // so don't redefine it
    const replacement = ['uniform float invertedDepth;\n', 'uniform int cameraParallel;\n', 'varying float radiusVCVSOutput;\n', 'varying vec3 centerVCVSOutput;\n', 'uniform mat4 VCPCMatrix;\n'];
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;
    let fragString = '';
    if (model.context.getExtension('EXT_frag_depth')) {
      fragString = 'gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Depth::Impl', [
    // compute the eye position and unit direction
    '  vec3 EyePos;\n', '  vec3 EyeDir;\n', '  if (cameraParallel != 0) {\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\n', '  else {\n', '    EyeDir = vertexVC.xyz;\n', '    EyePos = vec3(0.0,0.0,0.0);\n', '    float lengthED = length(EyeDir);\n', '    EyeDir = normalize(EyeDir);\n',
    // we adjust the EyePos to be closer if it is too far away
    // to prevent floating point precision noise
    '    if (lengthED > radiusVCVSOutput*3.0) {\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n', '    }\n',
    // translate to Sphere center
    '  EyePos = EyePos - centerVCVSOutput;\n',
    // scale to radius 1.0
    '  EyePos = EyePos/radiusVCVSOutput;\n',
    // find the intersection
    '  float b = 2.0*dot(EyePos,EyeDir);\n', '  float c = dot(EyePos,EyePos) - 1.0;\n', '  float d = b*b - 4.0*c;\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n', '  if (d < 0.0) { discard; }\n', '  else {\n', '    float t = (-b - invertedDepth*sqrt(d))*0.5;\n',
    // compute the normal, for unit sphere this is just
    // the intersection point
    '    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n',
    // compute the intersection point in VC
    '    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n', '    }\n',
    // compute the pixel's depth
    // ' normalVCVSOutput = vec3(0,0,1);\n'
    '  vec4 pos = VCPCMatrix * vertexVC;\n', fragString]).result;

    // Strip out the normal line -- the normal is computed as part of the depth
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Normal::Impl', '').result;
    if (model.haveSeenDepthRequest) {
      // special depth impl
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed('offsetMC')) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'offsetMC', 12,
      // 12:this->VBO->ColorOffset+sizeof(float)
      cellBO.getCABO().getStride(), model.context.FLOAT, 2, false)) {
        SphereMapper_vtkErrorMacro("Error setting 'offsetMC' in shader VAO.");
      }
    }
    if (cellBO.getProgram().isUniformUsed('invertedDepth')) {
      cellBO.getProgram().setUniformf('invertedDepth', model.invert ? -1.0 : 1.0);
    }
    if (cellBO.getProgram().isUniformUsed('scaleFactor')) {
      // apply scaling factor only if a scale array has been provided.
      const poly = model.currentInput;
      const pointData = poly.getPointData();
      if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
        cellBO.getProgram().setUniformf('scaleFactor', model.renderable.getScaleFactor());
      } else {
        cellBO.getProgram().setUniformf('scaleFactor', 1.0);
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed('VCPCMatrix')) {
      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);
    }
    if (program.isUniformUsed('MCVCMatrix')) {
      if (!actor.getIsIdentity()) {
        const actMats = model.openGLActor.getKeyMatrices();
        const tmp4 = new Float64Array(16);
        esm/* mat4.multiply */.pB.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix('MCVCMatrix', tmp4);
      } else {
        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);
      }
    }
    if (program.isUniformUsed('cameraParallel')) {
      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();
    const vbo = model.primitives[model.primTypes.Tris].getCABO();
    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    const pointSize = 5; // x,y,z,orientation1,orientation2
    let scales = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    let colorData = null;
    let colorComponents = 0;
    let packedUCVBO = null;
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(0);
      vbo.setColorBOStride(4);
      colorData = c.getData();
      packedUCVBO = new Uint8Array(3 * numPoints * 4);
      if (!vbo.getColorBO()) {
        vbo.setColorBO(BufferObject/* default.newInstance */.Ay.newInstance());
      }
      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    } else if (vbo.getColorBO()) {
      vbo.setColorBO(null);
    }
    vbo.setColorComponents(colorComponents);
    const packedVBO = new Float32Array(pointSize * numPoints * 3);
    vbo.setStride(pointSize * 4);
    const cos30 = Math.cos((0,Core_Math.r)(30.0));
    let pointIdx = 0;
    let colorIdx = 0;

    //
    // Generate points and point data for sides
    //
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0; i < numPoints; ++i) {
      let radius = model.renderable.getRadius();
      if (scales) {
        radius = scales[i];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = -2.0 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        colorIdx = i * colorComponents;
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 2.0 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 0.0;
      packedVBO[vboIdx++] = 2.0 * radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, BufferObject_Constants/* ObjectType */.a.ARRAY_BUFFER);
    if (c) {
      vbo.getColorBO().upload(packedUCVBO, BufferObject_Constants/* ObjectType */.a.ARRAY_BUFFER);
    }
    model.VBOBuildTime.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const SphereMapper_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function SphereMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, SphereMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  PolyDataMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLSphereMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const SphereMapper_newInstance = (0,macros2.n)(SphereMapper_extend, 'vtkOpenGLSphereMapper');

// ----------------------------------------------------------------------------

var vtkSphereMapper = {
  newInstance: SphereMapper_newInstance,
  extend: SphereMapper_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkSphereMapper', SphereMapper_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl.js
var vtkStickMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n";



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/StickMapper.js










const {
  vtkErrorMacro: StickMapper_vtkErrorMacro
} = macros2.c;

// ----------------------------------------------------------------------------
// vtkOpenGLStickMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLStickMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLStickMapper');

  // Capture 'parentClass' api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkStickMapperVS;
    shaders.Fragment = vtkPolyDataFS_glsl.v;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\n', 'uniform mat4 MCVCMatrix;']).result;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Dec', 'varying vec4 vertexVCVSOutput;').result;

    // we create vertexVC below, so turn off the default
    // implementation
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Impl', '  vec4 vertexVC = vertexVCVSOutput;\n').result;

    // for lights kit and positional the VCPC matrix is already defined
    // so don't redefine it
    const replacement = ['uniform int cameraParallel;\n', 'varying float radiusVCVSOutput;\n', 'varying vec3 orientVCVSOutput;\n', 'varying float lengthVCVSOutput;\n', 'varying vec3 centerVCVSOutput;\n', 'uniform mat4 VCPCMatrix;\n'];
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;
    let fragString = '';
    if (model.context.getExtension('EXT_frag_depth')) {
      fragString = '  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    // see https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Depth::Impl', [
    // compute the eye position and unit direction
    '  vec3 EyePos;\n', '  vec3 EyeDir;\n', '  if (cameraParallel != 0) {\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\n', '  else {\n', '    EyeDir = vertexVC.xyz;\n', '    EyePos = vec3(0.0,0.0,0.0);\n', '    float lengthED = length(EyeDir);\n', '    EyeDir = normalize(EyeDir);\n',
    // we adjust the EyePos to be closer if it is too far away
    // to prevent floating point precision noise
    '    if (lengthED > radiusVCVSOutput*3.0) {\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n', '    }\n',
    // translate to Stick center
    '  EyePos = EyePos - centerVCVSOutput;\n',
    // rotate to new basis
    // base1, base2, orientVC
    '  vec3 base1;\n', '  if (abs(orientVCVSOutput.z) < 0.99) {\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n', '  else {\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n', '  vec3 base2 = cross(orientVCVSOutput,base1);\n', '  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n', '  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n',
    // scale by radius
    '  EyePos = EyePos/radiusVCVSOutput;\n',
    // find the intersection
    '  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n', '  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n', '  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n', '  float d = b*b - 4.0*a*c;\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n', '  if (d < 0.0) { discard; }\n', '  else {\n', '    float t =  (-b - sqrt(d))/(2.0*a);\n', '    float tz = EyePos.z + t*EyeDir.z;\n', '    vec3 iPoint = EyePos + t*EyeDir;\n', '    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n',
    // test for end cap
    '      float t2 = (-b + sqrt(d))/(2.0*a);\n', '      float tz2 = EyePos.z + t2*EyeDir.z;\n', '      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n', '      else {\n', '        normalVCVSOutput = orientVCVSOutput;\n', '        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n', '        iPoint = EyePos + t3*EyeDir;\n', '        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n', '        }\n', '      }\n', '    else {\n',
    // The normal is the iPoint.xy rotated back into VC
    '      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n',
    // rescale rerotate and translate
    '      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n', '      }\n', '    }\n',
    //    '  vec3 normalVC = vec3(0.0,0.0,1.0);\n'
    // compute the pixel's depth
    '  vec4 pos = VCPCMatrix * vertexVC;\n', fragString]).result;

    // Strip out the normal line -- the normal is computed as part of the depth
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Normal::Impl', '').result;
    if (model.haveSeenDepthRequest) {
      // special depth impl
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed('orientMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'orientMC', 12,
        // after X Y Z
        cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          StickMapper_vtkErrorMacro("Error setting 'orientMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed('offsetMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'offsetMC', 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {
          StickMapper_vtkErrorMacro("Error setting 'offsetMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed('radiusMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'radiusMC', 24,
        // X Y Z OX OY OZ
        cellBO.getCABO().getStride(), model.context.FLOAT, 1, false)) {
          StickMapper_vtkErrorMacro("Error setting 'radiusMC' in shader VAO.");
        }
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed('VCPCMatrix')) {
      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);
    }
    if (!actor.getIsIdentity()) {
      const actMats = model.openGLActor.getKeyMatrices();
      if (program.isUniformUsed('MCVCMatrix')) {
        const tmp4 = new Float64Array(16);
        esm/* mat4.multiply */.pB.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix('MCVCMatrix', tmp4);
      }
      if (program.isUniformUsed('normalMatrix')) {
        const anorms = new Float64Array(9);
        esm/* mat3.multiply */.w0.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);
        program.setUniformMatrix3x3('normalMatrix', anorms);
      }
    } else {
      if (program.isUniformUsed('MCVCMatrix')) {
        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);
      }
      if (program.isUniformUsed('normalMatrix')) {
        program.setUniformMatrix3x3('normalMatrix', keyMats.normalMatrix);
      }
    }
    if (program.isUniformUsed('cameraParallel')) {
      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();
    const vbo = model.primitives[model.primTypes.Tris].getCABO();
    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    let pointSize = 3; // x,y,z

    // three more floats for orientation + 1 for radius
    pointSize += 4;
    let colorData = null;
    let colorComponents = 0;
    vbo.setColorBOStride(4);
    if (!vbo.getColorBO()) {
      vbo.setColorBO(BufferObject/* default.newInstance */.Ay.newInstance());
    }
    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(4);
      colorData = c.getData();
      vbo.setColorBOStride(8);
    }
    vbo.setColorComponents(colorComponents);
    vbo.setStride(pointSize * 4);

    // Create a buffer, and copy the data over.
    const packedVBO = new Float32Array(pointSize * numPoints * 12);
    const packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));
    let scales = null;
    let orientationArray = null;
    //
    // Generate points and point data for sides
    //
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {
      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();
    } else {
      StickMapper_vtkErrorMacro(['Error setting orientationArray.\n', 'You have to specify the stick orientation']);
    }

    // Vertices
    // 013 - 032 - 324 - 453
    //
    //       _.4---_.5
    //    .-*   .-*
    //   2-----3
    //   |    /|
    //   |   / |
    //   |  /  |
    //   | /   |
    //   |/    |
    //   0-----1
    //
    // coord for each points
    // 0: 000
    // 1: 100
    // 2: 001
    // 3: 101
    // 4: 011
    // 5: 111

    // prettier-ignore
    const verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];
    let pointIdx = 0;
    let colorIdx = 0;
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0; i < numPoints; ++i) {
      let length = model.renderable.getLength();
      let radius = model.renderable.getRadius();
      if (scales) {
        length = scales[i * 2];
        radius = scales[i * 2 + 1];
      }
      for (let j = 0; j < verticesArray.length; ++j) {
        pointIdx = i * 3;
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        pointIdx = i * 3;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = radius;
        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);
        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;
        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;
        packedUCVBO[ucIdx++] = 255;
        colorIdx = i * colorComponents;
        if (colorData) {
          packedUCVBO[ucIdx++] = colorData[colorIdx];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
        }
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, BufferObject_Constants/* ObjectType */.a.ARRAY_BUFFER);
    vbo.getColorBO().upload(packedUCVBO, BufferObject_Constants/* ObjectType */.a.ARRAY_BUFFER);
    model.VBOBuildTime.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const StickMapper_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function StickMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, StickMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  PolyDataMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLStickMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const StickMapper_newInstance = (0,macros2.n)(StickMapper_extend, 'vtkOpenGLStickMapper');

// ----------------------------------------------------------------------------

var vtkStickMapper = {
  newInstance: StickMapper_newInstance,
  extend: StickMapper_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkStickMapper', StickMapper_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
var Volume = __webpack_require__(8126);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js + 2 modules
var VolumeMapper = __webpack_require__(95785);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js
var SceneGraph_ViewNodeFactory = __webpack_require__(84784);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Texture_Constants = __webpack_require__(52271);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
var resourceSharingHelper = __webpack_require__(90919);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getBufferConfiguration.js
var getBufferConfiguration = __webpack_require__(99576);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLVolumeMapper.js









function vtkStreamingOpenGLVolumeMapper(publicAPI, model) {
    model.classHierarchy.push('vtkStreamingOpenGLVolumeMapper');
    publicAPI.buildBufferObjects = (ren, actor) => {
        const image = model.currentInput;
        if (!image) {
            return;
        }
        const vprop = actor.getProperty();
        if (!model.jitterTexture.getHandle()) {
            const oTable = new Uint8Array(32 * 32);
            for (let i = 0; i < 32 * 32; ++i) {
                oTable[i] = 255.0 * Math.random();
            }
            model.jitterTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.jitterTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.jitterTexture.create2DFromRaw(32, 32, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, oTable);
        }
        const { numberOfComponents: numIComps } = image.get('numberOfComponents');
        const useIndependentComps = publicAPI.useIndependentComponents(vprop);
        const scalarOpacityFunc = vprop.getScalarOpacity();
        const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);
        let toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(scalarOpacityFunc, useIndependentComps, numIComps);
        const reBuildOp = !opTex?.oglObject || opTex.hash !== toString;
        if (reBuildOp) {
            model.opacityTexture = Texture/* default.newInstance */.Ay.newInstance();
            model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
            const oWidth = 1024;
            const oSize = oWidth * 2 * numIComps;
            const ofTable = new Float32Array(oSize);
            const tmpTable = new Float32Array(oWidth);
            for (let c = 0; c < numIComps; ++c) {
                const ofun = vprop.getScalarOpacity(c);
                const opacityFactor = publicAPI.getCurrentSampleDistance(ren) /
                    vprop.getScalarOpacityUnitDistance(c);
                const oRange = ofun.getRange();
                ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
                for (let i = 0; i < oWidth; ++i) {
                    ofTable[c * oWidth * 2 + i] =
                        1.0 - (1.0 - tmpTable[i]) ** opacityFactor;
                    ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];
                }
            }
            model.opacityTexture.resetFormatAndType();
            model.opacityTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.opacityTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            if (model._openGLRenderWindow.getWebgl2() &&
                model.context.getExtension('OES_texture_float') &&
                model.context.getExtension('OES_texture_float_linear')) {
                model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, Constants/* VtkDataTypes */.JA.FLOAT, ofTable);
            }
            else {
                const oTable = new Uint8ClampedArray(oSize);
                for (let i = 0; i < oSize; ++i) {
                    oTable[i] = 255.0 * ofTable[i];
                }
                model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, oTable);
            }
            if (scalarOpacityFunc) {
                model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, toString);
                if (scalarOpacityFunc !== model._scalarOpacityFunc) {
                    model._openGLRenderWindow.registerGraphicsResourceUser(scalarOpacityFunc, publicAPI);
                    model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalarOpacityFunc, publicAPI);
                }
                model._scalarOpacityFunc = scalarOpacityFunc;
            }
        }
        else {
            model.opacityTexture = opTex.oglObject;
        }
        const colorTransferFunc = vprop.getRGBTransferFunction();
        toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(colorTransferFunc, useIndependentComps, numIComps);
        const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
        const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
        if (reBuildC) {
            model.colorTexture = Texture/* default.newInstance */.Ay.newInstance();
            model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
            const cWidth = 1024;
            const cSize = cWidth * 2 * numIComps * 3;
            const cTable = new Uint8ClampedArray(cSize);
            const tmpTable = new Float32Array(cWidth * 3);
            for (let c = 0; c < numIComps; ++c) {
                const cfun = vprop.getRGBTransferFunction(c);
                const cRange = cfun.getRange();
                cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
                for (let i = 0; i < cWidth * 3; ++i) {
                    cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
                    cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
                }
            }
            model.colorTexture.resetFormatAndType();
            model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
            if (colorTransferFunc) {
                model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
                if (colorTransferFunc !== model._colorTransferFunc) {
                    model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
                    model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
                }
                model._colorTransferFunc = colorTransferFunc;
            }
        }
        else {
            model.colorTexture = cTex.oglObject;
        }
        publicAPI.updateLabelOutlineThicknessTexture(actor);
        toString = `${image.getMTime()}-${model.scalarTexture.getMTime()}`;
        if (model.scalarTextureString !== toString) {
            const dims = image.getDimensions();
            model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
            model.scalarTexture.enableUseHalfFloat(false);
            const previousTextureParameters = model.scalarTexture.getTextureParameters();
            const dataType = image.get('dataType').dataType;
            let shouldReset = true;
            if (previousTextureParameters?.dataType === dataType) {
                if (previousTextureParameters?.width === dims[0]) {
                    if (previousTextureParameters?.height === dims[1]) {
                        if (previousTextureParameters?.depth === dims[2]) {
                            shouldReset = false;
                        }
                    }
                }
            }
            if (shouldReset) {
                const norm16Ext = model.context.getExtension('EXT_texture_norm16');
                model.scalarTexture.setOglNorm16Ext(norm16Ext);
                model.scalarTexture.resetFormatAndType();
                model.scalarTexture.setTextureParameters({
                    width: dims[0],
                    height: dims[1],
                    depth: dims[2],
                    numberOfComponents: numIComps,
                    dataType,
                });
                model.scalarTexture.create3DFromRaw(dims[0], dims[1], dims[2], numIComps, dataType, null);
                model.scalarTexture.update3DFromRaw();
            }
            else {
                model.scalarTexture.deactivate();
                model.scalarTexture.update3DFromRaw();
            }
            model.scalarTextureString = toString;
        }
        if (!model.tris.getCABO().getElementCount()) {
            const ptsArray = new Float32Array(12);
            for (let i = 0; i < 4; i++) {
                ptsArray[i * 3] = (i % 2) * 2 - 1.0;
                ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
                ptsArray[i * 3 + 2] = -1.0;
            }
            const cellArray = new Uint16Array(8);
            cellArray[0] = 3;
            cellArray[1] = 0;
            cellArray[2] = 1;
            cellArray[3] = 3;
            cellArray[4] = 3;
            cellArray[5] = 0;
            cellArray[6] = 3;
            cellArray[7] = 2;
            const points = DataArray/* default.newInstance */.Ay.newInstance({
                numberOfComponents: 3,
                values: ptsArray,
            });
            points.setName('points');
            const cells = DataArray/* default.newInstance */.Ay.newInstance({
                numberOfComponents: 1,
                values: cellArray,
            });
            model.tris.getCABO().createVBO(cells, 'polys', Property_Constants/* Representation */.YL.SURFACE, {
                points,
                cellOffset: 0,
            });
        }
        model.VBOBuildTime.modified();
    };
    publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
        if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() ||
            model.VBOBuildTime.getMTime() < actor.getMTime() ||
            model.VBOBuildTime.getMTime() < model.renderable.getMTime() ||
            model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() ||
            model.VBOBuildTime.getMTime() < model.currentInput.getMTime() ||
            model.VBOBuildTime.getMTime() < model.scalarTexture?.getMTime() ||
            model.VBOBuildTime.getMTime() < model.colorTexture?.getMTime() ||
            model.VBOBuildTime.getMTime() <
                model.labelOutlineThicknessTexture?.getMTime() ||
            !model.scalarTexture?.getHandle() ||
            !model.colorTexture?.getHandle() ||
            !model.labelOutlineThicknessTexture?.getHandle()) {
            return true;
        }
        return false;
    };
}
const vtkStreamingOpenGLVolumeMapper_DEFAULT_VALUES = {};
function vtkStreamingOpenGLVolumeMapper_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkStreamingOpenGLVolumeMapper_DEFAULT_VALUES, initialValues);
    VolumeMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);
    model.scalarTexture = initialValues.scalarTexture;
    model.previousState = {};
    vtkStreamingOpenGLVolumeMapper(publicAPI, model);
}
const vtkStreamingOpenGLVolumeMapper_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkStreamingOpenGLVolumeMapper_extend, 'vtkStreamingOpenGLVolumeMapper');
/* harmony default export */ const vtkClasses_vtkStreamingOpenGLVolumeMapper = ({ newInstance: vtkStreamingOpenGLVolumeMapper_newInstance, extend: vtkStreamingOpenGLVolumeMapper_extend });

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLViewNodeFactory.js


















const CLASS_MAPPING = Object.create(null);
function registerOverride(className, fn) {
    CLASS_MAPPING[className] = fn;
}
function vtkStreamingOpenGLViewNodeFactory(publicAPI, model) {
    model.classHierarchy.push('vtkStreamingOpenGLViewNodeFactory');
    publicAPI.createNode = (dataObject) => {
        if (dataObject.isDeleted()) {
            return null;
        }
        let cpt = 0;
        let className = dataObject.getClassName(cpt++);
        let isObject = false;
        const keys = Object.keys(model.overrides);
        while (className && !isObject) {
            if (keys.includes(className)) {
                isObject = true;
            }
            else {
                className = dataObject.getClassName(cpt++);
            }
        }
        if (!isObject) {
            return null;
        }
        const initialValues = model.getModelInitialValues(dataObject);
        const vn = model.overrides[className](initialValues);
        vn.setMyFactory(publicAPI);
        return vn;
    };
    model.overrides = CLASS_MAPPING;
    model.getModelInitialValues = (dataObject) => {
        const initialValues = {};
        const className = dataObject.getClassName();
        if (className === 'vtkSharedVolumeMapper') {
            initialValues.scalarTexture = dataObject.getScalarTexture();
        }
        return initialValues;
    };
}
const vtkStreamingOpenGLViewNodeFactory_DEFAULT_VALUES = {};
function vtkStreamingOpenGLViewNodeFactory_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkStreamingOpenGLViewNodeFactory_DEFAULT_VALUES, initialValues);
    SceneGraph_ViewNodeFactory/* default.extend */.Ay.extend(publicAPI, model, initialValues);
    vtkStreamingOpenGLViewNodeFactory(publicAPI, model);
    registerOverride('vtkActor', Actor/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkActor2D', Actor2D/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkCamera', Camera/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkGlyph3DMapper', vtkGlyph3DMapper.newInstance);
    registerOverride('vtkImageMapper', ImageMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkImageSlice', ImageSlice/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkMapper', PolyDataMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkPixelSpaceCallbackMapper', PixelSpaceCallbackMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkRenderer', Renderer/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkSkybox', Skybox/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkSphereMapper', vtkSphereMapper.newInstance);
    registerOverride('vtkStickMapper', vtkStickMapper.newInstance);
    registerOverride('vtkTexture', Texture/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkVolume', Volume/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkVolumeMapper', VolumeMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkSharedVolumeMapper', vtkClasses_vtkStreamingOpenGLVolumeMapper.newInstance);
}
const vtkStreamingOpenGLViewNodeFactory_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkStreamingOpenGLViewNodeFactory_extend, 'vtkStreamingOpenGLViewNodeFactory');
/* harmony default export */ const vtkClasses_vtkStreamingOpenGLViewNodeFactory = ({ newInstance: vtkStreamingOpenGLViewNodeFactory_newInstance, extend: vtkStreamingOpenGLViewNodeFactory_extend });

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLRenderWindow.js



function vtkStreamingOpenGLRenderWindow(publicAPI, model) {
    model.classHierarchy.push('vtkStreamingOpenGLRenderWindow');
}
function vtkStreamingOpenGLRenderWindow_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, initialValues);
    RenderWindow_vtkRenderWindow.extend(publicAPI, model, initialValues);
    model.myFactory = vtkClasses_vtkStreamingOpenGLViewNodeFactory.newInstance();
    registerOverride('vtkRenderWindow', vtkStreamingOpenGLRenderWindow_newInstance);
    vtkStreamingOpenGLRenderWindow(publicAPI, model);
}
const vtkStreamingOpenGLRenderWindow_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkStreamingOpenGLRenderWindow_extend, 'vtkStreamingOpenGLRenderWindow');
/* harmony default export */ const vtkClasses_vtkStreamingOpenGLRenderWindow = ({ newInstance: vtkStreamingOpenGLRenderWindow_newInstance, extend: vtkStreamingOpenGLRenderWindow_extend });

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js + 2 modules
var Core_Renderer = __webpack_require__(50036);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor/Constants.js
const Device = {
  Unknown: 0,
  LeftController: 1,
  RightController: 2
};
const Input = {
  Unknown: 0,
  Trigger: 1,
  TrackPad: 2,
  Grip: 3,
  Thumbstick: 4,
  A: 5,
  B: 6,
  ApplicationMenu: 7 // Not exposed in WebXR API
};

const Axis = {
  Unknown: 0,
  TouchpadX: 1,
  TouchpadY: 2,
  ThumbstickX: 3,
  ThumbstickY: 4
};
var RenderWindowInteractor_Constants_Constants = {
  Device,
  Input,
  Axis
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor.js




const {
  Device: RenderWindowInteractor_Device,
  Input: RenderWindowInteractor_Input
} = RenderWindowInteractor_Constants_Constants;
const {
  vtkWarningMacro,
  vtkErrorMacro: RenderWindowInteractor_vtkErrorMacro,
  normalizeWheel,
  vtkOnceErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

const EMPTY_MOUSE_EVENT = {
  ctrlKey: false,
  altKey: false,
  shiftKey: false
};
const deviceInputMap = {
  'xr-standard': [RenderWindowInteractor_Input.Trigger, RenderWindowInteractor_Input.Grip, RenderWindowInteractor_Input.TrackPad, RenderWindowInteractor_Input.Thumbstick, RenderWindowInteractor_Input.A, RenderWindowInteractor_Input.B]
};
const handledEvents = ['StartAnimation', 'Animation', 'EndAnimation', 'PointerEnter', 'PointerLeave', 'MouseEnter', 'MouseLeave', 'StartMouseMove', 'MouseMove', 'EndMouseMove', 'LeftButtonPress', 'LeftButtonRelease', 'MiddleButtonPress', 'MiddleButtonRelease', 'RightButtonPress', 'RightButtonRelease', 'KeyPress', 'KeyDown', 'KeyUp', 'StartMouseWheel', 'MouseWheel', 'EndMouseWheel', 'StartPinch', 'Pinch', 'EndPinch', 'StartPan', 'Pan', 'EndPan', 'StartRotate', 'Rotate', 'EndRotate', 'Button3D', 'Move3D', 'StartPointerLock', 'EndPointerLock', 'StartInteraction', 'Interaction', 'EndInteraction', 'AnimationFrameRateUpdate'];
function preventDefault(event) {
  if (event.cancelable) {
    event.preventDefault();
  }
}
function pointerCacheToPositions(cache) {
  const positions = Object.create(null);
  cache.forEach(_ref => {
    let {
      pointerId,
      position
    } = _ref;
    positions[pointerId] = position;
  });
  return positions;
}

// ----------------------------------------------------------------------------
// vtkRenderWindowInteractor methods
// ----------------------------------------------------------------------------

function vtkRenderWindowInteractor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderWindowInteractor');

  // Capture "parentClass" api for internal use
  const superClass = {
    ...publicAPI
  };

  // Initialize list of requesters
  const animationRequesters = new Set();

  // map from pointerId to { pointerId: number, position: [x, y] }
  const pointerCache = new Map();

  // Factor to apply on wheel spin.
  let wheelCoefficient = 1;

  // Public API methods

  //----------------------------------------------------------------------
  publicAPI.start = () => {
    // Let the compositing handle the event loop if it wants to.
    // if (publicAPI.HasObserver(vtkCommand::StartEvent) && !publicAPI.HandleEventLoop) {
    //   publicAPI.invokeEvent({ type: 'StartEvent' });
    //   return;
    // }

    // As a convenience, initialize if we aren't initialized yet.
    if (!model.initialized) {
      publicAPI.initialize();
      if (!model.initialized) {
        return;
      }
    }
    // Pass execution to the subclass which will run the event loop,
    // this will not return until TerminateApp is called.
    publicAPI.startEventLoop();
  };

  //----------------------------------------------------------------------
  publicAPI.setRenderWindow = aren => {
    RenderWindowInteractor_vtkErrorMacro('you want to call setView(view) instead of setRenderWindow on a vtk.js interactor');
  };

  //----------------------------------------------------------------------
  publicAPI.setInteractorStyle = style => {
    if (model.interactorStyle !== style) {
      if (model.interactorStyle != null) {
        model.interactorStyle.setInteractor(null);
      }
      model.interactorStyle = style;
      if (model.interactorStyle != null) {
        if (model.interactorStyle.getInteractor() !== publicAPI) {
          model.interactorStyle.setInteractor(publicAPI);
        }
      }
    }
  };

  //---------------------------------------------------------------------
  publicAPI.initialize = () => {
    model.initialized = true;
    publicAPI.enable();
    publicAPI.render();
  };
  publicAPI.enable = () => publicAPI.setEnabled(true);
  publicAPI.disable = () => publicAPI.setEnabled(false);
  publicAPI.startEventLoop = () => vtkWarningMacro('empty event loop');
  function updateCurrentRenderer(x, y) {
    if (!model._forcedRenderer) {
      model.currentRenderer = publicAPI.findPokedRenderer(x, y);
    }
  }
  publicAPI.getCurrentRenderer = () => {
    if (model.currentRenderer) {
      return model.currentRenderer;
    }
    updateCurrentRenderer(0, 0);
    return model.currentRenderer;
  };
  function _getScreenEventPositionFor(source) {
    const canvas = model._view.getCanvas();
    const bounds = canvas.getBoundingClientRect();
    const scaleX = canvas.width / bounds.width;
    const scaleY = canvas.height / bounds.height;
    const position = {
      x: scaleX * (source.clientX - bounds.left),
      y: scaleY * (bounds.height - source.clientY + bounds.top),
      z: 0
    };

    // if multitouch, do not update the current renderer
    if (pointerCache.size <= 1 || !model.currentRenderer) {
      updateCurrentRenderer(position.x, position.y);
    }
    return position;
  }
  // Allow user to override it
  const getScreenEventPositionFor = model._getScreenEventPositionFor || _getScreenEventPositionFor;
  function getModifierKeysFor(event) {
    return {
      controlKey: event.ctrlKey,
      altKey: event.altKey,
      shiftKey: event.shiftKey
    };
  }
  function getKeysFor(event) {
    const modifierKeys = getModifierKeysFor(event);
    const keys = {
      key: event.key,
      keyCode: event.charCode,
      ...modifierKeys
    };
    return keys;
  }
  function getDeviceTypeFor(event) {
    return event.pointerType || '';
  }
  const _bindEvents = () => {
    if (model.container === null) {
      return;
    }
    const {
      container
    } = model;
    container.addEventListener('contextmenu', preventDefault);
    container.addEventListener('wheel', publicAPI.handleWheel);
    container.addEventListener('DOMMouseScroll', publicAPI.handleWheel);
    container.addEventListener('pointerenter', publicAPI.handlePointerEnter);
    container.addEventListener('pointerleave', publicAPI.handlePointerLeave);
    container.addEventListener('pointermove', publicAPI.handlePointerMove, {
      passive: false
    });
    container.addEventListener('pointerdown', publicAPI.handlePointerDown, {
      passive: false
    });
    container.addEventListener('pointerup', publicAPI.handlePointerUp);
    container.addEventListener('pointercancel', publicAPI.handlePointerCancel);
    document.addEventListener('keypress', publicAPI.handleKeyPress);
    document.addEventListener('keydown', publicAPI.handleKeyDown);
    document.addEventListener('keyup', publicAPI.handleKeyUp);
    document.addEventListener('pointerlockchange', publicAPI.handlePointerLockChange);

    // using touchAction is more performant than preventDefault
    // in a touchstart handler.
    container.style.touchAction = 'none';
    container.style.userSelect = 'none';
    // disables tap highlight for when cursor is pointer
    container.style.webkitTapHighlightColor = 'rgba(0,0,0,0)';
  };

  // For backward compatibility.
  // Necessary for using unbind/bindEvent without calling setContainer.
  publicAPI.bindEvents = container => {
    if (container === null) {
      return;
    }
    const res = superClass.setContainer(container);
    if (res) {
      _bindEvents();
    }
  };
  const _unbindEvents = () => {
    // Clear any previous timeouts and state variables that control mouse / touchpad behavior.
    clearTimeout(model.moveTimeoutID);
    clearTimeout(model.wheelTimeoutID);
    model.moveTimeoutID = 0;
    model.wheelTimeoutID = 0;
    wheelCoefficient = 1.0;
    const {
      container
    } = model;
    if (container) {
      container.removeEventListener('contextmenu', preventDefault);
      container.removeEventListener('wheel', publicAPI.handleWheel);
      container.removeEventListener('DOMMouseScroll', publicAPI.handleWheel);
      container.removeEventListener('pointerenter', publicAPI.handlePointerEnter);
      container.removeEventListener('pointerleave', publicAPI.handlePointerLeave);
      container.removeEventListener('pointermove', publicAPI.handlePointerMove, {
        passive: false
      });
      container.removeEventListener('pointerdown', publicAPI.handlePointerDown, {
        passive: false
      });
      container.removeEventListener('pointerup', publicAPI.handlePointerUp);
      container.removeEventListener('pointercancel', publicAPI.handlePointerCancel);
    }
    document.removeEventListener('keypress', publicAPI.handleKeyPress);
    document.removeEventListener('keydown', publicAPI.handleKeyDown);
    document.removeEventListener('keyup', publicAPI.handleKeyUp);
    document.removeEventListener('pointerlockchange', publicAPI.handlePointerLockChange);
    pointerCache.clear();
  };
  publicAPI.unbindEvents = () => {
    _unbindEvents();
    superClass.setContainer(null);
  };
  publicAPI.handleKeyPress = event => {
    const data = getKeysFor(event);
    publicAPI.keyPressEvent(data);
  };
  publicAPI.handleKeyDown = event => {
    const data = getKeysFor(event);
    publicAPI.keyDownEvent(data);
  };
  publicAPI.handleKeyUp = event => {
    const data = getKeysFor(event);
    publicAPI.keyUpEvent(data);
  };
  publicAPI.handlePointerEnter = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    publicAPI.pointerEnterEvent(callData);
    if (callData.deviceType === 'mouse') {
      publicAPI.mouseEnterEvent(callData);
    }
  };
  publicAPI.handlePointerLeave = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    publicAPI.pointerLeaveEvent(callData);
    if (callData.deviceType === 'mouse') {
      publicAPI.mouseLeaveEvent(callData);
    }
  };
  publicAPI.handlePointerDown = event => {
    if (event.button > 2 || publicAPI.isPointerLocked()) {
      // ignore events from extra mouse buttons such as `back` and `forward`
      return;
    }
    if (model.preventDefaultOnPointerDown) {
      preventDefault(event);
    }
    if (event.target.hasPointerCapture(event.pointerId)) {
      event.target.releasePointerCapture(event.pointerId);
    }
    model.container.setPointerCapture(event.pointerId);
    if (pointerCache.has(event.pointerId)) {
      vtkWarningMacro('[RenderWindowInteractor] duplicate pointerId detected');
    }
    pointerCache.set(event.pointerId, {
      pointerId: event.pointerId,
      position: getScreenEventPositionFor(event)
    });
    switch (event.pointerType) {
      case 'pen':
      case 'touch':
        publicAPI.handleTouchStart(event);
        break;
      case 'mouse':
      default:
        publicAPI.handleMouseDown(event);
        break;
    }
  };
  publicAPI.handlePointerUp = event => {
    if (pointerCache.has(event.pointerId)) {
      if (model.preventDefaultOnPointerUp) {
        preventDefault(event);
      }
      pointerCache.delete(event.pointerId);
      model.container.releasePointerCapture(event.pointerId);
      switch (event.pointerType) {
        case 'pen':
        case 'touch':
          publicAPI.handleTouchEnd(event);
          break;
        case 'mouse':
        default:
          publicAPI.handleMouseUp(event);
          break;
      }
    }
  };
  publicAPI.handlePointerCancel = event => {
    if (pointerCache.has(event.pointerId)) {
      pointerCache.delete(event.pointerId);
      switch (event.pointerType) {
        case 'pen':
        case 'touch':
          publicAPI.handleTouchEnd(event);
          break;
        case 'mouse':
        default:
          publicAPI.handleMouseUp(event);
          break;
      }
    }
  };
  publicAPI.handlePointerMove = event => {
    if (pointerCache.has(event.pointerId)) {
      const pointer = pointerCache.get(event.pointerId);
      pointer.position = getScreenEventPositionFor(event);
    }
    switch (event.pointerType) {
      case 'pen':
      case 'touch':
        publicAPI.handleTouchMove(event);
        break;
      case 'mouse':
      default:
        publicAPI.handleMouseMove(event);
        break;
    }
  };
  publicAPI.handleMouseDown = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    switch (event.button) {
      case 0:
        publicAPI.leftButtonPressEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonPressEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonPressEvent(callData);
        break;
      default:
        RenderWindowInteractor_vtkErrorMacro(`Unknown mouse button pressed: ${event.button}`);
        break;
    }
  };

  //----------------------------------------------------------------------
  publicAPI.requestPointerLock = () => {
    if (model.container) {
      model.container.requestPointerLock();
    }
  };

  //----------------------------------------------------------------------
  publicAPI.exitPointerLock = () => document.exitPointerLock?.();

  //----------------------------------------------------------------------
  publicAPI.isPointerLocked = () => !!model.container && document.pointerLockElement === model.container;

  //----------------------------------------------------------------------
  publicAPI.handlePointerLockChange = () => {
    if (publicAPI.isPointerLocked()) {
      publicAPI.startPointerLockEvent();
    } else {
      publicAPI.endPointerLockEvent();
    }
  };

  //----------------------------------------------------------------------
  function forceRender() {
    if (model._view && model.enabled && model.enableRender) {
      model.inRender = true;
      model._view.traverseAllPasses();
      model.inRender = false;
    }
    // outside the above test so that third-party code can redirect
    // the render to the appropriate class
    publicAPI.invokeRenderEvent();
  }
  publicAPI.requestAnimation = requestor => {
    if (requestor === undefined) {
      RenderWindowInteractor_vtkErrorMacro(`undefined requester, can not start animating`);
      return;
    }
    if (animationRequesters.has(requestor)) {
      vtkWarningMacro(`requester is already registered for animating`);
      return;
    }
    animationRequesters.add(requestor);
    if (!model.animationRequest && animationRequesters.size === 1 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };

  // continue animating for at least the specified duration of
  // milliseconds.
  publicAPI.extendAnimation = duration => {
    const newEnd = Date.now() + duration;
    model._animationExtendedEnd = Math.max(model._animationExtendedEnd, newEnd);
    if (!model.animationRequest && animationRequesters.size === 0 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.isAnimating = () => model.xrAnimation || model.animationRequest !== null;
  publicAPI.cancelAnimation = function (requestor) {
    let skipWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!animationRequesters.has(requestor)) {
      if (!skipWarning) {
        const requestStr = requestor && requestor.getClassName ? requestor.getClassName() : requestor;
        vtkWarningMacro(`${requestStr} did not request an animation`);
      }
      return;
    }
    animationRequesters.delete(requestor);
    if (model.animationRequest && animationRequesters.size === 0 && Date.now() > model._animationExtendedEnd) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.switchToXRAnimation = () => {
    // cancel existing animation if any
    if (model.animationRequest) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
    }
    model.xrAnimation = true;
  };
  publicAPI.returnFromXRAnimation = () => {
    model.xrAnimation = false;
    if (animationRequesters.size !== 0) {
      model.recentAnimationFrameRate = 10.0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    }
  };
  publicAPI.updateXRGamepads = (xrSession, xrFrame, xrRefSpace) => {
    // watch for when buttons change state and fire events
    xrSession.inputSources.forEach(inputSource => {
      const gripPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.gripSpace, xrRefSpace);
      const targetRayPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.targetRaySpace, xrRefSpace);
      const gamepad = inputSource.gamepad;
      const hand = inputSource.handedness;
      if (!gamepad) {
        return;
      }
      if (!(gamepad.index in model.lastGamepadValues)) {
        model.lastGamepadValues[gamepad.index] = {
          left: {
            buttons: {}
          },
          right: {
            buttons: {}
          },
          none: {
            buttons: {}
          }
        };
      }
      for (let buttonIdx = 0; buttonIdx < gamepad.buttons.length; ++buttonIdx) {
        if (!(buttonIdx in model.lastGamepadValues[gamepad.index][hand].buttons)) {
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = false;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] !== gamepad.buttons[buttonIdx].pressed && gripPose != null) {
          publicAPI.button3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            pressed: gamepad.buttons[buttonIdx].pressed,
            device: inputSource.handedness === 'left' ? RenderWindowInteractor_Device.LeftController : RenderWindowInteractor_Device.RightController,
            input: deviceInputMap[gamepad.mapping] && deviceInputMap[gamepad.mapping][buttonIdx] ? deviceInputMap[gamepad.mapping][buttonIdx] : RenderWindowInteractor_Input.Trigger
          });
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = gamepad.buttons[buttonIdx].pressed;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] && gripPose != null) {
          publicAPI.move3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            device: inputSource.handedness === 'left' ? RenderWindowInteractor_Device.LeftController : RenderWindowInteractor_Device.RightController
          });
        }
      }
    });
  };
  publicAPI.handleMouseMove = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    if (model.moveTimeoutID === 0) {
      publicAPI.startMouseMoveEvent(callData);
    } else {
      publicAPI.mouseMoveEvent(callData);
      clearTimeout(model.moveTimeoutID);
    }

    // start a timer to keep us animating while we get mouse move events
    model.moveTimeoutID = setTimeout(() => {
      publicAPI.endMouseMoveEvent();
      model.moveTimeoutID = 0;
    }, 200);
  };
  publicAPI.handleAnimation = () => {
    const currTime = Date.now();
    model._animationFrameCount++;
    if (currTime - model._animationStartTime > 1000.0 && model._animationFrameCount > 1) {
      model.recentAnimationFrameRate = 1000.0 * (model._animationFrameCount - 1) / (currTime - model._animationStartTime);
      model.lastFrameTime = 1.0 / model.recentAnimationFrameRate;
      publicAPI.animationFrameRateUpdateEvent();
      model._animationStartTime = currTime;
      model._animationFrameCount = 1;
    }
    publicAPI.animationEvent();
    forceRender();
    if (animationRequesters.size > 0 || Date.now() < model._animationExtendedEnd) {
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    } else {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.handleWheel = event => {
    preventDefault(event);

    /**
     * wheel event values can vary significantly across browsers, platforms
     * and devices [1]. `normalizeWheel` uses facebook's solution from their
     * fixed-data-table repository [2].
     *
     * [1] https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel
     * [2] https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
     *
     * This code will return an object with properties:
     *
     *   spinX   -- normalized spin speed (use for zoom) - x plane
     *   spinY   -- " - y plane
     *   pixelX  -- normalized distance (to pixels) - x plane
     *   pixelY  -- " - y plane
     *
     */
    const callData = {
      ...normalizeWheel(event),
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };

    // Wheel events are thought to scroll pages (i.e. multiple lines at once).
    // See normalizeWheel() documentation for more context.
    // While trackpad wheel events are many small (<1) wheel spins,
    // mouse wheel events have absolute spin values higher than 1.
    // Here the first spin value is "recorded", and used to normalize
    // all the following mouse wheel events.
    if (model.wheelTimeoutID === 0) {
      // we attempt to distinguish between trackpads and mice
      // .3 will be larger than the first trackpad event,
      // but small enough to detect some common edge case mice
      if (Math.abs(callData.spinY) >= 0.3) {
        // Event is coming from mouse wheel
        wheelCoefficient = Math.abs(callData.spinY);
      } else {
        // Event is coming from trackpad
        wheelCoefficient = 1;
      }
    }
    callData.spinY /= wheelCoefficient;
    if (model.wheelTimeoutID === 0) {
      publicAPI.startMouseWheelEvent(callData);
      publicAPI.mouseWheelEvent(callData);
    } else {
      publicAPI.mouseWheelEvent(callData);
      clearTimeout(model.wheelTimeoutID);
    }
    if (model.mouseScrollDebounceByPass) {
      publicAPI.extendAnimation(600);
      publicAPI.endMouseWheelEvent();
      model.wheelTimeoutID = 0;
    } else {
      // start a timer to keep us animating while we get wheel events
      model.wheelTimeoutID = setTimeout(() => {
        publicAPI.extendAnimation(600);
        publicAPI.endMouseWheelEvent();
        model.wheelTimeoutID = 0;
      }, 200);
    }
  };
  publicAPI.handleMouseUp = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    switch (event.button) {
      case 0:
        publicAPI.leftButtonReleaseEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonReleaseEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonReleaseEvent(callData);
        break;
      default:
        RenderWindowInteractor_vtkErrorMacro(`Unknown mouse button released: ${event.button}`);
        break;
    }
  };
  publicAPI.handleTouchStart = event => {
    const pointers = [...pointerCache.values()];
    // If multitouch
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      // did we just transition to multitouch?
      if (pointers.length === 2) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      }
      // handle the gesture
      publicAPI.recognizeGesture('TouchStart', positions);
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.leftButtonPressEvent(callData);
    }
  };
  publicAPI.handleTouchMove = event => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      publicAPI.recognizeGesture('TouchMove', positions);
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.mouseMoveEvent(callData);
    }
  };
  publicAPI.handleTouchEnd = event => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures) {
      // No more fingers down
      if (pointers.length === 0) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: getScreenEventPositionFor(event),
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      } else if (pointers.length === 1) {
        // If one finger left, end touch and start button press
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture('TouchEnd', positions);
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonPressEvent(callData);
      } else {
        // If more than one finger left, keep touch move
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture('TouchMove', positions);
      }
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.leftButtonReleaseEvent(callData);
    }
  };
  publicAPI.setView = val => {
    if (model._view === val) {
      return;
    }
    model._view = val;
    model._view.getRenderable().setInteractor(publicAPI);
    publicAPI.modified();
  };
  publicAPI.getFirstRenderer = () => model._view?.getRenderable()?.getRenderersByReference()?.[0];
  publicAPI.findPokedRenderer = function () {
    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!model._view) {
      return null;
    }
    // The original order of renderers needs to remain as
    // the first one is the one we want to manipulate the camera on.
    const rc = model._view?.getRenderable()?.getRenderers();
    if (!rc || rc.length === 0) {
      return null;
    }
    rc.sort((a, b) => a.getLayer() - b.getLayer());
    let interactiveren = null;
    let viewportren = null;
    let currentRenderer = null;
    let count = rc.length;
    while (count--) {
      const aren = rc[count];
      if (model._view.isInViewport(x, y, aren) && aren.getInteractive()) {
        currentRenderer = aren;
        break;
      }
      if (interactiveren === null && aren.getInteractive()) {
        // Save this renderer in case we can't find one in the viewport that
        // is interactive.
        interactiveren = aren;
      }
      if (viewportren === null && model._view.isInViewport(x, y, aren)) {
        // Save this renderer in case we can't find one in the viewport that
        // is interactive.
        viewportren = aren;
      }
    }

    // We must have a value.  If we found an interactive renderer before, that's
    // better than a non-interactive renderer.
    if (currentRenderer === null) {
      currentRenderer = interactiveren;
    }

    // We must have a value.  If we found a renderer that is in the viewport,
    // that is better than any old viewport (but not as good as an interactive
    // one).
    if (currentRenderer === null) {
      currentRenderer = viewportren;
    }

    // We must have a value - take anything.
    if (currentRenderer == null) {
      currentRenderer = rc[0];
    }
    return currentRenderer;
  };

  // only render if we are not animating. If we are animating
  // then renders will happen naturally anyhow and we definitely
  // do not want extra renders as the make the apparent interaction
  // rate slower.
  publicAPI.render = () => {
    if (!publicAPI.isAnimating() && !model.inRender) {
      forceRender();
    }
  };

  // create the generic Event methods
  handledEvents.forEach(eventName => {
    const lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
    publicAPI[`${lowerFirst}Event`] = arg => {
      // Check that interactor enabled
      if (!model.enabled) {
        return;
      }

      // Check that a poked renderer exists
      const renderer = publicAPI.getCurrentRenderer();
      if (!renderer) {
        vtkOnceErrorMacro(`
          Can not forward events without a current renderer on the interactor.
        `);
        return;
      }

      // Pass the eventName and the poked renderer
      const callData = {
        type: eventName,
        pokedRenderer: model.currentRenderer,
        firstRenderer: publicAPI.getFirstRenderer(),
        // Add the arguments to the call data
        ...arg
      };

      // Call invoke
      publicAPI[`invoke${eventName}`](callData);
    };
  });

  // we know we are in multitouch now, so start recognizing
  publicAPI.recognizeGesture = (event, positions) => {
    // more than two pointers we ignore
    if (Object.keys(positions).length > 2) {
      return;
    }
    if (!model.startingEventPositions) {
      model.startingEventPositions = {};
    }

    // store the initial positions
    if (event === 'TouchStart') {
      Object.keys(positions).forEach(key => {
        model.startingEventPositions[key] = positions[key];
      });
      // we do not know what the gesture is yet
      model.currentGesture = 'Start';
      return;
    }

    // end the gesture if needed
    if (event === 'TouchEnd') {
      if (model.currentGesture === 'Pinch') {
        publicAPI.render();
        publicAPI.endPinchEvent();
      }
      if (model.currentGesture === 'Rotate') {
        publicAPI.render();
        publicAPI.endRotateEvent();
      }
      if (model.currentGesture === 'Pan') {
        publicAPI.render();
        publicAPI.endPanEvent();
      }
      model.currentGesture = 'Start';
      model.startingEventPositions = {};
      return;
    }

    // what are the two pointers we are working with
    let count = 0;
    const posVals = [];
    const startVals = [];
    Object.keys(positions).forEach(key => {
      posVals[count] = positions[key];
      startVals[count] = model.startingEventPositions[key];
      count++;
    });

    // The meat of the algorithm
    // on move events we analyze them to determine what type
    // of movement it is and then deal with it.
    // calculate the distances
    const originalDistance = Math.sqrt((startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) + (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y));
    const newDistance = Math.sqrt((posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) + (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y));

    // calculate rotations
    let originalAngle = (0,Core_Math.A)(Math.atan2(startVals[1].y - startVals[0].y, startVals[1].x - startVals[0].x));
    let newAngle = (0,Core_Math.A)(Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x));

    // angles are cyclic so watch for that, 1 and 359 are only 2 apart :)
    let angleDeviation = newAngle - originalAngle;
    newAngle = newAngle + 180.0 >= 360.0 ? newAngle - 180.0 : newAngle + 180.0;
    originalAngle = originalAngle + 180.0 >= 360.0 ? originalAngle - 180.0 : originalAngle + 180.0;
    if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
      angleDeviation = newAngle - originalAngle;
    }

    // calculate the translations
    const trans = [];
    trans[0] = (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2.0;
    trans[1] = (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2.0;
    if (event === 'TouchMove') {
      // OK we want to
      // - immediately respond to the user
      // - allow the user to zoom without panning (saves focal point)
      // - allow the user to rotate without panning (saves focal point)

      // do we know what gesture we are doing yet? If not
      // see if we can figure it out
      if (model.currentGesture === 'Start') {
        // pinch is a move to/from the center point
        // rotate is a move along the circumference
        // pan is a move of the center point
        // compute the distance along each of these axes in pixels
        // the first to break thresh wins
        let thresh = 0.01 * Math.sqrt(model.container.clientWidth * model.container.clientWidth + model.container.clientHeight * model.container.clientHeight);
        if (thresh < 15.0) {
          thresh = 15.0;
        }
        const pinchDistance = Math.abs(newDistance - originalDistance);
        const rotateDistance = newDistance * 3.1415926 * Math.abs(angleDeviation) / 360.0;
        const panDistance = Math.sqrt(trans[0] * trans[0] + trans[1] * trans[1]);
        if (pinchDistance > thresh && pinchDistance > rotateDistance && pinchDistance > panDistance) {
          model.currentGesture = 'Pinch';
          const callData = {
            scale: 1.0,
            touches: positions
          };
          publicAPI.startPinchEvent(callData);
        } else if (rotateDistance > thresh && rotateDistance > panDistance) {
          model.currentGesture = 'Rotate';
          const callData = {
            rotation: 0.0,
            touches: positions
          };
          publicAPI.startRotateEvent(callData);
        } else if (panDistance > thresh) {
          model.currentGesture = 'Pan';
          const callData = {
            translation: [0, 0],
            touches: positions
          };
          publicAPI.startPanEvent(callData);
        }
      } else {
        // if we have found a specific type of movement then
        // handle it
        if (model.currentGesture === 'Rotate') {
          const callData = {
            rotation: angleDeviation,
            touches: positions
          };
          publicAPI.rotateEvent(callData);
        }
        if (model.currentGesture === 'Pinch') {
          const callData = {
            scale: newDistance / originalDistance,
            touches: positions
          };
          publicAPI.pinchEvent(callData);
        }
        if (model.currentGesture === 'Pan') {
          const callData = {
            translation: trans,
            touches: positions
          };
          publicAPI.panEvent(callData);
        }
      }
    }
  };
  publicAPI.handleVisibilityChange = () => {
    model._animationStartTime = Date.now();
    model._animationFrameCount = 0;
  };
  publicAPI.setCurrentRenderer = r => {
    model._forcedRenderer = !!r;
    model.currentRenderer = r;
  };
  publicAPI.setContainer = container => {
    _unbindEvents();
    const res = superClass.setContainer(container ?? null);
    if (res) {
      _bindEvents();
    }
    return res;
  };

  // Stop animating if the renderWindowInteractor is deleted.
  publicAPI.delete = () => {
    while (animationRequesters.size) {
      publicAPI.cancelAnimation(animationRequesters.values().next().value);
    }
    if (typeof document.hidden !== 'undefined') {
      document.removeEventListener('visibilitychange', publicAPI.handleVisibilityChange);
    }
    if (model.container) {
      publicAPI.setContainer(null);
    }
    superClass.delete();
  };

  // Use the Page Visibility API to detect when we switch away from or back to
  // this tab, and reset the animationFrameStart. When tabs are not active, browsers
  // will stop calling requestAnimationFrame callbacks.
  if (typeof document.hidden !== 'undefined') {
    document.addEventListener('visibilitychange', publicAPI.handleVisibilityChange, false);
  }
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const RenderWindowInteractor_DEFAULT_VALUES = {
  renderWindow: null,
  interactorStyle: null,
  picker: null,
  pickingManager: null,
  initialized: false,
  enabled: false,
  enableRender: true,
  currentRenderer: null,
  lightFollowCamera: true,
  desiredUpdateRate: 30.0,
  stillUpdateRate: 2.0,
  container: null,
  // _view: null,
  recognizeGestures: true,
  currentGesture: 'Start',
  animationRequest: null,
  lastFrameTime: 0.1,
  recentAnimationFrameRate: 10.0,
  wheelTimeoutID: 0,
  moveTimeoutID: 0,
  lastGamepadValues: {},
  preventDefaultOnPointerDown: false,
  preventDefaultOnPointerUp: false,
  mouseScrollDebounceByPass: false
};

// ----------------------------------------------------------------------------

function RenderWindowInteractor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, RenderWindowInteractor_DEFAULT_VALUES, initialValues);

  // Object methods
  macros2.m.obj(publicAPI, model);

  // run animation at least until this time
  model._animationExtendedEnd = 0;
  macros2.m.event(publicAPI, model, 'RenderEvent');
  handledEvents.forEach(eventName => macros2.m.event(publicAPI, model, eventName));

  // Create get-only macros
  macros2.m.get(publicAPI, model, ['initialized', 'interactorStyle', 'lastFrameTime', 'recentAnimationFrameRate', '_view']);

  // Create get-set macros
  macros2.m.setGet(publicAPI, model, ['container', 'lightFollowCamera', 'enabled', 'enableRender', 'recognizeGestures', 'desiredUpdateRate', 'stillUpdateRate', 'picker', 'preventDefaultOnPointerDown', 'preventDefaultOnPointerUp', 'mouseScrollDebounceByPass']);
  macros2.m.moveToProtected(publicAPI, model, ['view']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkRenderWindowInteractor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const RenderWindowInteractor_newInstance = macros2.m.newInstance(RenderWindowInteractor_extend, 'vtkRenderWindowInteractor');

// ----------------------------------------------------------------------------

var vtkRenderWindowInteractor$1 = {
  newInstance: RenderWindowInteractor_newInstance,
  extend: RenderWindowInteractor_extend,
  handledEvents,
  ...RenderWindowInteractor_Constants_Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Points.js
var Points = __webpack_require__(74966);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 9 modules
var PolyData = __webpack_require__(79484);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var Core_Actor = __webpack_require__(7019);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var Mapper = __webpack_require__(82409);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkOffscreenMultiRenderWindow.js










function vtkOffscreenMultiRenderWindow(publicAPI, model) {
    const invokeResize = publicAPI.invokeResize;
    delete publicAPI.invokeResize;
    model.renderWindow = vtkRenderWindow$1.newInstance();
    model.rendererMap = {};
    model.openGLRenderWindow = vtkClasses_vtkStreamingOpenGLRenderWindow.newInstance();
    model.renderWindow.addView(model.openGLRenderWindow);
    model.interactor = vtkRenderWindowInteractor$1.newInstance();
    model.interactor.setView(model.openGLRenderWindow);
    model.interactor.initialize();
    publicAPI.addRenderer = ({ viewport, id, background }) => {
        const renderer = Core_Renderer/* default.newInstance */.Ay.newInstance({
            viewport,
            background: background || model.background,
        });
        model.renderWindow.addRenderer(renderer);
        model.rendererMap[id] = renderer;
    };
    publicAPI.destroy = () => {
        const rwi = model.renderWindow.getInteractor();
        rwi.delete();
    };
    publicAPI.removeRenderer = (id) => {
        const renderer = publicAPI.getRenderer(id);
        model.renderWindow.removeRenderer(renderer);
        renderer.delete();
        delete model.rendererMap[id];
    };
    publicAPI.getRenderer = (id) => {
        return model.rendererMap[id];
    };
    publicAPI.getRenderers = () => {
        const { rendererMap } = model;
        const renderers = Object.keys(rendererMap).map((id) => {
            return { id, renderer: rendererMap[id] };
        });
        return renderers;
    };
    publicAPI.resize = () => {
        if (model.container) {
            const { width, height } = model.container;
            model.openGLRenderWindow.setSize(Math.floor(width), Math.floor(height));
            invokeResize();
            model.renderWindow.render();
        }
    };
    publicAPI.setContainer = (el) => {
        model.container = el;
        model.openGLRenderWindow.setContainer(model.container);
    };
    publicAPI.delete = macros/* default.chain */.Ay.chain(publicAPI.setContainer, publicAPI.destroy, model.openGLRenderWindow.delete, publicAPI.delete);
    publicAPI.resize();
}
const vtkOffscreenMultiRenderWindow_DEFAULT_VALUES = {
    background: [0.0, 0.0, 0.0],
    container: null,
};
function vtkOffscreenMultiRenderWindow_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkOffscreenMultiRenderWindow_DEFAULT_VALUES, initialValues);
    macros/* default.obj */.Ay.obj(publicAPI, model);
    macros/* default.get */.Ay.get(publicAPI, model, [
        'renderWindow',
        'openGLRenderWindow',
        'interactor',
        'container',
    ]);
    macros/* default.event */.Ay.event(publicAPI, model, 'resize');
    vtkOffscreenMultiRenderWindow(publicAPI, model);
}
const vtkOffscreenMultiRenderWindow_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkOffscreenMultiRenderWindow_extend);
/* harmony default export */ const vtkClasses_vtkOffscreenMultiRenderWindow = ({ newInstance: vtkOffscreenMultiRenderWindow_newInstance, extend: vtkOffscreenMultiRenderWindow_extend });

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js
var VolumeMapper_Constants = __webpack_require__(67737);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
var AbstractMapper3D = __webpack_require__(68076);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js
var PiecewiseFunction = __webpack_require__(99341);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper.js






const {
  BlendMode,
  FilterMode
} = VolumeMapper_Constants/* default */.Ay;
function createRadonTransferFunction(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption, maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption, outputTransferFunction) {
  let ofun = null;
  if (outputTransferFunction) {
    ofun = outputTransferFunction;
    ofun.removeAllPoints();
  } else {
    ofun = PiecewiseFunction/* default.newInstance */.Ay.newInstance();
  }
  ofun.addPointLong(-1024, 0, 1, 1); // air (i.e. material with no absorption)
  ofun.addPoint(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption);
  ofun.addPoint(maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption);
  return ofun;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  createRadonTransferFunction
};

// ----------------------------------------------------------------------------
// vtkVolumeMapper methods
// ----------------------------------------------------------------------------

function vtkVolumeMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkVolumeMapper');
  const superClass = {
    ...publicAPI
  };
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = (0,Core_Math.F)();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.setBlendModeToComposite = () => {
    publicAPI.setBlendMode(BlendMode.COMPOSITE_BLEND);
  };
  publicAPI.setBlendModeToMaximumIntensity = () => {
    publicAPI.setBlendMode(BlendMode.MAXIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToMinimumIntensity = () => {
    publicAPI.setBlendMode(BlendMode.MINIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAverageIntensity = () => {
    publicAPI.setBlendMode(BlendMode.AVERAGE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAdditiveIntensity = () => {
    publicAPI.setBlendMode(BlendMode.ADDITIVE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToRadonTransform = () => {
    publicAPI.setBlendMode(BlendMode.RADON_TRANSFORM_BLEND);
  };
  publicAPI.getBlendModeAsString = () => macros2.m.enumToString(BlendMode, model.blendMode);
  publicAPI.setAverageIPScalarRange = (min, max) => {
    console.warn('setAverageIPScalarRange is deprecated use setIpScalarRange');
    publicAPI.setIpScalarRange(min, max);
  };
  publicAPI.getFilterModeAsString = () => macros2.m.enumToString(FilterMode, model.filterMode);
  publicAPI.setFilterModeToOff = () => {
    publicAPI.setFilterMode(FilterMode.OFF);
  };
  publicAPI.setFilterModeToNormalized = () => {
    publicAPI.setFilterMode(FilterMode.NORMALIZED);
  };
  publicAPI.setFilterModeToRaw = () => {
    publicAPI.setFilterMode(FilterMode.RAW);
  };
  publicAPI.setGlobalIlluminationReach = gl => superClass.setGlobalIlluminationReach((0,Core_Math.C)(gl, 0.0, 1.0));
  publicAPI.setVolumetricScatteringBlending = vsb => superClass.setVolumetricScatteringBlending((0,Core_Math.C)(vsb, 0.0, 1.0));
  publicAPI.setVolumeShadowSamplingDistFactor = vsdf => superClass.setVolumeShadowSamplingDistFactor(vsdf >= 1.0 ? vsdf : 1.0);
  publicAPI.setAnisotropy = at => superClass.setAnisotropy((0,Core_Math.C)(at, -0.99, 0.99));
  publicAPI.setLAOKernelSize = ks => superClass.setLAOKernelSize((0,Core_Math.I)((0,Core_Math.C)(ks, 1, 32)));
  publicAPI.setLAOKernelRadius = kr => superClass.setLAOKernelRadius(kr >= 1 ? kr : 1);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

// TODO: what values to use for averageIPScalarRange to get GLSL to use max / min values like [-Math.inf, Math.inf]?
const VolumeMapper_DEFAULT_VALUES = {
  bounds: [1, -1, 1, -1, 1, -1],
  sampleDistance: 1.0,
  imageSampleDistance: 1.0,
  maximumSamplesPerRay: 1000,
  autoAdjustSampleDistances: true,
  initialInteractionScale: 1.0,
  interactionSampleDistanceFactor: 1.0,
  blendMode: BlendMode.COMPOSITE_BLEND,
  ipScalarRange: [-1000000.0, 1000000.0],
  filterMode: FilterMode.OFF,
  // ignored by WebGL so no behavior change
  preferSizeOverAccuracy: false,
  // Whether to use halfFloat representation of float, when it is inaccurate
  computeNormalFromOpacity: false,
  // volume shadow parameters
  volumetricScatteringBlending: 0.0,
  globalIlluminationReach: 0.0,
  volumeShadowSamplingDistFactor: 5.0,
  anisotropy: 0.0,
  // local ambient occlusion
  localAmbientOcclusion: false,
  LAOKernelSize: 15,
  LAOKernelRadius: 7
};

// ----------------------------------------------------------------------------

function VolumeMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, VolumeMapper_DEFAULT_VALUES, initialValues);
  AbstractMapper3D/* default.extend */.A.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['sampleDistance', 'imageSampleDistance', 'maximumSamplesPerRay', 'autoAdjustSampleDistances', 'initialInteractionScale', 'interactionSampleDistanceFactor', 'blendMode', 'filterMode', 'preferSizeOverAccuracy', 'computeNormalFromOpacity', 'volumetricScatteringBlending', 'globalIlluminationReach', 'volumeShadowSamplingDistFactor', 'anisotropy', 'localAmbientOcclusion', 'LAOKernelSize', 'LAOKernelRadius']);
  macros2.m.setGetArray(publicAPI, model, ['ipScalarRange'], 2);
  macros2.m.event(publicAPI, model, 'lightingActivated');

  // Object methods
  vtkVolumeMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const VolumeMapper_newInstance = macros2.m.newInstance(VolumeMapper_extend, 'vtkVolumeMapper');

// ----------------------------------------------------------------------------

var vtkVolumeMapper$1 = {
  newInstance: VolumeMapper_newInstance,
  extend: VolumeMapper_extend,
  ...STATIC
};



;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkSharedVolumeMapper.js


function vtkSharedVolumeMapper(publicAPI, model) {
    model.classHierarchy.push('vtkSharedVolumeMapper');
    const superDelete = publicAPI.delete;
    publicAPI.delete = () => {
        model.scalarTexture = null;
        superDelete();
    };
}
const vtkSharedVolumeMapper_DEFAULT_VALUES = {
    scalarTexture: null,
};
function vtkSharedVolumeMapper_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkSharedVolumeMapper_DEFAULT_VALUES, initialValues);
    vtkVolumeMapper$1.extend(publicAPI, model, initialValues);
    macros/* default.setGet */.Ay.setGet(publicAPI, model, ['scalarTexture']);
    vtkSharedVolumeMapper(publicAPI, model);
}
const vtkSharedVolumeMapper_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkSharedVolumeMapper_extend, 'vtkSharedVolumeMapper');
/* harmony default export */ const vtkClasses_vtkSharedVolumeMapper = ({ newInstance: vtkSharedVolumeMapper_newInstance, extend: vtkSharedVolumeMapper_extend });

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLTexture.js




function vtkStreamingOpenGLTexture(publicAPI, model) {
    model.classHierarchy.push('vtkStreamingOpenGLTexture');
    model.updatedFrames = [];
    model.volumeId = null;
    const superCreate3DFilterableFromRaw = publicAPI.create3DFilterableFromRaw;
    publicAPI.create3DFilterableFromRaw = (width, height, depth, numberOfComponents, dataType, data, preferSizeOverAccuracy) => {
        model.inputDataType = dataType;
        model.inputNumComps = numberOfComponents;
        superCreate3DFilterableFromRaw(width, height, depth, numberOfComponents, dataType, data, preferSizeOverAccuracy);
    };
    publicAPI.update3DFromRaw = () => {
        const { volumeId } = model;
        if (!volumeId) {
            return;
        }
        const volume = cache/* default */.Ay.getVolume(volumeId);
        model._openGLRenderWindow.activateTexture(publicAPI);
        publicAPI.createTexture();
        publicAPI.bind();
        if (volume.isDynamicVolume()) {
            updateDynamicVolumeTexture();
            return;
        }
        return (publicAPI.hasUpdatedFrames() && updateTextureImagesUsingVoxelManager());
    };
    const superModified = publicAPI.modified;
    publicAPI.setUpdatedFrame = (frameIndex) => {
        model.updatedFrames[frameIndex] = true;
        superModified();
    };
    publicAPI.modified = () => {
        superModified();
        const volume = cache/* default */.Ay.getVolume(model.volumeId);
        if (!volume) {
            return;
        }
        const imageIds = volume.imageIds;
        for (let i = 0; i < imageIds.length; i++) {
            model.updatedFrames[i] = true;
        }
    };
    function updateTextureImagesUsingVoxelManager() {
        const volume = cache/* default */.Ay.getVolume(model.volumeId);
        const imageIds = volume.imageIds;
        for (let i = 0; i < model.updatedFrames.length; i++) {
            if (model.updatedFrames[i]) {
                const image = cache/* default */.Ay.getImage(imageIds[i]);
                if (!image) {
                    continue;
                }
                const data = image.voxelManager.getScalarData();
                const gl = model.context;
                const dataType = data.constructor.name;
                const [pixData] = publicAPI.updateArrayDataTypeForGL(dataType, [data]);
                publicAPI.bind();
                const zOffset = i;
                gl.texSubImage3D(model.target, 0, 0, 0, zOffset, model.width, model.height, 1, model.format, model.openGLDataType, pixData);
                publicAPI.deactivate();
                model.updatedFrames[i] = null;
            }
        }
        if (model.generateMipmap) {
            model.context.generateMipmap(model.target);
        }
        publicAPI.deactivate();
        return true;
    }
    function updateDynamicVolumeTexture() {
        const volume = cache/* default */.Ay.getVolume(model.volumeId);
        const imageIds = volume.getCurrentTimePointImageIds();
        if (!imageIds.length) {
            return false;
        }
        let constructor;
        for (let i = 0; i < imageIds.length; i++) {
            const imageId = imageIds[i];
            const image = cache/* default */.Ay.getImage(imageId);
            let data;
            if (!image) {
                constructor = (0,getBufferConfiguration/* getConstructorFromType */.j)(volume.dataType, true);
                data = new constructor(model.width * model.height);
            }
            else {
                data = image.voxelManager.getScalarData();
                constructor = data.constructor;
            }
            const gl = model.context;
            const dataType = data.constructor.name;
            const [pixData] = publicAPI.updateArrayDataTypeForGL(dataType, [data]);
            publicAPI.bind();
            let zOffset = i;
            gl.texSubImage3D(model.target, 0, 0, 0, zOffset, model.width, model.height, 1, model.format, model.openGLDataType, pixData);
            publicAPI.deactivate();
        }
        if (model.generateMipmap) {
            model.context.generateMipmap(model.target);
        }
        publicAPI.deactivate();
        return true;
    }
    publicAPI.hasUpdatedFrames = () => !model.updatedFrames.length || model.updatedFrames.some((frame) => frame);
    publicAPI.getUpdatedFrames = () => model.updatedFrames;
    publicAPI.setVolumeId = (volumeId) => {
        model.volumeId = volumeId;
    };
    publicAPI.getVolumeId = () => model.volumeId;
    publicAPI.setTextureParameters = ({ width, height, depth, numberOfComponents, dataType, }) => {
        model.width ??= width;
        model.height ??= height;
        model.depth ??= depth;
        model.inputNumComps ??= numberOfComponents;
        model.inputDataType ??= dataType;
    };
    publicAPI.getTextureParameters = () => ({
        width: model.width,
        height: model.height,
        depth: model.depth,
        numberOfComponents: model.inputNumComps,
        dataType: model.inputDataType,
    });
}
const vtkStreamingOpenGLTexture_DEFAULT_VALUES = {
    updatedFrames: [],
};
function vtkStreamingOpenGLTexture_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkStreamingOpenGLTexture_DEFAULT_VALUES, initialValues);
    Texture/* default.extend */.Ay.extend(publicAPI, model, initialValues);
    vtkStreamingOpenGLTexture(publicAPI, model);
}
const vtkStreamingOpenGLTexture_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkStreamingOpenGLTexture_extend, 'vtkStreamingOpenGLTexture');
/* harmony default export */ const vtkClasses_vtkStreamingOpenGLTexture = ({ newInstance: vtkStreamingOpenGLTexture_newInstance, extend: vtkStreamingOpenGLTexture_extend });

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkSlabCamera.js
var vtkSlabCamera = __webpack_require__(17232);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/index.js







/***/ }),

/***/ 17232:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports newInstance, extend */
/* harmony import */ var _kitware_vtk_js_macros__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37290);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_Camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26719);
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84607);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3823);




const DEFAULT_VALUES = {
    isPerformingCoordinateTransformation: false,
};
function extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, DEFAULT_VALUES, initialValues);
    _kitware_vtk_js_Rendering_Core_Camera__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);
    _kitware_vtk_js_macros__WEBPACK_IMPORTED_MODULE_0__/* ["default"].setGet */ .Ay.setGet(publicAPI, model, ['isPerformingCoordinateTransformation']);
    vtkSlabCamera(publicAPI, model);
}
const newInstance = _kitware_vtk_js_macros__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance(extend, 'vtkSlabCamera');
function vtkSlabCamera(publicAPI, model) {
    model.classHierarchy.push('vtkSlabCamera');
    const tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.identity */ .pB.identity(new Float64Array(16));
    const tmpvec1 = new Float64Array(3);
    publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
        const result = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.create */ .pB.create();
        if (model.projectionMatrix) {
            const scale = 1 / model.physicalScale;
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.set */ .eR.set(tmpvec1, scale, scale, scale);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.copy */ .pB.copy(result, model.projectionMatrix);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.scale */ .pB.scale(result, result, tmpvec1);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.transpose */ .pB.transpose(result, result);
            return result;
        }
        gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.identity */ .pB.identity(tmpMatrix);
        let cRange0 = model.clippingRange[0];
        let cRange1 = model.clippingRange[1];
        if (model.isPerformingCoordinateTransformation) {
            cRange0 = model.distance;
            cRange1 = model.distance + 0.1;
        }
        const cWidth = cRange1 - cRange0;
        const cRange = [
            cRange0 + ((nearz + 1) * cWidth) / 2.0,
            cRange0 + ((farz + 1) * cWidth) / 2.0,
        ];
        if (model.parallelProjection) {
            const width = model.parallelScale * aspect;
            const height = model.parallelScale;
            const xmin = (model.windowCenter[0] - 1.0) * width;
            const xmax = (model.windowCenter[0] + 1.0) * width;
            const ymin = (model.windowCenter[1] - 1.0) * height;
            const ymax = (model.windowCenter[1] + 1.0) * height;
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.ortho */ .pB.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.transpose */ .pB.transpose(tmpMatrix, tmpMatrix);
        }
        else if (model.useOffAxisProjection) {
            throw new Error('Off-Axis projection is not supported at this time');
        }
        else {
            const tmp = Math.tan(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__/* ["default"].radiansFromDegrees */ .Ay.radiansFromDegrees(model.viewAngle) / 2.0);
            let width;
            let height;
            if (model.useHorizontalViewAngle === true) {
                width = cRange0 * tmp;
                height = (cRange0 * tmp) / aspect;
            }
            else {
                width = cRange0 * tmp * aspect;
                height = cRange0 * tmp;
            }
            const xmin = (model.windowCenter[0] - 1.0) * width;
            const xmax = (model.windowCenter[0] + 1.0) * width;
            const ymin = (model.windowCenter[1] - 1.0) * height;
            const ymax = (model.windowCenter[1] + 1.0) * height;
            const znear = cRange[0];
            const zfar = cRange[1];
            tmpMatrix[0] = (2.0 * znear) / (xmax - xmin);
            tmpMatrix[5] = (2.0 * znear) / (ymax - ymin);
            tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
            tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
            tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
            tmpMatrix[14] = -1.0;
            tmpMatrix[11] = (-2.0 * znear * zfar) / (zfar - znear);
            tmpMatrix[15] = 0.0;
        }
        gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.copy */ .pB.copy(result, tmpMatrix);
        return result;
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ newInstance, extend });



/***/ }),

/***/ 49038:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports Cache, cache */
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69372);
/* harmony import */ var _utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39537);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10364);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32643);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31749);





const ONE_GB = 1073741824;
class Cache {
    constructor() {
        this._imageCache = new Map();
        this._volumeCache = new Map();
        this._geometryCache = new Map();
        this._imageCacheSize = 0;
        this._maxCacheSize = 3 * ONE_GB;
        this._geometryCacheSize = 0;
        this.setMaxCacheSize = (newMaxCacheSize) => {
            if (!newMaxCacheSize || typeof newMaxCacheSize !== 'number') {
                const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;
                throw new Error(errorMessage);
            }
            this._maxCacheSize = newMaxCacheSize;
        };
        this.isCacheable = (byteLength) => {
            const bytesAvailable = this.getBytesAvailable();
            const purgableImageBytes = Array.from(this._imageCache.values()).reduce((total, image) => {
                if (!image.sharedCacheKey) {
                    return total + image.sizeInBytes;
                }
                return total;
            }, 0);
            const availableSpaceWithoutSharedCacheKey = bytesAvailable + purgableImageBytes;
            return availableSpaceWithoutSharedCacheKey >= byteLength;
        };
        this.getMaxCacheSize = () => this._maxCacheSize;
        this.getCacheSize = () => this._imageCacheSize;
        this._decacheImage = (imageId, force = false) => {
            const cachedImage = this._imageCache.get(imageId);
            if (!cachedImage) {
                return;
            }
            if (cachedImage.sharedCacheKey && !force) {
                throw new Error('Cannot decache an image with a shared cache key. You need to manually decache the volume first.');
            }
            const { imageLoadObject } = cachedImage;
            if (imageLoadObject?.cancelFn) {
                imageLoadObject.cancelFn();
            }
            if (imageLoadObject?.decache) {
                imageLoadObject.decache();
            }
            this._imageCache.delete(imageId);
        };
        this._decacheVolume = (volumeId) => {
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                return;
            }
            const { volumeLoadObject, volume } = cachedVolume;
            if (!volume) {
                return;
            }
            if (volume.cancelLoading) {
                volume.cancelLoading();
            }
            if (volume.imageData) {
                volume.imageData.delete();
            }
            if (volumeLoadObject.cancelFn) {
                volumeLoadObject.cancelFn();
            }
            if (volume.imageIds) {
                volume.imageIds.forEach((imageId) => {
                    const cachedImage = this._imageCache.get(imageId);
                    if (cachedImage && cachedImage.sharedCacheKey === volumeId) {
                        cachedImage.sharedCacheKey = undefined;
                    }
                });
            }
            this._volumeCache.delete(volumeId);
        };
        this.purgeCache = () => {
            const imageIterator = this._imageCache.keys();
            this.purgeVolumeCache();
            while (true) {
                const { value: imageId, done } = imageIterator.next();
                if (done) {
                    break;
                }
                this.removeImageLoadObject(imageId, { force: true });
                (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
            }
        };
        this.purgeVolumeCache = () => {
            const volumeIterator = this._volumeCache.keys();
            while (true) {
                const { value: volumeId, done } = volumeIterator.next();
                if (done) {
                    break;
                }
                this.removeVolumeLoadObject(volumeId);
                (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.VOLUME_CACHE_VOLUME_REMOVED, {
                    volumeId,
                });
            }
        };
        this.getVolumeLoadObject = (volumeId) => {
            if (volumeId === undefined) {
                throw new Error('getVolumeLoadObject: volumeId must not be undefined');
            }
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                return;
            }
            cachedVolume.timeStamp = Date.now();
            return cachedVolume.volumeLoadObject;
        };
        this.putGeometryLoadObject = (geometryId, geometryLoadObject) => {
            if (geometryId === undefined) {
                throw new Error('putGeometryLoadObject: geometryId must not be undefined');
            }
            if (geometryLoadObject.promise === undefined) {
                throw new Error('putGeometryLoadObject: geometryLoadObject.promise must not be undefined');
            }
            if (this._geometryCache.has(geometryId)) {
                throw new Error('putGeometryLoadObject: geometryId already present in geometryCache');
            }
            if (geometryLoadObject.cancelFn &&
                typeof geometryLoadObject.cancelFn !== 'function') {
                throw new Error('putGeometryLoadObject: geometryLoadObject.cancel must be a function');
            }
            const cachedGeometry = {
                loaded: false,
                geometryId,
                geometryLoadObject,
                timeStamp: Date.now(),
                sizeInBytes: 0,
            };
            this._geometryCache.set(geometryId, cachedGeometry);
            return geometryLoadObject.promise
                .then((geometry) => {
                try {
                    this._putGeometryCommon(geometryId, geometry, cachedGeometry);
                }
                catch (error) {
                    console.debug(`Error in _putGeometryCommon for geometry ${geometryId}:`, error);
                    throw error;
                }
            })
                .catch((error) => {
                console.debug(`Error caching geometry ${geometryId}:`, error);
                this._geometryCache.delete(geometryId);
                throw error;
            });
        };
        this.getGeometry = (geometryId) => {
            if (geometryId === undefined) {
                throw new Error('getGeometry: geometryId must not be undefined');
            }
            const cachedGeometry = this._geometryCache.get(geometryId);
            if (!cachedGeometry) {
                return;
            }
            cachedGeometry.timeStamp = Date.now();
            return cachedGeometry.geometry;
        };
        this.removeGeometryLoadObject = (geometryId) => {
            if (geometryId === undefined) {
                throw new Error('removeGeometryLoadObject: geometryId must not be undefined');
            }
            const cachedGeometry = this._geometryCache.get(geometryId);
            if (!cachedGeometry) {
                throw new Error('removeGeometryLoadObject: geometryId was not present in geometryCache');
            }
            this.decrementGeometryCacheSize(cachedGeometry.sizeInBytes);
            const eventDetails = {
                geometry: cachedGeometry,
                geometryId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.GEOMETRY_CACHE_GEOMETRY_REMOVED, eventDetails);
            this._decacheGeometry(geometryId);
        };
        this._decacheGeometry = (geometryId) => {
            const cachedGeometry = this._geometryCache.get(geometryId);
            if (!cachedGeometry) {
                return;
            }
            const { geometryLoadObject } = cachedGeometry;
            if (geometryLoadObject.cancelFn) {
                geometryLoadObject.cancelFn();
            }
            if (geometryLoadObject.decache) {
                geometryLoadObject.decache();
            }
            this._geometryCache.delete(geometryId);
        };
        this.incrementGeometryCacheSize = (increment) => {
            this._geometryCacheSize += increment;
        };
        this.decrementGeometryCacheSize = (decrement) => {
            this._geometryCacheSize -= decrement;
        };
        this.getImage = (imageId, minQuality = _enums__WEBPACK_IMPORTED_MODULE_4__.ImageQualityStatus.FAR_REPLICATE) => {
            if (imageId === undefined) {
                throw new Error('getImage: imageId must not be undefined');
            }
            const cachedImage = this._imageCache.get(imageId);
            if (!cachedImage) {
                return;
            }
            cachedImage.timeStamp = Date.now();
            if (cachedImage.image?.imageQualityStatus < minQuality) {
                return;
            }
            return cachedImage.image;
        };
        this.getVolume = (volumeId, allowPartialMatch = false) => {
            if (volumeId === undefined) {
                throw new Error('getVolume: volumeId must not be undefined');
            }
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                return allowPartialMatch
                    ? [...this._volumeCache.values()].find((cv) => cv.volumeId.includes(volumeId))?.volume
                    : undefined;
            }
            cachedVolume.timeStamp = Date.now();
            return cachedVolume.volume;
        };
        this.getVolumes = () => {
            const cachedVolumes = Array.from(this._volumeCache.values());
            return cachedVolumes.map((cachedVolume) => cachedVolume.volume);
        };
        this.filterVolumesByReferenceId = (volumeId) => {
            const cachedVolumes = this.getVolumes();
            return cachedVolumes.filter((volume) => {
                return volume.referencedVolumeId === volumeId;
            });
        };
        this.removeImageLoadObject = (imageId, { force = false } = {}) => {
            if (imageId === undefined) {
                throw new Error('removeImageLoadObject: imageId must not be undefined');
            }
            const cachedImage = this._imageCache.get(imageId);
            if (!cachedImage) {
                throw new Error('removeImageLoadObject: imageId was not present in imageCache');
            }
            this._decacheImage(imageId, force);
            this.incrementImageCacheSize(-cachedImage.sizeInBytes);
            const eventDetails = {
                image: cachedImage,
                imageId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);
        };
        this.removeVolumeLoadObject = (volumeId) => {
            if (volumeId === undefined) {
                throw new Error('removeVolumeLoadObject: volumeId must not be undefined');
            }
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                throw new Error('removeVolumeLoadObject: volumeId was not present in volumeCache');
            }
            const eventDetails = {
                volume: cachedVolume,
                volumeId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);
            this._decacheVolume(volumeId);
        };
        this.incrementImageCacheSize = (increment) => {
            this._imageCacheSize += increment;
        };
        this.decrementImageCacheSize = (decrement) => {
            this._imageCacheSize -= decrement;
        };
        this.getGeometryLoadObject = (geometryId) => {
            if (geometryId === undefined) {
                throw new Error('getGeometryLoadObject: geometryId must not be undefined');
            }
            const cachedGeometry = this._geometryCache.get(geometryId);
            if (!cachedGeometry) {
                return;
            }
            cachedGeometry.timeStamp = Date.now();
            return cachedGeometry.geometryLoadObject;
        };
    }
    getBytesAvailable() {
        return this.getMaxCacheSize() - this.getCacheSize();
    }
    decacheIfNecessaryUntilBytesAvailable(numBytes, volumeImageIds) {
        let bytesAvailable = this.getBytesAvailable();
        if (bytesAvailable >= numBytes) {
            return bytesAvailable;
        }
        const cachedImages = Array.from(this._imageCache.values()).filter((cachedImage) => !cachedImage.sharedCacheKey);
        function compare(a, b) {
            if (a.timeStamp > b.timeStamp) {
                return 1;
            }
            if (a.timeStamp < b.timeStamp) {
                return -1;
            }
            return 0;
        }
        cachedImages.sort(compare);
        const cachedImageIds = cachedImages.map((im) => im.imageId);
        let imageIdsToPurge = cachedImageIds;
        if (volumeImageIds) {
            imageIdsToPurge = cachedImageIds.filter((id) => !volumeImageIds.includes(id));
        }
        for (const imageId of imageIdsToPurge) {
            this.removeImageLoadObject(imageId);
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
            bytesAvailable = this.getBytesAvailable();
            if (bytesAvailable >= numBytes) {
                return bytesAvailable;
            }
        }
        for (const imageId of cachedImageIds) {
            this.removeImageLoadObject(imageId);
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
            bytesAvailable = this.getBytesAvailable();
            if (bytesAvailable >= numBytes) {
                return bytesAvailable;
            }
        }
    }
    _putImageCommon(imageId, image, cachedImage) {
        if (!this._imageCache.has(imageId)) {
            console.warn('The image was purged from the cache before it completed loading.');
            return;
        }
        if (!image) {
            console.warn('Image is undefined');
            return;
        }
        if (image.sizeInBytes === undefined || Number.isNaN(image.sizeInBytes)) {
            throw new Error('_putImageCommon: image.sizeInBytes must not be undefined');
        }
        if (image.sizeInBytes.toFixed === undefined) {
            throw new Error('_putImageCommon: image.sizeInBytes is not a number');
        }
        if (!this.isCacheable(image.sizeInBytes)) {
            throw new Error(_enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.CACHE_SIZE_EXCEEDED);
        }
        this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);
        cachedImage.loaded = true;
        cachedImage.image = image;
        cachedImage.sizeInBytes = image.sizeInBytes;
        this.incrementImageCacheSize(cachedImage.sizeInBytes);
        const eventDetails = {
            image: cachedImage,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_ADDED, eventDetails);
        cachedImage.sharedCacheKey = image.sharedCacheKey;
    }
    async putImageLoadObject(imageId, imageLoadObject) {
        if (imageId === undefined) {
            console.error('putImageLoadObject: imageId must not be undefined');
            throw new Error('putImageLoadObject: imageId must not be undefined');
        }
        if (imageLoadObject.promise === undefined) {
            console.error('putImageLoadObject: imageLoadObject.promise must not be undefined');
            throw new Error('putImageLoadObject: imageLoadObject.promise must not be undefined');
        }
        const alreadyCached = this._imageCache.get(imageId);
        if (alreadyCached?.imageLoadObject) {
            console.warn(`putImageLoadObject: imageId ${imageId} already in cache`);
            throw new Error('putImageLoadObject: imageId already in cache');
        }
        if (imageLoadObject.cancelFn &&
            typeof imageLoadObject.cancelFn !== 'function') {
            console.error('putImageLoadObject: imageLoadObject.cancel must be a function');
            throw new Error('putImageLoadObject: imageLoadObject.cancel must be a function');
        }
        const cachedImage = {
            ...alreadyCached,
            loaded: false,
            imageId,
            sharedCacheKey: undefined,
            imageLoadObject,
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._imageCache.set(imageId, cachedImage);
        this._imageCache.set(imageId, cachedImage);
        return imageLoadObject.promise
            .then((image) => {
            try {
                this._putImageCommon(imageId, image, cachedImage);
            }
            catch (error) {
                console.debug(`Error in _putImageCommon for image ${imageId}:`, error);
                throw error;
            }
        })
            .catch((error) => {
            console.debug(`Error caching image ${imageId}:`, error);
            this._imageCache.delete(imageId);
            throw error;
        });
    }
    putImageSync(imageId, image) {
        if (imageId === undefined) {
            throw new Error('putImageSync: imageId must not be undefined');
        }
        if (this._imageCache.has(imageId)) {
            throw new Error('putImageSync: imageId already in cache');
        }
        const cachedImage = {
            loaded: false,
            imageId,
            sharedCacheKey: undefined,
            imageLoadObject: {
                promise: Promise.resolve(image),
            },
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._imageCache.set(imageId, cachedImage);
        try {
            this._putImageCommon(imageId, image, cachedImage);
        }
        catch (error) {
            this._imageCache.delete(imageId);
            throw error;
        }
    }
    getImageLoadObject(imageId) {
        if (imageId === undefined) {
            throw new Error('getImageLoadObject: imageId must not be undefined');
        }
        const cachedImage = this._imageCache.get(imageId);
        if (!cachedImage) {
            return;
        }
        cachedImage.timeStamp = Date.now();
        return cachedImage.imageLoadObject;
    }
    isLoaded(imageId) {
        const cachedImage = this._imageCache.get(imageId);
        if (!cachedImage) {
            return false;
        }
        return cachedImage.loaded;
    }
    getVolumeContainingImageId(imageId) {
        const volumeIds = Array.from(this._volumeCache.keys());
        const imageIdToUse = (0,_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageId);
        for (const volumeId of volumeIds) {
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                return;
            }
            const { volume } = cachedVolume;
            if (!volume.imageIds.length) {
                return;
            }
            const imageIdIndex = volume.getImageURIIndex(imageIdToUse);
            if (imageIdIndex > -1) {
                return { volume, imageIdIndex };
            }
        }
    }
    getCachedImageBasedOnImageURI(imageId) {
        const imageURIToUse = (0,_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageId);
        const cachedImageIds = Array.from(this._imageCache.keys());
        const foundImageId = cachedImageIds.find((imageId) => {
            return (0,_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageId) === imageURIToUse;
        });
        if (!foundImageId) {
            return;
        }
        return this._imageCache.get(foundImageId);
    }
    _putVolumeCommon(volumeId, volume, cachedVolume) {
        if (!this._volumeCache.get(volumeId)) {
            console.warn('The volume was purged from the cache before it completed loading.');
            return;
        }
        cachedVolume.loaded = true;
        cachedVolume.volume = volume;
        volume.imageIds?.forEach((imageId) => {
            const image = this._imageCache.get(imageId);
            if (image) {
                image.sharedCacheKey = volumeId;
            }
        });
        const eventDetails = {
            volume: cachedVolume,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.VOLUME_CACHE_VOLUME_ADDED, eventDetails);
    }
    putVolumeSync(volumeId, volume) {
        if (volumeId === undefined) {
            throw new Error('putVolumeSync: volumeId must not be undefined');
        }
        if (this._volumeCache.has(volumeId)) {
            throw new Error('putVolumeSync: volumeId already in cache');
        }
        const cachedVolume = {
            loaded: false,
            volumeId,
            volumeLoadObject: {
                promise: Promise.resolve(volume),
            },
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._volumeCache.set(volumeId, cachedVolume);
        try {
            this._putVolumeCommon(volumeId, volume, cachedVolume);
        }
        catch (error) {
            this._volumeCache.delete(volumeId);
            throw error;
        }
    }
    async putVolumeLoadObject(volumeId, volumeLoadObject) {
        if (volumeId === undefined) {
            throw new Error('putVolumeLoadObject: volumeId must not be undefined');
        }
        if (volumeLoadObject.promise === undefined) {
            throw new Error('putVolumeLoadObject: volumeLoadObject.promise must not be undefined');
        }
        if (this._volumeCache.has(volumeId)) {
            throw new Error(`putVolumeLoadObject: volumeId:${volumeId} already in cache`);
        }
        if (volumeLoadObject.cancelFn &&
            typeof volumeLoadObject.cancelFn !== 'function') {
            throw new Error('putVolumeLoadObject: volumeLoadObject.cancel must be a function');
        }
        const cachedVolume = {
            loaded: false,
            volumeId,
            volumeLoadObject,
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._volumeCache.set(volumeId, cachedVolume);
        return volumeLoadObject.promise
            .then((volume) => {
            try {
                this._putVolumeCommon(volumeId, volume, cachedVolume);
            }
            catch (error) {
                console.error(`Error in _putVolumeCommon for volume ${volumeId}:`, error);
                this._volumeCache.delete(volumeId);
                throw error;
            }
        })
            .catch((error) => {
            this._volumeCache.delete(volumeId);
            throw error;
        });
    }
    _putGeometryCommon(geometryId, geometry, cachedGeometry) {
        if (!this._geometryCache.get(geometryId)) {
            console.warn('The geometry was purged from the cache before it completed loading.');
            return;
        }
        if (!geometry) {
            console.warn('Geometry is undefined');
            return;
        }
        if (geometry.sizeInBytes === undefined ||
            Number.isNaN(geometry.sizeInBytes)) {
            throw new Error('_putGeometryCommon: geometry.sizeInBytes must not be undefined');
        }
        if (geometry.sizeInBytes.toFixed === undefined) {
            throw new Error('_putGeometryCommon: geometry.sizeInBytes is not a number');
        }
        if (!this.isCacheable(geometry.sizeInBytes)) {
            throw new Error(_enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.CACHE_SIZE_EXCEEDED);
        }
        this.decacheIfNecessaryUntilBytesAvailable(geometry.sizeInBytes);
        cachedGeometry.loaded = true;
        cachedGeometry.geometry = geometry;
        cachedGeometry.sizeInBytes = geometry.sizeInBytes;
        this.incrementGeometryCacheSize(cachedGeometry.sizeInBytes);
        const eventDetails = {
            geometry: cachedGeometry,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.GEOMETRY_CACHE_GEOMETRY_ADDED, eventDetails);
    }
    putGeometrySync(geometryId, geometry) {
        if (geometryId === undefined) {
            throw new Error('putGeometrySync: geometryId must not be undefined');
        }
        if (this._geometryCache.has(geometryId)) {
            throw new Error('putGeometrySync: geometryId already in cache');
        }
        const cachedGeometry = {
            loaded: false,
            geometryId,
            geometryLoadObject: {
                promise: Promise.resolve(geometry),
            },
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._geometryCache.set(geometryId, cachedGeometry);
        try {
            this._putGeometryCommon(geometryId, geometry, cachedGeometry);
        }
        catch (error) {
            this._geometryCache.delete(geometryId);
            throw error;
        }
    }
    setPartialImage(imageId, partialImage) {
        const cachedImage = this._imageCache.get(imageId);
        if (!cachedImage) {
            if (partialImage) {
                this._imageCache.set(imageId, {
                    image: partialImage,
                    imageId,
                    loaded: false,
                    timeStamp: Date.now(),
                    sizeInBytes: 0,
                });
            }
            return;
        }
        if (cachedImage.loaded) {
            cachedImage.loaded = false;
            cachedImage.imageLoadObject = null;
            this.incrementImageCacheSize(-cachedImage.sizeInBytes);
            cachedImage.sizeInBytes = 0;
            cachedImage.image = partialImage || cachedImage.image;
        }
        else {
            cachedImage.image = partialImage || cachedImage.image;
        }
    }
    getImageQuality(imageId) {
        const image = this._imageCache.get(imageId)?.image;
        return image
            ? image.imageQualityStatus || _enums__WEBPACK_IMPORTED_MODULE_4__.ImageQualityStatus.FULL_RESOLUTION
            : undefined;
    }
}
const cache = new Cache();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cache);



/***/ }),

/***/ 35637:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ BaseStreamingImageVolume)
/* harmony export */ });
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74876);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31749);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10364);
/* harmony import */ var _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51159);
/* harmony import */ var _utilities_ProgressiveIterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22191);
/* harmony import */ var _utilities_imageRetrieveMetadataProvider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17791);
/* harmony import */ var _utilities_hasFloatScalingParameters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30169);
/* harmony import */ var _utilities_autoLoad__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(91979);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69372);
/* harmony import */ var _ImageVolume__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(86252);
/* harmony import */ var _loaders_ProgressiveRetrieveImages__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(36822);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(59693);
/* harmony import */ var _loaders_imageLoader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(80068);













const requestTypeDefault = _enums__WEBPACK_IMPORTED_MODULE_1__.RequestType.Prefetch;
class BaseStreamingImageVolume extends _ImageVolume__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A {
    constructor(imageVolumeProperties, streamingProperties) {
        super(imageVolumeProperties);
        this.framesLoaded = 0;
        this.framesProcessed = 0;
        this.framesUpdated = 0;
        this.autoRenderOnLoad = true;
        this.cachedFrames = [];
        this.reRenderTarget = 0;
        this.reRenderFraction = 2;
        this.imagesLoader = this;
        this.cancelLoading = () => {
            const { loadStatus } = this;
            if (!loadStatus || !loadStatus.loading) {
                return;
            }
            loadStatus.loading = false;
            loadStatus.cancelled = true;
            this.clearLoadCallbacks();
            const filterFunction = ({ additionalDetails }) => {
                return additionalDetails.volumeId !== this.volumeId;
            };
            _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.filterRequests(filterFunction);
        };
        this.loadStatus = streamingProperties.loadStatus;
    }
    invalidateVolume(immediate) {
        const { vtkOpenGLTexture } = this;
        const { numFrames } = this;
        for (let i = 0; i < numFrames; i++) {
            vtkOpenGLTexture.setUpdatedFrame(i);
        }
        this.modified();
        if (immediate) {
            (0,_utilities_autoLoad__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(this.volumeId);
        }
    }
    clearLoadCallbacks() {
        this.loadStatus.callbacks = [];
    }
    callLoadStatusCallback(evt) {
        const { framesUpdated, framesProcessed, totalNumFrames } = evt;
        const { volumeId, reRenderFraction, loadStatus, metadata } = this;
        const { FrameOfReferenceUID } = metadata;
        if (this.autoRenderOnLoad) {
            if (framesUpdated > this.reRenderTarget ||
                framesProcessed === totalNumFrames) {
                this.reRenderTarget += reRenderFraction;
                (0,_utilities_autoLoad__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(volumeId);
            }
        }
        if (framesProcessed === totalNumFrames) {
            loadStatus.callbacks.forEach((callback) => callback(evt));
            const eventDetail = {
                FrameOfReferenceUID,
                volumeId: volumeId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_VOLUME_LOADING_COMPLETED, eventDetail);
        }
    }
    updateTextureAndTriggerEvents(imageIdIndex, imageId, imageQualityStatus = _enums__WEBPACK_IMPORTED_MODULE_1__.ImageQualityStatus.FULL_RESOLUTION) {
        const frameIndex = this.imageIdIndexToFrameIndex(imageIdIndex);
        const { cachedFrames, numFrames, totalNumFrames } = this;
        const { FrameOfReferenceUID } = this.metadata;
        const currentStatus = cachedFrames[frameIndex];
        if (currentStatus > imageQualityStatus) {
            return;
        }
        if (cachedFrames[frameIndex] === _enums__WEBPACK_IMPORTED_MODULE_1__.ImageQualityStatus.FULL_RESOLUTION) {
            return;
        }
        const complete = imageQualityStatus === _enums__WEBPACK_IMPORTED_MODULE_1__.ImageQualityStatus.FULL_RESOLUTION;
        cachedFrames[imageIdIndex] = imageQualityStatus;
        this.framesUpdated++;
        if (complete) {
            this.framesLoaded++;
            this.framesProcessed++;
        }
        const eventDetail = {
            FrameOfReferenceUID,
            volumeId: this.volumeId,
            numberOfFrames: numFrames,
            framesProcessed: this.framesProcessed,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_VOLUME_MODIFIED, eventDetail);
        if (complete && this.framesProcessed === this.totalNumFrames) {
            this.loadStatus.loaded = true;
            this.loadStatus.loading = false;
        }
        this.callLoadStatusCallback({
            success: true,
            imageIdIndex,
            imageId,
            framesLoaded: this.framesLoaded,
            framesProcessed: this.framesProcessed,
            framesUpdated: this.framesUpdated,
            numFrames,
            totalNumFrames,
            complete,
            imageQualityStatus,
        });
        this.vtkOpenGLTexture.setUpdatedFrame(frameIndex);
        if (this.loadStatus.loaded) {
            this.loadStatus.callbacks = [];
        }
    }
    successCallback(imageId, image) {
        const imageIdIndex = this.getImageIdIndex(imageId);
        const { imageQualityStatus } = image;
        if (this.loadStatus.cancelled) {
            console.warn('volume load cancelled, returning for imageIdIndex: ', imageIdIndex);
            return;
        }
        this.updateTextureAndTriggerEvents(imageIdIndex, imageId, imageQualityStatus);
        if (this.isDynamicVolume()) {
            this.checkTimePointCompletion(imageIdIndex);
        }
    }
    errorCallback(imageId, permanent, error) {
        if (!permanent) {
            return;
        }
        const { totalNumFrames, numFrames } = this;
        const imageIdIndex = this.getImageIdIndex(imageId);
        this.framesProcessed++;
        if (this.framesProcessed === totalNumFrames) {
            this.loadStatus.loaded = true;
            this.loadStatus.loading = false;
        }
        this.callLoadStatusCallback({
            success: false,
            imageId,
            imageIdIndex,
            error,
            framesLoaded: this.framesLoaded,
            framesProcessed: this.framesProcessed,
            framesUpdated: this.framesUpdated,
            numFrames,
            totalNumFrames,
        });
        if (this.loadStatus.loaded) {
            this.loadStatus.callbacks = [];
        }
        const eventDetail = {
            error,
            imageIdIndex,
            imageId,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_LOAD_ERROR, eventDetail);
    }
    load(callback) {
        const { imageIds, loadStatus, numFrames } = this;
        const { transferSyntaxUID } = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('transferSyntax', imageIds[0]) || {};
        const imageRetrieveConfiguration = _metaData__WEBPACK_IMPORTED_MODULE_0__.get(_utilities_imageRetrieveMetadataProvider__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.IMAGE_RETRIEVE_CONFIGURATION, this.volumeId, transferSyntaxUID, 'volume');
        this.imagesLoader = this.isDynamicVolume()
            ? this
            : imageRetrieveConfiguration
                ? (imageRetrieveConfiguration.create ||
                    _loaders_ProgressiveRetrieveImages__WEBPACK_IMPORTED_MODULE_10__/* ["default"].createProgressive */ .Ay.createProgressive)(imageRetrieveConfiguration)
                : this;
        if (loadStatus.loading === true) {
            return;
        }
        const { loaded } = this.loadStatus;
        const totalNumFrames = imageIds.length;
        if (loaded) {
            if (callback) {
                callback({
                    success: true,
                    framesLoaded: totalNumFrames,
                    framesProcessed: totalNumFrames,
                    numFrames,
                    totalNumFrames,
                });
            }
            return;
        }
        if (callback) {
            this.loadStatus.callbacks.push(callback);
        }
        this._prefetchImageIds();
    }
    getLoaderImageOptions(imageId) {
        const { transferSyntaxUID: transferSyntaxUID } = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('transferSyntax', imageId) || {};
        const imagePlaneModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('imagePlaneModule', imageId) || {};
        const { rows, columns } = imagePlaneModule;
        const imageIdIndex = this.getImageIdIndex(imageId);
        const modalityLutModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('modalityLutModule', imageId) || {};
        const generalSeriesModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('generalSeriesModule', imageId) || {};
        const scalingParameters = {
            rescaleSlope: modalityLutModule.rescaleSlope,
            rescaleIntercept: modalityLutModule.rescaleIntercept,
            modality: generalSeriesModule.modality,
        };
        if (scalingParameters.modality === 'PT') {
            const suvFactor = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('scalingModule', imageId);
            if (suvFactor) {
                this._addScalingToVolume(suvFactor);
                scalingParameters.suvbw = suvFactor.suvbw;
            }
        }
        const floatAfterScale = (0,_utilities_hasFloatScalingParameters__WEBPACK_IMPORTED_MODULE_6__/* .hasFloatScalingParameters */ .a)(scalingParameters);
        const allowFloatRendering = (0,_init__WEBPACK_IMPORTED_MODULE_11__/* .canRenderFloatTextures */ .lk)();
        this.isPreScaled = true;
        if (scalingParameters &&
            scalingParameters.rescaleSlope !== undefined &&
            scalingParameters.rescaleIntercept !== undefined) {
            const { rescaleSlope, rescaleIntercept } = scalingParameters;
            this.isPreScaled =
                typeof rescaleSlope === 'number' &&
                    typeof rescaleIntercept === 'number';
        }
        if (!allowFloatRendering && floatAfterScale) {
            this.isPreScaled = false;
        }
        const targetBuffer = {
            type: this.dataType,
            rows,
            columns,
        };
        return {
            targetBuffer,
            allowFloatRendering,
            preScale: {
                enabled: this.isPreScaled,
                scalingParameters,
            },
            transferPixelData: true,
            requestType: requestTypeDefault,
            transferSyntaxUID,
            additionalDetails: {
                imageId,
                imageIdIndex,
                volumeId: this.volumeId,
            },
        };
    }
    callLoadImage(imageId, imageIdIndex, options) {
        const { cachedFrames } = this;
        if (cachedFrames[imageIdIndex] === _enums__WEBPACK_IMPORTED_MODULE_1__.ImageQualityStatus.FULL_RESOLUTION) {
            return;
        }
        const handleImageCacheAdded = (event) => {
            const { image } = event.detail;
            if (image.imageId === imageId) {
                this.vtkOpenGLTexture.setUpdatedFrame(imageIdIndex);
                _eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_CACHE_IMAGE_ADDED, handleImageCacheAdded);
            }
        };
        _eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_CACHE_IMAGE_ADDED, handleImageCacheAdded);
        const uncompressedIterator = _utilities_ProgressiveIterator__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.as((0,_loaders_imageLoader__WEBPACK_IMPORTED_MODULE_12__.loadAndCacheImage)(imageId, options));
        return uncompressedIterator.forEach((image) => {
            this.successCallback(imageId, image);
        }, this.errorCallback.bind(this, imageIdIndex, imageId));
    }
    getImageIdsRequests(imageIds, priorityDefault) {
        this.totalNumFrames = this.imageIds.length;
        const autoRenderPercentage = 2;
        if (this.autoRenderOnLoad) {
            this.reRenderFraction =
                this.totalNumFrames * (autoRenderPercentage / 100);
            this.reRenderTarget = this.reRenderFraction;
        }
        const requests = imageIds.map((imageId) => {
            const imageIdIndex = this.getImageIdIndex(imageId);
            const requestType = requestTypeDefault;
            const priority = priorityDefault;
            const options = this.getLoaderImageOptions(imageId);
            return {
                callLoadImage: this.callLoadImage.bind(this),
                imageId,
                imageIdIndex,
                options,
                priority,
                requestType,
                additionalDetails: {
                    volumeId: this.volumeId,
                },
            };
        });
        return requests;
    }
    getImageLoadRequests(priority) {
        throw new Error('Abstract method');
    }
    getImageIdsToLoad() {
        throw new Error('Abstract method');
    }
    loadImages() {
        this.loadStatus.loading = true;
        const requests = this.getImageLoadRequests(5);
        requests.reverse().forEach((request) => {
            if (!request) {
                return;
            }
            const { callLoadImage, imageId, imageIdIndex, options, priority, requestType, additionalDetails, } = request;
            _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.addRequest(callLoadImage.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
        });
        return Promise.resolve(true);
    }
    _prefetchImageIds() {
        this.loadStatus.loading = true;
        const imageIds = [...this.getImageIdsToLoad()];
        this.totalNumFrames = this.imageIds.length;
        const autoRenderPercentage = 2;
        if (this.autoRenderOnLoad) {
            this.reRenderFraction =
                this.totalNumFrames * (autoRenderPercentage / 100);
            this.reRenderTarget = this.reRenderFraction;
        }
        return this.imagesLoader.loadImages(imageIds, this).catch((e) => {
            console.debug('progressive loading failed to complete', e);
        });
    }
    _addScalingToVolume(suvFactor) {
        if (this.scaling) {
            return;
        }
        const { suvbw, suvlbm, suvbsa } = suvFactor;
        const petScaling = {};
        if (suvlbm) {
            petScaling.suvbwToSuvlbm = suvlbm / suvbw;
        }
        if (suvbsa) {
            petScaling.suvbwToSuvbsa = suvbsa / suvbw;
        }
        if (suvbw) {
            petScaling.suvbw = suvbw;
        }
        this.scaling = { PT: petScaling };
    }
    checkTimePointCompletion(imageIdIndex) { }
}


/***/ }),

/***/ 86252:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   Q: () => (/* binding */ ImageVolume)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58498);
/* harmony import */ var _utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39537);
/* harmony import */ var _utilities_VoxelManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24623);
/* harmony import */ var _RenderingEngine_vtkClasses__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96097);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49038);





class ImageVolume {
    constructor(props) {
        this._imageIdsIndexMap = new Map();
        this._imageURIsIndexMap = new Map();
        this.cornerstoneImageMetaData = null;
        this.isPreScaled = false;
        this.numTimePoints = null;
        const { imageIds, scaling, dimensions, spacing, origin, direction, dataType, volumeId, referencedVolumeId, metadata, referencedImageIds, additionalDetails, voxelManager, numberOfComponents, } = props;
        if (!dataType) {
            throw new Error('Data type is required, please provide a data type as string such as "Uint8Array", "Float32Array", etc.');
        }
        let { imageData } = props;
        this.imageIds = imageIds;
        this.volumeId = volumeId;
        this.metadata = metadata;
        this.dimensions = dimensions;
        this.spacing = spacing;
        this.origin = origin;
        this.direction = direction;
        this.dataType = dataType;
        this.vtkOpenGLTexture = _RenderingEngine_vtkClasses__WEBPACK_IMPORTED_MODULE_3__/* .vtkStreamingOpenGLTexture */ .uT.newInstance();
        this.vtkOpenGLTexture.setVolumeId(volumeId);
        this.voxelManager =
            voxelManager ??
                _utilities_VoxelManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.createImageVolumeVoxelManager({
                    dimensions,
                    imageIds,
                    numberOfComponents,
                });
        this.numVoxels =
            this.dimensions[0] * this.dimensions[1] * this.dimensions[2];
        if (!imageData) {
            imageData = _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
            imageData.setDimensions(dimensions);
            imageData.setSpacing(spacing);
            imageData.setDirection(direction);
            imageData.setOrigin(origin);
        }
        imageData.set({
            dataType: dataType,
            voxelManager: this.voxelManager,
            id: volumeId,
            numberOfComponents: numberOfComponents || 1,
        });
        imageData.set({
            hasScalarVolume: false,
        });
        this.imageData = imageData;
        this.numFrames = this._getNumFrames();
        this._reprocessImageIds();
        if (scaling) {
            this.scaling = scaling;
        }
        if (referencedVolumeId) {
            this.referencedVolumeId = referencedVolumeId;
        }
        if (referencedImageIds) {
            this.referencedImageIds = referencedImageIds;
        }
        if (additionalDetails) {
            this.additionalDetails = additionalDetails;
        }
    }
    get sizeInBytes() {
        return this.voxelManager.sizeInBytes;
    }
    get imageIds() {
        return this._imageIds;
    }
    set imageIds(newImageIds) {
        this._imageIds = newImageIds;
        this._reprocessImageIds();
    }
    _reprocessImageIds() {
        this._imageIdsIndexMap.clear();
        this._imageURIsIndexMap.clear();
        this._imageIds.forEach((imageId, i) => {
            const imageURI = (0,_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageId);
            this._imageIdsIndexMap.set(imageId, i);
            this._imageURIsIndexMap.set(imageURI, i);
        });
    }
    isDynamicVolume() {
        return this.numTimePoints > 1;
    }
    getImageIdIndex(imageId) {
        return this._imageIdsIndexMap.get(imageId);
    }
    getImageIdByIndex(imageIdIndex) {
        return this._imageIds[imageIdIndex];
    }
    getImageURIIndex(imageURI) {
        return this._imageURIsIndexMap.get(imageURI);
    }
    load(callback) {
    }
    destroy() {
        this.imageData.delete();
        this.imageData = null;
        this.voxelManager.clear();
        this.vtkOpenGLTexture.releaseGraphicsResources();
        this.vtkOpenGLTexture.delete();
    }
    invalidate() {
        for (let i = 0; i < this.imageIds.length; i++) {
            this.vtkOpenGLTexture.setUpdatedFrame(i);
        }
        this.imageData.modified();
    }
    modified() {
        this.imageData.modified();
        this.vtkOpenGLTexture.modified();
        this.numFrames = this._getNumFrames();
    }
    removeFromCache() {
        _cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.removeVolumeLoadObject(this.volumeId);
    }
    getScalarDataLength() {
        return this.voxelManager.getScalarDataLength();
    }
    _getNumFrames() {
        if (!this.isDynamicVolume()) {
            return this.imageIds.length;
        }
        return this.numTimePoints;
    }
    imageIdIndexToFrameIndex(imageIdIndex) {
        return imageIdIndex % this.numFrames;
    }
    getCornerstoneImages() {
        const { imageIds } = this;
        return imageIds.map((imageId) => {
            return _cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getImage(imageId);
        });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageVolume);


/***/ }),

/***/ 50180:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ StreamingImageVolume)
/* harmony export */ });
/* harmony import */ var _BaseStreamingImageVolume__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35637);

class StreamingImageVolume extends _BaseStreamingImageVolume__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A {
    constructor(imageVolumeProperties, streamingProperties) {
        if (!imageVolumeProperties.imageIds) {
            imageVolumeProperties.imageIds = streamingProperties.imageIds;
        }
        super(imageVolumeProperties, streamingProperties);
        this.getImageIdsToLoad = () => {
            const { imageIds } = this;
            this.numFrames = imageIds.length;
            return imageIds;
        };
    }
    getScalarData() {
        return this.voxelManager.getScalarData();
    }
    getImageLoadRequests(priority) {
        const { imageIds } = this;
        return this.getImageIdsRequests(imageIds, priority);
    }
}


/***/ }),

/***/ 58927:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: Cache, ImageVolume, StreamingDynamicImageVolume, StreamingImageVolume, Surface

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/ImageVolume.js
var ImageVolume = __webpack_require__(86252);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Surface.js
var Surface = __webpack_require__(90808);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/StreamingImageVolume.js
var StreamingImageVolume = __webpack_require__(50180);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 4 modules
var enums = __webpack_require__(31749);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js + 40 modules
var utilities = __webpack_require__(49035);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/BaseStreamingImageVolume.js
var BaseStreamingImageVolume = __webpack_require__(35637);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/StreamingDynamicImageVolume.js




class StreamingDynamicImageVolume extends BaseStreamingImageVolume/* default */.A {
    constructor(imageVolumeProperties, streamingProperties) {
        super(imageVolumeProperties, streamingProperties);
        this._timePointIndex = 0;
        this._loadedTimePoints = new Set();
        this._getImageIdRequests = (imageIds, priority) => {
            return this.getImageIdsRequests(imageIds, priority);
        };
        this.getImageLoadRequests = (priority) => {
            const imageIds = this.getImageIdsToLoad();
            return this._getImageIdRequests(imageIds, priority);
        };
        const { imageIdGroups, splittingTag } = imageVolumeProperties;
        this._splittingTag = splittingTag;
        this._imageIdGroups = imageIdGroups;
        this.numTimePoints = this._imageIdGroups.length;
    }
    _getImageIdsToLoad() {
        const imageIdGroups = this._imageIdGroups;
        const initialImageIdGroupIndex = this._timePointIndex;
        const imageIds = [...imageIdGroups[initialImageIdGroupIndex]];
        let leftIndex = initialImageIdGroupIndex - 1;
        let rightIndex = initialImageIdGroupIndex + 1;
        while (leftIndex >= 0 || rightIndex < imageIdGroups.length) {
            if (leftIndex >= 0) {
                imageIds.push(...imageIdGroups[leftIndex--]);
            }
            if (rightIndex < imageIdGroups.length) {
                imageIds.push(...imageIdGroups[rightIndex++]);
            }
        }
        return imageIds;
    }
    getImageIdsToLoad() {
        return this._getImageIdsToLoad();
    }
    get timePointIndex() {
        return this._timePointIndex;
    }
    set timePointIndex(index) {
        if (this._timePointIndex === index) {
            return;
        }
        this._timePointIndex = index;
        this.voxelManager.setTimePoint(index);
        this.invalidateVolume(true);
        (0,utilities.triggerEvent)(eventTarget/* default */.A, enums.Events.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED, {
            volumeId: this.volumeId,
            timePointIndex: index,
            numTimePoints: this.numTimePoints,
            imageIdGroupIndex: index,
            numImageIdGroups: this.numTimePoints,
            splittingTag: this.splittingTag,
        });
    }
    scroll(delta) {
        const newIndex = this._timePointIndex + delta;
        if (newIndex < 0) {
            this.timePointIndex = this.numTimePoints - 1;
        }
        else if (newIndex >= this.numTimePoints) {
            this.timePointIndex = 0;
        }
        else {
            this.timePointIndex = newIndex;
        }
    }
    getCurrentTimePointImageIds() {
        return this._imageIdGroups[this._timePointIndex];
    }
    flatImageIdIndexToTimePointIndex(flatImageIdIndex) {
        return Math.floor(flatImageIdIndex / this._imageIdGroups[0].length);
    }
    flatImageIdIndexToImageIdIndex(flatImageIdIndex) {
        return flatImageIdIndex % this._imageIdGroups[0].length;
    }
    get splittingTag() {
        return this._splittingTag;
    }
    isTimePointLoaded(timePointIndex) {
        return this._loadedTimePoints.has(timePointIndex);
    }
    markTimePointAsLoaded(timePointIndex) {
        this._loadedTimePoints.add(timePointIndex);
        (0,utilities.triggerEvent)(eventTarget/* default */.A, enums.Events.DYNAMIC_VOLUME_TIME_POINT_LOADED, {
            volumeId: this.volumeId,
            timePointIndex,
        });
    }
    checkTimePointCompletion(imageIdIndex) {
        const timePointIndex = this.flatImageIdIndexToTimePointIndex(imageIdIndex);
        const imageIdsInTimePoint = this._imageIdGroups[timePointIndex];
        const allLoaded = imageIdsInTimePoint.every((imageId) => {
            const index = this.getImageIdIndex(imageId);
            return this.cachedFrames[index] === enums.ImageQualityStatus.FULL_RESOLUTION;
        });
        if (allLoaded && !this.isTimePointLoaded(timePointIndex)) {
            this.markTimePointAsLoaded(timePointIndex);
        }
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/index.js








/***/ }),

/***/ 21093:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const colormapsData = {
    hotIron: {
        name: 'Hot Iron',
        numOfColors: 256,
        colors: [
            [0, 0, 0, 255],
            [2, 0, 0, 255],
            [4, 0, 0, 255],
            [6, 0, 0, 255],
            [8, 0, 0, 255],
            [10, 0, 0, 255],
            [12, 0, 0, 255],
            [14, 0, 0, 255],
            [16, 0, 0, 255],
            [18, 0, 0, 255],
            [20, 0, 0, 255],
            [22, 0, 0, 255],
            [24, 0, 0, 255],
            [26, 0, 0, 255],
            [28, 0, 0, 255],
            [30, 0, 0, 255],
            [32, 0, 0, 255],
            [34, 0, 0, 255],
            [36, 0, 0, 255],
            [38, 0, 0, 255],
            [40, 0, 0, 255],
            [42, 0, 0, 255],
            [44, 0, 0, 255],
            [46, 0, 0, 255],
            [48, 0, 0, 255],
            [50, 0, 0, 255],
            [52, 0, 0, 255],
            [54, 0, 0, 255],
            [56, 0, 0, 255],
            [58, 0, 0, 255],
            [60, 0, 0, 255],
            [62, 0, 0, 255],
            [64, 0, 0, 255],
            [66, 0, 0, 255],
            [68, 0, 0, 255],
            [70, 0, 0, 255],
            [72, 0, 0, 255],
            [74, 0, 0, 255],
            [76, 0, 0, 255],
            [78, 0, 0, 255],
            [80, 0, 0, 255],
            [82, 0, 0, 255],
            [84, 0, 0, 255],
            [86, 0, 0, 255],
            [88, 0, 0, 255],
            [90, 0, 0, 255],
            [92, 0, 0, 255],
            [94, 0, 0, 255],
            [96, 0, 0, 255],
            [98, 0, 0, 255],
            [100, 0, 0, 255],
            [102, 0, 0, 255],
            [104, 0, 0, 255],
            [106, 0, 0, 255],
            [108, 0, 0, 255],
            [110, 0, 0, 255],
            [112, 0, 0, 255],
            [114, 0, 0, 255],
            [116, 0, 0, 255],
            [118, 0, 0, 255],
            [120, 0, 0, 255],
            [122, 0, 0, 255],
            [124, 0, 0, 255],
            [126, 0, 0, 255],
            [128, 0, 0, 255],
            [130, 0, 0, 255],
            [132, 0, 0, 255],
            [134, 0, 0, 255],
            [136, 0, 0, 255],
            [138, 0, 0, 255],
            [140, 0, 0, 255],
            [142, 0, 0, 255],
            [144, 0, 0, 255],
            [146, 0, 0, 255],
            [148, 0, 0, 255],
            [150, 0, 0, 255],
            [152, 0, 0, 255],
            [154, 0, 0, 255],
            [156, 0, 0, 255],
            [158, 0, 0, 255],
            [160, 0, 0, 255],
            [162, 0, 0, 255],
            [164, 0, 0, 255],
            [166, 0, 0, 255],
            [168, 0, 0, 255],
            [170, 0, 0, 255],
            [172, 0, 0, 255],
            [174, 0, 0, 255],
            [176, 0, 0, 255],
            [178, 0, 0, 255],
            [180, 0, 0, 255],
            [182, 0, 0, 255],
            [184, 0, 0, 255],
            [186, 0, 0, 255],
            [188, 0, 0, 255],
            [190, 0, 0, 255],
            [192, 0, 0, 255],
            [194, 0, 0, 255],
            [196, 0, 0, 255],
            [198, 0, 0, 255],
            [200, 0, 0, 255],
            [202, 0, 0, 255],
            [204, 0, 0, 255],
            [206, 0, 0, 255],
            [208, 0, 0, 255],
            [210, 0, 0, 255],
            [212, 0, 0, 255],
            [214, 0, 0, 255],
            [216, 0, 0, 255],
            [218, 0, 0, 255],
            [220, 0, 0, 255],
            [222, 0, 0, 255],
            [224, 0, 0, 255],
            [226, 0, 0, 255],
            [228, 0, 0, 255],
            [230, 0, 0, 255],
            [232, 0, 0, 255],
            [234, 0, 0, 255],
            [236, 0, 0, 255],
            [238, 0, 0, 255],
            [240, 0, 0, 255],
            [242, 0, 0, 255],
            [244, 0, 0, 255],
            [246, 0, 0, 255],
            [248, 0, 0, 255],
            [250, 0, 0, 255],
            [252, 0, 0, 255],
            [254, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 2, 0, 255],
            [255, 4, 0, 255],
            [255, 6, 0, 255],
            [255, 8, 0, 255],
            [255, 10, 0, 255],
            [255, 12, 0, 255],
            [255, 14, 0, 255],
            [255, 16, 0, 255],
            [255, 18, 0, 255],
            [255, 20, 0, 255],
            [255, 22, 0, 255],
            [255, 24, 0, 255],
            [255, 26, 0, 255],
            [255, 28, 0, 255],
            [255, 30, 0, 255],
            [255, 32, 0, 255],
            [255, 34, 0, 255],
            [255, 36, 0, 255],
            [255, 38, 0, 255],
            [255, 40, 0, 255],
            [255, 42, 0, 255],
            [255, 44, 0, 255],
            [255, 46, 0, 255],
            [255, 48, 0, 255],
            [255, 50, 0, 255],
            [255, 52, 0, 255],
            [255, 54, 0, 255],
            [255, 56, 0, 255],
            [255, 58, 0, 255],
            [255, 60, 0, 255],
            [255, 62, 0, 255],
            [255, 64, 0, 255],
            [255, 66, 0, 255],
            [255, 68, 0, 255],
            [255, 70, 0, 255],
            [255, 72, 0, 255],
            [255, 74, 0, 255],
            [255, 76, 0, 255],
            [255, 78, 0, 255],
            [255, 80, 0, 255],
            [255, 82, 0, 255],
            [255, 84, 0, 255],
            [255, 86, 0, 255],
            [255, 88, 0, 255],
            [255, 90, 0, 255],
            [255, 92, 0, 255],
            [255, 94, 0, 255],
            [255, 96, 0, 255],
            [255, 98, 0, 255],
            [255, 100, 0, 255],
            [255, 102, 0, 255],
            [255, 104, 0, 255],
            [255, 106, 0, 255],
            [255, 108, 0, 255],
            [255, 110, 0, 255],
            [255, 112, 0, 255],
            [255, 114, 0, 255],
            [255, 116, 0, 255],
            [255, 118, 0, 255],
            [255, 120, 0, 255],
            [255, 122, 0, 255],
            [255, 124, 0, 255],
            [255, 126, 0, 255],
            [255, 128, 4, 255],
            [255, 130, 8, 255],
            [255, 132, 12, 255],
            [255, 134, 16, 255],
            [255, 136, 20, 255],
            [255, 138, 24, 255],
            [255, 140, 28, 255],
            [255, 142, 32, 255],
            [255, 144, 36, 255],
            [255, 146, 40, 255],
            [255, 148, 44, 255],
            [255, 150, 48, 255],
            [255, 152, 52, 255],
            [255, 154, 56, 255],
            [255, 156, 60, 255],
            [255, 158, 64, 255],
            [255, 160, 68, 255],
            [255, 162, 72, 255],
            [255, 164, 76, 255],
            [255, 166, 80, 255],
            [255, 168, 84, 255],
            [255, 170, 88, 255],
            [255, 172, 92, 255],
            [255, 174, 96, 255],
            [255, 176, 100, 255],
            [255, 178, 104, 255],
            [255, 180, 108, 255],
            [255, 182, 112, 255],
            [255, 184, 116, 255],
            [255, 186, 120, 255],
            [255, 188, 124, 255],
            [255, 190, 128, 255],
            [255, 192, 132, 255],
            [255, 194, 136, 255],
            [255, 196, 140, 255],
            [255, 198, 144, 255],
            [255, 200, 148, 255],
            [255, 202, 152, 255],
            [255, 204, 156, 255],
            [255, 206, 160, 255],
            [255, 208, 164, 255],
            [255, 210, 168, 255],
            [255, 212, 172, 255],
            [255, 214, 176, 255],
            [255, 216, 180, 255],
            [255, 218, 184, 255],
            [255, 220, 188, 255],
            [255, 222, 192, 255],
            [255, 224, 196, 255],
            [255, 226, 200, 255],
            [255, 228, 204, 255],
            [255, 230, 208, 255],
            [255, 232, 212, 255],
            [255, 234, 216, 255],
            [255, 236, 220, 255],
            [255, 238, 224, 255],
            [255, 240, 228, 255],
            [255, 242, 232, 255],
            [255, 244, 236, 255],
            [255, 246, 240, 255],
            [255, 248, 244, 255],
            [255, 250, 248, 255],
            [255, 252, 252, 255],
            [255, 255, 255, 255],
        ],
    },
    pet: {
        name: 'PET',
        numColors: 256,
        colors: [
            [0, 0, 0, 255],
            [0, 2, 1, 255],
            [0, 4, 3, 255],
            [0, 6, 5, 255],
            [0, 8, 7, 255],
            [0, 10, 9, 255],
            [0, 12, 11, 255],
            [0, 14, 13, 255],
            [0, 16, 15, 255],
            [0, 18, 17, 255],
            [0, 20, 19, 255],
            [0, 22, 21, 255],
            [0, 24, 23, 255],
            [0, 26, 25, 255],
            [0, 28, 27, 255],
            [0, 30, 29, 255],
            [0, 32, 31, 255],
            [0, 34, 33, 255],
            [0, 36, 35, 255],
            [0, 38, 37, 255],
            [0, 40, 39, 255],
            [0, 42, 41, 255],
            [0, 44, 43, 255],
            [0, 46, 45, 255],
            [0, 48, 47, 255],
            [0, 50, 49, 255],
            [0, 52, 51, 255],
            [0, 54, 53, 255],
            [0, 56, 55, 255],
            [0, 58, 57, 255],
            [0, 60, 59, 255],
            [0, 62, 61, 255],
            [0, 65, 63, 255],
            [0, 67, 65, 255],
            [0, 69, 67, 255],
            [0, 71, 69, 255],
            [0, 73, 71, 255],
            [0, 75, 73, 255],
            [0, 77, 75, 255],
            [0, 79, 77, 255],
            [0, 81, 79, 255],
            [0, 83, 81, 255],
            [0, 85, 83, 255],
            [0, 87, 85, 255],
            [0, 89, 87, 255],
            [0, 91, 89, 255],
            [0, 93, 91, 255],
            [0, 95, 93, 255],
            [0, 97, 95, 255],
            [0, 99, 97, 255],
            [0, 101, 99, 255],
            [0, 103, 101, 255],
            [0, 105, 103, 255],
            [0, 107, 105, 255],
            [0, 109, 107, 255],
            [0, 111, 109, 255],
            [0, 113, 111, 255],
            [0, 115, 113, 255],
            [0, 117, 115, 255],
            [0, 119, 117, 255],
            [0, 121, 119, 255],
            [0, 123, 121, 255],
            [0, 125, 123, 255],
            [0, 128, 125, 255],
            [1, 126, 127, 255],
            [3, 124, 129, 255],
            [5, 122, 131, 255],
            [7, 120, 133, 255],
            [9, 118, 135, 255],
            [11, 116, 137, 255],
            [13, 114, 139, 255],
            [15, 112, 141, 255],
            [17, 110, 143, 255],
            [19, 108, 145, 255],
            [21, 106, 147, 255],
            [23, 104, 149, 255],
            [25, 102, 151, 255],
            [27, 100, 153, 255],
            [29, 98, 155, 255],
            [31, 96, 157, 255],
            [33, 94, 159, 255],
            [35, 92, 161, 255],
            [37, 90, 163, 255],
            [39, 88, 165, 255],
            [41, 86, 167, 255],
            [43, 84, 169, 255],
            [45, 82, 171, 255],
            [47, 80, 173, 255],
            [49, 78, 175, 255],
            [51, 76, 177, 255],
            [53, 74, 179, 255],
            [55, 72, 181, 255],
            [57, 70, 183, 255],
            [59, 68, 185, 255],
            [61, 66, 187, 255],
            [63, 64, 189, 255],
            [65, 63, 191, 255],
            [67, 61, 193, 255],
            [69, 59, 195, 255],
            [71, 57, 197, 255],
            [73, 55, 199, 255],
            [75, 53, 201, 255],
            [77, 51, 203, 255],
            [79, 49, 205, 255],
            [81, 47, 207, 255],
            [83, 45, 209, 255],
            [85, 43, 211, 255],
            [86, 41, 213, 255],
            [88, 39, 215, 255],
            [90, 37, 217, 255],
            [92, 35, 219, 255],
            [94, 33, 221, 255],
            [96, 31, 223, 255],
            [98, 29, 225, 255],
            [100, 27, 227, 255],
            [102, 25, 229, 255],
            [104, 23, 231, 255],
            [106, 21, 233, 255],
            [108, 19, 235, 255],
            [110, 17, 237, 255],
            [112, 15, 239, 255],
            [114, 13, 241, 255],
            [116, 11, 243, 255],
            [118, 9, 245, 255],
            [120, 7, 247, 255],
            [122, 5, 249, 255],
            [124, 3, 251, 255],
            [126, 1, 253, 255],
            [128, 0, 255, 255],
            [130, 2, 252, 255],
            [132, 4, 248, 255],
            [134, 6, 244, 255],
            [136, 8, 240, 255],
            [138, 10, 236, 255],
            [140, 12, 232, 255],
            [142, 14, 228, 255],
            [144, 16, 224, 255],
            [146, 18, 220, 255],
            [148, 20, 216, 255],
            [150, 22, 212, 255],
            [152, 24, 208, 255],
            [154, 26, 204, 255],
            [156, 28, 200, 255],
            [158, 30, 196, 255],
            [160, 32, 192, 255],
            [162, 34, 188, 255],
            [164, 36, 184, 255],
            [166, 38, 180, 255],
            [168, 40, 176, 255],
            [170, 42, 172, 255],
            [171, 44, 168, 255],
            [173, 46, 164, 255],
            [175, 48, 160, 255],
            [177, 50, 156, 255],
            [179, 52, 152, 255],
            [181, 54, 148, 255],
            [183, 56, 144, 255],
            [185, 58, 140, 255],
            [187, 60, 136, 255],
            [189, 62, 132, 255],
            [191, 64, 128, 255],
            [193, 66, 124, 255],
            [195, 68, 120, 255],
            [197, 70, 116, 255],
            [199, 72, 112, 255],
            [201, 74, 108, 255],
            [203, 76, 104, 255],
            [205, 78, 100, 255],
            [207, 80, 96, 255],
            [209, 82, 92, 255],
            [211, 84, 88, 255],
            [213, 86, 84, 255],
            [215, 88, 80, 255],
            [217, 90, 76, 255],
            [219, 92, 72, 255],
            [221, 94, 68, 255],
            [223, 96, 64, 255],
            [225, 98, 60, 255],
            [227, 100, 56, 255],
            [229, 102, 52, 255],
            [231, 104, 48, 255],
            [233, 106, 44, 255],
            [235, 108, 40, 255],
            [237, 110, 36, 255],
            [239, 112, 32, 255],
            [241, 114, 28, 255],
            [243, 116, 24, 255],
            [245, 118, 20, 255],
            [247, 120, 16, 255],
            [249, 122, 12, 255],
            [251, 124, 8, 255],
            [253, 126, 4, 255],
            [255, 128, 0, 255],
            [255, 130, 4, 255],
            [255, 132, 8, 255],
            [255, 134, 12, 255],
            [255, 136, 16, 255],
            [255, 138, 20, 255],
            [255, 140, 24, 255],
            [255, 142, 28, 255],
            [255, 144, 32, 255],
            [255, 146, 36, 255],
            [255, 148, 40, 255],
            [255, 150, 44, 255],
            [255, 152, 48, 255],
            [255, 154, 52, 255],
            [255, 156, 56, 255],
            [255, 158, 60, 255],
            [255, 160, 64, 255],
            [255, 162, 68, 255],
            [255, 164, 72, 255],
            [255, 166, 76, 255],
            [255, 168, 80, 255],
            [255, 170, 85, 255],
            [255, 172, 89, 255],
            [255, 174, 93, 255],
            [255, 176, 97, 255],
            [255, 178, 101, 255],
            [255, 180, 105, 255],
            [255, 182, 109, 255],
            [255, 184, 113, 255],
            [255, 186, 117, 255],
            [255, 188, 121, 255],
            [255, 190, 125, 255],
            [255, 192, 129, 255],
            [255, 194, 133, 255],
            [255, 196, 137, 255],
            [255, 198, 141, 255],
            [255, 200, 145, 255],
            [255, 202, 149, 255],
            [255, 204, 153, 255],
            [255, 206, 157, 255],
            [255, 208, 161, 255],
            [255, 210, 165, 255],
            [255, 212, 170, 255],
            [255, 214, 174, 255],
            [255, 216, 178, 255],
            [255, 218, 182, 255],
            [255, 220, 186, 255],
            [255, 222, 190, 255],
            [255, 224, 194, 255],
            [255, 226, 198, 255],
            [255, 228, 202, 255],
            [255, 230, 206, 255],
            [255, 232, 210, 255],
            [255, 234, 214, 255],
            [255, 236, 218, 255],
            [255, 238, 222, 255],
            [255, 240, 226, 255],
            [255, 242, 230, 255],
            [255, 244, 234, 255],
            [255, 246, 238, 255],
            [255, 248, 242, 255],
            [255, 250, 246, 255],
            [255, 252, 250, 255],
            [255, 255, 255, 255],
        ],
    },
    hotMetalBlue: {
        name: 'Hot Metal Blue',
        numColors: 256,
        colors: [
            [0, 0, 0, 255],
            [0, 0, 2, 255],
            [0, 0, 4, 255],
            [0, 0, 6, 255],
            [0, 0, 8, 255],
            [0, 0, 10, 255],
            [0, 0, 12, 255],
            [0, 0, 14, 255],
            [0, 0, 16, 255],
            [0, 0, 17, 255],
            [0, 0, 19, 255],
            [0, 0, 21, 255],
            [0, 0, 23, 255],
            [0, 0, 25, 255],
            [0, 0, 27, 255],
            [0, 0, 29, 255],
            [0, 0, 31, 255],
            [0, 0, 33, 255],
            [0, 0, 35, 255],
            [0, 0, 37, 255],
            [0, 0, 39, 255],
            [0, 0, 41, 255],
            [0, 0, 43, 255],
            [0, 0, 45, 255],
            [0, 0, 47, 255],
            [0, 0, 49, 255],
            [0, 0, 51, 255],
            [0, 0, 53, 255],
            [0, 0, 55, 255],
            [0, 0, 57, 255],
            [0, 0, 59, 255],
            [0, 0, 61, 255],
            [0, 0, 63, 255],
            [0, 0, 65, 255],
            [0, 0, 67, 255],
            [0, 0, 69, 255],
            [0, 0, 71, 255],
            [0, 0, 73, 255],
            [0, 0, 75, 255],
            [0, 0, 77, 255],
            [0, 0, 79, 255],
            [0, 0, 81, 255],
            [0, 0, 83, 255],
            [0, 0, 84, 255],
            [0, 0, 86, 255],
            [0, 0, 88, 255],
            [0, 0, 90, 255],
            [0, 0, 92, 255],
            [0, 0, 94, 255],
            [0, 0, 96, 255],
            [0, 0, 98, 255],
            [0, 0, 100, 255],
            [0, 0, 102, 255],
            [0, 0, 104, 255],
            [0, 0, 106, 255],
            [0, 0, 108, 255],
            [0, 0, 110, 255],
            [0, 0, 112, 255],
            [0, 0, 114, 255],
            [0, 0, 116, 255],
            [0, 0, 117, 255],
            [0, 0, 119, 255],
            [0, 0, 121, 255],
            [0, 0, 123, 255],
            [0, 0, 125, 255],
            [0, 0, 127, 255],
            [0, 0, 129, 255],
            [0, 0, 131, 255],
            [0, 0, 133, 255],
            [0, 0, 135, 255],
            [0, 0, 137, 255],
            [0, 0, 139, 255],
            [0, 0, 141, 255],
            [0, 0, 143, 255],
            [0, 0, 145, 255],
            [0, 0, 147, 255],
            [0, 0, 149, 255],
            [0, 0, 151, 255],
            [0, 0, 153, 255],
            [0, 0, 155, 255],
            [0, 0, 157, 255],
            [0, 0, 159, 255],
            [0, 0, 161, 255],
            [0, 0, 163, 255],
            [0, 0, 165, 255],
            [0, 0, 167, 255],
            [3, 0, 169, 255],
            [6, 0, 171, 255],
            [9, 0, 173, 255],
            [12, 0, 175, 255],
            [15, 0, 177, 255],
            [18, 0, 179, 255],
            [21, 0, 181, 255],
            [24, 0, 183, 255],
            [26, 0, 184, 255],
            [29, 0, 186, 255],
            [32, 0, 188, 255],
            [35, 0, 190, 255],
            [38, 0, 192, 255],
            [41, 0, 194, 255],
            [44, 0, 196, 255],
            [47, 0, 198, 255],
            [50, 0, 200, 255],
            [52, 0, 197, 255],
            [55, 0, 194, 255],
            [57, 0, 191, 255],
            [59, 0, 188, 255],
            [62, 0, 185, 255],
            [64, 0, 182, 255],
            [66, 0, 179, 255],
            [69, 0, 176, 255],
            [71, 0, 174, 255],
            [74, 0, 171, 255],
            [76, 0, 168, 255],
            [78, 0, 165, 255],
            [81, 0, 162, 255],
            [83, 0, 159, 255],
            [85, 0, 156, 255],
            [88, 0, 153, 255],
            [90, 0, 150, 255],
            [93, 2, 144, 255],
            [96, 4, 138, 255],
            [99, 6, 132, 255],
            [102, 8, 126, 255],
            [105, 9, 121, 255],
            [108, 11, 115, 255],
            [111, 13, 109, 255],
            [114, 15, 103, 255],
            [116, 17, 97, 255],
            [119, 19, 91, 255],
            [122, 21, 85, 255],
            [125, 23, 79, 255],
            [128, 24, 74, 255],
            [131, 26, 68, 255],
            [134, 28, 62, 255],
            [137, 30, 56, 255],
            [140, 32, 50, 255],
            [143, 34, 47, 255],
            [146, 36, 44, 255],
            [149, 38, 41, 255],
            [152, 40, 38, 255],
            [155, 41, 35, 255],
            [158, 43, 32, 255],
            [161, 45, 29, 255],
            [164, 47, 26, 255],
            [166, 49, 24, 255],
            [169, 51, 21, 255],
            [172, 53, 18, 255],
            [175, 55, 15, 255],
            [178, 56, 12, 255],
            [181, 58, 9, 255],
            [184, 60, 6, 255],
            [187, 62, 3, 255],
            [190, 64, 0, 255],
            [194, 66, 0, 255],
            [198, 68, 0, 255],
            [201, 70, 0, 255],
            [205, 72, 0, 255],
            [209, 73, 0, 255],
            [213, 75, 0, 255],
            [217, 77, 0, 255],
            [221, 79, 0, 255],
            [224, 81, 0, 255],
            [228, 83, 0, 255],
            [232, 85, 0, 255],
            [236, 87, 0, 255],
            [240, 88, 0, 255],
            [244, 90, 0, 255],
            [247, 92, 0, 255],
            [251, 94, 0, 255],
            [255, 96, 0, 255],
            [255, 98, 3, 255],
            [255, 100, 6, 255],
            [255, 102, 9, 255],
            [255, 104, 12, 255],
            [255, 105, 15, 255],
            [255, 107, 18, 255],
            [255, 109, 21, 255],
            [255, 111, 24, 255],
            [255, 113, 26, 255],
            [255, 115, 29, 255],
            [255, 117, 32, 255],
            [255, 119, 35, 255],
            [255, 120, 38, 255],
            [255, 122, 41, 255],
            [255, 124, 44, 255],
            [255, 126, 47, 255],
            [255, 128, 50, 255],
            [255, 130, 53, 255],
            [255, 132, 56, 255],
            [255, 134, 59, 255],
            [255, 136, 62, 255],
            [255, 137, 65, 255],
            [255, 139, 68, 255],
            [255, 141, 71, 255],
            [255, 143, 74, 255],
            [255, 145, 76, 255],
            [255, 147, 79, 255],
            [255, 149, 82, 255],
            [255, 151, 85, 255],
            [255, 152, 88, 255],
            [255, 154, 91, 255],
            [255, 156, 94, 255],
            [255, 158, 97, 255],
            [255, 160, 100, 255],
            [255, 162, 103, 255],
            [255, 164, 106, 255],
            [255, 166, 109, 255],
            [255, 168, 112, 255],
            [255, 169, 115, 255],
            [255, 171, 118, 255],
            [255, 173, 121, 255],
            [255, 175, 124, 255],
            [255, 177, 126, 255],
            [255, 179, 129, 255],
            [255, 181, 132, 255],
            [255, 183, 135, 255],
            [255, 184, 138, 255],
            [255, 186, 141, 255],
            [255, 188, 144, 255],
            [255, 190, 147, 255],
            [255, 192, 150, 255],
            [255, 194, 153, 255],
            [255, 196, 156, 255],
            [255, 198, 159, 255],
            [255, 200, 162, 255],
            [255, 201, 165, 255],
            [255, 203, 168, 255],
            [255, 205, 171, 255],
            [255, 207, 174, 255],
            [255, 209, 176, 255],
            [255, 211, 179, 255],
            [255, 213, 182, 255],
            [255, 215, 185, 255],
            [255, 216, 188, 255],
            [255, 218, 191, 255],
            [255, 220, 194, 255],
            [255, 222, 197, 255],
            [255, 224, 200, 255],
            [255, 226, 203, 255],
            [255, 228, 206, 255],
            [255, 229, 210, 255],
            [255, 231, 213, 255],
            [255, 233, 216, 255],
            [255, 235, 219, 255],
            [255, 237, 223, 255],
            [255, 239, 226, 255],
            [255, 240, 229, 255],
            [255, 242, 232, 255],
            [255, 244, 236, 255],
            [255, 246, 239, 255],
            [255, 248, 242, 255],
            [255, 250, 245, 255],
            [255, 251, 249, 255],
            [255, 253, 252, 255],
            [255, 255, 255, 255],
        ],
    },
    pet20Step: {
        name: 'PET 20 Step',
        numColors: 256,
        colors: [
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
        ],
    },
    gray: {
        name: 'Gray',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            blue: [
                [0, 0, 0],
                [1, 1, 1],
            ],
        },
    },
    jet: {
        name: 'Jet',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [0.35, 0, 0],
                [0.66, 1, 1],
                [0.89, 1, 1],
                [1, 0.5, 0.5],
            ],
            green: [
                [0, 0, 0],
                [0.125, 0, 0],
                [0.375, 1, 1],
                [0.64, 1, 1],
                [0.91, 0, 0],
                [1, 0, 0],
            ],
            blue: [
                [0, 0.5, 0.5],
                [0.11, 1, 1],
                [0.34, 1, 1],
                [0.65, 0, 0],
                [1, 0, 0],
            ],
        },
    },
    hsv: {
        name: 'HSV',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 1, 1],
                [0.15873, 1, 1],
                [0.174603, 0.96875, 0.96875],
                [0.333333, 0.03125, 0.03125],
                [0.349206, 0, 0],
                [0.666667, 0, 0],
                [0.68254, 0.03125, 0.03125],
                [0.84127, 0.96875, 0.96875],
                [0.857143, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [0.15873, 0.9375, 0.9375],
                [0.174603, 1, 1],
                [0.507937, 1, 1],
                [0.666667, 0.0625, 0.0625],
                [0.68254, 0, 0],
                [1, 0, 0],
            ],
            blue: [
                [0, 0, 0],
                [0.333333, 0, 0],
                [0.349206, 0.0625, 0.0625],
                [0.507937, 1, 1],
                [0.84127, 1, 1],
                [0.857143, 0.9375, 0.9375],
                [1, 0.09375, 0.09375],
            ],
        },
    },
    hot: {
        name: 'Hot',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0.0416, 0.0416],
                [0.365079, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [0.365079, 0, 0],
                [0.746032, 1, 1],
                [1, 1, 1],
            ],
            blue: [
                [0, 0, 0],
                [0.746032, 0, 0],
                [1, 1, 1],
            ],
        },
    },
    cool: {
        name: 'Cool',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            green: [
                [0, 1, 1],
                [1, 0, 0],
            ],
            blue: [
                [0, 1, 1],
                [1, 1, 1],
            ],
        },
    },
    spring: {
        name: 'Spring',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            blue: [
                [0, 1, 1],
                [1, 0, 0],
            ],
        },
    },
    summer: {
        name: 'Summer',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            green: [
                [0, 0.5, 0.5],
                [1, 1, 1],
            ],
            blue: [
                [0, 0.4, 0.4],
                [1, 0.4, 0.4],
            ],
        },
    },
    autumn: {
        name: 'Autumn',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            blue: [
                [0, 0, 0],
                [1, 0, 0],
            ],
        },
    },
    winter: {
        name: 'Winter',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [1, 0, 0],
            ],
            green: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            blue: [
                [0, 1, 1],
                [1, 0.5, 0.5],
            ],
        },
    },
    bone: {
        name: 'Bone',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [0.746032, 0.652778, 0.652778],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [0.365079, 0.319444, 0.319444],
                [0.746032, 0.777778, 0.777778],
                [1, 1, 1],
            ],
            blue: [
                [0, 0, 0],
                [0.365079, 0.444444, 0.444444],
                [1, 1, 1],
            ],
        },
    },
    copper: {
        name: 'Copper',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [0.809524, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [1, 0.7812, 0.7812],
            ],
            blue: [
                [0, 0, 0],
                [1, 0.4975, 0.4975],
            ],
        },
    },
    spectral: {
        name: 'Spectral',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [0.05, 0.4667, 0.4667],
                [0.1, 0.5333, 0.5333],
                [0.15, 0, 0],
                [0.2, 0, 0],
                [0.25, 0, 0],
                [0.3, 0, 0],
                [0.35, 0, 0],
                [0.4, 0, 0],
                [0.45, 0, 0],
                [0.5, 0, 0],
                [0.55, 0, 0],
                [0.6, 0, 0],
                [0.65, 0.7333, 0.7333],
                [0.7, 0.9333, 0.9333],
                [0.75, 1, 1],
                [0.8, 1, 1],
                [0.85, 1, 1],
                [0.9, 0.8667, 0.8667],
                [0.95, 0.8, 0.8],
                [1, 0.8, 0.8],
            ],
            green: [
                [0, 0, 0],
                [0.05, 0, 0],
                [0.1, 0, 0],
                [0.15, 0, 0],
                [0.2, 0, 0],
                [0.25, 0.4667, 0.4667],
                [0.3, 0.6, 0.6],
                [0.35, 0.6667, 0.6667],
                [0.4, 0.6667, 0.6667],
                [0.45, 0.6, 0.6],
                [0.5, 0.7333, 0.7333],
                [0.55, 0.8667, 0.8667],
                [0.6, 1, 1],
                [0.65, 1, 1],
                [0.7, 0.9333, 0.9333],
                [0.75, 0.8, 0.8],
                [0.8, 0.6, 0.6],
                [0.85, 0, 0],
                [0.9, 0, 0],
                [0.95, 0, 0],
                [1, 0.8, 0.8],
            ],
            blue: [
                [0, 0, 0],
                [0.05, 0.5333, 0.5333],
                [0.1, 0.6, 0.6],
                [0.15, 0.6667, 0.6667],
                [0.2, 0.8667, 0.8667],
                [0.25, 0.8667, 0.8667],
                [0.3, 0.8667, 0.8667],
                [0.35, 0.6667, 0.6667],
                [0.4, 0.5333, 0.5333],
                [0.45, 0, 0],
                [0.5, 0, 0],
                [0.55, 0, 0],
                [0.6, 0, 0],
                [0.65, 0, 0],
                [0.7, 0, 0],
                [0.75, 0, 0],
                [0.8, 0, 0],
                [0.85, 0, 0],
                [0.9, 0, 0],
                [0.95, 0, 0],
                [1, 0.8, 0.8],
            ],
        },
    },
    coolwarm: {
        name: 'CoolWarm',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0.2298057, 0.2298057],
                [0.03125, 0.26623388, 0.26623388],
                [0.0625, 0.30386891, 0.30386891],
                [0.09375, 0.342804478, 0.342804478],
                [0.125, 0.38301334, 0.38301334],
                [0.15625, 0.424369608, 0.424369608],
                [0.1875, 0.46666708, 0.46666708],
                [0.21875, 0.509635204, 0.509635204],
                [0.25, 0.552953156, 0.552953156],
                [0.28125, 0.596262162, 0.596262162],
                [0.3125, 0.639176211, 0.639176211],
                [0.34375, 0.681291281, 0.681291281],
                [0.375, 0.722193294, 0.722193294],
                [0.40625, 0.761464949, 0.761464949],
                [0.4375, 0.798691636, 0.798691636],
                [0.46875, 0.833466556, 0.833466556],
                [0.5, 0.865395197, 0.865395197],
                [0.53125, 0.897787179, 0.897787179],
                [0.5625, 0.924127593, 0.924127593],
                [0.59375, 0.944468518, 0.944468518],
                [0.625, 0.958852946, 0.958852946],
                [0.65625, 0.96732803, 0.96732803],
                [0.6875, 0.969954137, 0.969954137],
                [0.71875, 0.966811177, 0.966811177],
                [0.75, 0.958003065, 0.958003065],
                [0.78125, 0.943660866, 0.943660866],
                [0.8125, 0.923944917, 0.923944917],
                [0.84375, 0.89904617, 0.89904617],
                [0.875, 0.869186849, 0.869186849],
                [0.90625, 0.834620542, 0.834620542],
                [0.9375, 0.795631745, 0.795631745],
                [0.96875, 0.752534934, 0.752534934],
                [1, 0.705673158, 0.705673158],
            ],
            green: [
                [0, 0.298717966, 0.298717966],
                [0.03125, 0.353094838, 0.353094838],
                [0.0625, 0.406535296, 0.406535296],
                [0.09375, 0.458757618, 0.458757618],
                [0.125, 0.50941904, 0.50941904],
                [0.15625, 0.558148092, 0.558148092],
                [0.1875, 0.604562568, 0.604562568],
                [0.21875, 0.648280772, 0.648280772],
                [0.25, 0.688929332, 0.688929332],
                [0.28125, 0.726149107, 0.726149107],
                [0.3125, 0.759599947, 0.759599947],
                [0.34375, 0.788964712, 0.788964712],
                [0.375, 0.813952739, 0.813952739],
                [0.40625, 0.834302879, 0.834302879],
                [0.4375, 0.849786142, 0.849786142],
                [0.46875, 0.860207984, 0.860207984],
                [0.5, 0.86541021, 0.86541021],
                [0.53125, 0.848937047, 0.848937047],
                [0.5625, 0.827384882, 0.827384882],
                [0.59375, 0.800927443, 0.800927443],
                [0.625, 0.769767752, 0.769767752],
                [0.65625, 0.734132809, 0.734132809],
                [0.6875, 0.694266682, 0.694266682],
                [0.71875, 0.650421156, 0.650421156],
                [0.75, 0.602842431, 0.602842431],
                [0.78125, 0.551750968, 0.551750968],
                [0.8125, 0.49730856, 0.49730856],
                [0.84375, 0.439559467, 0.439559467],
                [0.875, 0.378313092, 0.378313092],
                [0.90625, 0.312874446, 0.312874446],
                [0.9375, 0.24128379, 0.24128379],
                [0.96875, 0.157246067, 0.157246067],
                [1, 0.01555616, 0.01555616],
            ],
            blue: [
                [0, 0.753683153, 0.753683153],
                [0.03125, 0.801466763, 0.801466763],
                [0.0625, 0.84495867, 0.84495867],
                [0.09375, 0.883725899, 0.883725899],
                [0.125, 0.917387822, 0.917387822],
                [0.15625, 0.945619588, 0.945619588],
                [0.1875, 0.968154911, 0.968154911],
                [0.21875, 0.98478814, 0.98478814],
                [0.25, 0.995375608, 0.995375608],
                [0.28125, 0.999836203, 0.999836203],
                [0.3125, 0.998151185, 0.998151185],
                [0.34375, 0.990363227, 0.990363227],
                [0.375, 0.976574709, 0.976574709],
                [0.40625, 0.956945269, 0.956945269],
                [0.4375, 0.931688648, 0.931688648],
                [0.46875, 0.901068838, 0.901068838],
                [0.5, 0.865395561, 0.865395561],
                [0.53125, 0.820880546, 0.820880546],
                [0.5625, 0.774508472, 0.774508472],
                [0.59375, 0.726736146, 0.726736146],
                [0.625, 0.678007945, 0.678007945],
                [0.65625, 0.628751763, 0.628751763],
                [0.6875, 0.579375448, 0.579375448],
                [0.71875, 0.530263762, 0.530263762],
                [0.75, 0.481775914, 0.481775914],
                [0.78125, 0.434243684, 0.434243684],
                [0.8125, 0.387970225, 0.387970225],
                [0.84375, 0.343229596, 0.343229596],
                [0.875, 0.300267182, 0.300267182],
                [0.90625, 0.259301199, 0.259301199],
                [0.9375, 0.220525627, 0.220525627],
                [0.96875, 0.184115123, 0.184115123],
                [1, 0.150232812, 0.150232812],
            ],
        },
    },
    blues: {
        name: 'Blues',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0.9686274528503418, 0.9686274528503418],
                [0.125, 0.87058824300765991, 0.87058824300765991],
                [0.25, 0.7764706015586853, 0.7764706015586853],
                [0.375, 0.61960786581039429, 0.61960786581039429],
                [0.5, 0.41960784792900085, 0.41960784792900085],
                [0.625, 0.25882354378700256, 0.25882354378700256],
                [0.75, 0.12941177189350128, 0.12941177189350128],
                [0.875, 0.031372550874948502, 0.031372550874948502],
                [1, 0.031372550874948502, 0.031372550874948502],
            ],
            green: [
                [0, 0.9843137264251709, 0.9843137264251709],
                [0.125, 0.92156863212585449, 0.92156863212585449],
                [0.25, 0.85882353782653809, 0.85882353782653809],
                [0.375, 0.7921568751335144, 0.7921568751335144],
                [0.5, 0.68235296010971069, 0.68235296010971069],
                [0.625, 0.57254904508590698, 0.57254904508590698],
                [0.75, 0.44313725829124451, 0.44313725829124451],
                [0.875, 0.31764706969261169, 0.31764706969261169],
                [1, 0.18823529779911041, 0.18823529779911041],
            ],
            blue: [
                [0, 1, 1],
                [0.125, 0.9686274528503418, 0.9686274528503418],
                [0.25, 0.93725490570068359, 0.93725490570068359],
                [0.375, 0.88235294818878174, 0.88235294818878174],
                [0.5, 0.83921569585800171, 0.83921569585800171],
                [0.625, 0.7764706015586853, 0.7764706015586853],
                [0.75, 0.70980393886566162, 0.70980393886566162],
                [0.875, 0.61176472902297974, 0.61176472902297974],
                [1, 0.41960784792900085, 0.41960784792900085],
            ],
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (colormapsData);


/***/ }),

/***/ 19325:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  EPSILON: () => (/* reexport */ epsilon),
  MPR_CAMERA_VALUES: () => (/* reexport */ constants_mprCameraValues),
  RENDERING_DEFAULTS: () => (/* reexport */ rendering),
  VIEWPORT_PRESETS: () => (/* reexport */ viewportPresets)
});

// UNUSED EXPORTS: BACKGROUND_COLORS, CPU_COLORMAPS

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/cpuColormaps.js
var cpuColormaps = __webpack_require__(21093);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/rendering.js
const RENDERING_DEFAULTS = {
    MINIMUM_SLAB_THICKNESS: 5e-2,
    MAXIMUM_RAY_DISTANCE: 1e6,
};
Object.freeze(RENDERING_DEFAULTS);
/* harmony default export */ const rendering = (RENDERING_DEFAULTS);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/epsilon.js
const EPSILON = 1e-3;
/* harmony default export */ const epsilon = (EPSILON);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepFreeze.js
function deepFreeze(object) {
    const propNames = Object.getOwnPropertyNames(object);
    for (const name of propNames) {
        const value = object[name];
        if (value && typeof value === 'object') {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}
/* harmony default export */ const utilities_deepFreeze = (deepFreeze);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/mprCameraValues.js

const MPR_CAMERA_VALUES = {
    axial: {
        viewPlaneNormal: [0, 0, -1],
        viewUp: [0, -1, 0],
        viewRight: [1, 0, 0],
    },
    sagittal: {
        viewPlaneNormal: [1, 0, 0],
        viewUp: [0, 0, 1],
        viewRight: [0, 1, 0],
    },
    coronal: {
        viewPlaneNormal: [0, -1, 0],
        viewUp: [0, 0, 1],
        viewRight: [1, 0, 0],
    },
};
const mprCameraValues = utilities_deepFreeze(MPR_CAMERA_VALUES);
/* harmony default export */ const constants_mprCameraValues = (mprCameraValues);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/viewportPresets.js
const presets = [
    {
        name: 'CT-AAA',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '12 -3024 0 143.556 0 166.222 0.686275 214.389 0.696078 419.736 0.833333 3071 0.803922',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '24 -3024 0 0 0 143.556 0.615686 0.356863 0.184314 166.222 0.882353 0.603922 0.290196 214.389 1 1 1 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-AAA2',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '16 -3024 0 129.542 0 145.244 0.166667 157.02 0.5 169.918 0.627451 395.575 0.8125 1578.73 0.8125 3071 0.8125',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '32 -3024 0 0 0 129.542 0.54902 0.25098 0.14902 145.244 0.6 0.627451 0.843137 157.02 0.890196 0.47451 0.6 169.918 0.992157 0.870588 0.392157 395.575 1 0.886275 0.658824 1578.73 1 0.829256 0.957922 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Bone',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '8 -3024 0 -16.4458 0 641.385 0.715686 3071 0.705882',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '16 -3024 0 0 0 -16.4458 0.729412 0.254902 0.301961 641.385 0.905882 0.815686 0.552941 3071 1 1 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Bones',
        gradientOpacity: '4 0 1 985.12 1',
        specularPower: '1',
        scalarOpacity: '8 -1000 0 152.19 0 278.93 0.190476 952 0.2',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '20 -1000 0.3 0.3 1 -488 0.3 1 0.3 463.28 1 0 0 659.15 1 0.912535 0.0374849 953 1 0.3 0.3',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Cardiac',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '12 -3024 0 -77.6875 0 94.9518 0.285714 179.052 0.553571 260.439 0.848214 3071 0.875',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '24 -3024 0 0 0 -77.6875 0.54902 0.25098 0.14902 94.9518 0.882353 0.603922 0.290196 179.052 1 0.937033 0.954531 260.439 0.615686 0 0 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Cardiac2',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '12 -3024 0 42.8964 0 163.488 0.428571 277.642 0.776786 1587 0.754902 3071 0.754902',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '24 -3024 0 0 0 42.8964 0.54902 0.25098 0.14902 163.488 0.917647 0.639216 0.0588235 277.642 1 0.878431 0.623529 1587 1 1 1 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Cardiac3',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '14 -3024 0 -86.9767 0 45.3791 0.169643 139.919 0.589286 347.907 0.607143 1224.16 0.607143 3071 0.616071',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '28 -3024 0 0 0 -86.9767 0 0.25098 1 45.3791 1 0 0 139.919 1 0.894893 0.894893 347.907 1 1 0.25098 1224.16 1 1 1 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Chest-Contrast-Enhanced',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '10 -3024 0 67.0106 0 251.105 0.446429 439.291 0.625 3071 0.616071',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '20 -3024 0 0 0 67.0106 0.54902 0.25098 0.14902 251.105 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Chest-Vessels',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '10 -3024 0 -1278.35 0 22.8277 0.428571 439.291 0.625 3071 0.616071',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '20 -3024 0 0 0 -1278.35 0.54902 0.25098 0.14902 22.8277 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Coronary-Arteries',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '12 -2048 0 136.47 0 159.215 0.258929 318.43 0.571429 478.693 0.776786 3661 1',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '24 -2048 0 0 0 136.47 0 0 0 159.215 0.159804 0.159804 0.159804 318.43 0.764706 0.764706 0.764706 478.693 1 1 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Coronary-Arteries-2',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '14 -2048 0 142.677 0 145.016 0.116071 192.174 0.5625 217.24 0.776786 384.347 0.830357 3661 0.830357',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '28 -2048 0 0 0 142.677 0 0 0 145.016 0.615686 0 0.0156863 192.174 0.909804 0.454902 0 217.24 0.972549 0.807843 0.611765 384.347 0.909804 0.909804 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Coronary-Arteries-3',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '14 -2048 0 128.643 0 129.982 0.0982143 173.636 0.669643 255.884 0.857143 584.878 0.866071 3661 1',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '28 -2048 0 0 0 128.643 0 0 0 129.982 0.615686 0 0.0156863 173.636 0.909804 0.454902 0 255.884 0.886275 0.886275 0.886275 584.878 0.968627 0.968627 0.968627 3661 1 1 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Cropped-Volume-Bone',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '10 -2048 0 -451 0 -450 1 1050 1 3661 1',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '20 -2048 0 0 0 -451 0 0 0 -450 0.0556356 0.0556356 0.0556356 1050 1 1 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Fat',
        gradientOpacity: '6 0 1 985.12 1 988 1',
        specularPower: '1',
        scalarOpacity: '14 -1000 0 -100 0 -99 0.15 -60 0.15 -59 0 101.2 0 952 0',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '36 -1000 0.3 0.3 1 -497.5 0.3 1 0.3 -99 0 0 1 -76.946 0 1 0 -65.481 0.835431 0.888889 0.0165387 83.89 1 0 0 463.28 1 0 0 659.15 1 0.912535 0.0374849 2952 1 0.300267 0.299886',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Liver-Vasculature',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '14 -2048 0 149.113 0 157.884 0.482143 339.96 0.660714 388.526 0.830357 1197.95 0.839286 3661 0.848214',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '28 -2048 0 0 0 149.113 0 0 0 157.884 0.501961 0.25098 0 339.96 0.695386 0.59603 0.36886 388.526 0.854902 0.85098 0.827451 1197.95 1 1 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Lung',
        gradientOpacity: '6 0 1 985.12 1 988 1',
        specularPower: '1',
        scalarOpacity: '12 -1000 0 -600 0 -599 0.15 -400 0.15 -399 0 2952 0',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '24 -1000 0.3 0.3 1 -600 0 0 1 -530 0.134704 0.781726 0.0724558 -460 0.929244 1 0.109473 -400 0.888889 0.254949 0.0240258 2952 1 0.3 0.3',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-MIP',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '8 -3024 0 -637.62 0 700 1 3071 1',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '16 -3024 0 0 0 -637.62 1 1 1 700 1 1 1 3071 1 1 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Muscle',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '10 -3024 0 -155.407 0 217.641 0.676471 419.736 0.833333 3071 0.803922',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '20 -3024 0 0 0 -155.407 0.54902 0.25098 0.14902 217.641 0.882353 0.603922 0.290196 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Pulmonary-Arteries',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '14 -2048 0 -568.625 0 -364.081 0.0714286 -244.813 0.401786 18.2775 0.607143 447.798 0.830357 3592.73 0.839286',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '28 -2048 0 0 0 -568.625 0 0 0 -364.081 0.396078 0.301961 0.180392 -244.813 0.611765 0.352941 0.0705882 18.2775 0.843137 0.0156863 0.156863 447.798 0.752941 0.752941 0.752941 3592.73 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Soft-Tissue',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '10 -2048 0 -167.01 0 -160 1 240 1 3661 1',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '20 -2048 0 0 0 -167.01 0 0 0 -160 0.0556356 0.0556356 0.0556356 240 1 1 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Air',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '8 -3024 0.705882 -900.0 0.715686 -500.0 0 3071 0',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '16 -3024 1 1 1 -900.0 0.2 1.0 1.0 -500.0 0.3 0.3 1.0 3071 0 0 0 ',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'MR-Angio',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '12 -2048 0 151.354 0 158.279 0.4375 190.112 0.580357 200.873 0.732143 3661 0.741071',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '24 -2048 0 0 0 151.354 0 0 0 158.279 0.74902 0.376471 0 190.112 1 0.866667 0.733333 200.873 0.937255 0.937255 0.937255 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'MR-Default',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '12 0 0 20 0 40 0.15 120 0.3 220 0.375 1024 0.5',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '24 0 0 0 0 20 0.168627 0 0 40 0.403922 0.145098 0.0784314 120 0.780392 0.607843 0.380392 220 0.847059 0.835294 0.788235 1024 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'MR-MIP',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '8 0 0 98.3725 0 416.637 1 2800 1',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '16 0 1 1 1 98.3725 1 1 1 416.637 1 1 1 2800 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'MR-T2-Brain',
        gradientOpacity: '4 0 1 160.25 1',
        specularPower: '40',
        scalarOpacity: '10 0 0 36.05 0 218.302 0.171429 412.406 1 641 1',
        specular: '0.5',
        shade: '1',
        ambient: '0.3',
        colorTransfer: '16 0 0 0 0 98.7223 0.956863 0.839216 0.192157 412.406 0 0.592157 0.807843 641 1 1 1',
        diffuse: '0.6',
        interpolation: '1',
    },
    {
        name: 'DTI-FA-Brain',
        gradientOpacity: '4 0 1 0.9950 1',
        specularPower: '40',
        scalarOpacity: '16 0 0 0 0 0.3501 0.0158 0.49379 0.7619 0.6419 1 0.9920 1 0.9950 0 0.9950 0',
        specular: '0.5',
        shade: '1',
        ambient: '0.3',
        colorTransfer: '28 0 1 0 0 0 1 0 0 0.24974 0.4941 1 0 0.49949 0 0.9882 1 0.7492 0.51764 0 1 0.9950 1 0 0 0.9950 1 0 0',
        diffuse: '0.9',
        interpolation: '1',
    },
];
/* harmony default export */ const viewportPresets = (presets);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/backgroundColors.js
const backgroundColors = {
    slicer3D: [160 / 255, 164 / 255, 217 / 255],
};
/* harmony default export */ const constants_backgroundColors = ((/* unused pure expression or super */ null && (backgroundColors)));

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js









/***/ }),

/***/ 86066:
/***/ (() => {

"use strict";
var ContourType;
(function (ContourType) {
    ContourType["CLOSED_PLANAR"] = "CLOSED_PLANAR";
    ContourType["OPEN_PLANAR"] = "OPEN_PLANAR";
})(ContourType || (ContourType = {}));
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (ContourType)));


/***/ }),

/***/ 91369:
/***/ (() => {

"use strict";
var DynamicOperatorType;
(function (DynamicOperatorType) {
    DynamicOperatorType["SUM"] = "SUM";
    DynamicOperatorType["AVERAGE"] = "AVERAGE";
    DynamicOperatorType["SUBTRACT"] = "SUBTRACT";
})(DynamicOperatorType || (DynamicOperatorType = {}));
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (DynamicOperatorType)));


/***/ }),

/***/ 32643:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events;
(function (Events) {
    Events["ERROR_EVENT"] = "CORNERSTONE_ERROR";
    Events["CACHE_SIZE_EXCEEDED"] = "CACHE_SIZE_EXCEEDED";
    Events["IMAGE_LOAD_ERROR"] = "IMAGE_LOAD_ERROR";
    Events["CAMERA_MODIFIED"] = "CORNERSTONE_CAMERA_MODIFIED";
    Events["CAMERA_RESET"] = "CORNERSTONE_CAMERA_RESET";
    Events["VOI_MODIFIED"] = "CORNERSTONE_VOI_MODIFIED";
    Events["PRESET_MODIFIED"] = "CORNERSTONE_VIEWPORT_RENDERING_PRESET_MODIFIED";
    Events["DISPLAY_AREA_MODIFIED"] = "CORNERSTONE_DISPLAY_AREA_MODIFIED";
    Events["ELEMENT_DISABLED"] = "CORNERSTONE_ELEMENT_DISABLED";
    Events["ELEMENT_ENABLED"] = "CORNERSTONE_ELEMENT_ENABLED";
    Events["IMAGE_RENDERED"] = "CORNERSTONE_IMAGE_RENDERED";
    Events["IMAGE_VOLUME_MODIFIED"] = "CORNERSTONE_IMAGE_VOLUME_MODIFIED";
    Events["IMAGE_VOLUME_LOADING_COMPLETED"] = "CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED";
    Events["IMAGE_LOADED"] = "CORNERSTONE_IMAGE_LOADED";
    Events["IMAGE_RETRIEVAL_STAGE"] = "CORNERSTONE_IMAGE_RETRIEVAL_STAGE";
    Events["IMAGE_LOAD_FAILED"] = "CORNERSTONE_IMAGE_LOAD_FAILED";
    Events["VOLUME_VIEWPORT_NEW_VOLUME"] = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME";
    Events["VOLUME_LOADED"] = "CORNERSTONE_VOLUME_LOADED";
    Events["VOLUME_LOADED_FAILED"] = "CORNERSTONE_VOLUME_LOADED_FAILED";
    Events["IMAGE_CACHE_IMAGE_ADDED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED";
    Events["IMAGE_CACHE_IMAGE_REMOVED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED";
    Events["VOLUME_CACHE_VOLUME_ADDED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED";
    Events["VOLUME_CACHE_VOLUME_REMOVED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED";
    Events["STACK_NEW_IMAGE"] = "CORNERSTONE_STACK_NEW_IMAGE";
    Events["VOLUME_NEW_IMAGE"] = "CORNERSTONE_VOLUME_NEW_IMAGE";
    Events["PRE_STACK_NEW_IMAGE"] = "CORNERSTONE_PRE_STACK_NEW_IMAGE";
    Events["IMAGE_SPACING_CALIBRATED"] = "CORNERSTONE_IMAGE_SPACING_CALIBRATED";
    Events["VIEWPORT_NEW_IMAGE_SET"] = "CORNERSTONE_VIEWPORT_NEW_IMAGE_SET";
    Events["STACK_VIEWPORT_SCROLL"] = "CORNERSTONE_STACK_VIEWPORT_SCROLL";
    Events["STACK_SCROLL_OUT_OF_BOUNDS"] = "STACK_SCROLL_OUT_OF_BOUNDS";
    Events["GEOMETRY_CACHE_GEOMETRY_ADDED"] = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED";
    Events["GEOMETRY_CACHE_GEOMETRY_REMOVED"] = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_REMOVED";
    Events["VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS"] = "VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS";
    Events["VOLUME_VIEWPORT_SCROLL"] = "VOLUME_VIEWPORT_SCROLL";
    Events["CLIPPING_PLANES_UPDATED"] = "CORNERSTONE_CLIPPING_PLANES_UPDATED";
    Events["WEB_WORKER_PROGRESS"] = "CORNERSTONE_WEB_WORKER_PROGRESS";
    Events["COLORMAP_MODIFIED"] = "CORNERSTONE_COLORMAP_MODIFIED";
    Events["DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED"] = "DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED";
    Events["DYNAMIC_VOLUME_TIME_POINT_LOADED"] = "DYNAMIC_VOLUME_TIME_POINT_LOADED";
    Events["GEOMETRY_LOADED"] = "GEOMETRY_LOADED";
    Events["GEOMETRY_LOADED_FAILED"] = "GEOMETRY_LOADED_FAILED";
})(Events || (Events = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);


/***/ }),

/***/ 77474:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ImageQualityStatus;
(function (ImageQualityStatus) {
    ImageQualityStatus[ImageQualityStatus["FAR_REPLICATE"] = 1] = "FAR_REPLICATE";
    ImageQualityStatus[ImageQualityStatus["ADJACENT_REPLICATE"] = 3] = "ADJACENT_REPLICATE";
    ImageQualityStatus[ImageQualityStatus["SUBRESOLUTION"] = 6] = "SUBRESOLUTION";
    ImageQualityStatus[ImageQualityStatus["LOSSY"] = 7] = "LOSSY";
    ImageQualityStatus[ImageQualityStatus["FULL_RESOLUTION"] = 8] = "FULL_RESOLUTION";
})(ImageQualityStatus || (ImageQualityStatus = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageQualityStatus);


/***/ }),

/***/ 29310:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var InterpolationType;
(function (InterpolationType) {
    InterpolationType[InterpolationType["NEAREST"] = 0] = "NEAREST";
    InterpolationType[InterpolationType["LINEAR"] = 1] = "LINEAR";
    InterpolationType[InterpolationType["FAST_LINEAR"] = 2] = "FAST_LINEAR";
})(InterpolationType || (InterpolationType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterpolationType);


/***/ }),

/***/ 69850:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var MetadataModules;
(function (MetadataModules) {
    MetadataModules["CALIBRATION"] = "calibrationModule";
    MetadataModules["CINE"] = "cineModule";
    MetadataModules["GENERAL_IMAGE"] = "generalImageModule";
    MetadataModules["GENERAL_SERIES"] = "generalSeriesModule";
    MetadataModules["GENERAL_STUDY"] = "generalStudyModule";
    MetadataModules["IMAGE_PIXEL"] = "imagePixelModule";
    MetadataModules["IMAGE_PLANE"] = "imagePlaneModule";
    MetadataModules["IMAGE_URL"] = "imageUrlModule";
    MetadataModules["MODALITY_LUT"] = "modalityLutModule";
    MetadataModules["MULTIFRAME"] = "multiframeModule";
    MetadataModules["NM_MULTIFRAME_GEOMETRY"] = "nmMultiframeGeometryModule";
    MetadataModules["OVERLAY_PLANE"] = "overlayPlaneModule";
    MetadataModules["PATIENT"] = "patientModule";
    MetadataModules["PATIENT_STUDY"] = "patientStudyModule";
    MetadataModules["PET_IMAGE"] = "petImageModule";
    MetadataModules["PET_ISOTOPE"] = "petIsotopeModule";
    MetadataModules["PET_SERIES"] = "petSeriesModule";
    MetadataModules["SOP_COMMON"] = "sopCommonModule";
    MetadataModules["ULTRASOUND_ENHANCED_REGION"] = "ultrasoundEnhancedRegionModule";
    MetadataModules["VOI_LUT"] = "voiLutModule";
    MetadataModules["WADO_WEB_CLIENT"] = "wadoWebClient";
})(MetadataModules || (MetadataModules = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MetadataModules);


/***/ }),

/***/ 18735:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var OrientationAxis;
(function (OrientationAxis) {
    OrientationAxis["AXIAL"] = "axial";
    OrientationAxis["CORONAL"] = "coronal";
    OrientationAxis["SAGITTAL"] = "sagittal";
    OrientationAxis["ACQUISITION"] = "acquisition";
})(OrientationAxis || (OrientationAxis = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrientationAxis);


/***/ }),

/***/ 43213:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var RequestType;
(function (RequestType) {
    RequestType["Interaction"] = "interaction";
    RequestType["Thumbnail"] = "thumbnail";
    RequestType["Prefetch"] = "prefetch";
    RequestType["Compute"] = "compute";
})(RequestType || (RequestType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RequestType);


/***/ }),

/***/ 82501:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var VOILUTFunctionType;
(function (VOILUTFunctionType) {
    VOILUTFunctionType["LINEAR"] = "LINEAR";
    VOILUTFunctionType["SAMPLED_SIGMOID"] = "SIGMOID";
})(VOILUTFunctionType || (VOILUTFunctionType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VOILUTFunctionType);


/***/ }),

/***/ 13545:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedUnit: () => (/* binding */ SpeedUnit)
/* harmony export */ });
var SpeedUnit;
(function (SpeedUnit) {
    SpeedUnit["FRAME"] = "f";
    SpeedUnit["SECOND"] = "s";
})(SpeedUnit || (SpeedUnit = {}));



/***/ }),

/***/ 1814:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ViewportStatus;
(function (ViewportStatus) {
    ViewportStatus["NO_DATA"] = "noData";
    ViewportStatus["LOADING"] = "loading";
    ViewportStatus["PRE_RENDER"] = "preRender";
    ViewportStatus["RESIZE"] = "resize";
    ViewportStatus["RENDERED"] = "rendered";
})(ViewportStatus || (ViewportStatus = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ViewportStatus);


/***/ }),

/***/ 41864:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ViewportType;
(function (ViewportType) {
    ViewportType["STACK"] = "stack";
    ViewportType["ORTHOGRAPHIC"] = "orthographic";
    ViewportType["PERSPECTIVE"] = "perspective";
    ViewportType["VOLUME_3D"] = "volume3d";
    ViewportType["VIDEO"] = "video";
    ViewportType["WHOLE_SLIDE"] = "wholeSlide";
})(ViewportType || (ViewportType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ViewportType);


/***/ }),

/***/ 10364:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class CornerstoneEventTarget {
    constructor() {
        this.listeners = {};
        this.debouncedListeners = {};
    }
    reset() {
        this.listeners = {};
        this.debouncedListeners = {};
    }
    addEventListenerOnce(type, callback) {
        const onceWrapper = (event) => {
            this.removeEventListener(type, onceWrapper);
            callback.call(this, event);
        };
        this.addEventListener(type, onceWrapper);
    }
    addEventListener(type, callback) {
        if (!this.listeners[type]) {
            this.listeners[type] = [];
        }
        if (this.listeners[type].indexOf(callback) !== -1) {
            return;
        }
        this.listeners[type].push(callback);
    }
    addEventListenerDebounced(type, callback, delay) {
        this.debouncedListeners[type] = this.debouncedListeners[type] || {};
        const debouncedCallbacks = this.debouncedListeners[type];
        if (!debouncedCallbacks[callback]) {
            const handle = (event) => {
                if (debouncedCallbacks[callback]) {
                    clearTimeout(debouncedCallbacks[callback].timeoutId);
                }
                debouncedCallbacks[callback].timeoutId = setTimeout(() => {
                    callback.call(this, event);
                }, delay);
            };
            debouncedCallbacks[callback] = {
                original: callback,
                handle,
                timeoutId: null,
            };
            this.addEventListener(type, handle);
        }
    }
    removeEventListenerDebounced(type, callback) {
        if (this.debouncedListeners[type]?.[callback]) {
            const debounced = this.debouncedListeners[type][callback];
            this.removeEventListener(type, debounced.handle);
            clearTimeout(debounced.timeoutId);
            delete this.debouncedListeners[type][callback];
        }
    }
    removeEventListener(type, callback) {
        if (!this.listeners[type]) {
            return;
        }
        const stack = this.listeners[type];
        const stackLength = stack.length;
        for (let i = 0; i < stackLength; i++) {
            if (stack[i] === callback) {
                stack.splice(i, 1);
                return;
            }
        }
    }
    dispatchEvent(event) {
        if (!this.listeners[event.type]) {
            return !event.defaultPrevented;
        }
        const stack = this.listeners[event.type].slice();
        const stackLength = stack.length;
        for (let i = 0; i < stackLength; i++) {
            try {
                stack[i].call(this, event);
            }
            catch (error) {
                console.error(`error in event listener of type:  ${event.type}`, error);
            }
        }
        return !event.defaultPrevented;
    }
}
const eventTarget = new CornerstoneEventTarget();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (eventTarget);


/***/ }),

/***/ 36822:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ke: () => (/* binding */ createProgressive),
  Ay: () => (/* binding */ loaders_ProgressiveRetrieveImages)
});

// UNUSED EXPORTS: ProgressiveRetrieveImages, interleavedRetrieveStages, sequentialRetrieveStages, singleRetrieveStages

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/singleRetrieve.js
const singleRetrieveStages = [
    {
        id: 'initialImages',
        retrieveType: 'single',
    },
];
/* harmony default export */ const singleRetrieve = (singleRetrieveStages);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/sequentialRetrieve.js
const sequentialRetrieveStages = [
    {
        id: 'lossySequential',
        retrieveType: 'singleFast',
    },
    {
        id: 'finalSequential',
        retrieveType: 'singleFinal',
    },
];
/* harmony default export */ const sequentialRetrieve = (sequentialRetrieveStages);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 4 modules
var enums = __webpack_require__(31749);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/interleavedRetrieve.js

const nearbyFrames = [
    {
        offset: -1,
        imageQualityStatus: enums.ImageQualityStatus.ADJACENT_REPLICATE,
    },
    {
        offset: +1,
        imageQualityStatus: enums.ImageQualityStatus.ADJACENT_REPLICATE,
    },
    { offset: +2, imageQualityStatus: enums.ImageQualityStatus.FAR_REPLICATE },
];
const interleavedRetrieveConfiguration = [
    {
        id: 'initialImages',
        positions: [0.5, 0, -1],
        retrieveType: 'default',
        requestType: enums.RequestType.Thumbnail,
        priority: 5,
        nearbyFrames,
    },
    {
        id: 'quarterThumb',
        decimate: 4,
        offset: 3,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFast',
        priority: 6,
        nearbyFrames,
    },
    {
        id: 'halfThumb',
        decimate: 4,
        offset: 1,
        priority: 7,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFast',
        nearbyFrames,
    },
    {
        id: 'quarterFull',
        decimate: 4,
        offset: 2,
        priority: 8,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFinal',
    },
    {
        id: 'halfFull',
        decimate: 4,
        offset: 0,
        priority: 9,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFinal',
    },
    {
        id: 'threeQuarterFull',
        decimate: 4,
        offset: 1,
        priority: 10,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFinal',
    },
    {
        id: 'finalFull',
        decimate: 4,
        offset: 3,
        priority: 11,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFinal',
    },
    {
        id: 'errorRetrieve',
    },
];
/* harmony default export */ const interleavedRetrieve = (interleavedRetrieveConfiguration);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var imageLoader = __webpack_require__(80068);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/ProgressiveIterator.js
var ProgressiveIterator = __webpack_require__(22191);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/decimate.js
var decimate = __webpack_require__(63470);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageLoadPoolManager.js
var imageLoadPoolManager = __webpack_require__(51159);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/fillNearbyFrames.js

function fillNearbyFrames(listener, request, image) {
    if (!request?.nearbyRequests?.length) {
        return;
    }
    for (const nearbyItem of request.nearbyRequests) {
        try {
            const { itemId: targetId, imageQualityStatus } = nearbyItem;
            const currentStatus = cache/* default */.Ay.getImageQuality(targetId);
            if (currentStatus !== undefined && currentStatus >= imageQualityStatus) {
                continue;
            }
            const nearbyImage = {
                ...image,
                imageId: targetId,
                imageQualityStatus,
            };
            cache/* default */.Ay.setPartialImage(targetId, nearbyImage);
            listener.successCallback(targetId, nearbyImage);
        }
        catch (e) {
            console.warn("Couldn't fill nearby item ", nearbyItem.itemId, e);
        }
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/ProgressiveRetrieveImages.js













class ProgressiveRetrieveImages {
    static { this.createProgressive = createProgressive; }
    static { this.interleavedRetrieveStages = {
        stages: interleavedRetrieve,
    }; }
    static { this.singleRetrieveStages = {
        stages: singleRetrieve,
    }; }
    static { this.sequentialRetrieveStages = {
        stages: sequentialRetrieve,
    }; }
    constructor(imageRetrieveConfiguration) {
        this.stages = imageRetrieveConfiguration.stages || singleRetrieve;
        this.retrieveOptions = imageRetrieveConfiguration.retrieveOptions || {};
    }
    loadImages(imageIds, listener) {
        const instance = new ProgressiveRetrieveImagesInstance(this, imageIds, listener);
        return instance.loadImages();
    }
}
class ProgressiveRetrieveImagesInstance {
    constructor(configuration, imageIds, listener) {
        this.outstandingRequests = 0;
        this.stageStatusMap = new Map();
        this.displayedIterator = new ProgressiveIterator/* default */.A('displayed');
        this.stages = configuration.stages;
        this.retrieveOptions = configuration.retrieveOptions;
        this.imageIds = imageIds;
        this.listener = listener;
    }
    async loadImages() {
        const interleaved = this.createStageRequests();
        this.outstandingRequests = interleaved.length;
        for (const request of interleaved) {
            this.addRequest(request);
        }
        if (this.outstandingRequests === 0) {
            return Promise.resolve(null);
        }
        return this.displayedIterator.getDonePromise();
    }
    sendRequest(request, options) {
        const { imageId, next } = request;
        const errorCallback = (reason, done) => {
            this.listener.errorCallback(imageId, complete || !next, reason);
            if (done) {
                this.updateStageStatus(request.stage, reason);
            }
        };
        const loadedPromise = (options.loader || imageLoader.loadAndCacheImage)(imageId, options);
        const uncompressedIterator = ProgressiveIterator/* default */.A.as(loadedPromise);
        let complete = false;
        uncompressedIterator
            .forEach(async (image, done) => {
            const oldStatus = cache/* default */.Ay.getImageQuality(imageId);
            if (!image) {
                console.warn('No image retrieved', imageId);
                return;
            }
            const { imageQualityStatus } = image;
            complete ||= imageQualityStatus === enums.ImageQualityStatus.FULL_RESOLUTION;
            if (oldStatus !== undefined && oldStatus > imageQualityStatus) {
                this.updateStageStatus(request.stage, null, true);
                return;
            }
            this.listener.successCallback(imageId, image);
            this.displayedIterator.add(image);
            if (done) {
                this.updateStageStatus(request.stage);
            }
            fillNearbyFrames(this.listener, request, image);
        }, errorCallback)
            .finally(() => {
            if (!complete && next) {
                cache/* default */.Ay.setPartialImage(imageId);
                this.addRequest(next, options.streamingData);
            }
            else {
                if (!complete) {
                    this.listener.errorCallback(imageId, true, "Couldn't decode");
                }
                this.outstandingRequests--;
                for (let skip = next; skip; skip = skip.next) {
                    this.updateStageStatus(skip.stage, null, true);
                }
            }
            if (this.outstandingRequests <= 0) {
                this.displayedIterator.resolve();
            }
        });
        const doneLoad = uncompressedIterator.getDonePromise();
        return doneLoad.catch((e) => null);
    }
    addRequest(request, streamingData = {}) {
        const { imageId, stage } = request;
        const baseOptions = this.listener.getLoaderImageOptions(imageId);
        if (!baseOptions) {
            return;
        }
        const { retrieveType = 'default' } = stage;
        const { retrieveOptions: keyedRetrieveOptions } = this;
        const retrieveOptions = keyedRetrieveOptions[retrieveType] || keyedRetrieveOptions.default;
        const options = {
            ...baseOptions,
            retrieveType,
            retrieveOptions,
            streamingData,
        };
        const priority = stage.priority ?? -5;
        const requestType = stage.requestType || enums.RequestType.Interaction;
        const additionalDetails = { imageId };
        imageLoadPoolManager/* default */.A.addRequest(this.sendRequest.bind(this, request, options), requestType, additionalDetails, priority);
    }
    updateStageStatus(stage, failure, skipped = false) {
        const { id } = stage;
        const stageStatus = this.stageStatusMap.get(id);
        if (!stageStatus) {
            return;
        }
        stageStatus.imageLoadPendingCount--;
        if (failure) {
            stageStatus.imageLoadFailedCount++;
        }
        else if (!skipped) {
            stageStatus.totalImageCount++;
        }
        if (!skipped && !stageStatus.stageStartTime) {
            stageStatus.stageStartTime = Date.now();
        }
        if (!stageStatus.imageLoadPendingCount) {
            const { imageLoadFailedCount: numberOfFailures, totalImageCount: numberOfImages, stageStartTime = Date.now(), startTime, } = stageStatus;
            const detail = {
                stageId: id,
                numberOfFailures,
                numberOfImages,
                stageDurationInMS: stageStartTime ? Date.now() - stageStartTime : null,
                startDurationInMS: Date.now() - startTime,
            };
            (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.IMAGE_RETRIEVAL_STAGE, detail);
            this.stageStatusMap.delete(id);
        }
    }
    createStageRequests() {
        const interleaved = new Array();
        const imageRequests = new Map();
        const addStageInstance = (stage, position) => {
            const index = position < 0
                ? this.imageIds.length + position
                : position < 1
                    ? Math.floor((this.imageIds.length - 1) * position)
                    : position;
            const imageId = this.imageIds[index];
            if (!imageId) {
                throw new Error(`No value found to add to requests at ${position}`);
            }
            const request = {
                imageId,
                stage,
                index,
                nearbyRequests: this.findNearbyRequests(index, stage),
            };
            this.addStageStatus(stage);
            const existingRequest = imageRequests.get(imageId);
            if (existingRequest) {
                existingRequest.next = request;
            }
            else {
                interleaved.push(request);
            }
            imageRequests.set(imageId, request);
        };
        for (const stage of this.stages) {
            const indices = stage.positions ||
                (0,decimate/* default */.A)(this.imageIds, stage.decimate || 1, stage.offset ?? 0);
            indices.forEach((index) => {
                addStageInstance(stage, index);
            });
        }
        return interleaved;
    }
    findNearbyRequests(index, stage) {
        const nearby = new Array();
        if (!stage.nearbyFrames) {
            return nearby;
        }
        for (const nearbyItem of stage.nearbyFrames) {
            const nearbyIndex = index + nearbyItem.offset;
            if (nearbyIndex < 0 || nearbyIndex >= this.imageIds.length) {
                continue;
            }
            nearby.push({
                itemId: this.imageIds[nearbyIndex],
                imageQualityStatus: nearbyItem.imageQualityStatus,
                index: nearbyIndex,
            });
        }
        return nearby;
    }
    addStageStatus(stage) {
        const { id } = stage;
        const stageStatus = this.stageStatusMap.get(id) || {
            stageId: id,
            startTime: Date.now(),
            stageStartTime: null,
            totalImageCount: 0,
            imageLoadFailedCount: 0,
            imageLoadPendingCount: 0,
        };
        stageStatus.imageLoadPendingCount++;
        this.stageStatusMap.set(id, stageStatus);
        return stageStatus;
    }
}
function createProgressive(configuration) {
    return new ProgressiveRetrieveImages(configuration);
}
/* harmony default export */ const loaders_ProgressiveRetrieveImages = (ProgressiveRetrieveImages);


/***/ }),

/***/ 55509:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export cornerstoneStreamingDynamicImageVolumeLoader */
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58927);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49035);


function cornerstoneStreamingDynamicImageVolumeLoader(volumeId, options) {
    if (!options || !options.imageIds || !options.imageIds.length) {
        throw new Error('ImageIds must be provided to create a 4D streaming image volume');
    }
    const { imageIds } = options;
    const { splittingTag, imageIdGroups } = splitImageIdsBy4DTags(imageIds);
    const middleIndex = Math.floor(imageIdGroups.length / 2);
    const volumeProps = generateVolumePropsFromImageIds(imageIdGroups[middleIndex], volumeId);
    const { metadata: volumeMetadata, dimensions, spacing, direction, sizeInBytes, origin, numberOfComponents, dataType, } = volumeProps;
    const scanAxisNormal = direction.slice(6, 9);
    const sortedImageIdGroups = imageIdGroups.map((imageIds) => {
        const sortedImageIds = sortImageIdsAndGetSpacing(imageIds, scanAxisNormal).sortedImageIds;
        return sortedImageIds;
    });
    const sortedFlatImageIds = sortedImageIdGroups.flat();
    const voxelManager = VoxelManager.createScalarDynamicVolumeVoxelManager({
        dimensions,
        imageIdGroups: sortedImageIdGroups,
        timePoint: 0,
        numberOfComponents,
    });
    let streamingImageVolume = new StreamingDynamicImageVolume({
        volumeId,
        metadata: volumeMetadata,
        dimensions,
        spacing,
        origin,
        direction,
        sizeInBytes,
        imageIds: sortedFlatImageIds,
        imageIdGroups: sortedImageIdGroups,
        splittingTag,
        voxelManager,
        numberOfComponents,
        dataType,
    }, {
        imageIds: sortedFlatImageIds,
        loadStatus: {
            loaded: false,
            loading: false,
            cancelled: false,
            cachedFrames: [],
            callbacks: [],
        },
    });
    return {
        promise: Promise.resolve(streamingImageVolume),
        decache: () => {
            streamingImageVolume.destroy();
            streamingImageVolume = null;
        },
        cancel: () => {
            streamingImageVolume.cancelLoading();
        },
    };
}



/***/ }),

/***/ 55500:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ cornerstoneStreamingImageVolumeLoader)
/* harmony export */ });
/* harmony import */ var _cache_classes_StreamingImageVolume__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50180);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31749);
/* harmony import */ var _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51159);
/* harmony import */ var _utilities_generateVolumePropsFromImageIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9734);
/* harmony import */ var _imageLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(80068);





function cornerstoneStreamingImageVolumeLoader(volumeId, options) {
    if (!options || !options.imageIds || !options.imageIds.length) {
        throw new Error('ImageIds must be provided to create a streaming image volume');
    }
    async function getStreamingImageVolume() {
        if (options.imageIds[0].split(':')[0] === 'wadouri') {
            const [middleImageIndex, lastImageIndex] = [
                Math.floor(options.imageIds.length / 2),
                options.imageIds.length - 1,
            ];
            const indexesToPrefetch = [0, middleImageIndex, lastImageIndex];
            await Promise.all(indexesToPrefetch.map((index) => {
                return new Promise((resolve, reject) => {
                    const imageId = options.imageIds[index];
                    _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.addRequest(async () => {
                        (0,_imageLoader__WEBPACK_IMPORTED_MODULE_4__.loadImage)(imageId)
                            .then(() => {
                            console.log(`Prefetched imageId: ${imageId}`);
                            resolve(true);
                        })
                            .catch((err) => {
                            reject(err);
                        });
                    }, _enums__WEBPACK_IMPORTED_MODULE_1__.RequestType.Prefetch, { volumeId }, 1);
                });
            })).catch(console.error);
        }
        const volumeProps = (0,_utilities_generateVolumePropsFromImageIds__WEBPACK_IMPORTED_MODULE_3__/* .generateVolumePropsFromImageIds */ .D)(options.imageIds, volumeId);
        const { dimensions, spacing, origin, direction, metadata, imageIds, dataType, numberOfComponents, } = volumeProps;
        const streamingImageVolume = new _cache_classes_StreamingImageVolume__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A({
            volumeId,
            metadata,
            dimensions,
            spacing,
            origin,
            direction,
            imageIds,
            dataType,
            numberOfComponents,
        }, {
            imageIds,
            loadStatus: {
                loaded: false,
                loading: false,
                cancelled: false,
                cachedFrames: [],
                callbacks: [],
            },
        });
        return streamingImageVolume;
    }
    const streamingImageVolumePromise = getStreamingImageVolume();
    return {
        promise: streamingImageVolumePromise,
        decache: () => {
            streamingImageVolumePromise.then((streamingImageVolume) => {
                streamingImageVolume.destroy();
                streamingImageVolume = null;
            });
        },
        cancel: () => {
            streamingImageVolumePromise.then((streamingImageVolume) => {
                streamingImageVolume.cancelLoading();
            });
        },
    };
}



/***/ }),

/***/ 74876:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addProvider: () => (/* binding */ addProvider),
/* harmony export */   get: () => (/* binding */ getMetaData),
/* harmony export */   removeAllProviders: () => (/* binding */ removeAllProviders),
/* harmony export */   removeProvider: () => (/* binding */ removeProvider)
/* harmony export */ });
const providers = [];
function addProvider(provider, priority = 0) {
    let i;
    for (i = 0; i < providers.length; i++) {
        if (providers[i].priority <= priority) {
            break;
        }
    }
    providers.splice(i, 0, {
        priority,
        provider,
    });
}
function removeProvider(provider) {
    for (let i = 0; i < providers.length; i++) {
        if (providers[i].provider === provider) {
            providers.splice(i, 1);
            break;
        }
    }
}
function removeAllProviders() {
    while (providers.length > 0) {
        providers.pop();
    }
}
function getMetaData(type, ...queries) {
    for (let i = 0; i < providers.length; i++) {
        const result = providers[i].provider(type, ...queries);
        if (result !== undefined) {
            return result;
        }
    }
}



/***/ }),

/***/ 51159:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _requestPoolManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24743);
/* harmony import */ var _enums_RequestType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43213);


const imageLoadPoolManager = new _requestPoolManager__WEBPACK_IMPORTED_MODULE_0__/* .RequestPoolManager */ .R('imageLoadPool');
imageLoadPoolManager.grabDelay = 0;
imageLoadPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Interaction, 1000);
imageLoadPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Thumbnail, 1000);
imageLoadPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Prefetch, 1000);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (imageLoadPoolManager);


/***/ }),

/***/ 91073:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _requestPoolManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24743);
/* harmony import */ var _enums_RequestType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43213);


const imageRetrievalPoolManager = new _requestPoolManager__WEBPACK_IMPORTED_MODULE_0__/* .RequestPoolManager */ .R('imageRetrievalPool');
imageRetrievalPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Interaction, 200);
imageRetrievalPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Thumbnail, 200);
imageRetrievalPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Prefetch, 200);
imageRetrievalPoolManager.grabDelay = 0;
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (imageRetrievalPoolManager)));


/***/ }),

/***/ 24743:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ RequestPoolManager)
/* harmony export */ });
/* harmony import */ var _enums_RequestType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43213);
/* harmony import */ var _utilities_uuidv4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80221);


class RequestPoolManager {
    constructor(id) {
        this.numRequests = {
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute]: 0,
        };
        this.id = id ? id : (0,_utilities_uuidv4__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)();
        this.requestPool = {
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction]: { 0: [] },
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail]: { 0: [] },
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch]: { 0: [] },
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute]: { 0: [] },
        };
        this.grabDelay = 5;
        this.awake = false;
        this.numRequests = {
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute]: 0,
        };
        this.maxNumRequests = {
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction]: 6,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail]: 6,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch]: 5,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute]: 1000,
        };
    }
    setMaxSimultaneousRequests(type, maxNumRequests) {
        this.maxNumRequests[type] = maxNumRequests;
    }
    getMaxSimultaneousRequests(type) {
        return this.maxNumRequests[type];
    }
    destroy() {
        if (this.timeoutHandle) {
            window.clearTimeout(this.timeoutHandle);
        }
    }
    addRequest(requestFn, type, additionalDetails, priority = 0) {
        const requestDetails = {
            requestFn,
            type,
            additionalDetails,
        };
        if (this.requestPool[type][priority] === undefined) {
            this.requestPool[type][priority] = [];
        }
        this.requestPool[type][priority].push(requestDetails);
        this.startGrabbing();
    }
    filterRequests(filterFunction) {
        Object.keys(this.requestPool).forEach((type) => {
            const requestType = this.requestPool[type];
            Object.keys(requestType).forEach((priority) => {
                requestType[priority] = requestType[priority].filter((requestDetails) => {
                    return filterFunction(requestDetails);
                });
            });
        });
    }
    clearRequestStack(type) {
        if (!this.requestPool[type]) {
            throw new Error(`No category for the type ${type} found`);
        }
        this.requestPool[type] = { 0: [] };
    }
    sendRequests(type) {
        const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];
        let syncImageCount = 0;
        for (let i = 0; i < requestsToSend; i++) {
            const requestDetails = this.getNextRequest(type);
            if (requestDetails === null) {
                return false;
            }
            else if (requestDetails) {
                this.numRequests[type]++;
                this.awake = true;
                let requestResult;
                try {
                    requestResult = requestDetails.requestFn();
                }
                catch (e) {
                    console.warn('sendRequest failed', e);
                }
                if (requestResult?.finally) {
                    requestResult.finally(() => {
                        this.numRequests[type]--;
                        this.startAgain();
                    });
                }
                else {
                    this.numRequests[type]--;
                    syncImageCount++;
                }
            }
        }
        if (syncImageCount) {
            this.startAgain();
        }
        return true;
    }
    getNextRequest(type) {
        const interactionPriorities = this.getSortedPriorityGroups(type);
        for (const priority of interactionPriorities) {
            if (this.requestPool[type][priority].length) {
                return this.requestPool[type][priority].shift();
            }
        }
        return null;
    }
    startGrabbing() {
        const hasRemainingInteractionRequests = this.sendRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction);
        const hasRemainingThumbnailRequests = this.sendRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail);
        const hasRemainingPrefetchRequests = this.sendRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch);
        const hasRemainingComputeRequests = this.sendRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute);
        if (!hasRemainingInteractionRequests &&
            !hasRemainingThumbnailRequests &&
            !hasRemainingPrefetchRequests &&
            !hasRemainingComputeRequests) {
            this.awake = false;
        }
    }
    startAgain() {
        if (!this.awake) {
            return;
        }
        if (this.grabDelay !== undefined) {
            if (!this.timeoutHandle) {
                this.timeoutHandle = window.setTimeout(() => {
                    this.timeoutHandle = null;
                    this.startGrabbing();
                }, this.grabDelay);
            }
        }
        else {
            this.startGrabbing();
        }
    }
    getSortedPriorityGroups(type) {
        const priorities = Object.keys(this.requestPool[type])
            .map(Number)
            .filter((priority) => this.requestPool[type][priority].length)
            .sort((a, b) => a - b);
        return priorities;
    }
    getRequestPool() {
        return this.requestPool;
    }
}



/***/ }),

/***/ 24623:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ VoxelManager)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49038);
/* harmony import */ var _RLEVoxelMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67645);
/* harmony import */ var _isEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74638);




const DEFAULT_RLE_SIZE = 5 * 1024;
class VoxelManager {
    constructor(dimensions, _get, _set) {
        this.modifiedSlices = new Set();
        this.boundsIJK = [
            [Infinity, -Infinity],
            [Infinity, -Infinity],
            [Infinity, -Infinity],
        ];
        this.numberOfComponents = 1;
        this.scalarData = null;
        this._sliceDataCache = null;
        this.getAtIJK = (i, j, k) => {
            const index = this.toIndex([i, j, k]);
            return this._get(index);
        };
        this.setAtIJK = (i, j, k, v) => {
            const index = this.toIndex([i, j, k]);
            const changed = this._set(index, v);
            if (changed !== false) {
                this.modifiedSlices.add(k);
                VoxelManager.addBounds(this.boundsIJK, [i, j, k]);
            }
            return changed;
        };
        this.getAtIJKPoint = ([i, j, k]) => this.getAtIJK(i, j, k);
        this.setAtIJKPoint = ([i, j, k], v) => {
            this.setAtIJK(i, j, k, v);
        };
        this.getAtIndex = (index) => this._get(index);
        this.setAtIndex = (index, v) => {
            const changed = this._set(index, v);
            if (changed !== false) {
                const pointIJK = this.toIJK(index);
                this.modifiedSlices.add(pointIJK[2]);
                VoxelManager.addBounds(this.boundsIJK, pointIJK);
            }
            return changed;
        };
        this.getMiddleSliceData = () => {
            const middleSliceIndex = Math.floor(this.dimensions[2] / 2);
            return this.getSliceData({
                sliceIndex: middleSliceIndex,
                slicePlane: 2,
            });
        };
        this.forEach = (callback, options = {}) => {
            const isInObjectBoundsIJK = options.boundsIJK || this.getBoundsIJK();
            const isInObject = options.isInObject || this.isInObject || (() => true);
            const returnPoints = options.returnPoints || false;
            const useLPSTransform = options.imageData;
            const iMin = Math.min(isInObjectBoundsIJK[0][0], isInObjectBoundsIJK[0][1]);
            const iMax = Math.max(isInObjectBoundsIJK[0][0], isInObjectBoundsIJK[0][1]);
            const jMin = Math.min(isInObjectBoundsIJK[1][0], isInObjectBoundsIJK[1][1]);
            const jMax = Math.max(isInObjectBoundsIJK[1][0], isInObjectBoundsIJK[1][1]);
            const kMin = Math.min(isInObjectBoundsIJK[2][0], isInObjectBoundsIJK[2][1]);
            const kMax = Math.max(isInObjectBoundsIJK[2][0], isInObjectBoundsIJK[2][1]);
            const pointsInShape = [];
            if (useLPSTransform) {
                const { imageData } = options;
                const direction = imageData.getDirection();
                const rowCosines = direction.slice(0, 3);
                const columnCosines = direction.slice(3, 6);
                const scanAxisNormal = direction.slice(6, 9);
                const spacing = imageData.getSpacing();
                const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;
                const start = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(iMin, jMin, kMin);
                const worldPosStart = imageData.indexToWorld(start);
                const rowStep = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(rowCosines[0] * rowSpacing, rowCosines[1] * rowSpacing, rowCosines[2] * rowSpacing);
                const columnStep = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(columnCosines[0] * columnSpacing, columnCosines[1] * columnSpacing, columnCosines[2] * columnSpacing);
                const scanAxisStep = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(scanAxisNormal[0] * scanAxisSpacing, scanAxisNormal[1] * scanAxisSpacing, scanAxisNormal[2] * scanAxisSpacing);
                const currentPos = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.clone */ .eR.clone(worldPosStart);
                for (let k = kMin; k <= kMax; k++) {
                    const startPosJ = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.clone */ .eR.clone(currentPos);
                    for (let j = jMin; j <= jMax; j++) {
                        const startPosI = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.clone */ .eR.clone(currentPos);
                        for (let i = iMin; i <= iMax; i++) {
                            const pointIJK = [i, j, k];
                            if (isInObject(currentPos, pointIJK)) {
                                const index = this.toIndex(pointIJK);
                                const value = this._get(index);
                                if (returnPoints) {
                                    pointsInShape.push({
                                        value,
                                        index,
                                        pointIJK,
                                        pointLPS: currentPos.slice(),
                                    });
                                }
                                if (callback) {
                                    callback({ value, index, pointIJK, pointLPS: currentPos });
                                }
                            }
                            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(currentPos, currentPos, rowStep);
                        }
                        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.copy */ .eR.copy(currentPos, startPosI);
                        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(currentPos, currentPos, columnStep);
                    }
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.copy */ .eR.copy(currentPos, startPosJ);
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(currentPos, currentPos, scanAxisStep);
                }
                return pointsInShape;
            }
            if (this.map) {
                for (const index of this.map.keys()) {
                    const pointIJK = this.toIJK(index);
                    if (!isInObject(null, pointIJK)) {
                        continue;
                    }
                    const value = this._get(index);
                    if (returnPoints) {
                        pointsInShape.push({
                            value,
                            index,
                            pointIJK,
                            pointLPS: null,
                        });
                    }
                    callback({ value, index, pointIJK, pointLPS: null });
                }
                return pointsInShape;
            }
            else {
                for (let k = kMin; k <= kMax; k++) {
                    const kIndex = k * this.frameSize;
                    for (let j = jMin; j <= jMax; j++) {
                        const jIndex = kIndex + j * this.width;
                        for (let i = iMin, index = jIndex + i; i <= iMax; i++, index++) {
                            const value = this.getAtIndex(index);
                            const pointIJK = [i, j, k];
                            if (!isInObject(null, pointIJK)) {
                                continue;
                            }
                            if (returnPoints) {
                                pointsInShape.push({
                                    value,
                                    index,
                                    pointIJK,
                                    pointLPS: null,
                                });
                            }
                            callback({ value, index, pointIJK: [i, j, k], pointLPS: null });
                        }
                    }
                }
                return pointsInShape;
            }
        };
        this.getSliceData = ({ sliceIndex, slicePlane, }) => {
            const [width, height, depth] = this.dimensions;
            const frameSize = width * height;
            const startIndex = sliceIndex * frameSize;
            let sliceSize;
            const SliceDataConstructor = this.getConstructor();
            function isValidConstructor(ctor) {
                return typeof ctor === 'function';
            }
            if (!isValidConstructor(SliceDataConstructor)) {
                return new Uint8Array(0);
            }
            let sliceData;
            switch (slicePlane) {
                case 0:
                    sliceSize = height * depth;
                    sliceData = new SliceDataConstructor(sliceSize);
                    for (let i = 0; i < height; i++) {
                        for (let j = 0; j < depth; j++) {
                            const index = sliceIndex + i * width + j * frameSize;
                            this.setSliceDataValue(sliceData, i * depth + j, this._get(index));
                        }
                    }
                    break;
                case 1:
                    sliceSize = width * depth;
                    sliceData = new SliceDataConstructor(sliceSize);
                    for (let i = 0; i < width; i++) {
                        for (let j = 0; j < depth; j++) {
                            const index = i + sliceIndex * width + j * frameSize;
                            this.setSliceDataValue(sliceData, i + j * width, this._get(index));
                        }
                    }
                    break;
                case 2:
                    sliceSize = width * height;
                    sliceData = new SliceDataConstructor(sliceSize);
                    for (let i = 0; i < sliceSize; i++) {
                        this.setSliceDataValue(sliceData, i, this._get(startIndex + i));
                    }
                    break;
                default:
                    throw new Error('Oblique plane - todo - implement as ortho normal vector');
            }
            return sliceData;
        };
        this.dimensions = dimensions;
        this.width = dimensions[0];
        this.frameSize = this.width * dimensions[1];
        this._get = _get;
        this._set = _set;
    }
    toIJK(index) {
        return [
            index % this.width,
            Math.floor((index % this.frameSize) / this.width),
            Math.floor(index / this.frameSize),
        ];
    }
    toIndex(ijk) {
        return ijk[0] + ijk[1] * this.width + ijk[2] * this.frameSize;
    }
    getDefaultBounds() {
        return this.dimensions.map((dimension) => [0, dimension - 1]);
    }
    getBoundsIJK() {
        if (this.boundsIJK[0][0] < this.dimensions[0]) {
            return this.boundsIJK;
        }
        return this.getDefaultBounds();
    }
    getScalarData() {
        if (this.scalarData) {
            return this.scalarData;
        }
        if (this._getScalarData) {
            return this._getScalarData();
        }
        throw new Error('No scalar data available');
    }
    setScalarData(newScalarData) {
        this.scalarData = newScalarData;
    }
    getScalarDataLength() {
        if (this.scalarData) {
            return this.scalarData.length;
        }
        if (this._getScalarDataLength) {
            return this._getScalarDataLength();
        }
        throw new Error('No scalar data available');
    }
    get sizeInBytes() {
        return this.getScalarDataLength() * this.bytePerVoxel;
    }
    get bytePerVoxel() {
        if (this.scalarData) {
            return this.scalarData.BYTES_PER_ELEMENT;
        }
        const value = this._get(0);
        return value.BYTES_PER_ELEMENT;
    }
    clear() {
        if (this.map) {
            this.map.clear();
        }
        this.boundsIJK.map((bound) => {
            bound[0] = Infinity;
            bound[1] = -Infinity;
        });
        this.modifiedSlices.clear();
        this.points?.clear();
    }
    getConstructor() {
        if (this.scalarData) {
            return this.scalarData.constructor;
        }
        if (this._getConstructor) {
            return this._getConstructor();
        }
        console.warn('No scalar data available or can be used to get the constructor');
        return Float32Array;
    }
    getArrayOfModifiedSlices() {
        return Array.from(this.modifiedSlices);
    }
    resetModifiedSlices() {
        this.modifiedSlices.clear();
    }
    static addBounds(bounds, point) {
        if (!bounds) {
            bounds = [
                [Infinity, -Infinity],
                [Infinity, -Infinity],
                [Infinity, -Infinity],
            ];
        }
        bounds[0][0] = Math.min(point[0], bounds[0][0]);
        bounds[0][1] = Math.max(point[0], bounds[0][1]);
        bounds[1][0] = Math.min(point[1], bounds[1][0]);
        bounds[1][1] = Math.max(point[1], bounds[1][1]);
        bounds[2][0] = Math.min(point[2], bounds[2][0]);
        bounds[2][1] = Math.max(point[2], bounds[2][1]);
    }
    addPoint(point) {
        const index = Array.isArray(point)
            ? point[0] + this.width * point[1] + this.frameSize * point[2]
            : point;
        if (!this.points) {
            this.points = new Set();
        }
        this.points.add(index);
    }
    getPoints() {
        return this.points
            ? [...this.points].map((index) => this.toIJK(index))
            : [];
    }
    setSliceDataValue(sliceData, index, value) {
        if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                sliceData[index * value.length + i] = this.toNumber(value[i]);
            }
        }
        else {
            sliceData[index] = this.toNumber(value);
        }
    }
    toNumber(value) {
        if (typeof value === 'number') {
            return value;
        }
        if (Array.isArray(value)) {
            return value[0] || 0;
        }
        return 0;
    }
    static _createRGBScalarVolumeVoxelManager({ dimensions, scalarData, numberOfComponents = 3, }) {
        const voxels = new VoxelManager(dimensions, (index) => {
            index *= numberOfComponents;
            return [scalarData[index++], scalarData[index++], scalarData[index++]];
        }, (index, v) => {
            index *= 3;
            const isChanged = !(0,_isEqual__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay)(scalarData[index], v);
            scalarData[index++] = v[0];
            scalarData[index++] = v[1];
            scalarData[index++] = v[2];
            return isChanged;
        });
        voxels.numberOfComponents = numberOfComponents;
        voxels.scalarData = scalarData;
        return voxels;
    }
    static createImageVolumeVoxelManager({ dimensions, imageIds, numberOfComponents = 1, }) {
        const pixelsPerSlice = dimensions[0] * dimensions[1];
        function getPixelInfo(index) {
            const sliceIndex = Math.floor(index / pixelsPerSlice);
            const imageId = imageIds[sliceIndex];
            if (!imageId) {
                console.warn(`ImageId not found for sliceIndex: ${sliceIndex}`);
                return { pixelData: null, pixelIndex: null };
            }
            const image = _cache_cache__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.getImage(imageId);
            if (!image) {
                console.warn(`Image not found for imageId: ${imageId}`);
                return { pixelData: null, pixelIndex: null };
            }
            const pixelData = image.voxelManager.getScalarData();
            const pixelIndex = (index % pixelsPerSlice) * numberOfComponents;
            return { pixelData, pixelIndex };
        }
        function getVoxelValue(index) {
            const { pixelData, pixelIndex } = getPixelInfo(index);
            if (!pixelData || pixelIndex === null) {
                return null;
            }
            if (numberOfComponents === 1) {
                return pixelData[pixelIndex];
            }
            else {
                return [
                    pixelData[pixelIndex],
                    pixelData[pixelIndex + 1],
                    pixelData[pixelIndex + 2],
                ];
            }
        }
        function setVoxelValue(index, v) {
            const { pixelData, pixelIndex } = getPixelInfo(index);
            if (!pixelData || pixelIndex === null) {
                return false;
            }
            let isChanged = false;
            if (numberOfComponents === 1) {
                if (pixelData[pixelIndex] !== v) {
                    pixelData[pixelIndex] = v;
                    isChanged = true;
                }
            }
            else {
                const rgbValue = v;
                for (let i = 0; i < numberOfComponents; i++) {
                    if (pixelData[pixelIndex + i] !== rgbValue[i]) {
                        pixelData[pixelIndex + i] = rgbValue[i];
                        isChanged = true;
                    }
                }
            }
            return isChanged;
        }
        const voxelManager = new VoxelManager(dimensions, (index) => getVoxelValue(index), (index, v) => setVoxelValue(index, v));
        voxelManager.numberOfComponents = numberOfComponents;
        voxelManager._getConstructor = () => {
            const pixelInfo = getPixelInfo(0);
            if (!pixelInfo.pixelData) {
                return null;
            }
            return pixelInfo.pixelData.constructor;
        };
        voxelManager.getMiddleSliceData = () => {
            const middleSliceIndex = Math.floor(dimensions[2] / 2);
            return voxelManager.getSliceData({
                sliceIndex: middleSliceIndex,
                slicePlane: 2,
            });
        };
        voxelManager.getRange = () => {
            let minValue = Infinity;
            let maxValue = -Infinity;
            for (const imageId of imageIds) {
                const image = _cache_cache__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.getImage(imageId);
                if (image.minPixelValue < minValue) {
                    minValue = image.minPixelValue;
                }
                if (image.maxPixelValue > maxValue) {
                    maxValue = image.maxPixelValue;
                }
            }
            return [minValue, maxValue];
        };
        voxelManager._getScalarDataLength = () => {
            const { pixelData } = getPixelInfo(0);
            return pixelData.length * dimensions[2];
        };
        voxelManager.getCompleteScalarDataArray = () => {
            const ScalarDataConstructor = voxelManager._getConstructor();
            if (!ScalarDataConstructor) {
                return new Uint8Array(0);
            }
            const dataLength = voxelManager.getScalarDataLength();
            const scalarData = new ScalarDataConstructor(dataLength);
            const sliceSize = dimensions[0] * dimensions[1] * numberOfComponents;
            for (let sliceIndex = 0; sliceIndex < dimensions[2]; sliceIndex++) {
                const { pixelData } = getPixelInfo((sliceIndex * sliceSize) / numberOfComponents);
                if (pixelData) {
                    const sliceStart = sliceIndex * sliceSize;
                    if (numberOfComponents === 1) {
                        scalarData.set(pixelData, sliceStart);
                    }
                    else {
                        for (let i = 0; i < pixelData.length; i += numberOfComponents) {
                            for (let j = 0; j < numberOfComponents; j++) {
                                scalarData[sliceStart + i + j] = pixelData[i + j];
                            }
                        }
                    }
                }
            }
            return scalarData;
        };
        voxelManager.setCompleteScalarDataArray = (scalarData) => {
            const sliceSize = dimensions[0] * dimensions[1] * numberOfComponents;
            const SliceDataConstructor = voxelManager._getConstructor();
            let minValue = Infinity;
            let maxValue = -Infinity;
            for (let sliceIndex = 0; sliceIndex < dimensions[2]; sliceIndex++) {
                const { pixelData } = getPixelInfo((sliceIndex * sliceSize) / numberOfComponents);
                if (pixelData && SliceDataConstructor) {
                    const sliceStart = sliceIndex * sliceSize;
                    const sliceEnd = sliceStart + sliceSize;
                    const sliceData = new SliceDataConstructor(sliceSize);
                    sliceData.set(scalarData.subarray(sliceStart, sliceEnd));
                    pixelData.set(sliceData);
                    for (let i = 0; i < sliceData.length; i++) {
                        const value = sliceData[i];
                        minValue = Math.min(minValue, value);
                        maxValue = Math.max(maxValue, value);
                    }
                    const imageId = imageIds[sliceIndex];
                    const image = _cache_cache__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.getImage(imageId);
                    if (image) {
                        image.minPixelValue = minValue;
                        image.maxPixelValue = maxValue;
                    }
                }
            }
            for (let k = 0; k < dimensions[2]; k++) {
                voxelManager.modifiedSlices.add(k);
            }
            voxelManager.boundsIJK = [
                [0, dimensions[0] - 1],
                [0, dimensions[1] - 1],
                [0, dimensions[2] - 1],
            ];
        };
        return voxelManager;
    }
    static createScalarVolumeVoxelManager({ dimensions, scalarData, numberOfComponents = 1, }) {
        if (dimensions.length !== 3) {
            throw new Error('Dimensions must be provided as [number, number, number] for [width, height, depth]');
        }
        if (!numberOfComponents) {
            numberOfComponents =
                scalarData.length / dimensions[0] / dimensions[1] / dimensions[2];
            if (numberOfComponents > 4 ||
                numberOfComponents < 1 ||
                numberOfComponents === 2) {
                throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
            }
        }
        if (numberOfComponents > 1) {
            return VoxelManager._createRGBScalarVolumeVoxelManager({
                dimensions,
                scalarData,
                numberOfComponents,
            });
        }
        return VoxelManager._createNumberVolumeVoxelManager({
            dimensions,
            scalarData,
        });
    }
    static createScalarDynamicVolumeVoxelManager({ imageIdGroups, dimensions, timePoint = 0, numberOfComponents = 1, }) {
        if (!numberOfComponents) {
            const firstImage = _cache_cache__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.getImage(imageIdGroups[0][0]);
            if (!firstImage) {
                throw new Error('Unable to determine number of components: No image found');
            }
            numberOfComponents =
                firstImage.getPixelData().length / (dimensions[0] * dimensions[1]);
            if (numberOfComponents > 4 ||
                numberOfComponents < 1 ||
                numberOfComponents === 2) {
                throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
            }
        }
        const voxelGroups = imageIdGroups.map((imageIds) => {
            return VoxelManager.createImageVolumeVoxelManager({
                dimensions,
                imageIds,
                numberOfComponents,
            });
        });
        const voxelManager = new VoxelManager(dimensions, (index) => voxelGroups[timePoint]._get(index), (index, v) => voxelGroups[timePoint]._set(index, v));
        voxelManager.numberOfComponents = numberOfComponents;
        voxelManager.getScalarDataLength = () => {
            return voxelGroups[timePoint].getScalarDataLength();
        };
        voxelManager.getConstructor = () => {
            return voxelGroups[timePoint].getConstructor();
        };
        voxelManager.getRange = () => {
            return voxelGroups[timePoint].getRange();
        };
        voxelManager.getMiddleSliceData = () => {
            return voxelGroups[timePoint].getMiddleSliceData();
        };
        voxelManager.setTimePoint = (newTimePoint) => {
            timePoint = newTimePoint;
            voxelManager._get = (index) => voxelGroups[timePoint]._get(index);
            voxelManager._set = (index, v) => voxelGroups[timePoint]._set(index, v);
        };
        voxelManager.getAtIndexAndTimePoint = (index, tp) => {
            return voxelGroups[tp]._get(index);
        };
        voxelManager.getTimePointScalarData = (tp) => {
            return voxelGroups[tp].getCompleteScalarDataArray();
        };
        voxelManager.getTimePointScalarData = (tp) => {
            return voxelGroups[tp].getCompleteScalarDataArray();
        };
        voxelManager.getCurrentTimePointScalarData = () => {
            return voxelGroups[timePoint].getCompleteScalarDataArray();
        };
        return voxelManager;
    }
    static createImageVoxelManager({ width, height, scalarData, numberOfComponents = 1, }) {
        const dimensions = [width, height, 1];
        if (!numberOfComponents) {
            numberOfComponents = scalarData.length / width / height;
            if (numberOfComponents > 4 ||
                numberOfComponents < 1 ||
                numberOfComponents === 2) {
                throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
            }
        }
        if (numberOfComponents > 1) {
            return VoxelManager._createRGBScalarVolumeVoxelManager({
                dimensions,
                scalarData,
                numberOfComponents,
            });
        }
        return VoxelManager._createNumberVolumeVoxelManager({
            dimensions,
            scalarData,
        });
    }
    static _createNumberVolumeVoxelManager({ dimensions, scalarData, }) {
        const voxels = new VoxelManager(dimensions, (index) => scalarData[index], (index, v) => {
            const isChanged = scalarData[index] !== v;
            scalarData[index] = v;
            return isChanged;
        });
        voxels.scalarData = scalarData;
        voxels.getMiddleSliceData = () => {
            const middleSliceIndex = Math.floor(dimensions[2] / 2);
            return voxels.getSliceData({
                sliceIndex: middleSliceIndex,
                slicePlane: 2,
            });
        };
        return voxels;
    }
    static createMapVoxelManager({ dimension, }) {
        const map = new Map();
        const voxelManager = new VoxelManager(dimension, map.get.bind(map), (index, v) => map.set(index, v) && true);
        voxelManager.map = map;
        return voxelManager;
    }
    static createHistoryVoxelManager({ sourceVoxelManager, }) {
        const map = new Map();
        const { dimensions } = sourceVoxelManager;
        const voxelManager = new VoxelManager(dimensions, (index) => map.get(index), function (index, v) {
            if (!map.has(index)) {
                const oldV = this.sourceVoxelManager.getAtIndex(index);
                if (oldV === v) {
                    return false;
                }
                map.set(index, oldV);
            }
            else if (v === map.get(index)) {
                map.delete(index);
            }
            this.sourceVoxelManager.setAtIndex(index, v);
        });
        voxelManager.map = map;
        voxelManager.scalarData = sourceVoxelManager.scalarData;
        voxelManager.sourceVoxelManager = sourceVoxelManager;
        return voxelManager;
    }
    static createLazyVoxelManager({ dimensions, planeFactory, }) {
        const map = new Map();
        const [width, height] = dimensions;
        const planeSize = width * height;
        const voxelManager = new VoxelManager(dimensions, (index) => map.get(Math.floor(index / planeSize))[index % planeSize], (index, v) => {
            const k = Math.floor(index / planeSize);
            let layer = map.get(k);
            if (!layer) {
                layer = planeFactory(width, height);
                map.set(k, layer);
            }
            layer[index % planeSize] = v;
            return true;
        });
        voxelManager.map = map;
        return voxelManager;
    }
    static createRLEVoxelManager({ dimensions, }) {
        const [width, height, depth] = dimensions;
        const map = new _RLEVoxelMap__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A(width, height, depth);
        const voxelManager = new VoxelManager(dimensions, (index) => map.get(index), (index, v) => {
            map.set(index, v);
            return true;
        });
        voxelManager.map = map;
        voxelManager.getPixelData = map.getPixelData.bind(map);
        return voxelManager;
    }
    static addInstanceToImage(image) {
        const { width, height } = image;
        const scalarData = image.voxelManager.getScalarData();
        if (scalarData.length >= width * height) {
            image.voxelManager = VoxelManager.createScalarVolumeVoxelManager({
                dimensions: [width, height, 1],
                scalarData,
            });
            return;
        }
        image.voxelManager = VoxelManager.createRLEVoxelManager({
            dimensions: [width, height, 1],
        });
        image.getPixelData = image.voxelManager.getPixelData;
        image.sizeInBytes = DEFAULT_RLE_SIZE;
    }
}


/***/ }),

/***/ 74268:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const isMergeableObject = (val) => {
    const nonNullObject = val && typeof val === 'object';
    return (nonNullObject &&
        Object.prototype.toString.call(val) !== '[object RegExp]' &&
        Object.prototype.toString.call(val) !== '[object Date]');
};
const emptyTarget = (val) => {
    const isEmpty = Array.isArray(val) ? [] : {};
    return isEmpty;
};
const cloneIfNecessary = (value, optionsArgument) => {
    const clone = optionsArgument && optionsArgument.clone === true;
    return clone && isMergeableObject(value)
        ? deepMerge(emptyTarget(value), value, optionsArgument)
        : value;
};
const defaultArrayMerge = (target, source, optionsArgument) => {
    const destination = target.slice();
    source.forEach(function (e, i) {
        if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        }
        else if (isMergeableObject(e)) {
            destination[i] = deepMerge(target[i], e, optionsArgument);
        }
        else if (target.indexOf(e) === -1) {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        }
    });
    return destination;
};
const mergeObject = (target, source, optionsArgument) => {
    const destination = {};
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function (key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
    }
    Object.keys(source).forEach(function (key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
        }
        else {
            destination[key] = deepMerge(target[key], source[key], optionsArgument);
        }
    });
    return destination;
};
const deepMerge = (target = {}, source = {}, optionsArgument = undefined) => {
    const array = Array.isArray(source);
    const options = optionsArgument || { arrayMerge: defaultArrayMerge };
    const arrayMerge = options.arrayMerge || defaultArrayMerge;
    if (array) {
        return Array.isArray(target)
            ? arrayMerge(target, source, optionsArgument)
            : cloneIfNecessary(source, optionsArgument);
    }
    return mergeObject(target, source, optionsArgument);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deepMerge);


/***/ }),

/***/ 9734:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ generateVolumePropsFromImageIds)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _makeVolumeMetadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1865);
/* harmony import */ var _sortImageIdsAndGetSpacing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90537);
/* harmony import */ var _getScalingParameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32173);
/* harmony import */ var _hasFloatScalingParameters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30169);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59693);






function generateVolumePropsFromImageIds(imageIds, volumeId) {
    const volumeMetadata = (0,_makeVolumeMetadata__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageIds);
    const { ImageOrientationPatient, PixelSpacing, Columns, Rows } = volumeMetadata;
    const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(ImageOrientationPatient[0], ImageOrientationPatient[1], ImageOrientationPatient[2]);
    const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(ImageOrientationPatient[3], ImageOrientationPatient[4], ImageOrientationPatient[5]);
    const scanAxisNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    const { zSpacing, origin, sortedImageIds } = (0,_sortImageIdsAndGetSpacing__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(imageIds, scanAxisNormal);
    const numFrames = imageIds.length;
    const spacing = [PixelSpacing[1], PixelSpacing[0], zSpacing];
    const dimensions = [Columns, Rows, numFrames].map((it) => Math.floor(it));
    const direction = [
        ...rowCosineVec,
        ...colCosineVec,
        ...scanAxisNormal,
    ];
    return {
        dimensions,
        spacing,
        origin,
        dataType: _determineDataType(sortedImageIds, volumeMetadata),
        direction,
        metadata: volumeMetadata,
        imageIds: sortedImageIds,
        volumeId,
        voxelManager: null,
        numberOfComponents: volumeMetadata.PhotometricInterpretation === 'RGB' ? 3 : 1,
    };
}
function _determineDataType(imageIds, volumeMetadata) {
    const { BitsAllocated, PixelRepresentation } = volumeMetadata;
    const signed = PixelRepresentation === 1;
    const [firstIndex, middleIndex, lastIndex] = [
        0,
        Math.floor(imageIds.length / 2),
        imageIds.length - 1,
    ];
    const scalingParameters = [firstIndex, middleIndex, lastIndex].map((index) => (0,_getScalingParameters__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(imageIds[index]));
    const hasNegativeRescale = scalingParameters.some((params) => params.rescaleIntercept < 0 || params.rescaleSlope < 0);
    const floatAfterScale = scalingParameters.some((params) => (0,_hasFloatScalingParameters__WEBPACK_IMPORTED_MODULE_4__/* .hasFloatScalingParameters */ .a)(params));
    const canRenderFloat = (0,_init__WEBPACK_IMPORTED_MODULE_5__/* .canRenderFloatTextures */ .lk)();
    switch (BitsAllocated) {
        case 8:
            if (signed) {
                throw new Error('8 Bit signed images are not yet supported by this plugin.');
            }
            return 'Uint8Array';
        case 16:
            if (canRenderFloat && floatAfterScale) {
                return 'Float32Array';
            }
            if (signed || hasNegativeRescale) {
                return 'Int16Array';
            }
            if (!signed && !hasNegativeRescale) {
                return 'Uint16Array';
            }
            return 'Float32Array';
        case 24:
            return 'Uint8Array';
        case 32:
            return 'Float32Array';
        default:
            throw new Error(`Bits allocated of ${BitsAllocated} is not defined to generate scalarData for the volume.`);
    }
}



/***/ }),

/***/ 27119:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74876);

let state = {};
const metadataProvider = {
    add: (imageId, payload) => {
        metadataProvider.addRaw(imageId, {
            ...payload,
            metadata: structuredClone(payload.metadata),
        });
    },
    addRaw: (imageId, payload) => {
        const type = payload.type;
        if (!state[imageId]) {
            state[imageId] = {};
        }
        state[imageId][type] = payload.metadata;
    },
    get: (type, imageId) => {
        return state[imageId]?.[type];
    },
    clear: () => {
        state = {};
    },
};
(0,_metaData__WEBPACK_IMPORTED_MODULE_0__.addProvider)(metadataProvider.get);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (metadataProvider);


/***/ }),

/***/ 99576:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ getBufferConfiguration),
/* harmony export */   j: () => (/* binding */ getConstructorFromType)
/* harmony export */ });
function getConstructorFromType(bufferType, isVolumeBuffer) {
    switch (bufferType) {
        case 'Float32Array':
            return Float32Array;
        case 'Uint8Array':
            return Uint8Array;
        case 'Uint16Array':
        case 'Int16Array':
            if (!isVolumeBuffer) {
                return bufferType === 'Uint16Array' ? Uint16Array : Int16Array;
            }
            else {
                console.debug(`${bufferType} is not supported for volume rendering, switching back to Float32Array`);
                return Float32Array;
            }
        default:
            if (bufferType) {
                throw new Error('TargetBuffer should be Float32Array, Uint8Array, Uint16Array, or Int16Array');
            }
            else {
                return Float32Array;
            }
    }
}
function getBufferConfiguration(targetBufferType, length, options = {}) {
    const { isVolumeBuffer = false } = options;
    const TypedArrayConstructor = getConstructorFromType(targetBufferType, isVolumeBuffer);
    const bytesPerElement = TypedArrayConstructor.BYTES_PER_ELEMENT;
    const numBytes = length * bytesPerElement;
    return { numBytes, TypedArrayConstructor };
}



/***/ }),

/***/ 69372:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ triggerEvent)
/* harmony export */ });
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10364);

function triggerEvent(el = _eventTarget__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A, type, detail = null) {
    if (!type) {
        throw new Error('Event type was not defined');
    }
    const event = new CustomEvent(type, {
        detail,
        cancelable: true,
    });
    return el?.dispatchEvent(event);
}


/***/ }),

/***/ 80221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ uuidv4)
/* harmony export */ });
function uuidv4() {
    if (typeof crypto.randomUUID === 'function') {
        return crypto.randomUUID();
    }
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^
        (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16));
}


/***/ }),

/***/ 44302:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ClassHierarchy)
/* harmony export */ });
/* eslint-disable prefer-rest-params */
class ClassHierarchy extends Array {
  push() {
    for (let i = 0; i < arguments.length; i++) {
      if (!this.includes(arguments[i])) {
        super.push(arguments[i]);
      }
    }
    return this.length;
  }
}




/***/ }),

/***/ 42008:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkDataArray$1)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28914);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16632);




const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.c;
const {
  DefaultDataType
} = _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
const EPSILON = 1e-6;

// Original source from https://www.npmjs.com/package/compute-range
// Modified to accept type arrays
function fastComputeRange(arr, offset, numberOfComponents) {
  const len = arr.length;
  let min = Number.MAX_VALUE;
  let max = -Number.MAX_VALUE;
  let x;
  let i;

  // find first non-NaN value
  for (i = offset; i < len; i += numberOfComponents) {
    if (!Number.isNaN(arr[i])) {
      min = arr[i];
      max = min;
      break;
    }
  }
  for (; i < len; i += numberOfComponents) {
    x = arr[i];
    if (x < min) {
      min = x;
    } else if (x > max) {
      max = x;
    }
  }
  return {
    min,
    max
  };
}

/**
 * @deprecated please use fastComputeRange instead
 */
function createRangeHelper() {
  let min = Number.MAX_VALUE;
  let max = -Number.MAX_VALUE;
  let count = 0;
  let sum = 0;
  return {
    add(value) {
      if (min > value) {
        min = value;
      }
      if (max < value) {
        max = value;
      }
      count++;
      sum += value;
    },
    get() {
      return {
        min,
        max,
        count,
        sum,
        mean: sum / count
      };
    },
    getRange() {
      return {
        min,
        max
      };
    }
  };
}
function computeRange(values) {
  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  if (component < 0 && numberOfComponents > 1) {
    // Compute magnitude
    const size = values.length;
    const numberOfValues = size / numberOfComponents;
    const data = new Float64Array(numberOfValues);
    for (let i = 0, j = 0; i < numberOfValues; ++i) {
      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {
        data[i] += values[j] * values[j];
      }
      data[i] **= 0.5;
    }
    return fastComputeRange(data, 0, 1);
  }
  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
}
function ensureRangeSize(rangeArray) {
  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const ranges = rangeArray || [];
  // Pad ranges with null value to get the
  while (ranges.length <= size) {
    ranges.push(null);
  }
  return ranges;
}
function getDataType(typedArray) {
  // Expects toString() to return "[object ...Array]"
  return Object.prototype.toString.call(typedArray).slice(8, -1);
}
function getMaxNorm(normArray) {
  const numComps = normArray.getNumberOfComponents();
  let maxNorm = 0.0;
  const tuple = new Array(numComps);
  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {
    normArray.getTuple(i, tuple);
    const norm$1 = (0,_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.n)(tuple, numComps);
    if (norm$1 > maxNorm) {
      maxNorm = norm$1;
    }
  }
  return maxNorm;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  computeRange,
  createRangeHelper,
  fastComputeRange,
  getDataType,
  getMaxNorm
};

// ----------------------------------------------------------------------------
// vtkDataArray methods
// ----------------------------------------------------------------------------

function vtkDataArray(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkDataArray');

  /**
   * Resize model.values and copy the old values to the new array.
   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0
   * @returns {Boolean} True if a resize occured, false otherwise
   */
  function resize(requestedNumTuples) {
    if (requestedNumTuples < 0) {
      return false;
    }
    const numComps = publicAPI.getNumberOfComponents();
    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);
    if (requestedNumTuples === curNumTuples) {
      return true;
    }
    if (requestedNumTuples > curNumTuples) {
      // Requested size is bigger than current size.  Allocate enough
      // memory to fit the requested size and be more than double the
      // currently allocated memory.
      const oldValues = model.values;
      model.values = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.a)(model.dataType, (requestedNumTuples + curNumTuples) * numComps);
      model.values.set(oldValues);
      return true;
    }

    // Requested size is smaller than currently allocated size
    if (model.size > requestedNumTuples * numComps) {
      model.size = requestedNumTuples * numComps;
      publicAPI.dataChange();
    }
    return true;
  }
  publicAPI.dataChange = () => {
    model.ranges = null;
    publicAPI.modified();
  };
  publicAPI.resize = requestedNumTuples => {
    resize(requestedNumTuples);
    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();
    if (model.size !== newSize) {
      model.size = newSize;
      publicAPI.dataChange();
      return true;
    }
    return false;
  };

  // FIXME, to rename into "clear()" or "reset()"
  publicAPI.initialize = () => {
    publicAPI.resize(0);
  };
  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;

  // Description:
  // Return the data component at the location specified by tupleIdx and
  // compIdx.
  publicAPI.getComponent = function (tupleIdx) {
    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };

  // Description:
  // Set the data component at the location specified by tupleIdx and compIdx
  // to value.
  // Note that i is less than NumberOfTuples and j is less than
  //  NumberOfComponents. Make sure enough memory has been allocated
  // (use SetNumberOfTuples() and SetNumberOfComponents()).
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.dataChange();
    }
  };
  publicAPI.getValue = valueIdx => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    return publicAPI.getComponent(idx, comp);
  };
  publicAPI.setValue = (valueIdx, value) => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    publicAPI.setComponent(idx, comp, value);
  };
  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);
  publicAPI.getRange = function () {
    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    let rangeIdx = componentIndex;
    if (rangeIdx < 0) {
      // If scalar data, then store in slot 0 (same as componentIndex = 0).
      // If vector data, then store in last slot.
      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;
    }
    let range = null;
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    range = model.ranges[rangeIdx];
    if (range) {
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    }

    // Need to compute ranges...
    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);
    model.ranges[rangeIdx] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setRange = (rangeValue, componentIndex) => {
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    const range = {
      min: rangeValue.min,
      max: rangeValue.max
    };
    model.ranges[componentIndex] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setTuple = (idx, tuple) => {
    const offset = idx * model.numberOfComponents;
    for (let i = 0; i < model.numberOfComponents; i++) {
      model.values[offset + i] = tuple[i];
    }
  };
  publicAPI.setTuples = (idx, tuples) => {
    let i = idx * model.numberOfComponents;
    const last = Math.min(tuples.length, model.size - i);
    for (let j = 0; j < last;) {
      model.values[i++] = tuples[j++];
    }
  };
  publicAPI.insertTuple = (idx, tuple) => {
    if (model.size <= idx * model.numberOfComponents) {
      model.size = (idx + 1) * model.numberOfComponents;
      resize(idx + 1);
    }
    publicAPI.setTuple(idx, tuple);
    return idx;
  };
  publicAPI.insertTuples = (idx, tuples) => {
    const end = idx + tuples.length / model.numberOfComponents;
    if (model.size < end * model.numberOfComponents) {
      model.size = end * model.numberOfComponents;
      resize(end);
    }
    publicAPI.setTuples(idx, tuples);
    return end;
  };
  publicAPI.insertNextTuple = tuple => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuple(idx, tuple);
  };
  publicAPI.insertNextTuples = tuples => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuples(idx, tuples);
  };
  publicAPI.findTuple = function (tuple) {
    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;
    for (let i = 0; i < model.size; i += model.numberOfComponents) {
      if (Math.abs(tuple[0] - model.values[i]) <= precision) {
        let match = true;
        for (let j = 1; j < model.numberOfComponents; ++j) {
          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {
            match = false;
            break;
          }
        }
        if (match) {
          return i / model.numberOfComponents;
        }
      }
    }
    return -1;
  };
  publicAPI.getTuple = function (idx) {
    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const numberOfComponents = model.numberOfComponents || 1;
    const offset = idx * numberOfComponents;
    // Check most common component sizes first
    // to avoid doing a for loop if possible
    switch (numberOfComponents) {
      case 4:
        tupleToFill[3] = model.values[offset + 3];
      // eslint-disable-next-line no-fallthrough
      case 3:
        tupleToFill[2] = model.values[offset + 2];
      // eslint-disable-next-line no-fallthrough
      case 2:
        tupleToFill[1] = model.values[offset + 1];
      // eslint-disable-next-line no-fallthrough
      case 1:
        tupleToFill[0] = model.values[offset];
        break;
      default:
        for (let i = numberOfComponents - 1; i >= 0; --i) {
          tupleToFill[i] = model.values[offset + i];
        }
    }
    return tupleToFill;
  };
  publicAPI.getTuples = (fromId, toId) => {
    const from = (fromId ?? 0) * model.numberOfComponents;
    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;
    const arr = publicAPI.getData().subarray(from, to);
    return arr.length > 0 ? arr : null;
  };
  publicAPI.getTupleLocation = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.size;
  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  /* eslint-disable no-use-before-define */
  publicAPI.newClone = () => newInstance({
    empty: true,
    name: model.name,
    dataType: model.dataType,
    numberOfComponents: model.numberOfComponents
  });
  /* eslint-enable no-use-before-define */

  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.modified();
      model.name = `vtkDataArray${publicAPI.getMTime()}`;
    }
    return model.name;
  };
  publicAPI.setData = (typedArray, numberOfComponents) => {
    model.values = typedArray;
    model.size = typedArray.length;
    model.dataType = getDataType(typedArray);
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    publicAPI.dataChange();
  };

  // Override serialization support
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = {
      ...model,
      vtkClass: publicAPI.getClassName()
    };

    // Convert typed array to regular array
    jsonArchive.values = Array.from(jsonArchive.values);
    delete jsonArchive.buffer;

    // Clean any empty data
    Object.keys(jsonArchive).forEach(keyName => {
      if (!jsonArchive[keyName]) {
        delete jsonArchive[keyName];
      }
    });

    // Sort resulting object by key name
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(name => {
      sortedObj[name] = jsonArchive[name];
    });

    // Remove mtime
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.deepCopy = other => {
    // Retain current dataType and array reference before shallowCopy call.
    const currentType = publicAPI.getDataType();
    const currentArray = model.values;
    publicAPI.shallowCopy(other);

    // Avoid array reallocation if size already sufficient
    // and dataTypes match.
    if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {
      currentArray.set(other.getData());
      model.values = currentArray;
      publicAPI.dataChange();
    } else {
      publicAPI.setData(other.getData().slice());
    }
  };
  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {
    const numberOfComponents = model.numberOfComponents || 1;
    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {
      vtkErrorMacro('numberOfComponents must match');
    }
    const tuple1 = source1.getTuple(source1Idx);
    const tuple2 = source2.getTuple(source2Idx);
    const out = [];
    out.length = numberOfComponents;

    // Check most common component sizes first
    // to avoid doing a for loop if possible
    switch (numberOfComponents) {
      case 4:
        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;
      // eslint-disable-next-line no-fallthrough
      case 3:
        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;
      // eslint-disable-next-line no-fallthrough
      case 2:
        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;
      // eslint-disable-next-line no-fallthrough
      case 1:
        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;
        break;
      default:
        for (let i = 0; i < numberOfComponents; i++) {
          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;
        }
    }
    return publicAPI.insertTuple(idx, out);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

// size: The current size of the dataArray.
// NOTE: The underlying typed array may be larger than 'size'.
const DEFAULT_VALUES = {
  name: '',
  numberOfComponents: 1,
  dataType: DefaultDataType,
  rangeTuple: [0, 0]
  // size: undefined,
  // values: null,
  // ranges: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');
  }
  if (!model.values) {
    model.values = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.a)(model.dataType, model.size);
  } else if (Array.isArray(model.values)) {
    model.values = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.b)(model.dataType, model.values);
  }
  if (model.values) {
    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.
    model.size = model.size ?? model.values.length;
    model.dataType = getDataType(model.values);
  }

  // Object methods
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(publicAPI, model);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.s)(publicAPI, model, ['name', 'numberOfComponents']);
  if (model.size % model.numberOfComponents !== 0) {
    throw new RangeError('model.size is not a multiple of model.numberOfComponents');
  }

  // Object specific methods
  vtkDataArray(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend, 'vtkDataArray');

// ----------------------------------------------------------------------------

var vtkDataArray$1 = {
  newInstance,
  extend,
  ...STATIC,
  ..._DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay
};




/***/ }),

/***/ 97888:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ HalfFloat)
/* harmony export */ });
/* eslint-disable no-bitwise */

const floatView = new Float32Array(1);
const int32View = new Int32Array(floatView.buffer);

/* eslint-disable no-bitwise */
/* This method is faster than the OpenEXR implementation (very often
 * used, eg. in Ogre), with the additional benefit of rounding, inspired
 * by James Tursa?s half-precision code. */
function toHalf(val) {
  floatView[0] = val;
  const x = int32View[0];
  let bits = x >> 16 & 0x8000; /* Get the sign */
  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */
  const e = x >> 23 & 0xff; /* Using int is faster here */

  /* If zero, or denormal, or exponent underflows too much for a denormal
   * half, return signed zero. */
  if (e < 103) {
    return bits;
  }

  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
  if (e > 142) {
    bits |= 0x7c00;
    /* If exponent was 0xff and one mantissa bit was set, it means NaN,
     * not Inf, so make sure we set one mantissa bit too. */
    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
    return bits;
  }

  /* If exponent underflows but not too much, return a denormal */
  if (e < 113) {
    m |= 0x0800;
    /* Extra rounding may overflow and set mantissa to 0 and exponent
     * to 1, which is OK. */
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  /* Extra rounding. An overflow will set mantissa to 0 and increment
   * the exponent, which is OK. */
  bits += m & 1;
  return bits;
}
function fromHalf(h) {
  const s = (h & 0x8000) >> 15;
  const e = (h & 0x7c00) >> 10;
  const f = h & 0x03ff;
  if (e === 0) {
    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);
  }
  if (e === 0x1f) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);
}
var HalfFloat = {
  fromHalf,
  toHalf
};




/***/ }),

/***/ 72879:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkLookupTable$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16632);
/* harmony import */ var _ScalarsToColors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80993);
/* harmony import */ var _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62955);
/* harmony import */ var _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28914);






const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// Add module-level functions or api that you want to expose statically via
// the next section...

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const BELOW_RANGE_COLOR_INDEX = 0;
const ABOVE_RANGE_COLOR_INDEX = 1;
const NAN_COLOR_INDEX = 2;

// ----------------------------------------------------------------------------
// vtkMyClass methods
// ----------------------------------------------------------------------------

function vtkLookupTable(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLookupTable');

  //----------------------------------------------------------------------------
  // Description:
  // Return true if all of the values defining the mapping have an opacity
  // equal to 1. Default implementation return true.
  publicAPI.isOpaque = () => {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      let opaque = true;
      if (model.nanColor[3] < 1.0) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1.0) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1.0) {
        opaque = 0;
      }
      for (let i = 3; i < model.table.length && opaque; i += 4) {
        if (model.table[i] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }
    return model.opaqueFlag;
  };
  publicAPI.usingLogScale = () => false;

  //----------------------------------------------------------------------------
  // Don't count special colors (min, max, NaN) as available colors
  publicAPI.getNumberOfAvailableColors = () => model.table.length / 4 - 3;

  //----------------------------------------------------------------------------
  // Apply shift/scale to the scalar value v and return the index.
  publicAPI.linearIndexLookup = (v, p) => {
    let dIndex = 0;
    const nv = Number(v);
    if (nv < p.range[0]) {
      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (nv > p.range[1]) {
      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (nv + p.shift) * p.scale;

      // This conditional is needed because when v is very close to
      // p.Range[1], it may map above p.MaxIndex in the linear mapping
      // above.
      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
    }
    return Math.floor(dIndex);
  };
  publicAPI.linearLookup = (v, table, p) => {
    let index = 0;
    if ((0,_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.i)(v)) {
      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index = publicAPI.linearIndexLookup(v, p);
    }
    const offset = 4 * index;
    return table.slice(offset, offset + 4);
  };
  publicAPI.indexedLookupFunction = (v, table, p) => {
    let index = publicAPI.getAnnotatedValueIndexInternal(v);
    if (index === -1) {
      index = model.numberOfColors + NAN_COLOR_INDEX;
    }
    const offset = 4 * index;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };

  //----------------------------------------------------------------------------
  publicAPI.lookupShiftAndScale = (range, p) => {
    p.shift = -range[0];
    p.scale = Number.MAX_VALUE;
    if (range[1] > range[0]) {
      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
    }
  };

  // Public API methods
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    let lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }
    const trange = publicAPI.getMappingRange();
    const p = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0.0,
      scale: 0.0
    };
    publicAPI.lookupShiftAndScale(trange, p);
    const alpha = publicAPI.getAlpha();
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    if (alpha >= 1.0) {
      if (outFormat === _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ScalarMappingTarget */ .y0.RGBA) {
        for (let i = 0; i < length; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = cptr[3];
        }
      }
    } else {
      /* eslint-disable no-lonely-if */
      if (outFormat === _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ScalarMappingTarget */ .y0.RGBA) {
        for (let i = 0; i < length; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
        }
      }
    } // alpha blending
  };

  publicAPI.forceBuild = () => {
    let hinc = 0.0;
    let sinc = 0.0;
    let vinc = 0.0;
    let ainc = 0.0;
    const maxIndex = model.numberOfColors - 1;
    if (maxIndex) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
    }
    model.table.length = 4 * maxIndex + 16;
    const hsv = [];
    const rgba = [];
    for (let i = 0; i <= maxIndex; i++) {
      hsv[0] = model.hueRange[0] + i * hinc;
      hsv[1] = model.saturationRange[0] + i * sinc;
      hsv[2] = model.valueRange[0] + i * vinc;
      (0,_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.h)(hsv, rgba);
      rgba[3] = model.alphaRange[0] + i * ainc;

      //  case VTK_RAMP_LINEAR:
      model.table[i * 4] = rgba[0] * 255.0 + 0.5;
      model.table[i * 4 + 1] = rgba[1] * 255.0 + 0.5;
      model.table[i * 4 + 2] = rgba[2] * 255.0 + 0.5;
      model.table[i * 4 + 3] = rgba[3] * 255.0 + 0.5;
    }
    publicAPI.buildSpecialColors();
    model.buildTime.modified();
  };
  publicAPI.setTable = table => {
    // Handle JS array (assume 2D array)
    if (Array.isArray(table)) {
      const nbComponents = table[0].length;
      model.numberOfColors = table.length;
      const colorOffset = 4 - nbComponents;
      let offset = 0;
      // fill table
      for (let i = 0; i < model.numberOfColors; i++) {
        model.table[i * 4] = 255;
        model.table[i * 4 + 1] = 255;
        model.table[i * 4 + 2] = 255;
        model.table[i * 4 + 3] = 255;
      }
      // extract colors
      for (let i = 0; i < table.length; i++) {
        const color = table[i];
        for (let j = 0; j < nbComponents; j++) {
          model.table[offset++] = color[j];
        }
        offset += colorOffset;
      }
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
      publicAPI.modified();
      return true;
    }
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro('Expected 4 components for RGBA colors');
      return false;
    }
    if (table.getDataType() !== _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR) {
      vtkErrorMacro('Expected unsigned char values for RGBA colors');
      return false;
    }
    model.numberOfColors = table.getNumberOfTuples();
    const data = table.getData();
    model.table.length = data.length;
    for (let i = 0; i < data.length; i++) {
      model.table[i] = data[i];
    }
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
    return true;
  };
  publicAPI.buildSpecialColors = () => {
    // Add "special" colors (NaN, below range, above range) to table here.
    const {
      numberOfColors
    } = model;
    const tptr = model.table;
    let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;

    // Below range color
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255.0 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255.0 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255.0 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255.0 + 0.5;
    } else {
      // Duplicate the first color in the table.
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }

    // Above range color
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255.0 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255.0 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255.0 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255.0 + 0.5;
    } else {
      // Duplicate the last color in the table.
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }

    // Always use NanColor
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255.0 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255.0 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255.0 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255.0 + 0.5;
  };
  publicAPI.build = () => {
    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
      publicAPI.forceBuild();
    }
  };
  if (model.table.length > 0) {
    // Ensure that special colors are properly included in the table
    publicAPI.buildSpecialColors();

    // ensure insertTime is more recently modified than buildTime if
    // a table is provided via the constructor
    model.insertTime.modified();
  }
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  numberOfColors: 256,
  // table: null,

  hueRange: [0.0, 0.66667],
  saturationRange: [1.0, 1.0],
  valueRange: [1.0, 1.0],
  alphaRange: [1.0, 1.0],
  nanColor: [0.5, 0.0, 0.0, 1.0],
  belowRangeColor: [0.0, 0.0, 0.0, 1.0],
  aboveRangeColor: [1.0, 1.0, 1.0, 1.0],
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  alpha: 1.0
  // buildTime: null,
  // opaqueFlagBuildTime: null,
  // insertTime: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _ScalarsToColors_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Internal objects initialization
  if (!model.table) {
    model.table = [];
  }
  model.buildTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.buildTime);
  model.opaqueFlagBuildTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.opaqueFlagBuildTime, {
    mtime: 0
  });
  model.insertTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.insertTime, {
    mtime: 0
  });

  // Create get-only macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['buildTime']);

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['numberOfColors', 'useAboveRangeColor', 'useBelowRangeColor']);

  // Create set macros for array (needs to know size)
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['alphaRange', 'hueRange', 'saturationRange', 'valueRange'], 2);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);

  // Create get macros for array
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['hueRange', 'saturationRange', 'valueRange', 'alphaRange', 'nanColor', 'belowRangeColor', 'aboveRangeColor']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkLookupTable(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkLookupTable');

// ----------------------------------------------------------------------------

var vtkLookupTable$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 84607:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_3__.f)
/* harmony export */ });
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56037);
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Math_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35341);
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16632);






/***/ }),

/***/ 35341:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GY: () => (/* binding */ IDENTITY_3X3),
/* harmony export */   kP: () => (/* binding */ VTK_SMALL_NUMBER),
/* harmony export */   p8: () => (/* binding */ EPSILON),
/* harmony export */   zK: () => (/* binding */ IDENTITY)
/* harmony export */ });
/* unused harmony export default */
const IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const IDENTITY_3X3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
const EPSILON = 1e-6;
const VTK_SMALL_NUMBER = 1.0e-12;
var Constants = {
  IDENTITY,
  IDENTITY_3X3,
  EPSILON,
  VTK_SMALL_NUMBER
};




/***/ }),

/***/ 16632:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ degreesFromRadians),
/* harmony export */   C: () => (/* binding */ clampValue),
/* harmony export */   F: () => (/* binding */ createUninitializedBounds),
/* harmony export */   I: () => (/* binding */ floor),
/* harmony export */   J: () => (/* binding */ isInf),
/* harmony export */   K: () => (/* binding */ rgb2hsv),
/* harmony export */   L: () => (/* binding */ rgb2lab),
/* harmony export */   M: () => (/* binding */ lab2rgb),
/* harmony export */   N: () => (/* binding */ round),
/* harmony export */   O: () => (/* binding */ normalize2D),
/* harmony export */   P: () => (/* binding */ nearestPowerOfTwo),
/* harmony export */   Q: () => (/* binding */ multiply3x3_vect3),
/* harmony export */   R: () => (/* binding */ getSparseOrthogonalMatrix),
/* harmony export */   S: () => (/* binding */ areBoundsInitialized),
/* harmony export */   T: () => (/* binding */ isPowerOfTwo),
/* harmony export */   a: () => (/* binding */ areMatricesEqual),
/* harmony export */   b: () => (/* binding */ roundVector),
/* harmony export */   c: () => (/* binding */ clampVector),
/* harmony export */   d: () => (/* binding */ dot),
/* harmony export */   e: () => (/* binding */ distance2BetweenPoints),
/* harmony export */   f: () => (/* binding */ vtkMath),
/* harmony export */   g: () => (/* binding */ solveLinearSystem),
/* harmony export */   h: () => (/* binding */ hsv2rgb),
/* harmony export */   i: () => (/* binding */ isNan),
/* harmony export */   j: () => (/* binding */ cross),
/* harmony export */   k: () => (/* binding */ add),
/* harmony export */   l: () => (/* binding */ normalize),
/* harmony export */   m: () => (/* binding */ multiplyAccumulate),
/* harmony export */   n: () => (/* binding */ norm),
/* harmony export */   o: () => (/* binding */ determinant2x2),
/* harmony export */   r: () => (/* binding */ radiansFromDegrees),
/* harmony export */   s: () => (/* binding */ subtract),
/* harmony export */   u: () => (/* binding */ uninitializeBounds)
/* harmony export */ });
/* unused harmony exports $, B, D, E, G, H, U, V, W, X, Y, Z, _, a$, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE, aF, aG, aH, aI, aJ, aK, aL, aM, aN, aO, aP, aQ, aR, aS, aT, aU, aV, aW, aX, aY, aZ, a_, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, p, q, t, v, w, x, y, z */
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56037);
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35341);




const {
  vtkErrorMacro,
  vtkWarningMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m;

// ----------------------------------------------------------------------------
/* eslint-disable camelcase                                                  */
/* eslint-disable no-cond-assign                                             */
/* eslint-disable no-bitwise                                                 */
/* eslint-disable no-multi-assign                                            */
// ----------------------------------------------------------------------------
let randomSeedValue = 0;
const VTK_MAX_ROTATIONS = 20;
function notImplemented(method) {
  return () => vtkErrorMacro(`vtkMath::${method} - NOT IMPLEMENTED`);
}

// Swap rows for n by n matrix
function swapRowsMatrix_nxn(matrix, n, row1, row2) {
  let tmp;
  for (let i = 0; i < n; i++) {
    tmp = matrix[row1 * n + i];
    matrix[row1 * n + i] = matrix[row2 * n + i];
    matrix[row2 * n + i] = tmp;
  }
}

// Swap columns for n by n matrix
function swapColumnsMatrix_nxn(matrix, n, column1, column2) {
  let tmp;
  for (let i = 0; i < n; i++) {
    tmp = matrix[i * n + column1];
    matrix[i * n + column1] = matrix[i * n + column2];
    matrix[i * n + column2] = tmp;
  }
}

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function createArray() {
  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
  // faster than Array.from and/or while loop
  const res = Array(size);
  for (let i = 0; i < size; ++i) {
    res[i] = 0;
  }
  return res;
}
const Pi = () => Math.PI;
function radiansFromDegrees(deg) {
  return deg / 180 * Math.PI;
}
function degreesFromRadians(rad) {
  return rad * 180 / Math.PI;
}
const {
  round,
  floor,
  ceil,
  min,
  max
} = Math;
function arrayMin(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let minValue = Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
  }
  return minValue;
}
function arrayMax(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let maxValue = -Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return maxValue;
}
function arrayRange(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let minValue = Infinity;
  let maxValue = -Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return [minValue, maxValue];
}
const ceilLog2 = notImplemented('ceilLog2');
const factorial = notImplemented('factorial');
function nearestPowerOfTwo(xi) {
  let v = 1;
  while (v < xi) {
    v *= 2;
  }
  return v;
}
function isPowerOfTwo(x) {
  return x === nearestPowerOfTwo(x);
}
function binomial(m, n) {
  let r = 1;
  for (let i = 1; i <= n; ++i) {
    r *= (m - i + 1) / i;
  }
  return Math.floor(r);
}
function beginCombination(m, n) {
  if (m < n) {
    return 0;
  }
  const r = createArray(n);
  for (let i = 0; i < n; ++i) {
    r[i] = i;
  }
  return r;
}
function nextCombination(m, n, r) {
  let status = 0;
  for (let i = n - 1; i >= 0; --i) {
    if (r[i] < m - n + i) {
      let j = r[i] + 1;
      while (i < n) {
        r[i++] = j++;
      }
      status = 1;
      break;
    }
  }
  return status;
}
function randomSeed(seed) {
  seedrandom__WEBPACK_IMPORTED_MODULE_0___default()(`${seed}`, {
    global: true
  });
  randomSeedValue = seed;
}
function getSeed() {
  return randomSeedValue;
}
function random() {
  let minValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let maxValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  const delta = maxValue - minValue;
  return minValue + delta * Math.random();
}
const gaussian = notImplemented('gaussian');

// Vect3 operations
function add(a, b, out) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(a, b, out) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiplyScalar(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  vec[2] *= scalar;
  return vec;
}
function multiplyScalar2D(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  return vec;
}
function multiplyAccumulate(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  out[2] = a[2] + b[2] * scalar;
  return out;
}
function multiplyAccumulate2D(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  return out;
}
function dot(x, y) {
  return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
}
function outer(x, y, out_3x3) {
  out_3x3[0] = x[0] * y[0];
  out_3x3[1] = x[0] * y[1];
  out_3x3[2] = x[0] * y[2];
  out_3x3[3] = x[1] * y[0];
  out_3x3[4] = x[1] * y[1];
  out_3x3[5] = x[1] * y[2];
  out_3x3[6] = x[2] * y[0];
  out_3x3[7] = x[2] * y[1];
  out_3x3[8] = x[2] * y[2];
}
function cross(x, y, out) {
  const Zx = x[1] * y[2] - x[2] * y[1];
  const Zy = x[2] * y[0] - x[0] * y[2];
  const Zz = x[0] * y[1] - x[1] * y[0];
  out[0] = Zx;
  out[1] = Zy;
  out[2] = Zz;
  return out;
}
function norm(x) {
  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  switch (n) {
    case 1:
      return Math.abs(x);
    case 2:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);
    case 3:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
    default:
      {
        let sum = 0;
        for (let i = 0; i < n; i++) {
          sum += x[i] * x[i];
        }
        return Math.sqrt(sum);
      }
  }
}
function normalize(x) {
  const den = norm(x);
  if (den !== 0.0) {
    x[0] /= den;
    x[1] /= den;
    x[2] /= den;
  }
  return den;
}
function perpendiculars(x, y, z, theta) {
  const x2 = x[0] * x[0];
  const y2 = x[1] * x[1];
  const z2 = x[2] * x[2];
  const r = Math.sqrt(x2 + y2 + z2);
  let dx;
  let dy;
  let dz;

  // transpose the vector to avoid divide-by-zero error
  if (x2 > y2 && x2 > z2) {
    dx = 0;
    dy = 1;
    dz = 2;
  } else if (y2 > z2) {
    dx = 1;
    dy = 2;
    dz = 0;
  } else {
    dx = 2;
    dy = 0;
    dz = 1;
  }
  const a = x[dx] / r;
  const b = x[dy] / r;
  const c = x[dz] / r;
  const tmp = Math.sqrt(a * a + c * c);
  if (theta !== 0) {
    const sintheta = Math.sin(theta);
    const costheta = Math.cos(theta);
    if (y) {
      y[dx] = (c * costheta - a * b * sintheta) / tmp;
      y[dy] = sintheta * tmp;
      y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;
    }
    if (z) {
      z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;
      z[dy] = costheta * tmp;
      z[dz] = (a * sintheta - b * c * costheta) / tmp;
    }
  } else {
    if (y) {
      y[dx] = c / tmp;
      y[dy] = 0;
      y[dz] = -a / tmp;
    }
    if (z) {
      z[dx] = -a * b / tmp;
      z[dy] = tmp;
      z[dz] = -b * c / tmp;
    }
  }
}
function projectVector(a, b, projection) {
  const bSquared = dot(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    projection[2] = 0;
    return false;
  }
  const scale = dot(a, b) / bSquared;
  for (let i = 0; i < 3; i++) {
    projection[i] = b[i];
  }
  multiplyScalar(projection, scale);
  return true;
}
function dot2D(x, y) {
  return x[0] * y[0] + x[1] * y[1];
}
function projectVector2D(a, b, projection) {
  const bSquared = dot2D(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    return false;
  }
  const scale = dot2D(a, b) / bSquared;
  for (let i = 0; i < 2; i++) {
    projection[i] = b[i];
  }
  multiplyScalar2D(projection, scale);
  return true;
}
function distance2BetweenPoints(x, y) {
  return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);
}
function angleBetweenVectors(v1, v2) {
  const crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  return Math.atan2(norm(crossVect), dot(v1, v2));
}
function signedAngleBetweenVectors(v1, v2, vN) {
  const crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  const angle = Math.atan2(norm(crossVect), dot(v1, v2));
  return dot(crossVect, vN) >= 0 ? angle : -angle;
}
function gaussianAmplitude(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-(distanceFromMean ** 2) / (2 * variance));
}
function gaussianWeight(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return Math.exp(-(distanceFromMean ** 2) / (2 * variance));
}
function outer2D(x, y, out_2x2) {
  out_2x2[0] = x[0] * y[0];
  out_2x2[1] = x[0] * y[1];
  out_2x2[2] = x[1] * y[0];
  out_2x2[3] = x[1] * y[1];
}
function norm2D(x2D) {
  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
}
function normalize2D(x) {
  const den = norm2D(x);
  if (den !== 0.0) {
    x[0] /= den;
    x[1] /= den;
  }
  return den;
}
function rowsToMat4(row0, row1, row2, row3, mat) {
  for (let i = 0; i < 4; i++) {
    mat[i] = row0[i];
    mat[4 + i] = row1[i];
    mat[8 + i] = row2[i];
    mat[12 + i] = row3[i];
  }
  return mat;
}
function columnsToMat4(column0, column1, column2, column3, mat) {
  for (let i = 0; i < 4; i++) {
    mat[4 * i] = column0[i];
    mat[4 * i + 1] = column1[i];
    mat[4 * i + 2] = column2[i];
    mat[4 * i + 3] = column3[i];
  }
  return mat;
}
function rowsToMat3(row0, row1, row2, mat) {
  for (let i = 0; i < 3; i++) {
    mat[i] = row0[i];
    mat[3 + i] = row1[i];
    mat[6 + i] = row2[i];
  }
  return mat;
}
function columnsToMat3(column0, column1, column2, mat) {
  for (let i = 0; i < 3; i++) {
    mat[3 * i] = column0[i];
    mat[3 * i + 1] = column1[i];
    mat[3 * i + 2] = column2[i];
  }
  return mat;
}
function determinant2x2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length === 2) {
    return args[0][0] * args[1][1] - args[1][0] * args[0][1];
  }
  if (args.length === 4) {
    return args[0] * args[3] - args[1] * args[2];
  }
  return Number.NaN;
}
function LUFactor3x3(mat_3x3, index_3) {
  let maxI;
  let tmp;
  let largest;
  const scale = [0, 0, 0];

  // Loop over rows to get implicit scaling information
  for (let i = 0; i < 3; i++) {
    largest = Math.abs(mat_3x3[i * 3]);
    if ((tmp = Math.abs(mat_3x3[i * 3 + 1])) > largest) {
      largest = tmp;
    }
    if ((tmp = Math.abs(mat_3x3[i * 3 + 2])) > largest) {
      largest = tmp;
    }
    scale[i] = 1 / largest;
  }

  // Loop over all columns using Crout's method

  // first column
  largest = scale[0] * Math.abs(mat_3x3[0]);
  maxI = 0;
  if ((tmp = scale[1] * Math.abs(mat_3x3[3])) >= largest) {
    largest = tmp;
    maxI = 1;
  }
  if ((tmp = scale[2] * Math.abs(mat_3x3[6])) >= largest) {
    maxI = 2;
  }
  if (maxI !== 0) {
    swapRowsMatrix_nxn(mat_3x3, 3, maxI, 0);
    scale[maxI] = scale[0];
  }
  index_3[0] = maxI;
  mat_3x3[3] /= mat_3x3[0];
  mat_3x3[6] /= mat_3x3[0];

  // second column
  mat_3x3[4] -= mat_3x3[3] * mat_3x3[1];
  mat_3x3[7] -= mat_3x3[6] * mat_3x3[1];
  largest = scale[1] * Math.abs(mat_3x3[4]);
  maxI = 1;
  if ((tmp = scale[2] * Math.abs(mat_3x3[7])) >= largest) {
    maxI = 2;
    swapRowsMatrix_nxn(mat_3x3, 3, 1, 2);
    scale[2] = scale[1];
  }
  index_3[1] = maxI;
  mat_3x3[7] /= mat_3x3[4];

  // third column
  mat_3x3[5] -= mat_3x3[3] * mat_3x3[2];
  mat_3x3[8] -= mat_3x3[6] * mat_3x3[2] + mat_3x3[7] * mat_3x3[5];
  index_3[2] = 2;
}
function LUSolve3x3(mat_3x3, index_3, x_3) {
  // forward substitution
  let sum = x_3[index_3[0]];
  x_3[index_3[0]] = x_3[0];
  x_3[0] = sum;
  sum = x_3[index_3[1]];
  x_3[index_3[1]] = x_3[1];
  x_3[1] = sum - mat_3x3[3] * x_3[0];
  sum = x_3[index_3[2]];
  x_3[index_3[2]] = x_3[2];
  x_3[2] = sum - mat_3x3[6] * x_3[0] - mat_3x3[7] * x_3[1];

  // back substitution
  x_3[2] /= mat_3x3[8];
  x_3[1] = (x_3[1] - mat_3x3[5] * x_3[2]) / mat_3x3[4];
  x_3[0] = (x_3[0] - mat_3x3[1] * x_3[1] - mat_3x3[2] * x_3[2]) / mat_3x3[0];
}
function linearSolve3x3(mat_3x3, x_3, y_3) {
  const a1 = mat_3x3[0];
  const b1 = mat_3x3[1];
  const c1 = mat_3x3[2];
  const a2 = mat_3x3[3];
  const b2 = mat_3x3[4];
  const c2 = mat_3x3[5];
  const a3 = mat_3x3[6];
  const b3 = mat_3x3[7];
  const c3 = mat_3x3[8];

  // Compute the adjoint
  const d1 = +determinant2x2(b2, b3, c2, c3);
  const d2 = -determinant2x2(a2, a3, c2, c3);
  const d3 = +determinant2x2(a2, a3, b2, b3);
  const e1 = -determinant2x2(b1, b3, c1, c3);
  const e2 = +determinant2x2(a1, a3, c1, c3);
  const e3 = -determinant2x2(a1, a3, b1, b3);
  const f1 = +determinant2x2(b1, b2, c1, c2);
  const f2 = -determinant2x2(a1, a2, c1, c2);
  const f3 = +determinant2x2(a1, a2, b1, b2);

  // Compute the determinant
  const det = a1 * d1 + b1 * d2 + c1 * d3;

  // Multiply by the adjoint
  const v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
  const v2 = d2 * x_3[0] + e2 * x_3[1] + f2 * x_3[2];
  const v3 = d3 * x_3[0] + e3 * x_3[1] + f3 * x_3[2];

  // Divide by the determinant
  y_3[0] = v1 / det;
  y_3[1] = v2 / det;
  y_3[2] = v3 / det;
}
function multiply3x3_vect3(mat_3x3, in_3, out_3) {
  const x = mat_3x3[0] * in_3[0] + mat_3x3[1] * in_3[1] + mat_3x3[2] * in_3[2];
  const y = mat_3x3[3] * in_3[0] + mat_3x3[4] * in_3[1] + mat_3x3[5] * in_3[2];
  const z = mat_3x3[6] * in_3[0] + mat_3x3[7] * in_3[1] + mat_3x3[8] * in_3[2];
  out_3[0] = x;
  out_3[1] = y;
  out_3[2] = z;
}
function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
  const copyA = [...a_3x3];
  const copyB = [...b_3x3];
  for (let i = 0; i < 3; i++) {
    out_3x3[i] = copyA[0] * copyB[i] + copyA[1] * copyB[i + 3] + copyA[2] * copyB[i + 6];
    out_3x3[i + 3] = copyA[3] * copyB[i] + copyA[4] * copyB[i + 3] + copyA[5] * copyB[i + 6];
    out_3x3[i + 6] = copyA[6] * copyB[i] + copyA[7] * copyB[i + 3] + copyA[8] * copyB[i + 6];
  }
}
function multiplyMatrix(a, b, rowA, colA, rowB, colB, outRowAColB) {
  // we need colA == rowB
  if (colA !== rowB) {
    vtkErrorMacro('Number of columns of A must match number of rows of B.');
  }

  // If a or b is used to store the result, copying them is required
  const copyA = [...a];
  const copyB = [...b];
  // output matrix is rowA*colB
  // output row
  for (let i = 0; i < rowA; i++) {
    // output col
    for (let j = 0; j < colB; j++) {
      outRowAColB[i * colB + j] = 0;
      // sum for this point
      for (let k = 0; k < colA; k++) {
        outRowAColB[i * colB + j] += copyA[i * colA + k] * copyB[j + colB * k];
      }
    }
  }
}
function transpose3x3(in_3x3, outT_3x3) {
  let tmp;

  // off-diagonal elements
  tmp = in_3x3[3];
  outT_3x3[3] = in_3x3[1];
  outT_3x3[1] = tmp;
  tmp = in_3x3[6];
  outT_3x3[6] = in_3x3[2];
  outT_3x3[2] = tmp;
  tmp = in_3x3[7];
  outT_3x3[7] = in_3x3[5];
  outT_3x3[5] = tmp;

  // on-diagonal elements
  outT_3x3[0] = in_3x3[0];
  outT_3x3[4] = in_3x3[4];
  outT_3x3[8] = in_3x3[8];
}
function invert3x3(in_3x3, outI_3x3) {
  const a1 = in_3x3[0];
  const b1 = in_3x3[1];
  const c1 = in_3x3[2];
  const a2 = in_3x3[3];
  const b2 = in_3x3[4];
  const c2 = in_3x3[5];
  const a3 = in_3x3[6];
  const b3 = in_3x3[7];
  const c3 = in_3x3[8];

  // Compute the adjoint
  const d1 = +determinant2x2(b2, b3, c2, c3);
  const d2 = -determinant2x2(a2, a3, c2, c3);
  const d3 = +determinant2x2(a2, a3, b2, b3);
  const e1 = -determinant2x2(b1, b3, c1, c3);
  const e2 = +determinant2x2(a1, a3, c1, c3);
  const e3 = -determinant2x2(a1, a3, b1, b3);
  const f1 = +determinant2x2(b1, b2, c1, c2);
  const f2 = -determinant2x2(a1, a2, c1, c2);
  const f3 = +determinant2x2(a1, a2, b1, b2);

  // Divide by the determinant
  const det = a1 * d1 + b1 * d2 + c1 * d3;
  if (det === 0) {
    vtkWarningMacro('Matrix has 0 determinant');
  }
  outI_3x3[0] = d1 / det;
  outI_3x3[3] = d2 / det;
  outI_3x3[6] = d3 / det;
  outI_3x3[1] = e1 / det;
  outI_3x3[4] = e2 / det;
  outI_3x3[7] = e3 / det;
  outI_3x3[2] = f1 / det;
  outI_3x3[5] = f2 / det;
  outI_3x3[8] = f3 / det;
}
function determinant3x3(mat_3x3) {
  return mat_3x3[0] * mat_3x3[4] * mat_3x3[8] + mat_3x3[3] * mat_3x3[7] * mat_3x3[2] + mat_3x3[6] * mat_3x3[1] * mat_3x3[5] - mat_3x3[0] * mat_3x3[7] * mat_3x3[5] - mat_3x3[3] * mat_3x3[1] * mat_3x3[8] - mat_3x3[6] * mat_3x3[4] * mat_3x3[2];
}

/**
 * Returns true if elements of both arrays are equals.
 * @param {Array} a an array of numbers (vector, point, matrix...)
 * @param {Array} b an array of numbers (vector, point, matrix...)
 * @param {Number} eps tolerance
 */
function areEquals(a, b) {
  let eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .EPSILON */ .p8;
  if (a.length !== b.length) {
    return false;
  }
  function isEqual(element, index) {
    return Math.abs(element - b[index]) <= eps;
  }
  return a.every(isEqual);
}
const areMatricesEqual = areEquals;
function identity3x3(mat_3x3) {
  for (let i = 0; i < 3; i++) {
    /* eslint-disable-next-line no-multi-assign */
    mat_3x3[i * 3] = mat_3x3[i * 3 + 1] = mat_3x3[i * 3 + 2] = 0;
    mat_3x3[i * 3 + i] = 1;
  }
}
function identity(n, mat) {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      mat[i * n + j] = 0;
    }
    mat[i * n + i] = 1;
  }
  return mat;
}
function isIdentity(mat) {
  let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .EPSILON */ .p8;
  return areMatricesEqual(mat, _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .IDENTITY */ .zK, eps);
}
function isIdentity3x3(mat) {
  let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .EPSILON */ .p8;
  return areMatricesEqual(mat, _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .IDENTITY_3X3 */ .GY, eps);
}
function quaternionToMatrix3x3(quat_4, mat_3x3) {
  const ww = quat_4[0] * quat_4[0];
  const wx = quat_4[0] * quat_4[1];
  const wy = quat_4[0] * quat_4[2];
  const wz = quat_4[0] * quat_4[3];
  const xx = quat_4[1] * quat_4[1];
  const yy = quat_4[2] * quat_4[2];
  const zz = quat_4[3] * quat_4[3];
  const xy = quat_4[1] * quat_4[2];
  const xz = quat_4[1] * quat_4[3];
  const yz = quat_4[2] * quat_4[3];
  const rr = xx + yy + zz;
  // normalization factor, just in case quaternion was not normalized
  let f = 1 / (ww + rr);
  const s = (ww - rr) * f;
  f *= 2;
  mat_3x3[0] = xx * f + s;
  mat_3x3[3] = (xy + wz) * f;
  mat_3x3[6] = (xz - wy) * f;
  mat_3x3[1] = (xy - wz) * f;
  mat_3x3[4] = yy * f + s;
  mat_3x3[7] = (yz + wx) * f;
  mat_3x3[2] = (xz + wy) * f;
  mat_3x3[5] = (yz - wx) * f;
  mat_3x3[8] = zz * f + s;
}
function roundNumber(num) {
  let digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!`${num}`.includes('e')) {
    return +`${Math.round(`${num}e+${digits}`)}e-${digits}`;
  }
  const arr = `${num}`.split('e');
  let sig = '';
  if (+arr[1] + digits > 0) {
    sig = '+';
  }
  return +`${Math.round(`${+arr[0]}e${sig}${+arr[1] + digits}`)}e-${digits}`;
}
function roundVector(vector) {
  let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  let digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  out[0] = roundNumber(vector[0], digits);
  out[1] = roundNumber(vector[1], digits);
  out[2] = roundNumber(vector[2], digits);
  return out;
}
function jacobiN(a, n, w, v) {
  let i;
  let j;
  let k;
  let iq;
  let ip;
  let numPos;
  let tresh;
  let theta;
  let t;
  let tau;
  let sm;
  let s;
  let h;
  let g;
  let c;
  let tmp;
  const b = createArray(n);
  const z = createArray(n);
  const vtkROTATE = (aa, ii, jj) => {
    g = aa[ii];
    h = aa[jj];
    aa[ii] = g - s * (h + g * tau);
    aa[jj] = h + s * (g - h * tau);
  };

  // initialize
  identity(n, v);
  for (ip = 0; ip < n; ip++) {
    b[ip] = w[ip] = a[ip + ip * n];
    z[ip] = 0.0;
  }

  // begin rotation sequence
  for (i = 0; i < VTK_MAX_ROTATIONS; i++) {
    sm = 0.0;
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        sm += Math.abs(a[ip * n + iq]);
      }
    }
    if (sm === 0.0) {
      break;
    }

    // first 3 sweeps
    if (i < 3) {
      tresh = 0.2 * sm / (n * n);
    } else {
      tresh = 0.0;
    }
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        g = 100.0 * Math.abs(a[ip * n + iq]);

        // after 4 sweeps
        if (i > 3 && Math.abs(w[ip]) + g === Math.abs(w[ip]) && Math.abs(w[iq]) + g === Math.abs(w[iq])) {
          a[ip * n + iq] = 0.0;
        } else if (Math.abs(a[ip * n + iq]) > tresh) {
          h = w[iq] - w[ip];
          if (Math.abs(h) + g === Math.abs(h)) {
            t = a[ip * n + iq] / h;
          } else {
            theta = 0.5 * h / a[ip * n + iq];
            t = 1.0 / (Math.abs(theta) + Math.sqrt(1.0 + theta * theta));
            if (theta < 0.0) {
              t = -t;
            }
          }
          c = 1.0 / Math.sqrt(1 + t * t);
          s = t * c;
          tau = s / (1.0 + c);
          h = t * a[ip * n + iq];
          z[ip] -= h;
          z[iq] += h;
          w[ip] -= h;
          w[iq] += h;
          a[ip * n + iq] = 0.0;

          // ip already shifted left by 1 unit
          for (j = 0; j <= ip - 1; j++) {
            vtkROTATE(a, j * n + ip, j * n + iq);
          }
          // ip and iq already shifted left by 1 unit
          for (j = ip + 1; j <= iq - 1; j++) {
            vtkROTATE(a, ip * n + j, j * n + iq);
          }
          // iq already shifted left by 1 unit
          for (j = iq + 1; j < n; j++) {
            vtkROTATE(a, ip * n + j, iq * n + j);
          }
          for (j = 0; j < n; j++) {
            vtkROTATE(v, j * n + ip, j * n + iq);
          }
        }
      }
    }
    for (ip = 0; ip < n; ip++) {
      b[ip] += z[ip];
      w[ip] = b[ip];
      z[ip] = 0.0;
    }
  }

  // this is NEVER called
  if (i >= VTK_MAX_ROTATIONS) {
    vtkWarningMacro('vtkMath::Jacobi: Error extracting eigenfunctions');
    return 0;
  }

  // sort eigenfunctions: these changes do not affect accuracy
  for (j = 0; j < n - 1; j++) {
    // boundary incorrect
    k = j;
    tmp = w[k];
    for (i = j + 1; i < n; i++) {
      // boundary incorrect, shifted already
      if (w[i] >= tmp || Math.abs(w[i] - tmp) < _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VTK_SMALL_NUMBER */ .kP) {
        // why exchange if same?
        k = i;
        tmp = w[k];
      }
    }
    if (k !== j) {
      w[k] = w[j];
      w[j] = tmp;
      swapColumnsMatrix_nxn(v, n, j, k);
    }
  }
  // ensure eigenvector consistency (i.e., Jacobi can compute vectors that
  // are negative of one another (.707,.707,0) and (-.707,-.707,0). This can
  // reek havoc in hyperstreamline/other stuff. We will select the most
  // positive eigenvector.
  const ceil_half_n = (n >> 1) + (n & 1);
  for (numPos = 0, i = 0; i < n * n; i++) {
    if (v[i] >= 0.0) {
      numPos++;
    }
  }
  //    if ( numPos < ceil(double(n)/double(2.0)) )
  if (numPos < ceil_half_n) {
    for (i = 0; i < n; i++) {
      v[i * n + j] *= -1.0;
    }
  }
  return 1;
}
function matrix3x3ToQuaternion(mat_3x3, quat_4) {
  const tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

  // on-diagonal elements
  tmp[0] = mat_3x3[0] + mat_3x3[4] + mat_3x3[8];
  tmp[5] = mat_3x3[0] - mat_3x3[4] - mat_3x3[8];
  tmp[10] = -mat_3x3[0] + mat_3x3[4] - mat_3x3[8];
  tmp[15] = -mat_3x3[0] - mat_3x3[4] + mat_3x3[8];

  // off-diagonal elements
  tmp[1] = tmp[4] = mat_3x3[7] - mat_3x3[5];
  tmp[2] = tmp[8] = mat_3x3[2] - mat_3x3[6];
  tmp[3] = tmp[12] = mat_3x3[3] - mat_3x3[1];
  tmp[6] = tmp[9] = mat_3x3[3] + mat_3x3[1];
  tmp[7] = tmp[13] = mat_3x3[2] + mat_3x3[6];
  tmp[11] = tmp[14] = mat_3x3[7] + mat_3x3[5];
  const eigenvectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  const eigenvalues = [0, 0, 0, 0];

  // convert into format that JacobiN can use,
  // then use Jacobi to find eigenvalues and eigenvectors
  // tmp is copied because jacobiN may modify it
  const NTemp = [...tmp];
  jacobiN(NTemp, 4, eigenvalues, eigenvectors);

  // the first eigenvector is the one we want
  quat_4[0] = eigenvectors[0];
  quat_4[1] = eigenvectors[4];
  quat_4[2] = eigenvectors[8];
  quat_4[3] = eigenvectors[12];
}
function multiplyQuaternion(quat_1, quat_2, quat_out) {
  const ww = quat_1[0] * quat_2[0];
  const wx = quat_1[0] * quat_2[1];
  const wy = quat_1[0] * quat_2[2];
  const wz = quat_1[0] * quat_2[3];
  const xw = quat_1[1] * quat_2[0];
  const xx = quat_1[1] * quat_2[1];
  const xy = quat_1[1] * quat_2[2];
  const xz = quat_1[1] * quat_2[3];
  const yw = quat_1[2] * quat_2[0];
  const yx = quat_1[2] * quat_2[1];
  const yy = quat_1[2] * quat_2[2];
  const yz = quat_1[2] * quat_2[3];
  const zw = quat_1[3] * quat_2[0];
  const zx = quat_1[3] * quat_2[1];
  const zy = quat_1[3] * quat_2[2];
  const zz = quat_1[3] * quat_2[3];
  quat_out[0] = ww - xx - yy - zz;
  quat_out[1] = wx + xw + yz - zy;
  quat_out[2] = wy - xz + yw + zx;
  quat_out[3] = wz + xy - yx + zw;
}
function orthogonalize3x3(a_3x3, out_3x3) {
  // copy the matrix
  for (let i = 0; i < 9; i++) {
    out_3x3[i] = a_3x3[i];
  }

  // Pivot the matrix to improve accuracy
  const scale = createArray(3);
  const index = createArray(3);
  let largest;

  // Loop over rows to get implicit scaling information
  for (let i = 0; i < 3; i++) {
    const x1 = Math.abs(out_3x3[i * 3]);
    const x2 = Math.abs(out_3x3[i * 3 + 1]);
    const x3 = Math.abs(out_3x3[i * 3 + 2]);
    largest = x2 > x1 ? x2 : x1;
    largest = x3 > largest ? x3 : largest;
    scale[i] = 1;
    if (largest !== 0) {
      scale[i] /= largest;
    }
  }

  // first column
  const x1 = Math.abs(out_3x3[0]) * scale[0];
  const x2 = Math.abs(out_3x3[3]) * scale[1];
  const x3 = Math.abs(out_3x3[6]) * scale[2];
  index[0] = 0;
  largest = x1;
  if (x2 >= largest) {
    largest = x2;
    index[0] = 1;
  }
  if (x3 >= largest) {
    index[0] = 2;
  }
  if (index[0] !== 0) {
    // swap vectors
    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
    scale[index[0]] = scale[0];
  }

  // second column
  const y2 = Math.abs(out_3x3[4]) * scale[1];
  const y3 = Math.abs(out_3x3[7]) * scale[2];
  index[1] = 1;
  largest = y2;
  if (y3 >= largest) {
    index[1] = 2;
    // swap vectors
    swapColumnsMatrix_nxn(out_3x3, 3, 1, 2);
  }

  // third column
  index[2] = 2;

  // A quaternion can only describe a pure rotation, not
  // a rotation with a flip, therefore the flip must be
  // removed before the matrix is converted to a quaternion.
  let flip = 0;
  if (determinant3x3(out_3x3) < 0) {
    flip = 1;
    for (let i = 0; i < 9; i++) {
      out_3x3[i] = -out_3x3[i];
    }
  }

  // Do orthogonalization using a quaternion intermediate
  // (this, essentially, does the orthogonalization via
  // diagonalization of an appropriately constructed symmetric
  // 4x4 matrix rather than by doing SVD of the 3x3 matrix)
  const quat = createArray(4);
  matrix3x3ToQuaternion(out_3x3, quat);
  quaternionToMatrix3x3(quat, out_3x3);

  // Put the flip back into the orthogonalized matrix.
  if (flip) {
    for (let i = 0; i < 9; i++) {
      out_3x3[i] = -out_3x3[i];
    }
  }

  // Undo the pivoting
  if (index[1] !== 1) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[1], 1);
  }
  if (index[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
  }
}
function diagonalize3x3(a_3x3, w_3, v_3x3) {
  let i;
  let j;
  let k;
  let maxI;
  let tmp;
  let maxVal;

  // a is copied because jacobiN may modify it
  const copyA = [...a_3x3];

  // diagonalize using Jacobi
  jacobiN(copyA, 3, w_3, v_3x3);

  // if all the eigenvalues are the same, return identity matrix
  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
    identity3x3(v_3x3);
    return;
  }

  // transpose temporarily, it makes it easier to sort the eigenvectors
  transpose3x3(v_3x3, v_3x3);

  // if two eigenvalues are the same, re-orthogonalize to optimally line
  // up the eigenvectors with the x, y, and z axes
  for (i = 0; i < 3; i++) {
    // two eigenvalues are the same
    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {
      // find maximum element of the independent eigenvector
      maxVal = Math.abs(v_3x3[i * 3]);
      maxI = 0;
      for (j = 1; j < 3; j++) {
        if (maxVal < (tmp = Math.abs(v_3x3[i * 3 + j]))) {
          maxVal = tmp;
          maxI = j;
        }
      }
      // swap the eigenvector into its proper position
      if (maxI !== i) {
        tmp = w_3[maxI];
        w_3[maxI] = w_3[i];
        w_3[i] = tmp;
        swapRowsMatrix_nxn(v_3x3, 3, i, maxI);
      }
      // maximum element of eigenvector should be positive
      if (v_3x3[maxI * 3 + maxI] < 0) {
        v_3x3[maxI * 3] = -v_3x3[maxI * 3];
        v_3x3[maxI * 3 + 1] = -v_3x3[maxI * 3 + 1];
        v_3x3[maxI * 3 + 2] = -v_3x3[maxI * 3 + 2];
      }

      // re-orthogonalize the other two eigenvectors
      j = (maxI + 1) % 3;
      k = (maxI + 2) % 3;
      v_3x3[j * 3] = 0.0;
      v_3x3[j * 3 + 1] = 0.0;
      v_3x3[j * 3 + 2] = 0.0;
      v_3x3[j * 3 + j] = 1.0;
      const vectTmp1 = cross([v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], [v_3x3[j * 3], v_3x3[j * 3 + 1], v_3x3[j * 3 + 2]], []);
      normalize(vectTmp1);
      const vectTmp2 = cross(vectTmp1, [v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], []);
      for (let t = 0; t < 3; t++) {
        v_3x3[k * 3 + t] = vectTmp1[t];
        v_3x3[j * 3 + t] = vectTmp2[t];
      }

      // transpose vectors back to columns
      transpose3x3(v_3x3, v_3x3);
      return;
    }
  }

  // the three eigenvalues are different, just sort the eigenvectors
  // to align them with the x, y, and z axes

  // find the vector with the largest x element, make that vector
  // the first vector
  maxVal = Math.abs(v_3x3[0]);
  maxI = 0;
  for (i = 1; i < 3; i++) {
    if (maxVal < (tmp = Math.abs(v_3x3[i * 3]))) {
      maxVal = tmp;
      maxI = i;
    }
  }
  // swap eigenvalue and eigenvector
  if (maxI !== 0) {
    const eigenValTmp = w_3[maxI];
    w_3[maxI] = w_3[0];
    w_3[0] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, maxI, 0);
  }
  // do the same for the y element
  if (Math.abs(v_3x3[4]) < Math.abs(v_3x3[7])) {
    const eigenValTmp = w_3[2];
    w_3[2] = w_3[1];
    w_3[1] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, 1, 2);
  }

  // ensure that the sign of the eigenvectors is correct
  for (i = 0; i < 2; i++) {
    if (v_3x3[i * 3 + i] < 0) {
      v_3x3[i * 3] = -v_3x3[i * 3];
      v_3x3[i * 3 + 1] = -v_3x3[i * 3 + 1];
      v_3x3[i * 3 + 2] = -v_3x3[i * 3 + 2];
    }
  }
  // set sign of final eigenvector to ensure that determinant is positive
  if (determinant3x3(v_3x3) < 0) {
    v_3x3[6] = -v_3x3[6];
    v_3x3[7] = -v_3x3[7];
    v_3x3[8] = -v_3x3[8];
  }

  // transpose the eigenvectors back again
  transpose3x3(v_3x3, v_3x3);
}
function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
  let i;
  // copy so that A can be used for U or VT without risk
  const B = [...a_3x3];

  // temporarily flip if determinant is negative
  const d = determinant3x3(B);
  if (d < 0) {
    for (i = 0; i < 9; i++) {
      B[i] = -B[i];
    }
  }

  // orthogonalize, diagonalize, etc.
  orthogonalize3x3(B, u_3x3);
  transpose3x3(B, B);
  multiply3x3_mat3(B, u_3x3, vT_3x3);
  diagonalize3x3(vT_3x3, w_3, vT_3x3);
  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
  transpose3x3(vT_3x3, vT_3x3);

  // re-create the flip
  if (d < 0) {
    w_3[0] = -w_3[0];
    w_3[1] = -w_3[1];
    w_3[2] = -w_3[2];
  }
}

/**
 * Factor linear equations Ax = b using LU decomposition A = LU. Output factorization LU is in matrix A.
 * @param {Matrix} A square matrix
 * @param {Number} index integer array of pivot indices index[0->n-1]
 * @param {Number} size matrix size
 */
function luFactorLinearSystem(A, index, size) {
  let i;
  let j;
  let k;
  let largest;
  let maxI = 0;
  let sum;
  let temp1;
  let temp2;
  const scale = createArray(size);

  //
  // Loop over rows to get implicit scaling information
  //
  for (i = 0; i < size; i++) {
    for (largest = 0.0, j = 0; j < size; j++) {
      if ((temp2 = Math.abs(A[i * size + j])) > largest) {
        largest = temp2;
      }
    }
    if (largest === 0.0) {
      vtkWarningMacro('Unable to factor linear system');
      return 0;
    }
    scale[i] = 1.0 / largest;
  }
  //
  // Loop over all columns using Crout's method
  //
  for (j = 0; j < size; j++) {
    for (i = 0; i < j; i++) {
      sum = A[i * size + j];
      for (k = 0; k < i; k++) {
        sum -= A[i * size + k] * A[k * size + j];
      }
      A[i * size + j] = sum;
    }
    //
    // Begin search for largest pivot element
    //
    for (largest = 0.0, i = j; i < size; i++) {
      sum = A[i * size + j];
      for (k = 0; k < j; k++) {
        sum -= A[i * size + k] * A[k * size + j];
      }
      A[i * size + j] = sum;
      if ((temp1 = scale[i] * Math.abs(sum)) >= largest) {
        largest = temp1;
        maxI = i;
      }
    }
    //
    // Check for row interchange
    //
    if (j !== maxI) {
      for (k = 0; k < size; k++) {
        temp1 = A[maxI * size + k];
        A[maxI * size + k] = A[j * size + k];
        A[j * size + k] = temp1;
      }
      scale[maxI] = scale[j];
    }
    //
    // Divide by pivot element and perform elimination
    //
    index[j] = maxI;
    if (Math.abs(A[j * size + j]) <= _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VTK_SMALL_NUMBER */ .kP) {
      vtkWarningMacro('Unable to factor linear system');
      return 0;
    }
    if (j !== size - 1) {
      temp1 = 1.0 / A[j * size + j];
      for (i = j + 1; i < size; i++) {
        A[i * size + j] *= temp1;
      }
    }
  }
  return 1;
}
function luSolveLinearSystem(A, index, x, size) {
  let i;
  let j;
  let ii;
  let idx;
  let sum;
  //
  // Proceed with forward and backsubstitution for L and U
  // matrices.  First, forward substitution.
  //
  for (ii = -1, i = 0; i < size; i++) {
    idx = index[i];
    sum = x[idx];
    x[idx] = x[i];
    if (ii >= 0) {
      for (j = ii; j <= i - 1; j++) {
        sum -= A[i * size + j] * x[j];
      }
    } else if (sum !== 0.0) {
      ii = i;
    }
    x[i] = sum;
  }
  //
  // Now, back substitution
  //
  for (i = size - 1; i >= 0; i--) {
    sum = x[i];
    for (j = i + 1; j < size; j++) {
      sum -= A[i * size + j] * x[j];
    }
    x[i] = sum / A[i * size + i];
  }
}
function solveLinearSystem(A, x, size) {
  // if we solving something simple, just solve it
  if (size === 2) {
    const y = createArray(2);
    const det = determinant2x2(A[0], A[1], A[2], A[3]);
    if (det === 0.0) {
      // Unable to solve linear system
      return 0;
    }
    y[0] = (A[3] * x[0] - A[1] * x[1]) / det;
    y[1] = (-(A[2] * x[0]) + A[0] * x[1]) / det;
    x[0] = y[0];
    x[1] = y[1];
    return 1;
  }
  if (size === 1) {
    if (A[0] === 0.0) {
      // Unable to solve linear system
      return 0;
    }
    x[0] /= A[0];
    return 1;
  }

  //
  // System of equations is not trivial, use Crout's method
  //

  // Check on allocation of working vectors
  const index = createArray(size);

  // Factor and solve matrix
  if (luFactorLinearSystem(A, index, size) === 0) {
    return 0;
  }
  luSolveLinearSystem(A, index, x, size);
  return 1;
}

// Note that A is modified during the inversion !
function invertMatrix(A, AI, size) {
  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  let column = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  const tmp1Size = index || createArray(size);
  const tmp2Size = column || createArray(size);

  // Factor matrix; then begin solving for inverse one column at a time.
  // Note: tmp1Size returned value is used later, tmp2Size is just working
  // memory whose values are not used in LUSolveLinearSystem
  if (luFactorLinearSystem(A, tmp1Size, size) === 0) {
    return null;
  }
  for (let j = 0; j < size; j++) {
    for (let i = 0; i < size; i++) {
      tmp2Size[i] = 0.0;
    }
    tmp2Size[j] = 1.0;
    luSolveLinearSystem(A, tmp1Size, tmp2Size, size);
    for (let i = 0; i < size; i++) {
      AI[i * size + j] = tmp2Size[i];
    }
  }
  return AI;
}
function estimateMatrixCondition(A, size) {
  let minValue = +Number.MAX_VALUE;
  let maxValue = -Number.MAX_VALUE;

  // find the maximum value
  for (let i = 0; i < size; i++) {
    for (let j = i; j < size; j++) {
      if (Math.abs(A[i * size + j]) > maxValue) {
        maxValue = Math.abs(A[i * size + j]);
      }
    }
  }

  // find the minimum diagonal value
  for (let i = 0; i < size; i++) {
    if (Math.abs(A[i * size + i]) < minValue) {
      minValue = Math.abs(A[i * size + i]);
    }
  }
  if (minValue === 0.0) {
    return Number.MAX_VALUE;
  }
  return maxValue / minValue;
}
function jacobi(a_3x3, w, v) {
  return jacobiN(a_3x3, 3, w, v);
}
function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
  // check dimensional consistency
  if (numberOfSamples < xOrder) {
    vtkWarningMacro('Insufficient number of samples. Underdetermined.');
    return 0;
  }
  let i;
  let j;
  let k;

  // set up intermediate variables
  // Allocate matrix to hold X times transpose of X
  const XXt = createArray(xOrder * xOrder); // size x by x
  // Allocate the array of eigenvalues and eigenvectors
  const eigenvals = createArray(xOrder);
  const eigenvecs = createArray(xOrder * xOrder);

  // Calculate XXt upper half only, due to symmetry
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      for (j = i; j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }
    }
  }

  // now fill in the lower half of the XXt matrix
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }

  // Compute the eigenvectors and eigenvalues
  jacobiN(XXt, xOrder, eigenvals, eigenvecs);

  // Smallest eigenval is at the end of the list (xOrder-1), and solution is
  // corresponding eigenvec.
  for (i = 0; i < xOrder; i++) {
    mt[i] = eigenvecs[i * xOrder + xOrder - 1];
  }
  return 1;
}
function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {
  let checkHomogeneous = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
  // check dimensional consistency
  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
    vtkWarningMacro('Insufficient number of samples. Underdetermined.');
    return 0;
  }
  const homogenFlags = createArray(yOrder);
  let allHomogeneous = 1;
  let hmt;
  let homogRC = 0;
  let i;
  let j;
  let k;
  let someHomogeneous = 0;

  // Ok, first init some flags check and see if all the systems are homogeneous
  if (checkHomogeneous) {
    // If Y' is zero, it's a homogeneous system and can't be solved via
    // the pseudoinverse method. Detect this case, warn the user, and
    // invoke SolveHomogeneousLeastSquares instead. Note that it doesn't
    // really make much sense for yOrder to be greater than one in this case,
    // since that's just yOrder occurrences of a 0 vector on the RHS, but
    // we allow it anyway. N

    // Initialize homogeneous flags on a per-right-hand-side basis
    for (j = 0; j < yOrder; j++) {
      homogenFlags[j] = 1;
    }
    for (i = 0; i < numberOfSamples; i++) {
      for (j = 0; j < yOrder; j++) {
        if (Math.abs(yt[i * yOrder + j]) > _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VTK_SMALL_NUMBER */ .kP) {
          allHomogeneous = 0;
          homogenFlags[j] = 0;
        }
      }
    }

    // If we've got one system, and it's homogeneous, do it and bail out quickly.
    if (allHomogeneous && yOrder === 1) {
      vtkWarningMacro('Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()');
      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
    }

    // Ok, we've got more than one system of equations.
    // Figure out if we need to calculate the homogeneous equation solution for
    // any of them.
    if (allHomogeneous) {
      someHomogeneous = 1;
    } else {
      for (j = 0; j < yOrder; j++) {
        if (homogenFlags[j]) {
          someHomogeneous = 1;
        }
      }
    }
  }

  // If necessary, solve the homogeneous problem
  if (someHomogeneous) {
    // hmt is the homogeneous equation version of mt, the general solution.
    // hmt should be xOrder x yOrder, but since we are solving only the homogeneous part, here it is xOrder x 1
    hmt = createArray(xOrder);

    // Ok, solve the homogeneous problem
    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
  }

  // set up intermediate variables
  const XXt = createArray(xOrder * xOrder); // size x by x
  const XXtI = createArray(xOrder * xOrder); // size x by x
  const XYt = createArray(xOrder * yOrder); // size x by y

  // first find the pseudoinverse matrix
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      // first calculate the XXt matrix, only do the upper half (symmetrical)
      for (j = i; j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }

      // now calculate the XYt matrix
      for (j = 0; j < yOrder; j++) {
        XYt[i * yOrder + j] += xt[k * xOrder + i] * yt[k * yOrder + j];
      }
    }
  }

  // now fill in the lower half of the XXt matrix
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }
  const successFlag = invertMatrix(XXt, XXtI, xOrder);

  // next get the inverse of XXt
  if (successFlag) {
    for (i = 0; i < xOrder; i++) {
      for (j = 0; j < yOrder; j++) {
        mt[i * yOrder + j] = 0.0;
        for (k = 0; k < xOrder; k++) {
          mt[i * yOrder + j] += XXtI[i * xOrder + k] * XYt[k * yOrder + j];
        }
      }
    }
  }

  // Fix up any of the solutions that correspond to the homogeneous equation
  // problem.
  if (someHomogeneous) {
    for (j = 0; j < yOrder; j++) {
      if (homogenFlags[j]) {
        // Fix this one
        for (i = 0; i < xOrder; i++) {
          mt[i * yOrder + j] = hmt[i * yOrder];
        }
      }
    }
  }
  if (someHomogeneous) {
    return homogRC && successFlag;
  }
  return successFlag;
}
function hex2float(hexStr) {
  let outFloatArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0.5, 1];
  switch (hexStr.length) {
    case 3:
      // abc => #aabbcc
      outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;
      return outFloatArray;
    case 4:
      // #abc => #aabbcc
      outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;
      return outFloatArray;
    case 6:
      // ab01df => #ab01df
      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
      return outFloatArray;
    case 7:
      // #ab01df
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      return outFloatArray;
    case 9:
      // #ab01df00
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
      return outFloatArray;
    default:
      return outFloatArray;
  }
}
function rgb2hsv(rgb, hsv) {
  let h;
  let s;
  const [r, g, b] = rgb;
  const onethird = 1.0 / 3.0;
  const onesixth = 1.0 / 6.0;
  const twothird = 2.0 / 3.0;
  let cmax = r;
  let cmin = r;
  if (g > cmax) {
    cmax = g;
  } else if (g < cmin) {
    cmin = g;
  }
  if (b > cmax) {
    cmax = b;
  } else if (b < cmin) {
    cmin = b;
  }
  const v = cmax;
  if (v > 0.0) {
    s = (cmax - cmin) / cmax;
  } else {
    s = 0.0;
  }
  if (s > 0) {
    if (r === cmax) {
      h = onesixth * (g - b) / (cmax - cmin);
    } else if (g === cmax) {
      h = onethird + onesixth * (b - r) / (cmax - cmin);
    } else {
      h = twothird + onesixth * (r - g) / (cmax - cmin);
    }
    if (h < 0.0) {
      h += 1.0;
    }
  } else {
    h = 0.0;
  }

  // Set the values back to the array
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
}
function hsv2rgb(hsv, rgb) {
  const [h, s, v] = hsv;
  const onethird = 1.0 / 3.0;
  const onesixth = 1.0 / 6.0;
  const twothird = 2.0 / 3.0;
  const fivesixth = 5.0 / 6.0;
  let r;
  let g;
  let b;

  // compute RGB from HSV
  if (h > onesixth && h <= onethird) {
    // green/red
    g = 1.0;
    r = (onethird - h) / onesixth;
    b = 0.0;
  } else if (h > onethird && h <= 0.5) {
    // green/blue
    g = 1.0;
    b = (h - onethird) / onesixth;
    r = 0.0;
  } else if (h > 0.5 && h <= twothird) {
    // blue/green
    b = 1.0;
    g = (twothird - h) / onesixth;
    r = 0.0;
  } else if (h > twothird && h <= fivesixth) {
    // blue/red
    b = 1.0;
    r = (h - twothird) / onesixth;
    g = 0.0;
  } else if (h > fivesixth && h <= 1.0) {
    // red/blue
    r = 1.0;
    b = (1.0 - h) / onesixth;
    g = 0.0;
  } else {
    // red/green
    r = 1.0;
    g = h / onesixth;
    b = 0.0;
  }

  // add Saturation to the equation.
  r = s * r + (1.0 - s);
  g = s * g + (1.0 - s);
  b = s * b + (1.0 - s);
  r *= v;
  g *= v;
  b *= v;

  // Assign back to the array
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function lab2xyz(lab, xyz) {
  // LAB to XYZ
  const [L, a, b] = lab;
  let var_Y = (L + 16) / 116;
  let var_X = a / 500 + var_Y;
  let var_Z = var_Y - b / 200;
  if (var_Y ** 3 > 0.008856) {
    var_Y **= 3;
  } else {
    var_Y = (var_Y - 16.0 / 116.0) / 7.787;
  }
  if (var_X ** 3 > 0.008856) {
    var_X **= 3;
  } else {
    var_X = (var_X - 16.0 / 116.0) / 7.787;
  }
  if (var_Z ** 3 > 0.008856) {
    var_Z **= 3;
  } else {
    var_Z = (var_Z - 16.0 / 116.0) / 7.787;
  }
  const ref_X = 0.9505;
  const ref_Y = 1.0;
  const ref_Z = 1.089;
  xyz[0] = ref_X * var_X; // ref_X = 0.9505  Observer= 2 deg Illuminant= D65
  xyz[1] = ref_Y * var_Y; // ref_Y = 1.000
  xyz[2] = ref_Z * var_Z; // ref_Z = 1.089
}

function xyz2lab(xyz, lab) {
  const [x, y, z] = xyz;
  const ref_X = 0.9505;
  const ref_Y = 1.0;
  const ref_Z = 1.089;
  let var_X = x / ref_X; // ref_X = 0.9505  Observer= 2 deg, Illuminant= D65
  let var_Y = y / ref_Y; // ref_Y = 1.000
  let var_Z = z / ref_Z; // ref_Z = 1.089

  if (var_X > 0.008856) var_X **= 1.0 / 3.0;else var_X = 7.787 * var_X + 16.0 / 116.0;
  if (var_Y > 0.008856) var_Y **= 1.0 / 3.0;else var_Y = 7.787 * var_Y + 16.0 / 116.0;
  if (var_Z > 0.008856) var_Z **= 1.0 / 3.0;else var_Z = 7.787 * var_Z + 16.0 / 116.0;
  lab[0] = 116 * var_Y - 16;
  lab[1] = 500 * (var_X - var_Y);
  lab[2] = 200 * (var_Y - var_Z);
}
function xyz2rgb(xyz, rgb) {
  const [x, y, z] = xyz;
  let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  let b = x * 0.0557 + y * -0.204 + z * 1.057;

  // The following performs a "gamma correction" specified by the sRGB color
  // space.  sRGB is defined by a canonical definition of a display monitor and
  // has been standardized by the International Electrotechnical Commission (IEC
  // 61966-2-1).  The nonlinearity of the correction is designed to make the
  // colors more perceptually uniform.  This color space has been adopted by
  // several applications including Adobe Photoshop and Microsoft Windows color
  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable
  // to assume it is close to this one.
  if (r > 0.0031308) r = 1.055 * r ** (1 / 2.4) - 0.055;else r *= 12.92;
  if (g > 0.0031308) g = 1.055 * g ** (1 / 2.4) - 0.055;else g *= 12.92;
  if (b > 0.0031308) b = 1.055 * b ** (1 / 2.4) - 0.055;else b *= 12.92;

  // Clip colors. ideally we would do something that is perceptually closest
  // (since we can see colors outside of the display gamut), but this seems to
  // work well enough.
  let maxVal = r;
  if (maxVal < g) maxVal = g;
  if (maxVal < b) maxVal = b;
  if (maxVal > 1.0) {
    r /= maxVal;
    g /= maxVal;
    b /= maxVal;
  }
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;

  // Push values back to array
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function rgb2xyz(rgb, xyz) {
  let [r, g, b] = rgb;
  // The following performs a "gamma correction" specified by the sRGB color
  // space.  sRGB is defined by a canonical definition of a display monitor and
  // has been standardized by the International Electrotechnical Commission (IEC
  // 61966-2-1).  The nonlinearity of the correction is designed to make the
  // colors more perceptually uniform.  This color space has been adopted by
  // several applications including Adobe Photoshop and Microsoft Windows color
  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable
  // to assume it is close to this one.
  if (r > 0.04045) r = ((r + 0.055) / 1.055) ** 2.4;else r /= 12.92;
  if (g > 0.04045) g = ((g + 0.055) / 1.055) ** 2.4;else g /= 12.92;
  if (b > 0.04045) b = ((b + 0.055) / 1.055) ** 2.4;else b /= 12.92;

  // Observer. = 2 deg, Illuminant = D65
  xyz[0] = r * 0.4124 + g * 0.3576 + b * 0.1805;
  xyz[1] = r * 0.2126 + g * 0.7152 + b * 0.0722;
  xyz[2] = r * 0.0193 + g * 0.1192 + b * 0.9505;
}
function rgb2lab(rgb, lab) {
  const xyz = [0, 0, 0];
  rgb2xyz(rgb, xyz);
  xyz2lab(xyz, lab);
}
function lab2rgb(lab, rgb) {
  const xyz = [0, 0, 0];
  lab2xyz(lab, xyz);
  xyz2rgb(xyz, rgb);
}
function uninitializeBounds(bounds) {
  bounds[0] = 1.0;
  bounds[1] = -1.0;
  bounds[2] = 1.0;
  bounds[3] = -1.0;
  bounds[4] = 1.0;
  bounds[5] = -1.0;
  return bounds;
}
function areBoundsInitialized(bounds) {
  return !(bounds[1] - bounds[0] < 0.0);
}

/**
 * @deprecated please use vtkBoundingBox.addPoints(vtkBoundingBox.reset([]), points)
 */
function computeBoundsFromPoints(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
  return bounds;
}
function clampValue(value, minValue, maxValue) {
  if (value < minValue) {
    return minValue;
  }
  if (value > maxValue) {
    return maxValue;
  }
  return value;
}
function clampVector(vector, minVector, maxVector) {
  let out = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0, 0];
  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
  return out;
}
function clampAndNormalizeValue(value, range) {
  let result = 0;
  if (range[0] !== range[1]) {
    // clamp
    if (value < range[0]) {
      result = range[0];
    } else if (value > range[1]) {
      result = range[1];
    } else {
      result = value;
    }
    // normalize
    result = (result - range[0]) / (range[1] - range[0]);
  }
  return result;
}
const getScalarTypeFittingRange = notImplemented('GetScalarTypeFittingRange');
const getAdjustedScalarRange = notImplemented('GetAdjustedScalarRange');
function extentIsWithinOtherExtent(extent1, extent2) {
  if (!extent1 || !extent2) {
    return 0;
  }
  for (let i = 0; i < 6; i += 2) {
    if (extent1[i] < extent2[i] || extent1[i] > extent2[i + 1] || extent1[i + 1] < extent2[i] || extent1[i + 1] > extent2[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
  if (!bounds1_6 || !bounds2_6) {
    return 0;
  }
  for (let i = 0; i < 6; i += 2) {
    if (bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] || bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function pointIsWithinBounds(point_3, bounds_6, delta_3) {
  if (!point_3 || !bounds_6 || !delta_3) {
    return 0;
  }
  for (let i = 0; i < 3; i++) {
    if (point_3[i] + delta_3[i] < bounds_6[2 * i] || point_3[i] - delta_3[i] > bounds_6[2 * i + 1]) {
      return 0;
    }
  }
  return 1;
}
function solve3PointCircle(p1, p2, p3, center) {
  const v21 = createArray(3);
  const v32 = createArray(3);
  const v13 = createArray(3);
  const v12 = createArray(3);
  const v23 = createArray(3);
  const v31 = createArray(3);
  for (let i = 0; i < 3; ++i) {
    v21[i] = p1[i] - p2[i];
    v32[i] = p2[i] - p3[i];
    v13[i] = p3[i] - p1[i];
    v12[i] = -v21[i];
    v23[i] = -v32[i];
    v31[i] = -v13[i];
  }
  const norm12 = norm(v12);
  const norm23 = norm(v23);
  const norm13 = norm(v13);
  const crossv21v32 = createArray(3);
  cross(v21, v32, crossv21v32);
  const normCross = norm(crossv21v32);
  const radius = norm12 * norm23 * norm13 / (2 * normCross);
  const normCross22 = 2 * normCross * normCross;
  const alpha = norm23 * norm23 * dot(v21, v31) / normCross22;
  const beta = norm13 * norm13 * dot(v12, v32) / normCross22;
  const gamma = norm12 * norm12 * dot(v13, v23) / normCross22;
  for (let i = 0; i < 3; ++i) {
    center[i] = alpha * p1[i] + beta * p2[i] + gamma * p3[i];
  }
  return radius;
}
const inf = Infinity;
const negInf = -Infinity;
const isInf = value => !Number.isFinite(value);
const {
  isFinite,
  isNaN
} = Number;
const isNan = isNaN;

// JavaScript - add-on ----------------------

function createUninitializedBounds() {
  return [].concat([Number.MAX_VALUE, -Number.MAX_VALUE,
  // X
  Number.MAX_VALUE, -Number.MAX_VALUE,
  // Y
  Number.MAX_VALUE, -Number.MAX_VALUE // Z
  ]);
}

function getMajorAxisIndex(vector) {
  let maxValue = -1;
  let axisIndex = -1;
  for (let i = 0; i < vector.length; i++) {
    const value = Math.abs(vector[i]);
    if (value > maxValue) {
      axisIndex = i;
      maxValue = value;
    }
  }
  return axisIndex;
}

// Return the closest orthogonal matrix of 1, -1 and 0
// It works for both column major and row major matrices
// This function iteratively associate a column with a row by choosing
// the greatest absolute value from the remaining row and columns
// For each association, a -1 or a 1 is set in the output, depending on
// the sign of the value in the original matrix
function getSparseOrthogonalMatrix(matrix) {
  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  // Initialize rows and columns to available indices
  const rows = new Array(n);
  const cols = new Array(n);
  for (let i = 0; i < n; ++i) {
    rows[i] = i;
    cols[i] = i;
  }
  // No need for the last iteration: i = 0
  for (let i = n - 1; i > 0; i--) {
    // Loop invariant:
    // rows[0:i] and cols[0:i] contain the remaining rows and columns
    // rows]i:n[ and cols]i:n[ contain the associations found (rows[k] is associated with cols[k])
    let bestValue = -Infinity;
    let bestRowI = 0;
    let bestColI = 0;
    for (let rowI = 0; rowI <= i; ++rowI) {
      const row = rows[rowI];
      for (let colI = 0; colI <= i; ++colI) {
        const col = cols[colI];
        const absVal = Math.abs(matrix[row + n * col]);
        if (absVal > bestValue) {
          bestValue = absVal;
          bestRowI = rowI;
          bestColI = colI;
        }
      }
    }
    // Found an association between rows[bestRowI] and cols[bestColI]
    // Put both at the end of their array by swapping with i
    [rows[i], rows[bestRowI]] = [rows[bestRowI], rows[i]];
    [cols[i], cols[bestColI]] = [cols[bestColI], cols[i]];
  }

  // Convert row/column association to a matrix
  const output = new Array(n * n).fill(0);
  for (let i = 0; i < n; ++i) {
    const matIdx = rows[i] + n * cols[i];
    output[matIdx] = matrix[matIdx] < 0 ? -1 : 1;
  }
  return output;
}
function floatToHex2(value) {
  const integer = Math.floor(value * 255);
  if (integer > 15) {
    return integer.toString(16);
  }
  return `0${integer.toString(16)}`;
}
function floatRGB2HexCode(rgbArray) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';
  return `${prefix}${rgbArray.map(floatToHex2).join('')}`;
}
function floatToChar(f) {
  return Math.round(f * 255);
}
function float2CssRGBA(rgbArray) {
  if (rgbArray.length === 3) {
    return `rgb(${rgbArray.map(floatToChar).join(', ')})`;
  }
  return `rgba(${floatToChar(rgbArray[0] || 0)}, ${floatToChar(rgbArray[1] || 0)}, ${floatToChar(rgbArray[2] || 0)}, ${rgbArray[3] || 0})`;
}

// ----------------------------------------------------------------------------
// Only Static API
// ----------------------------------------------------------------------------

var vtkMath = {
  Pi,
  radiansFromDegrees,
  degreesFromRadians,
  round,
  floor,
  ceil,
  ceilLog2,
  min,
  max,
  arrayMin,
  arrayMax,
  arrayRange,
  isPowerOfTwo,
  nearestPowerOfTwo,
  factorial,
  binomial,
  beginCombination,
  nextCombination,
  randomSeed,
  getSeed,
  random,
  gaussian,
  add,
  subtract,
  multiplyScalar,
  multiplyScalar2D,
  multiplyAccumulate,
  multiplyAccumulate2D,
  dot,
  outer,
  cross,
  norm,
  normalize,
  perpendiculars,
  projectVector,
  projectVector2D,
  distance2BetweenPoints,
  angleBetweenVectors,
  gaussianAmplitude,
  gaussianWeight,
  dot2D,
  outer2D,
  norm2D,
  normalize2D,
  determinant2x2,
  LUFactor3x3,
  LUSolve3x3,
  linearSolve3x3,
  multiply3x3_vect3,
  multiply3x3_mat3,
  multiplyMatrix,
  transpose3x3,
  invert3x3,
  identity3x3,
  identity,
  isIdentity,
  isIdentity3x3,
  determinant3x3,
  quaternionToMatrix3x3,
  areEquals,
  areMatricesEqual,
  roundNumber,
  roundVector,
  matrix3x3ToQuaternion,
  multiplyQuaternion,
  orthogonalize3x3,
  diagonalize3x3,
  singularValueDecomposition3x3,
  solveLinearSystem,
  invertMatrix,
  luFactorLinearSystem,
  luSolveLinearSystem,
  estimateMatrixCondition,
  jacobi,
  jacobiN,
  solveHomogeneousLeastSquares,
  solveLeastSquares,
  hex2float,
  rgb2hsv,
  hsv2rgb,
  lab2xyz,
  xyz2lab,
  xyz2rgb,
  rgb2xyz,
  rgb2lab,
  lab2rgb,
  uninitializeBounds,
  areBoundsInitialized,
  computeBoundsFromPoints,
  clampValue,
  clampVector,
  clampAndNormalizeValue,
  getScalarTypeFittingRange,
  getAdjustedScalarRange,
  extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds,
  pointIsWithinBounds,
  solve3PointCircle,
  inf,
  negInf,
  isInf,
  isNan: isNaN,
  isNaN,
  isFinite,
  // JS add-on
  createUninitializedBounds,
  getMajorAxisIndex,
  getSparseOrthogonalMatrix,
  floatToHex2,
  floatRGB2HexCode,
  float2CssRGBA
};

var vtkMath$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createArray: createArray,
  Pi: Pi,
  radiansFromDegrees: radiansFromDegrees,
  degreesFromRadians: degreesFromRadians,
  round: round,
  floor: floor,
  ceil: ceil,
  min: min,
  max: max,
  arrayMin: arrayMin,
  arrayMax: arrayMax,
  arrayRange: arrayRange,
  ceilLog2: ceilLog2,
  factorial: factorial,
  nearestPowerOfTwo: nearestPowerOfTwo,
  isPowerOfTwo: isPowerOfTwo,
  binomial: binomial,
  beginCombination: beginCombination,
  nextCombination: nextCombination,
  randomSeed: randomSeed,
  getSeed: getSeed,
  random: random,
  gaussian: gaussian,
  add: add,
  subtract: subtract,
  multiplyScalar: multiplyScalar,
  multiplyScalar2D: multiplyScalar2D,
  multiplyAccumulate: multiplyAccumulate,
  multiplyAccumulate2D: multiplyAccumulate2D,
  dot: dot,
  outer: outer,
  cross: cross,
  norm: norm,
  normalize: normalize,
  perpendiculars: perpendiculars,
  projectVector: projectVector,
  dot2D: dot2D,
  projectVector2D: projectVector2D,
  distance2BetweenPoints: distance2BetweenPoints,
  angleBetweenVectors: angleBetweenVectors,
  signedAngleBetweenVectors: signedAngleBetweenVectors,
  gaussianAmplitude: gaussianAmplitude,
  gaussianWeight: gaussianWeight,
  outer2D: outer2D,
  norm2D: norm2D,
  normalize2D: normalize2D,
  rowsToMat4: rowsToMat4,
  columnsToMat4: columnsToMat4,
  rowsToMat3: rowsToMat3,
  columnsToMat3: columnsToMat3,
  determinant2x2: determinant2x2,
  LUFactor3x3: LUFactor3x3,
  LUSolve3x3: LUSolve3x3,
  linearSolve3x3: linearSolve3x3,
  multiply3x3_vect3: multiply3x3_vect3,
  multiply3x3_mat3: multiply3x3_mat3,
  multiplyMatrix: multiplyMatrix,
  transpose3x3: transpose3x3,
  invert3x3: invert3x3,
  determinant3x3: determinant3x3,
  areEquals: areEquals,
  areMatricesEqual: areMatricesEqual,
  identity3x3: identity3x3,
  identity: identity,
  isIdentity: isIdentity,
  isIdentity3x3: isIdentity3x3,
  quaternionToMatrix3x3: quaternionToMatrix3x3,
  roundNumber: roundNumber,
  roundVector: roundVector,
  jacobiN: jacobiN,
  matrix3x3ToQuaternion: matrix3x3ToQuaternion,
  multiplyQuaternion: multiplyQuaternion,
  orthogonalize3x3: orthogonalize3x3,
  diagonalize3x3: diagonalize3x3,
  singularValueDecomposition3x3: singularValueDecomposition3x3,
  luFactorLinearSystem: luFactorLinearSystem,
  luSolveLinearSystem: luSolveLinearSystem,
  solveLinearSystem: solveLinearSystem,
  invertMatrix: invertMatrix,
  estimateMatrixCondition: estimateMatrixCondition,
  jacobi: jacobi,
  solveHomogeneousLeastSquares: solveHomogeneousLeastSquares,
  solveLeastSquares: solveLeastSquares,
  hex2float: hex2float,
  rgb2hsv: rgb2hsv,
  hsv2rgb: hsv2rgb,
  lab2xyz: lab2xyz,
  xyz2lab: xyz2lab,
  xyz2rgb: xyz2rgb,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  lab2rgb: lab2rgb,
  uninitializeBounds: uninitializeBounds,
  areBoundsInitialized: areBoundsInitialized,
  computeBoundsFromPoints: computeBoundsFromPoints,
  clampValue: clampValue,
  clampVector: clampVector,
  clampAndNormalizeValue: clampAndNormalizeValue,
  getScalarTypeFittingRange: getScalarTypeFittingRange,
  getAdjustedScalarRange: getAdjustedScalarRange,
  extentIsWithinOtherExtent: extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds: boundsIsWithinOtherBounds,
  pointIsWithinBounds: pointIsWithinBounds,
  solve3PointCircle: solve3PointCircle,
  inf: inf,
  negInf: negInf,
  isInf: isInf,
  isFinite: isFinite,
  isNaN: isNaN,
  isNan: isNan,
  createUninitializedBounds: createUninitializedBounds,
  getMajorAxisIndex: getMajorAxisIndex,
  getSparseOrthogonalMatrix: getSparseOrthogonalMatrix,
  floatToHex2: floatToHex2,
  floatRGB2HexCode: floatRGB2HexCode,
  float2CssRGBA: float2CssRGBA,
  'default': vtkMath
});




/***/ }),

/***/ 89265:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkMatrixBuilder)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16632);
/* harmony import */ var _Math_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35341);




const NoOp = v => v;
const EPSILON = 1e-6;
class Transform {
  constructor() {
    let useDegree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .glMatrix.toRadian */ .Fd.toRadian : NoOp;
  }
  rotateFromDirections(originDirection, targetDirection) {
    const src = new Float64Array(3);
    const dst = new Float64Array(3);
    const transf = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(src, originDirection[0], originDirection[1], originDirection[2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(src, src);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(dst, dst);
    const cosAlpha = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(src, dst);
    if (cosAlpha >= 1) {
      return this;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(this.tmp, src, dst);
    if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(this.tmp) < EPSILON) {
      // cross product is 0, so pick arbitrary axis perpendicular
      // to originDirection.
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(this.tmp, [1, 0, 0], originDirection);
      if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(this.tmp) < EPSILON) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(this.tmp, [0, 1, 0], originDirection);
      }
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromRotation */ .pB.fromRotation(transf, Math.acos(cosAlpha), this.tmp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(this.matrix, this.matrix, transf);
    return this;
  }
  rotate(angle, axis) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(this.tmp, ...axis);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(this.tmp, this.tmp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(this.matrix, this.matrix, this.angleConv(angle), this.tmp);
    return this;
  }
  rotateX(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateX */ .pB.rotateX(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  rotateY(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateY */ .pB.rotateY(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  rotateZ(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateZ */ .pB.rotateZ(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  translate(x, y, z) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(this.tmp, x, y, z);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(this.matrix, this.matrix, this.tmp);
    return this;
  }
  scale(sx, sy, sz) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(this.tmp, sx, sy, sz);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.scale */ .pB.scale(this.matrix, this.matrix, this.tmp);
    return this;
  }
  multiply(mat4x4) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(this.matrix, this.matrix, mat4x4);
    return this;
  }
  multiply3x3(mat3x3) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(this.matrix, this.matrix, [mat3x3[0], mat3x3[1], mat3x3[2], 0, mat3x3[3], mat3x3[4], mat3x3[5], 0, mat3x3[6], mat3x3[7], mat3x3[8], 0, 0, 0, 0, 1]);
    return this;
  }
  invert() {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(this.matrix, this.matrix);
    return this;
  }
  identity() {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(this.matrix);
    return this;
  }

  //-----------

  apply(typedArray) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let nbIterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    if ((0,_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.a)(_Math_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .IDENTITY */ .zK, this.matrix)) {
      // Make sure we can chain apply...
      return this;
    }
    const size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
    for (let i = offset; i < size; i += 3) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(this.tmp, this.tmp, this.matrix);
      typedArray[i] = this.tmp[0];
      typedArray[i + 1] = this.tmp[1];
      typedArray[i + 2] = this.tmp[2];
    }

    // Make sure we can chain apply...
    return this;
  }
  getMatrix() {
    return this.matrix;
  }
  setMatrix(mat4x4) {
    if (!!mat4x4 && mat4x4.length === 16) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(this.matrix, mat4x4);
    }
    return this;
  }
}
function buildFromDegree() {
  return new Transform(true);
}
function buildFromRadian() {
  return new Transform(false);
}
var vtkMatrixBuilder = {
  buildFromDegree,
  buildFromRadian
};




/***/ }),

/***/ 74966:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkPoints$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _DataArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42008);
/* harmony import */ var _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28914);




const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;
const INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];

// ----------------------------------------------------------------------------
// vtkPoints methods
// ----------------------------------------------------------------------------

function vtkPoints(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPoints');

  // Forwarding methods
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
  publicAPI.setNumberOfPoints = function (nbPoints) {
    let dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension;
      model.values = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.dataType, model.size);
      publicAPI.setNumberOfComponents(dimension);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint = function (idx) {
    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      xyz[_key - 1] = arguments[_key];
    }
    publicAPI.setTuple(idx, xyz);
  };
  publicAPI.getPoint = publicAPI.getTuple;
  publicAPI.findPoint = publicAPI.findTuple;
  publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);
  publicAPI.getBounds = () => {
    if (publicAPI.getNumberOfComponents() === 3) {
      const xRange = publicAPI.getRange(0);
      model.bounds[0] = xRange[0];
      model.bounds[1] = xRange[1];
      const yRange = publicAPI.getRange(1);
      model.bounds[2] = yRange[0];
      model.bounds[3] = yRange[1];
      const zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
      return model.bounds;
    }
    if (publicAPI.getNumberOfComponents() !== 2) {
      vtkErrorMacro(`getBounds called on an array with components of
        ${publicAPI.getNumberOfComponents()}`);
      return INVALID_BOUNDS;
    }
    const xRange = publicAPI.getRange(0);
    model.bounds[0] = xRange[0];
    model.bounds[1] = xRange[1];
    const yRange = publicAPI.getRange(1);
    model.bounds[2] = yRange[0];
    model.bounds[3] = yRange[1];
    model.bounds[4] = 0;
    model.bounds[5] = 0;
    return model.bounds;
  };

  // Trigger the computation of bounds
  publicAPI.computeBounds = publicAPI.getBounds;

  // Initialize
  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  empty: true,
  numberOfComponents: 3,
  dataType: _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VtkDataTypes */ .JA.FLOAT,
  bounds: [1, -1, 1, -1, 1, -1]
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);
  vtkPoints(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkPoints');

// ----------------------------------------------------------------------------

var vtkPoints$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 80993:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkScalarsToColors$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _DataArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42008);
/* harmony import */ var _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62955);
/* harmony import */ var _Rendering_Core_Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33395);





const {
  ScalarMappingTarget,
  VectorMode
} = _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay;
const {
  VtkDataTypes
} = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay;
const {
  ColorMode
} = _Rendering_Core_Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay;
const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// Add module-level functions or api that you want to expose statically via
// the next section...

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

function intColorToUChar(c) {
  return c;
}
function floatColorToUChar(c) {
  return Math.floor(c * 255.0 + 0.5);
}

// ----------------------------------------------------------------------------
// vtkScalarsToColors methods
// ----------------------------------------------------------------------------

function vtkScalarsToColors(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkScalarsToColors');
  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode.MAGNITUDE);
  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode.COMPONENT);
  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode.RGBCOLORS);
  publicAPI.build = () => {};
  publicAPI.isOpaque = () => true;

  //----------------------------------------------------------------------------
  publicAPI.setAnnotations = (values, annotations) => {
    if (values && !annotations || !values && annotations) {
      return;
    }
    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');
      return;
    }
    model.annotationArray = [];
    if (annotations && values) {
      const num = annotations.length;
      for (let i = 0; i < num; i++) {
        model.annotationArray.push({
          value: values[i],
          annotation: String(annotations[i])
        });
      }
    }
    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.setAnnotation = (value, annotation) => {
    let i = publicAPI.checkForAnnotatedValue(value);
    let modified = false;
    if (i >= 0) {
      if (model.annotationArray[i].annotation !== annotation) {
        model.annotationArray[i].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({
        value,
        annotation
      });
      i = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i;
  };

  //----------------------------------------------------------------------------
  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;

  //----------------------------------------------------------------------------
  publicAPI.getAnnotatedValue = idx => {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotation = idx => {
    if (model.annotationArray[idx] === undefined) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotatedValueIndex = val => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;

  //----------------------------------------------------------------------------
  publicAPI.removeAnnotation = value => {
    const i = publicAPI.checkForAnnotatedValue(value);
    const needToRemove = i >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };

  //----------------------------------------------------------------------------
  publicAPI.resetAnnotations = () => {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotationColor = (val, rgba) => {
    if (model.indexedLookup) {
      const i = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i, rgba);
    } else {
      publicAPI.getColor(parseFloat(val), rgba);
      rgba[3] = 1.0;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.checkForAnnotatedValue = value => publicAPI.getAnnotatedValueIndexInternal(value);

  //----------------------------------------------------------------------------
  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for
  // internal use (no pointer checks performed)
  publicAPI.getAnnotatedValueIndexInternal = value => {
    if (model.annotatedValueMap[value] !== undefined) {
      const na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    // Treat as a NaN
    return -1;
  };

  //----------------------------------------------------------------------------
  publicAPI.getIndexedColor = (val, rgba) => {
    rgba[0] = 0.0;
    rgba[1] = 0.0;
    rgba[2] = 0.0;
    rgba[3] = 0.0;
  };

  //----------------------------------------------------------------------------
  publicAPI.updateAnnotatedValueMap = () => {
    model.annotatedValueMap = [];
    const na = model.annotationArray.length;
    for (let i = 0; i < na; i++) {
      model.annotatedValueMap[model.annotationArray[i].value] = i;
    }
  };

  // Description:
  // Internal methods that map a data array into a 4-component,
  // unsigned char RGBA array. The color mode determines the behavior
  // of mapping. If ColorMode.DEFAULT is set, then unsigned char
  // data arrays are treated as colors (and converted to RGBA if
  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays
  // are treated as colors (integer types are clamped in the range 0-255,
  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does
  // not have enough values to represent a color so mapping this type is
  // considered an error);
  // otherwise, the data is mapped through this instance
  // of ScalarsToColors. The component argument is used for data
  // arrays with more than one component; it indicates which component
  // to use to do the blending.  When the component argument is -1,
  // then the this object uses its own selected technique to change a
  // vector into a scalar to map.
  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
    const numberOfComponents = scalars.getNumberOfComponents();
    let newColors = null;

    // map scalars through lookup table only if needed
    if (colorMode === ColorMode.DEFAULT && (scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR_CLAMPED) || colorMode === ColorMode.DIRECT_SCALARS && scalars) {
      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
    } else {
      const newscalars = {
        type: 'vtkDataArray',
        name: 'temp',
        numberOfComponents: 4,
        dataType: VtkDataTypes.UNSIGNED_CHAR
      };
      const s = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
      newscalars.values = s;
      newscalars.size = s.length;
      newColors = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance(newscalars);
      let component = componentIn;

      // If mapper did not specify a component, use the VectorMode
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }

        // Map the scalars to colors
        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);
      }
    }
    return newColors;
  };
  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    for (let i = 0; i < length; i++) {
      let sum = 0.0;
      for (let j = 0; j < compsToUse; j++) {
        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
      }
      outputV[i] = Math.sqrt(sum);
    }
  };

  //----------------------------------------------------------------------------
  // Map a set of vector values through the table
  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {
    let vectorMode = publicAPI.getVectorMode();
    let vectorSize = vectorSizeIn;
    let vectorComponent = vectorComponentIn;
    const inComponents = input.getNumberOfComponents();
    if (vectorMode === VectorMode.COMPONENT) {
      // make sure vectorComponent is within allowed range
      if (vectorComponent === -1) {
        // if set to -1, use default value provided by table
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      // make sure vectorSize is within allowed range
      if (vectorSize === -1) {
        // if set to -1, use default value provided by table
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }
      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
        vectorMode = VectorMode.COMPONENT;
      }
    }

    // increment input pointer to the first component to map
    let inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }

    // map according to the current vector mode
    switch (vectorMode) {
      case VectorMode.COMPONENT:
        {
          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
          break;
        }
      case VectorMode.RGBCOLORS:
        {
          // publicAPI.mapColorsToColors(
          //   input, output, inComponents, vectorSize,
          //   outputFormat);
          break;
        }

      // MAGNITUDE is considered default
      case VectorMode.MAGNITUDE:
      default:
        {
          const magValues = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
            numberOfComponents: 1,
            values: new Float32Array(input.getNumberOfTuples())
          });
          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
          break;
        }
    }
  };
  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = convtFun(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 1;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count * 4] = l;
      newValues[count * 4 + 1] = l;
      newValues[count * 4 + 2] = l;
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 2;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count] = l;
      newValues[count + 1] = l;
      newValues[count + 2] = l;
      newValues[count + 3] = convtFun(values[i + 1]) * alpha;
      count += 4;
    }
  };
  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = floatColorToUChar(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 3;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 4;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
      count++;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
    let {
      alpha
    } = model;
    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {
      return colors;
    }
    const newColors = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes.UNSIGNED_CHAR
    });
    if (numTuples <= 0) {
      return newColors;
    }
    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;
    let convtFun = intColorToUChar;
    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {
      convtFun = floatColorToUChar;
    }
    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;
      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;
      default:
        vtkErrorMacro('Cannot convert colors');
        return null;
    }
    return newColors;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;
  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);
  publicAPI.getRange = () => publicAPI.getMappingRange();
  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {
    if (!scalars) {
      return publicAPI.isOpaque();
    }
    const numberOfComponents = scalars.getNumberOfComponents();

    // map scalars through lookup table only if needed
    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS) {
      // we will be using the scalars directly, so look at the number of
      // components and the range
      if (numberOfComponents === 3 || numberOfComponents === 1) {
        return model.alpha >= 1.0;
      }
      // otherwise look at the range of the alpha channel
      const range = scalars.getRange(numberOfComponents - 1);
      return range[0] === 255;
    }
    return true;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  alpha: 1.0,
  vectorComponent: 0,
  vectorSize: -1,
  vectorMode: VectorMode.COMPONENT,
  mappingRange: null,
  annotationArray: null,
  annotatedValueMap: null,
  indexedLookup: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']);

  // Create set macros for array (needs to know size)
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['mappingRange'], 2);

  // Create get macros for array
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['mappingRange']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkScalarsToColors(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkScalarsToColors');

// ----------------------------------------------------------------------------

var vtkScalarsToColors$1 = {
  newInstance,
  extend,
  ..._ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay
};




/***/ }),

/***/ 62955:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkScalarsToColors),
/* harmony export */   y0: () => (/* binding */ ScalarMappingTarget)
/* harmony export */ });
/* unused harmony export VectorMode */
const VectorMode = {
  MAGNITUDE: 0,
  COMPONENT: 1,
  RGBCOLORS: 2
};
const ScalarMappingTarget = {
  LUMINANCE: 1,
  LUMINANCE_ALPHA: 2,
  RGB: 3,
  RGBA: 4
};
var vtkScalarsToColors = {
  VectorMode,
  ScalarMappingTarget
};




/***/ }),

/***/ 99341:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkPiecewiseFunction$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// vtkPiecewiseFunction methods
// ----------------------------------------------------------------------------

function vtkPiecewiseFunction(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPiecewiseFunction');

  // Return the number of points which specify this function
  publicAPI.getSize = () => model.nodes.length;

  // Return the type of function stored in object:
  // Function Types:
  //    0 : Constant        (No change in slope between end points)
  //    1 : NonDecreasing   (Always increasing or zero slope)
  //    2 : NonIncreasing   (Always decreasing or zero slope)
  //    3 : Varied          (Contains both decreasing and increasing slopes)
  //    4 : Unknown         (Error condition)
  //
  publicAPI.getType = () => {
    let value;
    let prevValue = 0.0;
    let functionType = 0;
    if (model.nodes.length > 0) {
      prevValue = model.nodes[0].y;
    }
    for (let i = 1; i < model.nodes.length; i++) {
      value = model.nodes[i].y;

      // Do not change the function type if equal
      if (value !== prevValue) {
        if (value > prevValue) {
          switch (functionType) {
            case 0:
            case 1:
              // NonDecreasing
              functionType = 1;
              break;
            case 2:
            default:
              // Varied
              functionType = 3;
              break;
          }
        } else {
          // value < prev_value
          switch (functionType) {
            case 0:
            case 2:
              // NonIncreasing
              functionType = 2;
              break;
            case 1:
            default:
              // Varied
              functionType = 3;
              break;
          }
        }
      }
      prevValue = value;

      // Exit loop if we find a Varied function
      if (functionType === 3) {
        break;
      }
    }
    switch (functionType) {
      case 0:
        return 'Constant';
      case 1:
        return 'NonDecreasing';
      case 2:
        return 'NonIncreasing';
      case 3:
      default:
        return 'Varied';
    }
  };

  // Since we no longer store the data in an array, we must
  // copy out of the vector into an array. No modified check -
  // could be added if performance is a problem
  publicAPI.getDataPointer = () => {
    const size = model.nodes.length;
    model.function = null;
    if (size > 0) {
      model.function = [];
      for (let i = 0; i < size; i++) {
        model.function[2 * i] = model.nodes[i].x;
        model.function[2 * i + 1] = model.nodes[i].y;
      }
    }
    return model.function;
  };

  // Returns the first point location which starts a non-zero segment of the
  // function. Note that the value at this point may be zero.
  publicAPI.getFirstNonZeroValue = () => {
    // Check if no points specified
    if (model.nodes.length === 0) {
      return 0;
    }
    let allZero = 1;
    let x = 0.0;
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].y !== 0.0) {
        allZero = 0;
        break;
      }
    }

    // If every specified point has a zero value then return
    // a large value
    if (allZero) {
      x = Number.MAX_VALUE;
    } else if (i > 0) {
      // A point was found with a non-zero value
      // Return the value of the point that precedes this one
      x = model.nodes[i - 1].x;
    } else if (model.clamping) {
      // If this is the first point in the function, return its
      // value is clamping is off, otherwise VTK_DOUBLE_MIN if
      // clamping is on.
      x = -Number.MAX_VALUE;
    } else {
      x = model.nodes[0].x;
    }
    return x;
  };

  // For a specified index value, get the node parameters
  publicAPI.getNodeValue = (index, val) => {
    const size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro('Index out of range!');
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].y;
    val[2] = model.nodes[index].midpoint;
    val[3] = model.nodes[index].sharpness;
    return 1;
  };

  // For a specified index value, get the node parameters
  publicAPI.setNodeValue = (index, val) => {
    const size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro('Index out of range!');
      return -1;
    }
    const oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].y = val[1];
    model.nodes[index].midpoint = val[2];
    model.nodes[index].sharpness = val[3];
    if (oldX !== val[0]) {
      // The point has been moved, the order of points or the range might have
      // been modified.
      publicAPI.sortAndUpdateRange();
      // No need to call Modified() here because SortAndUpdateRange() has done it
      // already.
    } else {
      publicAPI.modified();
    }
    return 1;
  };

  // Adds a point to the function. If a duplicate point is inserted
  // then the function value at that location is set to the new value.
  // This is the legacy version that assumes midpoint = 0.5 and
  // sharpness = 0.0
  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0);

  // Adds a point to the function and returns the array index of the point.
  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {
    // Error check
    if (midpoint < 0.0 || midpoint > 1.0) {
      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');
      return -1;
    }
    if (sharpness < 0.0 || sharpness > 1.0) {
      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');
      return -1;
    }

    // remove any node already at this X location
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }

    // Create the new node
    const node = {
      x,
      y,
      midpoint,
      sharpness
    };

    // Add it, then sort to get everything in order
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();

    // Now find this node so we can return the index
    let i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }

    // If we didn't find it, something went horribly wrong so
    // return -1
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.setNodes = nodes => {
    if (model.nodes !== nodes) {
      model.nodes = nodes;
      publicAPI.sortAndUpdateRange();
    }
  };

  // Sort the vector in increasing order, then fill in
  // the Range
  publicAPI.sortAndUpdateRange = () => {
    model.nodes.sort((a, b) => a.x - b.x);
    const modifiedInvoked = publicAPI.updateRange();
    // If range is updated, Modified() has been called, don't call it again.
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.updateRange = () => {
    const oldRange = model.range.slice();
    const size = model.nodes.length;
    if (size) {
      model.range[0] = model.nodes[0].x;
      model.range[1] = model.nodes[size - 1].x;
    } else {
      model.range[0] = 0;
      model.range[1] = 0;
    }
    // If the rage is the same, then no need to call Modified()
    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };

  // Removes a point from the function. If no point is found then function
  // remains the same.
  publicAPI.removePoint = x => {
    // First find the node since we need to know its
    // index as our return value
    let i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }

    // If the node doesn't exist, we return -1
    if (i >= model.nodes.length) {
      return -1;
    }
    const retVal = i;

    // If the first or last point has been removed, then we update the range
    // No need to sort here as the order of points hasn't changed.
    let modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };

  // Removes all points from the function.
  publicAPI.removeAllPoints = () => {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };

  // Add in end points of line and remove any points between them
  // Legacy method with no way to specify midpoint and sharpness
  publicAPI.addSegment = (x1, y1, x2, y2) => {
    // First, find all points in this range and remove them
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length;) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }

    // Now add the points
    publicAPI.addPoint(x1, y1, 0.5, 0.0);
    publicAPI.addPoint(x2, y2, 0.5, 0.0);
  };

  // Return the value of the function at a position
  publicAPI.getValue = x => {
    const table = [];
    publicAPI.getTable(x, x, 1, table);
    return table[0];
  };

  // Remove all points outside the range, and make sure a point
  // exists at each end of the range. Used as a convenience method
  // for transfer function editors
  publicAPI.adjustRange = range => {
    if (range.length < 2) {
      return 0;
    }
    const functionRange = publicAPI.getRange();

    // Make sure we have points at each end of the range
    if (functionRange[0] < range[0]) {
      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));
    } else {
      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));
    }
    if (functionRange[1] > range[1]) {
      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));
    } else {
      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));
    }

    // Remove all points out-of-range
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length;) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    publicAPI.sortAndUpdateRange();
    return 1;
  };

  //--------------------------------------------------------------------------
  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
    const d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };

  //----------------------------------------------------------------------------
  publicAPI.findMinimumXDistance = () => {
    const size = model.nodes.length;
    if (size < 2) {
      return -1.0;
    }
    let distance = model.nodes[1].x - model.nodes[0].x;
    for (let i = 0; i < size - 1; i++) {
      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };

  // Returns a table of function values evaluated at regular intervals
  /* eslint-disable prefer-destructuring */
  /* eslint-disable no-continue */
  publicAPI.getTable = function (xStart, xEnd, size, table) {
    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    let i;
    let idx = 0;
    const numNodes = model.nodes.length;

    // Need to keep track of the last value so that
    // we can fill in table locations past this with
    // this value if Clamping is On.
    let lastValue = 0.0;
    if (numNodes !== 0) {
      lastValue = model.nodes[numNodes - 1].y;
    }
    let x = 0.0;
    let x1 = 0.0;
    let x2 = 0.0;
    let y1 = 0.0;
    let y2 = 0.0;
    let midpoint = 0.0;
    let sharpness = 0.0;

    // For each table entry
    for (i = 0; i < size; i++) {
      // Find our location in the table
      const tidx = stride * i;

      // Find our X location. If we are taking only 1 sample, make
      // it halfway between start and end (usually start and end will
      // be the same in this case)
      if (size > 1) {
        x = xStart + i / (size - 1.0) * (xEnd - xStart);
      } else {
        x = 0.5 * (xStart + xEnd);
      }

      // Do we need to move to the next node?
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        // If we are at a valid point index, fill in
        // the value at this node, and the one before (the
        // two that surround our current sample location)
        // idx cannot be 0 since we just incremented it.
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          y1 = model.nodes[idx - 1].y;
          y2 = model.nodes[idx].y;

          // We only need the previous midpoint and sharpness
          // since these control this region
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;

          // Move midpoint away from extreme ends of range to avoid
          // degenerate math
          if (midpoint < 0.00001) {
            midpoint = 0.00001;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }

      // Are we at the end? If so, just use the last value
      if (idx >= numNodes) {
        table[tidx] = model.clamping ? lastValue : 0.0;
      } else if (idx === 0) {
        // Are we before the first node? If so, duplicate this nodes values
        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;
      } else {
        // Otherwise, we are between two nodes - interpolate
        // Our first attempt at a normalized location [0,1] -
        // we will be modifying this based on midpoint and
        // sharpness to get the curve shape we want and to have
        // it pass through (y1+y2)/2 at the midpoint.
        let s = (x - x1) / (x2 - x1);

        // Readjust based on the midpoint - linear adjustment
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);
        }

        // override for sharpness > 0.99
        // In this case we just want piecewise constant
        if (sharpness > 0.99) {
          // Use the first value since we are below the midpoint
          if (s < 0.5) {
            table[tidx] = y1;
            continue;
          } else {
            // Use the second value at or above the midpoint
            table[tidx] = y2;
            continue;
          }
        }

        // Override for sharpness < 0.01
        // In this case we want piecewise linear
        if (sharpness < 0.01) {
          // Simple linear interpolation
          table[tidx] = (1 - s) * y1 + s * y2;
          continue;
        }

        // We have a sharpness between [0.01, 0.99] - we will
        // used a modified hermite curve interpolation where we
        // derive the slope based on the sharpness, and we compress
        // the curve non-linearly based on the sharpness

        // First, we will adjust our position based on sharpness in
        // order to make the curve sharper (closer to piecewise constant)
        if (s < 0.5) {
          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);
        }

        // Compute some coefficients we will need for the hermite curve
        const ss = s * s;
        const sss = ss * s;
        const h1 = 2 * sss - 3 * ss + 1;
        const h2 = -2 * sss + 3 * ss;
        const h3 = sss - 2 * ss + s;
        const h4 = sss - ss;

        // Use one slope for both end points
        const slope = y2 - y1;
        const t = (1.0 - sharpness) * slope;

        // Compute the value
        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;

        // Final error check to make sure we don't go outside
        // the Y range
        const min = y1 < y2 ? y1 : y2;
        const max = y1 > y2 ? y1 : y2;
        table[tidx] = table[tidx] < min ? min : table[tidx];
        table[tidx] = table[tidx] > max ? max : table[tidx];
      }
    }
  };
}
/* eslint-enable prefer-destructuring */
/* eslint-enable no-continue */

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // model.function = NULL;
  range: [0, 0],
  clamping: true,
  allowDuplicateScalars: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Internal objects initialization
  model.nodes = [];

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['range'], 2);

  // Create get macros for array
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['range']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkPiecewiseFunction(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkPiecewiseFunction');

// ----------------------------------------------------------------------------

var vtkPiecewiseFunction$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 79484:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkPolyData$1)
});

// UNUSED EXPORTS: CELL_FACTORY, extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/vtk.js
var vtk = __webpack_require__(42852);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js
var CellArray = __webpack_require__(35056);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Points.js
var Points = __webpack_require__(74966);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Cell.js




// ----------------------------------------------------------------------------
// vtkCell methods
// ----------------------------------------------------------------------------

function vtkCell(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCell');
  publicAPI.initialize = function (points) {
    let pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {
        model.pointsIds[i] = i;
      }
    } else {
      model.pointsIds = pointIdsList;
      let triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = macros2.m.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
      }
      const pointsData = points.getData();
      model.pointsIds.forEach((pointId, index) => {
        // const start = 3 * pointId;
        // pointsData.set(p.subarray(start, start + 3), 3 * index);
        let pointOffset = 3 * pointId;
        let trianglePointOffset = 3 * index;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };
  publicAPI.getBounds = () => {
    const nbPoints = model.points.getNumberOfPoints();
    const x = [];
    if (nbPoints) {
      model.points.getPoint(0, x);
      model.bounds[0] = x[0];
      model.bounds[1] = x[0];
      model.bounds[2] = x[1];
      model.bounds[3] = x[1];
      model.bounds[4] = x[2];
      model.bounds[5] = x[2];
      for (let i = 1; i < nbPoints; i++) {
        model.points.getPoint(i, x);
        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];
        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];
        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];
        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];
        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];
        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];
      }
    } else {
      (0,Core_Math.u)(model.bounds);
    }
    return model.bounds;
  };
  publicAPI.getLength2 = () => {
    publicAPI.getBounds();
    let length = 0.0;
    let diff = 0;
    for (let i = 0; i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      length += diff * diff;
    }
    return length;
  };
  publicAPI.getParametricDistance = pcoords => {
    let pDist;
    let pDistMax = 0.0;
    for (let i = 0; i < 3; i++) {
      if (pcoords[i] < 0.0) {
        pDist = -pcoords[i];
      } else if (pcoords[i] > 1.0) {
        pDist = pcoords[i] - 1.0;
      } else {
        // inside the cell in the parametric direction
        pDist = 0.0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.deepCopy = cell => {
    cell.initialize(model.points, model.pointsIds);
  };
  publicAPI.getCellDimension = () => {}; // virtual
  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual
  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist2, weights) => {
    macros2.m.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');
  }; // virtual
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  bounds: [-1, -1, -1, -1, -1, -1],
  pointsIds: []
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  if (!model.points) {
    model.points = Points/* default.newInstance */.Ay.newInstance();
  }
  macros2.m.get(publicAPI, model, ['points', 'pointsIds']);
  vtkCell(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkCell');

// ----------------------------------------------------------------------------

var vtkCell$1 = {
  newInstance,
  extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js



// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
const InitLink = {
  ncells: 0,
  cells: null
};
function resize(model, sz) {
  let newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length) model.array.push({
    ncells: 0,
    cells: null
  });
  model.array.length = newSize;
}

// ----------------------------------------------------------------------------
// vtkCellLinks methods
// ----------------------------------------------------------------------------

function vtkCellLinks(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCellLinks');

  /**
   * Build the link list array. All subclasses of vtkAbstractCellLinks
   * must support this method.
   */
  publicAPI.buildLinks = data => {
    const numPts = data.getPoints().getNumberOfPoints();
    const numCells = data.getNumberOfCells();

    // fill out lists with number of references to cells
    const linkLoc = new Uint32Array(numPts);

    // Use fast path if polydata
    if (data.isA('vtkPolyData')) {
      // traverse data to determine number of uses of each point
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach(cellPointId => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }

      // now allocate storage for the links
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach(cellPointId => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } // any other type of dataset
    else {
      // traverse data to determine number of uses of each point
      for (let cellId = 0; cellId < numCells; cellId++) {
        // TODO: Currently not supported: const cell = data.getCell(cellId);
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach(cellPointId => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }

      // now allocate storage for the links
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        // TODO: Currently not supported: const cell = data.getCell(cellId);
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach(cellPointId => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } // end else
  };

  /**
   * Build the link list array with a provided connectivity array.
   */
  // publicAPI.buildLinks = (data, connectivity) => {};

  /**
   * Allocate the specified number of links (i.e., number of points) that
   * will be built.
   */
  publicAPI.allocate = function (numLinks) {
    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    model.array = Array(numLinks).fill().map(() => ({
      ncells: 0,
      cells: null
    }));
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = () => {
    model.array = null;
  };

  /**
   * Get a link structure given a point id.
   */
  publicAPI.getLink = ptId => model.array[ptId];

  /**
   * Get the number of cells using the point specified by ptId.
   */
  publicAPI.getNcells = ptId => model.array[ptId].ncells;

  /**
   * Return a list of cell ids using the point.
   */
  publicAPI.getCells = ptId => model.array[ptId].cells;

  /**
   * Insert a new point into the cell-links data structure. The size parameter
   * is the initial size of the list.
   */
  publicAPI.insertNextPoint = numLinks => {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };

  /**
   * Insert a cell id into the list of cells (at the end) using the cell id
   * provided. (Make sure to extend the link list (if necessary) using the
   * method resizeCellList().)
   */
  publicAPI.insertNextCellReference = (ptId, cellId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };

  /**
   * Delete point (and storage) by destroying links to using cells.
   */
  publicAPI.deletePoint = ptId => {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };

  /**
   * Delete the reference to the cell (cellId) from the point (ptId). This
   * removes the reference to the cellId from the cell list, but does not
   * resize the list (recover memory with resizeCellList(), if necessary).
   */
  publicAPI.removeCellReference = (cellId, ptId) => {
    model.array[ptId].cells = model.array[ptId].cells.filter(cell => cell !== cellId);
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };

  /**
   * Add the reference to the cell (cellId) from the point (ptId). This
   * adds a reference to the cellId from the cell list, but does not resize
   * the list (extend memory with resizeCellList(), if necessary).
   */
  publicAPI.addCellReference = (cellId, ptId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };

  /**
   * Change the length of a point's link list (i.e., list of cells using a
   * point) by the size specified.
   */
  publicAPI.resizeCellList = (ptId, size) => {
    model.array[ptId].cells.length = size;
  };

  /**
   * Reclaim any unused memory.
   */
  publicAPI.squeeze = () => {
    resize(model, model.maxId + 1);
  };

  /**
   * Reset to a state of no entries without freeing the memory.
   */
  publicAPI.reset = () => {
    model.maxId = -1;
  };

  /**
   * Standard DeepCopy method.  Since this object contains no reference
   * to other objects, there is no ShallowCopy.
   */
  publicAPI.deepCopy = src => {
    model.array = [...src.array];
    model.extend = src.extend;
    model.maxId = src.maxId;
  };

  /**
   * Increment the count of the number of cells using the point.
   */
  publicAPI.incrementLinkCount = ptId => {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = n => {
    for (let i = 0; i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };

  /**
   * Insert a cell id into the list of cells using the point.
   */
  publicAPI.insertCellReference = (ptId, pos, cellId) => {
    model.array[ptId].cells[pos] = cellId;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const CellLinks_DEFAULT_VALUES = {
  array: null,
  // pointer to data
  maxId: 0,
  // maximum index inserted thus far
  extend: 0 // grow array by this point
};

// ----------------------------------------------------------------------------

function CellLinks_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, CellLinks_DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}

// ----------------------------------------------------------------------------

const CellLinks_newInstance = macros2.m.newInstance(CellLinks_extend, 'vtkCellLinks');

// ----------------------------------------------------------------------------

var vtkCellLinks$1 = {
  newInstance: CellLinks_newInstance,
  extend: CellLinks_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
const CellType = {
  // Linear cells
  VTK_EMPTY_CELL: 0,
  VTK_VERTEX: 1,
  VTK_POLY_VERTEX: 2,
  VTK_LINE: 3,
  VTK_POLY_LINE: 4,
  VTK_TRIANGLE: 5,
  VTK_TRIANGLE_STRIP: 6,
  VTK_POLYGON: 7,
  VTK_PIXEL: 8,
  VTK_QUAD: 9,
  VTK_TETRA: 10,
  VTK_VOXEL: 11,
  VTK_HEXAHEDRON: 12,
  VTK_WEDGE: 13,
  VTK_PYRAMID: 14,
  VTK_PENTAGONAL_PRISM: 15,
  VTK_HEXAGONAL_PRISM: 16,
  // Quadratic, isoparametric cells
  VTK_QUADRATIC_EDGE: 21,
  VTK_QUADRATIC_TRIANGLE: 22,
  VTK_QUADRATIC_QUAD: 23,
  VTK_QUADRATIC_POLYGON: 36,
  VTK_QUADRATIC_TETRA: 24,
  VTK_QUADRATIC_HEXAHEDRON: 25,
  VTK_QUADRATIC_WEDGE: 26,
  VTK_QUADRATIC_PYRAMID: 27,
  VTK_BIQUADRATIC_QUAD: 28,
  VTK_TRIQUADRATIC_HEXAHEDRON: 29,
  VTK_QUADRATIC_LINEAR_QUAD: 30,
  VTK_QUADRATIC_LINEAR_WEDGE: 31,
  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
  VTK_BIQUADRATIC_TRIANGLE: 34,
  // Cubic, isoparametric cell
  VTK_CUBIC_LINE: 35,
  // Special class of cells formed by convex group of points
  VTK_CONVEX_POINT_SET: 41,
  // Polyhedron cell (consisting of polygonal faces)
  VTK_POLYHEDRON: 42,
  // Higher order cells in parametric form
  VTK_PARAMETRIC_CURVE: 51,
  VTK_PARAMETRIC_SURFACE: 52,
  VTK_PARAMETRIC_TRI_SURFACE: 53,
  VTK_PARAMETRIC_QUAD_SURFACE: 54,
  VTK_PARAMETRIC_TETRA_REGION: 55,
  VTK_PARAMETRIC_HEX_REGION: 56,
  // Higher order cells
  VTK_HIGHER_ORDER_EDGE: 60,
  VTK_HIGHER_ORDER_TRIANGLE: 61,
  VTK_HIGHER_ORDER_QUAD: 62,
  VTK_HIGHER_ORDER_POLYGON: 63,
  VTK_HIGHER_ORDER_TETRAHEDRON: 64,
  VTK_HIGHER_ORDER_WEDGE: 65,
  VTK_HIGHER_ORDER_PYRAMID: 66,
  VTK_HIGHER_ORDER_HEXAHEDRON: 67,
  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)
  VTK_LAGRANGE_CURVE: 68,
  VTK_LAGRANGE_TRIANGLE: 69,
  VTK_LAGRANGE_QUADRILATERAL: 70,
  VTK_LAGRANGE_TETRAHEDRON: 71,
  VTK_LAGRANGE_HEXAHEDRON: 72,
  VTK_LAGRANGE_WEDGE: 73,
  VTK_LAGRANGE_PYRAMID: 74,
  VTK_NUMBER_OF_CELL_TYPES: 75
};

// This list should contain the cell class names in
// the same order as in CellType.
const CellTypesStrings = ['vtkEmptyCell', 'vtkVertex', 'vtkPolyVertex', 'vtkLine', 'vtkPolyLine', 'vtkTriangle', 'vtkTriangleStrip', 'vtkPolygon', 'vtkPixel', 'vtkQuad', 'vtkTetra', 'vtkVoxel', 'vtkHexahedron', 'vtkWedge', 'vtkPyramid', 'vtkPentagonalPrism', 'vtkHexagonalPrism', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkQuadraticEdge', 'vtkQuadraticTriangle', 'vtkQuadraticQuad', 'vtkQuadraticTetra', 'vtkQuadraticHexahedron', 'vtkQuadraticWedge', 'vtkQuadraticPyramid', 'vtkBiQuadraticQuad', 'vtkTriQuadraticHexahedron', 'vtkQuadraticLinearQuad', 'vtkQuadraticLinearWedge', 'vtkBiQuadraticQuadraticWedge', 'vtkBiQuadraticQuadraticHexahedron', 'vtkBiQuadraticTriangle', 'vtkCubicLine', 'vtkQuadraticPolygon', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkConvexPointSet', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkParametricCurve', 'vtkParametricSurface', 'vtkParametricTriSurface', 'vtkParametricQuadSurface', 'vtkParametricTetraRegion', 'vtkParametricHexRegion', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkHigherOrderEdge', 'vtkHigherOrderTriangle', 'vtkHigherOrderQuad', 'vtkHigherOrderPolygon', 'vtkHigherOrderTetrahedron', 'vtkHigherOrderWedge', 'vtkHigherOrderPyramid', 'vtkHigherOrderHexahedron'];
var Constants = {
  CellType,
  CellTypesStrings
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js



// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

/**
 * Given an int (as defined in vtkCellType.h) identifier for a class
 * return it's classname.
 */
function getClassNameFromTypeId(typeId) {
  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';
}

/**
 * Given a data object classname, return it's int identified (as
 * defined in vtkCellType.h)
 */
function getTypeIdFromClassName(cellTypeString) {
  return CellTypesStrings.findIndex(cellTypeString);
}

/**
 * This convenience method is a fast check to determine if a cell type
 * represents a linear or nonlinear cell.  This is generally much more
 * efficient than getting the appropriate vtkCell and checking its IsLinear
 * method.
 */
function isLinear(type) {
  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
}
function hasSubCells(cellType) {
  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  getClassNameFromTypeId,
  getTypeIdFromClassName,
  isLinear,
  hasSubCells
};

// ----------------------------------------------------------------------------
// vtkCellTypes methods
// ----------------------------------------------------------------------------

function vtkCellTypes(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCellTypes');

  /**
   * Allocate memory for this array. Delete old storage only if necessary.
   */
  publicAPI.allocate = function () {
    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;
    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };

  /**
   * Add a cell at specified id.
   */
  publicAPI.insertCell = (cellId, type, loc) => {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;
    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };

  /**
   * Add a cell to the object in the next available slot.
   */
  publicAPI.insertNextCell = (type, loc) => {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };

  /**
   * Specify a group of cell types. This version is provided to maintain
   * backwards compatibility and does a copy of the cellLocations
   */
  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
    model.size = ncells;
    model.typeArray = cellTypes;
    model.locationArray = cellLocations;
    model.maxId = ncells - 1;
  };

  /**
   * Return the location of the cell in the associated vtkCellArray.
   */
  publicAPI.getCellLocation = cellId => model.locationArray[cellId];

  /**
   * Delete cell by setting to nullptr cell type.
   */
  publicAPI.deleteCell = cellId => {
    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
  };

  /**
   * Return the number of types in the list.
   */
  publicAPI.getNumberOfTypes = () => model.maxId + 1;

  /**
   * Return true if type specified is contained in list; false otherwise.
   */
  publicAPI.isType = type => {
    const numTypes = publicAPI.getNumberOfTypes();
    for (let i = 0; i < numTypes; ++i) {
      if (type === publicAPI.getCellType(i)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Add the type specified to the end of the list. Range checking is performed.
   */
  publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);

  /**
   * Return the type of cell.
   */
  publicAPI.getCellType = cellId => model.typeArray[cellId];

  /**
   * Reclaim any extra memory.
   */
  // TODO: publicAPI.squeeze = () =>  {};

  /**
   * Initialize object without releasing memory.
   */
  publicAPI.reset = () => {
    model.maxId = -1;
  };

  /**
   * Standard DeepCopy method.  Since this object contains no reference
   * to other objects, there is no ShallowCopy.
   */
  publicAPI.deepCopy = src => {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const CellTypes_DEFAULT_VALUES = {
  // typeArray: null, // pointer to types array
  // locationArray: null;   // pointer to array of offsets
  size: 0,
  // allocated size of data
  maxId: -1,
  // maximum index inserted thus far
  extend: 1000 // grow array by this point
};

// ----------------------------------------------------------------------------

function CellTypes_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, CellTypes_DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['size', 'maxId', 'extend']);
  macros2.m.getArray(publicAPI, model, ['typeArray', 'locationArray']);
  vtkCellTypes(publicAPI, model);
}

// ----------------------------------------------------------------------------

const CellTypes_newInstance = macros2.m.newInstance(CellTypes_extend, 'vtkCellTypes');

// ----------------------------------------------------------------------------

var vtkCellTypes$1 = {
  newInstance: CellTypes_newInstance,
  extend: CellTypes_extend,
  ...STATIC
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
const IntersectionState = {
  NO_INTERSECTION: 0,
  YES_INTERSECTION: 1,
  ON_LINE: 2
};
var Constants_Constants = {
  IntersectionState
};



// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Line.js






const {
  IntersectionState: Line_IntersectionState
} = Constants_Constants;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
function distanceToLine(x, p1, p2) {
  let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  const outObj = {
    t: Number.MIN_VALUE,
    distance: 0
  };
  const p21 = [];
  let closest;
  // Determine appropriate vector
  p21[0] = p2[0] - p1[0];
  p21[1] = p2[1] - p1[1];
  p21[2] = p2[2] - p1[2];

  // Get parametric location
  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
  const denom = (0,Core_Math.d)(p21, p21);

  // trying to avoid an expensive fabs
  let tolerance = 1e-5 * num;
  if (denom !== 0.0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0.0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0.0 || outObj.t < 0.0) {
    // If parametric coordinate is within 0<=p<=1, then the point is closest to
    // the line.  Otherwise, it's closest to a point at the end of the line.
    closest = p1;
  } else if (outObj.t > 1.0) {
    closest = p2;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }
  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = (0,Core_Math.e)(closest, x);
  return outObj;
}
function intersection(a1, a2, b1, b2, u, v) {
  const a21 = [];
  const b21 = [];
  const b1a1 = [];
  u[0] = 0.0;
  v[0] = 0.0;

  // Determine line vectors.
  (0,Core_Math.s)(a2, a1, a21);
  (0,Core_Math.s)(b2, b1, b21);
  (0,Core_Math.s)(b1, a1, b1a1);

  // Compute the system (least squares) matrix.
  const A = [(0,Core_Math.d)(a21, a21), -(0,Core_Math.d)(a21, b21), -(0,Core_Math.d)(a21, b21), (0,Core_Math.d)(b21, b21)];

  // Compute the least squares system constant term.
  const c = [];
  c[0] = (0,Core_Math.d)(a21, b1a1);
  c[1] = -(0,Core_Math.d)(b21, b1a1);
  // Solve the system of equations
  if ((0,Core_Math.g)(A, c, 2) === 0) {
    // The lines are colinear. Therefore, one of the four endpoints is the
    // point of closest approach
    let minDist = Number.MAX_VALUE;
    const p = [a1, a2, b1, b2];
    const l1 = [b1, b1, a1, a1];
    const l2 = [b2, b2, a2, a2];
    [v[0], v[0], u[0], u[0]];
    [u[0], u[0], v[0], v[0]];
    let obj;
    for (let i = 0; i < 4; i++) {
      obj = distanceToLine(p[i], l1[i], l2[i]);
      if (obj.distance < minDist) {
        minDist = obj.distance;
      }
    }
    return Line_IntersectionState.ON_LINE;
  }
  u[0] = c[0];
  v[0] = c[1];

  // Check parametric coordinates for intersection.
  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {
    return Line_IntersectionState.YES_INTERSECTION;
  }
  return Line_IntersectionState.NO_INTERSECTION;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const Line_STATIC = {
  distanceToLine,
  intersection
};

// ----------------------------------------------------------------------------
// vtkLine methods
// ----------------------------------------------------------------------------

function vtkLine(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLine');
  function isBetweenPoints(t) {
    return t >= 0.0 && t <= 1.0;
  }
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    pcoords[1] = 0.0;
    pcoords[2] = 0.0;
    const projXYZ = [];
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    const u = [];
    const v = [];
    const intersect = intersection(p1, p2, a1, a2, u, v);
    outObj.t = u[0];
    outObj.betweenPoints = isBetweenPoints(outObj.t);
    pcoords[0] = v[0];
    if (intersect === Line_IntersectionState.YES_INTERSECTION) {
      // make sure we are within tolerance
      for (let i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
      }
      if ((0,Core_Math.e)(x, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      let outDistance;
      // check to see if it lies within tolerance
      // one of the parametric coords must be outside 0-1
      if (outObj.t < 0.0) {
        outDistance = distanceToLine(p1, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 0.0;
          outObj.intersect = 1;
          outObj.betweenPoints = true; // Intersection is near p1
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1.0) {
        outDistance = distanceToLine(p2, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 1.0;
          outObj.intersect = 1;
          outObj.betweenPoints = true; // Intersection is near p2
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0.0) {
        pcoords[0] = 0.0;
        outDistance = distanceToLine(a1, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] > 1.0) {
        pcoords[0] = 1.0;
        outDistance = distanceToLine(a2, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    for (let i = 0; i < 3; i++) {
      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
    }
    weights[0] = 1.0 - pcoords[0];
    weights[1] = pcoords[0];
  };
  publicAPI.evaluateOrientation = (pcoords, q, weights) => {
    if (model.orientations) {
      esm/* quat.slerp */.Yu.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);
      weights[0] = 1.0 - pcoords[0];
      weights[1] = pcoords[0];
      return true;
    }
    return false;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Line_DEFAULT_VALUES = {
  orientations: null // an array of two quat or null
};

// ----------------------------------------------------------------------------

function Line_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Line_DEFAULT_VALUES, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['orientations']);
  vtkLine(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Line_newInstance = macros2.m.newInstance(Line_extend, 'vtkLine');

// ----------------------------------------------------------------------------

var vtkLine$1 = {
  newInstance: Line_newInstance,
  extend: Line_extend,
  ...Line_STATIC,
  ...Constants_Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js + 3 modules
var DataSet = __webpack_require__(69147);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js





// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkPointSet methods
// ----------------------------------------------------------------------------

function vtkPointSet(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPointSet');

  // Create empty points
  if (!model.points) {
    model.points = Points/* default.newInstance */.Ay.newInstance();
  } else {
    model.points = (0,vtk/* default */.A)(model.points);
  }
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.computeBounds = () => {
    publicAPI.getBounds();
  };
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function (other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = Points/* default.newInstance */.Ay.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const PointSet_DEFAULT_VALUES = {
  // points: null,
};

// ----------------------------------------------------------------------------

function PointSet_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PointSet_DEFAULT_VALUES, initialValues);

  // Inheritance
  DataSet/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['points']);

  // Object specific methods
  vtkPointSet(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PointSet_newInstance = macros2.m.newInstance(PointSet_extend, 'vtkPointSet');

// ----------------------------------------------------------------------------

var vtkPointSet$1 = {
  newInstance: PointSet_newInstance,
  extend: PointSet_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js + 1 modules
var Plane = __webpack_require__(75127);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js






// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function computeNormalDirection(v1, v2, v3, n) {
  // order is important!!! maintain consistency with triangle vertex order
  const ax = v3[0] - v2[0];
  const ay = v3[1] - v2[1];
  const az = v3[2] - v2[2];
  const bx = v1[0] - v2[0];
  const by = v1[1] - v2[1];
  const bz = v1[2] - v2[2];
  n[0] = ay * bz - az * by;
  n[1] = az * bx - ax * bz;
  n[2] = ax * by - ay * bx;
}
function computeNormal(v1, v2, v3, n) {
  computeNormalDirection(v1, v2, v3, n);
  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (length !== 0.0) {
    n[0] /= length;
    n[1] /= length;
    n[2] /= length;
  }
}
function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;
  let coplanar = false;
  const pt1 = [];
  const pt2 = [];
  const surfaceId = [];
  const n1 = [];
  const n2 = [];

  // Compute supporting plane normals.
  computeNormal(p1, q1, r1, n1);
  computeNormal(p2, q2, r2, n2);
  const s1 = -(0,Core_Math.d)(n1, p1);
  const s2 = -(0,Core_Math.d)(n2, p2);

  // Compute signed distances of points p1, q1, r1 from supporting
  // plane of second triangle.
  const dist1 = [(0,Core_Math.d)(n2, p1) + s2, (0,Core_Math.d)(n2, q1) + s2, (0,Core_Math.d)(n2, r1) + s2];

  // If signs of all points are the same, all the points lie on the
  // same side of the supporting plane, and we can exit early.
  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
    // vtkDebugMacro(<<"Same side supporting plane 1!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  // Do the same for p2, q2, r2 and supporting plane of first
  // triangle.
  const dist2 = [(0,Core_Math.d)(n1, p2) + s1, (0,Core_Math.d)(n1, q2) + s1, (0,Core_Math.d)(n1, r2) + s1];

  // If signs of all points are the same, all the points lie on the
  // same side of the supporting plane, and we can exit early.
  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {
    // vtkDebugMacro(<<"Same side supporting plane 2!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  // Check for coplanarity of the supporting planes.
  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {
    coplanar = true;
    // vtkDebugMacro(<<"Coplanar!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }

  // There are more efficient ways to find the intersection line (if
  // it exists), but this is clear enough.
  const pts1 = [p1, q1, r1];
  const pts2 = [p2, q2, r2];

  // Find line of intersection (L = p + t*v) between two planes.
  const n1n2 = (0,Core_Math.d)(n1, n2);
  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);
  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);
  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
  const v = (0,Core_Math.j)(n1, n2, []);
  (0,Core_Math.l)(v);
  let index1 = 0;
  let index2 = 0;
  const t1 = [];
  const t2 = [];
  let ts1 = 50;
  let ts2 = 50;
  for (let i = 0; i < 3; i++) {
    const id1 = i;
    const id2 = (i + 1) % 3;

    // Find t coordinate on line of intersection between two planes.
    const val1 = Plane/* default */.Ay.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
        ts1 = index1;
      }
      t1[index1++] = (0,Core_Math.d)(val1.x, v) - (0,Core_Math.d)(p, v);
    }
    const val2 = Plane/* default */.Ay.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
        ts2 = index2;
      }
      t2[index2++] = (0,Core_Math.d)(val2.x, v) - (0,Core_Math.d)(p, v);
    }
  }

  // If the value of the index is greater than 2, the intersecting point
  // actually is intersected by all three edges. In this case, set the two
  // edges to the two edges where the intersecting point is not the end point
  if (index1 > 2) {
    index1--;
    // swap
    const t12 = t1[2];
    t1[2] = t1[ts1];
    t1[ts1] = t12;
  }
  if (index2 > 2) {
    index2--;
    const t22 = t2[2];
    t2[2] = t2[ts2];
    t2[ts2] = t22;
  }
  // Check if only one edge or all edges intersect the supporting
  // planes intersection.
  if (index1 !== 2 || index2 !== 2) {
    // vtkDebugMacro(<<"Only one edge intersecting!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }

  // Check for NaNs
  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {
    // vtkWarningMacro(<<"NaNs!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] > t1[1]) {
    // swap
    const t11 = t1[1];
    t1[1] = t1[0];
    t1[0] = t11;
  }
  if (t2[0] > t2[1]) {
    // swap
    const t21 = t2[1];
    t2[1] = t2[0];
    t2[0] = t21;
  }
  // Handle the different interval configuration cases.
  let tt1;
  let tt2;
  if (t1[1] < t2[0] || t2[1] < t1[0]) {
    // vtkDebugMacro(<<"No Overlap!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    }; // No overlap
  }

  if (t1[0] < t2[0]) {
    if (t1[1] < t2[1]) {
      // First point on surface 2, second point on surface 1
      surfaceId[0] = 2;
      surfaceId[1] = 1;
      tt1 = t2[0];
      tt2 = t1[1];
    } else {
      // Both points belong to lines on surface 2
      surfaceId[0] = 2;
      surfaceId[1] = 2;
      tt1 = t2[0];
      tt2 = t2[1];
    }
  } // t1[0] >= t2[0]
  else if (t1[1] < t2[1]) {
    // Both points belong to lines on surface 1
    surfaceId[0] = 1;
    surfaceId[1] = 1;
    tt1 = t1[0];
    tt2 = t1[1];
  } else {
    // First point on surface 1, second point on surface 2
    surfaceId[0] = 1;
    surfaceId[1] = 2;
    tt1 = t1[0];
    tt2 = t2[1];
  }

  // Create actual intersection points.
  (0,Core_Math.m)(p, v, tt1, pt1);
  (0,Core_Math.m)(p, v, tt2, pt2);
  return {
    intersect: true,
    coplanar,
    pt1,
    pt2,
    surfaceId
  };
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const Triangle_STATIC = {
  computeNormalDirection,
  computeNormal,
  intersectWithTriangle
};

// ----------------------------------------------------------------------------
// vtkTriangle methods
// ----------------------------------------------------------------------------

function vtkTriangle(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkTriangle');
  publicAPI.getCellDimension = () => 2;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    pcoords[2] = 0.0;
    const closestPoint = [];
    const tol2 = tol * tol;

    // Get normal for triangle
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    const n = [];
    const weights = [];
    computeNormal(pt1, pt2, pt3, n);
    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
      // Intersect plane of triangle with line
      const plane = Plane/* default */.Ay.intersectWithLine(p1, p2, pt1, n);
      outObj.betweenPoints = plane.betweenPoints;
      outObj.t = plane.t;
      x[0] = plane.x[0];
      x[1] = plane.x[1];
      x[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0.0;
        pcoords[1] = 0.0;
        outObj.intersect = 0;
        return outObj;
      }

      // Evaluate position
      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }

    // Normals are null, so the triangle is degenerated and
    // we still need to check intersection between line and
    // the longest edge.
    const dist2Pt1Pt2 = (0,Core_Math.e)(pt1, pt2);
    const dist2Pt2Pt3 = (0,Core_Math.e)(pt2, pt3);
    const dist2Pt3Pt1 = (0,Core_Math.e)(pt3, pt1);
    if (!model.line) {
      model.line = vtkLine$1.newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }
    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
    outObj.betweenPoints = intersectLine.betweenPoints;
    outObj.t = intersectLine.t;
    if (intersectLine.intersect) {
      const pt3Pt1 = [];
      const pt3Pt2 = [];
      const pt3X = [];
      // Compute r and s manually, using dot and norm.
      for (let i = 0; i < 3; i++) {
        pt3Pt1[i] = pt1[i] - pt3[i];
        pt3Pt2[i] = pt2[i] - pt3[i];
        pt3X[i] = x[i] - pt3[i];
      }
      pcoords[0] = (0,Core_Math.d)(pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = (0,Core_Math.d)(pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.intersect = 1;
      return outObj;
    }
    pcoords[0] = 0.0;
    pcoords[1] = 0.0;
    outObj.intersect = 0;
    return outObj;
  };
  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {
    // will return obj
    const outObj = {
      subId: 0,
      dist2: 0,
      evaluation: -1
    };
    let i;
    let j;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    const n = [];
    let fabsn;
    const rhs = [];
    const c1 = [];
    const c2 = [];
    let det = 0;
    let idx = 0;
    const indices = [];
    let dist2Point;
    let dist2Line1;
    let dist2Line2;
    let closest = [];
    const closestPoint1 = [];
    const closestPoint2 = [];
    const cp = [];
    outObj.subId = 0;
    pcoords[2] = 0.0;

    // Get normal for triangle, only the normal direction is needed, i.e. the
    // normal need not be normalized (unit length)
    //
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);
    computeNormalDirection(pt1, pt2, pt3, n);

    // Project point to plane
    Plane/* default */.Ay.generalizedProjectPoint(x, pt1, n, cp);

    // Construct matrices.  Since we have over determined system, need to find
    // which 2 out of 3 equations to use to develop equations. (Any 2 should
    // work since we've projected point to plane.)
    let maxComponent = 0.0;
    for (i = 0; i < 3; i++) {
      // trying to avoid an expensive call to fabs()
      if (n[i] < 0) {
        fabsn = -n[i];
      } else {
        fabsn = n[i];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i;
      }
    }
    for (j = 0, i = 0; i < 3; i++) {
      if (i !== idx) {
        indices[j++] = i;
      }
    }
    for (i = 0; i < 2; i++) {
      rhs[i] = cp[indices[i]] - pt3[indices[i]];
      c1[i] = pt1[indices[i]] - pt3[indices[i]];
      c2[i] = pt2[indices[i]] - pt3[indices[i]];
    }
    det = (0,Core_Math.o)(c1, c2);
    if (det === 0.0) {
      pcoords[0] = 0.0;
      pcoords[1] = 0.0;
      outObj.evaluation = -1;
      return outObj;
    }
    pcoords[0] = (0,Core_Math.o)(rhs, c2) / det;
    pcoords[1] = (0,Core_Math.o)(c1, rhs) / det;

    // Okay, now find closest point to element
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {
      // projection distance
      if (closestPoint) {
        outObj.dist2 = (0,Core_Math.e)(cp, x);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      let t;
      if (closestPoint) {
        if (weights[1] < 0.0 && weights[2] < 0.0) {
          dist2Point = (0,Core_Math.e)(x, pt3);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt3, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[2] < 0.0 && weights[0] < 0.0) {
          dist2Point = (0,Core_Math.e)(x, pt1);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[1] < 0.0 && weights[0] < 0.0) {
          dist2Point = (0,Core_Math.e)(x, pt2);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt2, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[0] < 0.0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt2, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0.0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt2, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[2] < 0.0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        }
      }
      outObj.evaluation = 0;
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const p0 = [];
    const p1 = [];
    const p2 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p2);
    const u3 = 1.0 - pcoords[0] - pcoords[1];
    for (let i = 0; i < 3; i++) {
      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
    }
    weights[0] = u3;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };
  publicAPI.getParametricDistance = pcoords => {
    let pDist;
    let pDistMax = 0.0;
    const pc = [];
    pc[0] = pcoords[0];
    pc[1] = pcoords[1];
    pc[2] = 1.0 - pcoords[0] - pcoords[1];
    for (let i = 0; i < 3; i++) {
      if (pc[i] < 0.0) {
        pDist = -pc[i];
      } else if (pc[i] > 1.0) {
        pDist = pc[i] - 1.0;
      } else {
        // inside the cell in the parametric direction
        pDist = 0.0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Triangle_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function Triangle_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Triangle_DEFAULT_VALUES, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkTriangle(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Triangle_newInstance = macros2.m.newInstance(Triangle_extend, 'vtkTriangle');

// ----------------------------------------------------------------------------

var vtkTriangle$1 = {
  newInstance: Triangle_newInstance,
  extend: Triangle_extend,
  ...Triangle_STATIC
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
const POLYDATA_FIELDS = ['verts', 'lines', 'polys', 'strips'];
var PolyData_Constants_Constants = {
  POLYDATA_FIELDS
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js











const {
  vtkWarningMacro
} = macros2.m;
const CELL_FACTORY = {
  [CellType.VTK_LINE]: vtkLine$1,
  [CellType.VTK_POLY_LINE]: vtkLine$1,
  [CellType.VTK_TRIANGLE]: vtkTriangle$1
};

// ----------------------------------------------------------------------------
// vtkPolyData methods
// ----------------------------------------------------------------------------

function vtkPolyData(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPolyData');
  function camelize(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, letter => letter.toUpperCase()).replace(/\s+/g, '');
  }

  // build empty cell arrays and set methods
  POLYDATA_FIELDS.forEach(type => {
    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
    if (!model[type]) {
      model[type] = CellArray/* default.newInstance */.Ay.newInstance();
    } else {
      model[type] = (0,vtk/* default */.A)(model[type]);
    }
  });
  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function (other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach(type => {
      model[type] = CellArray/* default.newInstance */.Ay.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  publicAPI.buildCells = () => {
    // here are the number of cells we have
    const nVerts = publicAPI.getNumberOfVerts();
    const nLines = publicAPI.getNumberOfLines();
    const nPolys = publicAPI.getNumberOfPolys();
    const nStrips = publicAPI.getNumberOfStrips();

    // pre-allocate the space we need
    const nCells = nVerts + nLines + nPolys + nStrips;
    const types = new Uint8Array(nCells);
    let pTypes = types;
    const locs = new Uint32Array(nCells);
    let pLocs = locs;

    // record locations and type of each cell.
    // verts
    if (nVerts) {
      let nextCellPts = 0;
      model.verts.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }

    // lines
    if (nLines) {
      let nextCellPts = 0;
      model.lines.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }

    // polys
    if (nPolys) {
      let nextCellPts = 0;
      model.polys.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        switch (numCellPts) {
          case 3:
            pTypes[index] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }

    // strips
    if (nStrips) {
      let nextCellPts = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        nextCellPts += numCellPts + 1;
      });
    }

    // set up the cell types data structure
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };

  /**
   * Create upward links from points to cells that use each point. Enables
   * topologically complex queries.
   */
  publicAPI.buildLinks = function () {
    let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.cells === undefined) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = cellId => model.cells.getCellType(cellId);
  publicAPI.getCellPoints = cellId => {
    const cellType = publicAPI.getCellType(cellId);
    let cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    const loc = model.cells.getCellLocation(cellId);
    const cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = ptId => model.links.getCells(ptId);
  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
    const link1 = model.links.getLink(point1);
    const link2 = model.links.getLink(point2);
    return link1.cells.filter(cell => cell !== cellId && link2.cells.indexOf(cell) !== -1);
  };

  /**
   * If you know the type of cell, you may provide it to improve performances.
   */
  publicAPI.getCell = function (cellId) {
    let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const cellInfo = publicAPI.getCellPoints(cellId);
    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const PolyData_DEFAULT_VALUES = {
  // verts: null,
  // lines: null,
  // polys: null,
  // strips: null,
  // cells: null,
  // links: null,
};

// ----------------------------------------------------------------------------

function PolyData_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PolyData_DEFAULT_VALUES, initialValues);

  // Inheritance
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macros2.m.get(publicAPI, model, ['cells', 'links']);
  macros2.m.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);

  // Object specific methods
  vtkPolyData(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PolyData_newInstance = macros2.m.newInstance(PolyData_extend, 'vtkPolyData');

// ----------------------------------------------------------------------------

var vtkPolyData$1 = {
  newInstance: PolyData_newInstance,
  extend: PolyData_extend
};




/***/ }),

/***/ 61088:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCutter$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79484);



const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.c;
function initPolyIterator(pd) {
  const polys = pd.getPolys().getData();
  const strips = pd.getStrips().getData();
  const it = {
    cellSize: 0,
    cell: [],
    done: false,
    polyIdx: 0,
    stripIdx: 0,
    remainingStripLength: 0,
    // returns a single poly cell
    next() {
      if (it.polyIdx < polys.length) {
        it.cellSize = polys[it.polyIdx];
        const start = it.polyIdx + 1;
        const end = start + it.cellSize;
        it.polyIdx = end;
        let p = 0;
        for (let i = start; i < end; ++i) {
          it.cell[p++] = polys[i];
        }
      } else if (it.stripIdx < strips.length) {
        it.cellSize = 3;
        if (it.remainingStripLength === 0) {
          it.remainingStripLength = strips[it.stripIdx] - 2; // sliding window of 3 points
          // stripIdx points to the last point in a triangle 3-tuple
          it.stripIdx += 3;
        }
        const start = it.stripIdx - 2;
        const end = it.stripIdx + 1;
        it.stripIdx++;
        it.remainingStripLength--;
        let p = 0;
        for (let i = start; i < end; ++i) {
          it.cell[p++] = strips[i];
        }
      } else if (!it.done) {
        it.done = true;
      } else {
        throw new Error('Iterator is done');
      }
    }
  };
  it.next();
  return it;
}

// ----------------------------------------------------------------------------
// vtkCutter methods
// ----------------------------------------------------------------------------

function vtkCutter(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCutter');

  // Capture "parentClass" api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.getMTime = () => {
    let mTime = superClass.getMTime();
    if (!model.cutFunction) {
      return mTime;
    }
    mTime = Math.max(mTime, model.cutFunction.getMTime());
    return mTime;
  };
  function dataSetCutter(input, output) {
    const points = input.getPoints();
    const pointsData = points.getData();
    const numPts = points.getNumberOfPoints();
    const newPointsData = [];
    const newLinesData = [];
    const newPolysData = [];
    if (!model.cutScalars || model.cutScalars.length < numPts) {
      model.cutScalars = new Float32Array(numPts);
    }

    // Loop over all points evaluating scalar function at each point
    let inOffset = 0;
    let outOffset = 0;
    while (inOffset < pointsData.length) {
      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);
    }
    const crossedEdges = [];
    const x1 = new Array(3);
    const x2 = new Array(3);
    const cellPointsScalars = [];

    // Loop over all cells; get scalar values for all cell points
    // and process each cell.
    /* eslint-disable no-continue */
    for (const it = initPolyIterator(input); !it.done; it.next()) {
      // cell contains the point IDs/indices

      // Check that cells have at least 3 points
      if (it.cellSize <= 2) {
        continue;
      }

      // Get associated scalar of points that constitute the current cell
      for (let i = 0; i < it.cellSize;) {
        cellPointsScalars[i] = model.cutScalars[it.cell[i++]];
      }

      // Check if all cell points are on same side (same side == cell not crossed by cut function)
      // TODO: won't work if one point scalar is = 0 ?
      const sideFirstPoint = cellPointsScalars[0] > 0;
      let allPointsSameSide = true;
      for (let i = 1; i < it.cell.length; i++) {
        const sideCurrentPoint = cellPointsScalars[i] > 0;
        if (sideCurrentPoint !== sideFirstPoint) {
          allPointsSameSide = false;
          break;
        }
      }

      // Go to next cell if cell is not crossed by cut function
      if (allPointsSameSide) {
        continue;
      }

      // Find and compute edges which intersect cells
      const intersectedEdgesList = [];
      for (let i = 0; i < it.cellSize; i++) {
        const idNext = i + 1 === it.cellSize ? 0 : i + 1;

        // Go to next edge if edge is not crossed
        // TODO: in most come cases, (numberOfPointsInCell - 1) or 0 edges of the cell
        // will be crossed, but if it crosses right at a point, it could be intersecting
        // with (numberOfPoints) or 1 edge(s). Do we account for that?
        const signPoint0 = cellPointsScalars[i] > 0;
        const signPoint1 = cellPointsScalars[idNext] > 0;
        if (signPoint1 === signPoint0) {
          continue;
        }

        // Compute preferred interpolation direction
        let e1 = i;
        let e2 = idNext;
        let deltaScalar = cellPointsScalars[e2] - cellPointsScalars[e1];
        if (deltaScalar <= 0) {
          e1 = idNext;
          e2 = i;
          deltaScalar *= -1;
        }

        // linear interpolation
        let t = 0.0;
        if (deltaScalar !== 0.0) {
          t = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;
        }

        // points position
        const pointID1 = it.cell[e1];
        const pointID2 = it.cell[e2];
        x1[0] = pointsData[pointID1 * 3];
        x1[1] = pointsData[pointID1 * 3 + 1];
        x1[2] = pointsData[pointID1 * 3 + 2];
        x2[0] = pointsData[pointID2 * 3];
        x2[1] = pointsData[pointID2 * 3 + 1];
        x2[2] = pointsData[pointID2 * 3 + 2];

        // Compute the intersected point on edge
        const computedIntersectedPoint = [x1[0] + t * (x2[0] - x1[0]), x1[1] + t * (x2[1] - x1[1]), x1[2] + t * (x2[2] - x1[2])];

        // Keep track of it
        intersectedEdgesList.push({
          pointEdge1: pointID1,
          // id of one point of the edge
          pointEdge2: pointID2,
          // id of one point of the edge
          intersectedPoint: computedIntersectedPoint,
          // 3D coordinate of points that intersected edge
          newPointID: -1 // id of the intersected point when it will be added into vtkPoints
        });
      }

      // Add points into newPointList
      for (let i = 0; i < intersectedEdgesList.length; i++) {
        const intersectedEdge = intersectedEdgesList[i];
        let alreadyAdded = false;
        // Check if point/edge already added
        for (let j = 0; j < crossedEdges.length; j++) {
          const crossedEdge = crossedEdges[j];
          const sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;
          const samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];
          if (sameEdge || samePoint) {
            alreadyAdded = true;
            intersectedEdgesList[i].newPointID = crossedEdges[j].newPointID;
            break;
          }
        }
        if (!alreadyAdded) {
          newPointsData.push(intersectedEdge.intersectedPoint[0]);
          newPointsData.push(intersectedEdge.intersectedPoint[1]);
          newPointsData.push(intersectedEdge.intersectedPoint[2]);
          intersectedEdgesList[i].newPointID = newPointsData.length / 3 - 1;
          crossedEdges.push(intersectedEdgesList[i]);
        }
      }

      // Store cells
      const cellSize = intersectedEdgesList.length;
      if (cellSize === 2) {
        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);
      } else if (cellSize > 2) {
        newPolysData.push(cellSize);
        intersectedEdgesList.forEach(edge => {
          newPolysData.push(edge.newPointID);
        });
      }
    }

    // Set points
    const outputPoints = output.getPoints();
    outputPoints.setData((0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.b)(points.getDataType(), newPointsData), 3);

    // Set lines
    if (newLinesData.length !== 0) {
      output.getLines().setData(Uint16Array.from(newLinesData));
    }

    // Set polys
    if (newPolysData.length !== 0) {
      output.getPolys().setData(Uint16Array.from(newPolysData));
    }
  }

  // expose requestData
  publicAPI.requestData = (inData, outData) => {
    // implement requestData
    const input = inData[0];
    if (!input) {
      vtkErrorMacro('Invalid or missing input');
      return;
    }
    if (!model.cutFunction) {
      vtkErrorMacro('Missing cut function');
      return;
    }
    const output = _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance();
    dataSetCutter(input, output);
    outData[0] = output;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  cutFunction: null,
  // support method with evaluateFunction method
  cutScalars: null,
  cutValue: 0.0
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Make this a VTK object
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.o)(publicAPI, model);

  // Also make it an algorithm with one input and one output
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.d)(publicAPI, model, 1, 1);

  // Set implicit function use to cut the input data (is vtkPlane)
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.e)(publicAPI, model, ['cutFunction', 'cutValue']);

  // Object specific methods
  vtkCutter(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend, 'vtkCutter');

// ----------------------------------------------------------------------------

var vtkCutter$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 56748:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCubeSource$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_CellArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35056);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42008);
/* harmony import */ var _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(79484);
/* harmony import */ var _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89265);






// prettier-ignore
const LINE_ARRAY = [2, 0, 1, 2, 2, 3, 2, 4, 5, 2, 6, 7, 2, 0, 2, 2, 1, 3, 2, 4, 6, 2, 5, 7, 2, 0, 4, 2, 1, 5, 2, 2, 6, 2, 3, 7];

// prettier-ignore
const POLY_ARRAY = [4, 0, 1, 3, 2, 4, 4, 6, 7, 5, 4, 8, 10, 11, 9, 4, 12, 13, 15, 14, 4, 16, 18, 19, 17, 4, 20, 21, 23, 22];

// ----------------------------------------------------------------------------
// vtkCubeSource methods
// ----------------------------------------------------------------------------

function vtkCubeSource(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCubeSource');
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    const polyData = _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
    outData[0] = polyData;
    const numberOfPoints = 24;

    // Define points
    const points = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.pointType, numberOfPoints * 3);
    polyData.getPoints().setData(points, 3);
    const normals = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.pointType, numberOfPoints * 3);
    const normalArray = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
      name: 'Normals',
      values: normals,
      numberOfComponents: 3
    });
    polyData.getPointData().setNormals(normalArray);
    let tcdim = 2;
    if (model.generate3DTextureCoordinates === true) {
      tcdim = 3;
    }
    const textureCoords = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.pointType, numberOfPoints * tcdim);
    const tcoords = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
      name: 'TextureCoordinates',
      values: textureCoords,
      numberOfComponents: tcdim
    });
    polyData.getPointData().setTCoords(tcoords);
    const x = [0.0, 0.0, 0.0];
    const n = [0.0, 0.0, 0.0];
    const tc = [0.0, 0.0];
    let pointIndex = 0;
    x[0] = -model.xLength / 2.0;
    n[0] = -1.0;
    n[1] = 0.0;
    n[2] = 0.0;
    for (let i = 0; i < 2; i++) {
      x[1] = -model.yLength / 2.0;
      for (let j = 0; j < 2; j++) {
        tc[1] = x[1] + 0.5;
        x[2] = -model.zLength / 2.0;
        for (let k = 0; k < 2; k++) {
          tc[0] = (x[2] + 0.5) * (1 - 2 * i);
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * i - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k - 1;
          }
          pointIndex++;
          x[2] += model.zLength;
        }
        x[1] += model.yLength;
      }
      x[0] += model.xLength;
      n[0] += 2.0;
    }
    x[1] = -model.yLength / 2.0;
    n[1] = -1.0;
    n[0] = 0.0;
    n[2] = 0.0;
    for (let i = 0; i < 2; i++) {
      x[0] = -model.xLength / 2.0;
      for (let j = 0; j < 2; j++) {
        tc[0] = (x[0] + 0.5) * (2 * i - 1);
        x[2] = -model.zLength / 2.0;
        for (let k = 0; k < 2; k++) {
          tc[1] = (x[2] + 0.5) * -1;
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * i - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k - 1;
          }
          pointIndex++;
          x[2] += model.zLength;
        }
        x[0] += model.xLength;
      }
      x[1] += model.yLength;
      n[1] += 2.0;
    }
    x[2] = -model.zLength / 2.0;
    n[2] = -1.0;
    n[0] = 0.0;
    n[1] = 0.0;
    for (let i = 0; i < 2; i++) {
      x[1] = -model.yLength / 2.0;
      for (let j = 0; j < 2; j++) {
        tc[1] = x[1] + 0.5;
        x[0] = -model.xLength / 2.0;
        for (let k = 0; k < 2; k++) {
          tc[0] = (x[0] + 0.5) * (2 * i - 1);
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * k - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * i - 1;
          }
          pointIndex++;
          x[0] += model.xLength;
        }
        x[1] += model.yLength;
      }
      x[2] += model.zLength;
      n[2] += 2.0;
    }

    // Apply rotation to the points coordinates and normals
    if (model.rotations) {
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.buildFromDegree().rotateX(model.rotations[0]).rotateY(model.rotations[1]).rotateZ(model.rotations[2]).apply(points).apply(normals);
    }

    // Apply transformation to the points coordinates
    if (model.center) {
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.buildFromRadian().translate(...model.center).apply(points);
    }

    // Apply optional additionally specified matrix transformation
    if (model.matrix) {
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.buildFromRadian().setMatrix(model.matrix).apply(points);

      // prettier-ignore
      const rotMatrix = [model.matrix[0], model.matrix[1], model.matrix[2], 0, model.matrix[4], model.matrix[5], model.matrix[6], 0, model.matrix[8], model.matrix[9], model.matrix[10], 0, 0, 0, 0, 1];
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.buildFromRadian().setMatrix(rotMatrix).apply(normals);
    }

    // Lastly, generate the necessary cell arrays.
    if (model.generateFaces) {
      polyData.getPolys().deepCopy(model._polys);
    } else {
      polyData.getPolys().initialize();
    }
    if (model.generateLines) {
      polyData.getLines().deepCopy(model._lineCells);
      // only set normals for faces, not for lines.
      polyData.getPointData().setNormals(null);
    } else {
      polyData.getLines().initialize();
    }
    polyData.modified();
  }
  publicAPI.setBounds = function () {
    let boundsArray = [];
    if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {
      boundsArray = arguments.length <= 0 ? undefined : arguments[0];
    } else {
      for (let i = 0; i < arguments.length; i++) {
        boundsArray.push(i < 0 || arguments.length <= i ? undefined : arguments[i]);
      }
    }
    if (boundsArray.length !== 6) {
      return;
    }
    publicAPI.setXLength(boundsArray[1] - boundsArray[0]);
    publicAPI.setYLength(boundsArray[3] - boundsArray[2]);
    publicAPI.setZLength(boundsArray[5] - boundsArray[4]);
    publicAPI.setCenter([(boundsArray[0] + boundsArray[1]) / 2.0, (boundsArray[2] + boundsArray[3]) / 2.0, (boundsArray[4] + boundsArray[5]) / 2.0]);
  };

  // Expose methods
  publicAPI.requestData = requestData;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  xLength: 1.0,
  yLength: 1.0,
  zLength: 1.0,
  pointType: 'Float64Array',
  generate3DTextureCoordinates: false,
  generateFaces: true,
  generateLines: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['xLength', 'yLength', 'zLength', 'generate3DTextureCoordinates', 'generateFaces', 'generateLines']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['center', 'rotations'], 3);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['matrix'], 16);

  // Internal persistent/static objects
  model._polys = _Common_Core_CellArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
    values: Uint16Array.from(POLY_ARRAY)
  });
  model._lineCells = _Common_Core_CellArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
    values: Uint16Array.from(LINE_ARRAY)
  });
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.moveToProtected(publicAPI, model, ['polys', 'lineCells']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 0, 1);
  vtkCubeSource(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkCubeSource');

// ----------------------------------------------------------------------------

var vtkCubeSource$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 85311:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkAbstractMapper$1)
/* harmony export */ });
/* unused harmony export extend */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkAbstractMapper methods
// ----------------------------------------------------------------------------

function vtkAbstractMapper(publicAPI, model) {
  model.classHierarchy.push('vtkAbstractMapper');
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.addClippingPlane = plane => {
    if (!plane.isA('vtkPlane')) {
      return false;
    }
    if (!model.clippingPlanes.includes(plane)) {
      model.clippingPlanes.push(plane);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;
  publicAPI.removeAllClippingPlanes = () => {
    if (model.clippingPlanes.length === 0) {
      return false;
    }
    model.clippingPlanes.length = 0;
    publicAPI.modified();
    return true;
  };
  publicAPI.removeClippingPlane = clippingPlane => {
    const i = model.clippingPlanes.indexOf(clippingPlane);
    if (i === -1) {
      return false;
    }
    model.clippingPlanes.splice(i, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.getClippingPlanes = () => model.clippingPlanes;
  publicAPI.setClippingPlanes = planes => {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      const nbPlanes = planes.length;
      for (let i = 0; i < nbPlanes && i < 6; i++) {
        publicAPI.addClippingPlane(planes[i]);
      }
    }
  };
  publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {
    const clipPlanes = model.clippingPlanes;
    const mat = propMatrix;
    if (clipPlanes) {
      const n = clipPlanes.length;
      if (i >= 0 && i < n) {
        // Get the plane
        const plane = clipPlanes[i];
        const normal = plane.getNormal();
        const origin = plane.getOrigin();

        // Compute the plane equation
        const v1 = normal[0];
        const v2 = normal[1];
        const v3 = normal[2];
        const v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);

        // Transform normal from world to data coords
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
        return;
      }
    }
    _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro(`Clipping plane index ${i} is out of range.`);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  clippingPlanes: []
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 1, 0);
  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }
  vtkAbstractMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------
var vtkAbstractMapper$1 = {
  extend
};




/***/ }),

/***/ 68076:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkAbstractMapper3D$1)
/* harmony export */ });
/* unused harmony export extend */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _AbstractMapper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85311);
/* harmony import */ var _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21734);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16632);





// ----------------------------------------------------------------------------
// vtkAbstractMapper methods
// ----------------------------------------------------------------------------

function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = () => {
    _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);
    return (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.F)();
  };
  publicAPI.getCenter = () => {
    const bounds = publicAPI.getBounds();
    model.center = _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].isValid */ .Ay.isValid(bounds) ? _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCenter */ .Ay.getCenter(bounds) : null;
    return model.center?.slice();
  };
  publicAPI.getLength = () => {
    const bounds = publicAPI.getBounds();
    return _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getDiagonalLength */ .Ay.getDiagonalLength(bounds);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const defaultValues = initialValues => ({
  bounds: [..._Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay.INIT_BOUNDS],
  center: [0, 0, 0],
  viewSpecificProperties: {},
  ...initialValues
});

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, defaultValues(initialValues));
  // Inheritance
  _AbstractMapper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .A.extend(publicAPI, model, initialValues);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['viewSpecificProperties']);
  vtkAbstractMapper3D(publicAPI, model);
}

// ----------------------------------------------------------------------------

var vtkAbstractMapper3D$1 = {
  extend
};




/***/ }),

/***/ 7019:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkActor$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21734);
/* harmony import */ var _Prop3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62502);
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89585);






const {
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m;

// ----------------------------------------------------------------------------
// vtkActor methods
// ----------------------------------------------------------------------------

function vtkActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkActor');

  // Capture 'parentClass' api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.getActors = () => [publicAPI];
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    // make sure we have a property
    if (!model.property) {
      // force creation of a property
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1.0;

    // are we using an opaque texture, if any?
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());

    // are we using an opaque scalar array, if any?
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    // make sure we have a property
    if (model.property === null) {
      // force creation of a property
      publicAPI.setProperty(publicAPI.makeProperty());
    }

    // is this actor opaque ?
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = _Property_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].newInstance */ .Ay.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }

    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }

    // Check for the special case when the actor is empty.
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }

    // Check if we have cached values for these bounds - we cache the
    // values returned by model.mapper.getBounds() and we store the time
    // of caching. If the values returned this time are different, or
    // the modified time of this class is newer than the cached time,
    // then we need to rebuild.
    if (!model.mapperBounds || bds[0] !== model.mapperBounds[0] || bds[1] !== model.mapperBounds[1] || bds[2] !== model.mapperBounds[2] || bds[3] !== model.mapperBounds[3] || bds[4] !== model.mapperBounds[4] || bds[5] !== model.mapperBounds[5] || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro('Recomputing bounds...');
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      const bbox = [];
      _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCorners */ .Ay.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(tmp4, model.matrix);
      bbox.forEach(pt => gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(pt, pt, tmp4));

      /* eslint-disable no-multi-assign */
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      /* eslint-enable no-multi-assign */

      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    if (model.backfaceProperty !== null) {
      const time = model.backfaceProperty.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        // FIXME !!! getInputAlgorithm / getInput
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (model.mapper && model.mapper.processSelectorPixelBuffers) {
      model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  mapper: null,
  property: null,
  backfaceProperty: null,
  forceOpaque: false,
  forceTranslucent: false,
  bounds: [1, -1, 1, -1, 1, -1]
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _Prop3D_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // vtkTimeStamp
  model.boundsMTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.obj(model.boundsMTime);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.set(publicAPI, model, ['property']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGet(publicAPI, model, ['backfaceProperty', 'forceOpaque', 'forceTranslucent', 'mapper']);

  // Object methods
  vtkActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.newInstance(extend, 'vtkActor');

// ----------------------------------------------------------------------------

var vtkActor$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 26719:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCamera$1)
/* harmony export */ });
/* unused harmony exports DEFAULT_VALUES, extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16632);




const {
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m;

/* eslint-disable new-cap */

/*
 * Convenience function to access elements of a gl-matrix.  If it turns
 * out I have rows and columns swapped everywhere, then I'll just change
 * the order of 'row' and 'col' parameters in this function
 */
// function getMatrixElement(matrix, row, col) {
//   const idx = (row * 4) + col;
//   return matrix[idx];
// }

// ----------------------------------------------------------------------------
// vtkCamera methods
// ----------------------------------------------------------------------------

function vtkCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCamera');

  // Set up private variables and methods
  const origin = new Float64Array(3);
  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);
  const upbasis = new Float64Array([0.0, 1.0, 0.0]);
  const tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  const tmpMatrix2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  const tmpvec1 = new Float64Array(3);
  const tmpvec2 = new Float64Array(3);
  const tmpvec3 = new Float64Array(3);
  const rotateMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  const trans = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  const newPosition = new Float64Array(3);
  const newFocalPoint = new Float64Array(3);

  // Internal Functions that don't need to be public
  function computeViewPlaneNormal() {
    // VPN is -DOP
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }
  publicAPI.orthogonalizeViewUp = () => {
    const vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];
    publicAPI.modified();
  };
  publicAPI.setPosition = (x, y, z) => {
    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
      return;
    }
    model.position[0] = x;
    model.position[1] = y;
    model.position[2] = z;

    // recompute the focal distance
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setFocalPoint = (x, y, z) => {
    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
      return;
    }
    model.focalPoint[0] = x;
    model.focalPoint[1] = y;
    model.focalPoint[2] = z;

    // recompute the focal distance
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setDistance = d => {
    if (model.distance === d) {
      return;
    }
    model.distance = d;
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro('Distance is set to minimum.');
    }

    // we want to keep the camera pointing in the same direction
    const vec = model.directionOfProjection;

    // recalculate FocalPoint
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  // This method must be called when the focal point or camera position changes
  publicAPI.computeDistance = () => {
    const dx = model.focalPoint[0] - model.position[0];
    const dy = model.focalPoint[1] - model.position[1];
    const dz = model.focalPoint[2] - model.position[2];
    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro('Distance is set to minimum.');
      const vec = model.directionOfProjection;

      // recalculate FocalPoint
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }
    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy / model.distance;
    model.directionOfProjection[2] = dz / model.distance;
    computeViewPlaneNormal();
  };

  //----------------------------------------------------------------------------
  // Move the position of the camera along the view plane normal. Moving
  // towards the focal point (e.g., > 1) is a dolly-in, moving away
  // from the focal point (e.g., < 1) is a dolly-out.
  publicAPI.dolly = amount => {
    if (amount <= 0.0) {
      return;
    }

    // dolly moves the camera towards the focus
    const d = model.distance / amount;
    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
  };
  publicAPI.roll = angle => {
    const eye = model.position;
    const at = model.focalPoint;
    const up = model.viewUp;
    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(rotateMatrix);
    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotateMatrix, rotateMatrix, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), viewDir);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];
    publicAPI.modified();
  };
  publicAPI.azimuth = angle => {
    const fp = model.focalPoint;
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(trans);

    // translate the focal point to the origin,
    // rotate about view up,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, fp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(trans, trans, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), model.viewUp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.yaw = angle => {
    const position = model.position;
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(trans);

    // translate the camera to the origin,
    // rotate about axis,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, position);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(trans, trans, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), model.viewUp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, [-position[0], -position[1], -position[2]]);

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
  };
  publicAPI.elevation = angle => {
    const fp = model.focalPoint;

    // get the eye / camera position from the viewMatrix
    const vt = publicAPI.getViewMatrix();
    const axis = [-vt[0], -vt[1], -vt[2]];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(trans);

    // translate the focal point to the origin,
    // rotate about view up,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, fp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(trans, trans, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), axis);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.pitch = angle => {
    const position = model.position;
    const vt = publicAPI.getViewMatrix();
    const axis = [vt[0], vt[1], vt[2]];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(trans);

    // translate the camera to the origin,
    // rotate about axis,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, position);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(trans, trans, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), axis);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, [-position[0], -position[1], -position[2]]);

    // apply the transform to the focal point
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(...newFocalPoint);
  };
  publicAPI.zoom = factor => {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };
  publicAPI.translate = (x, y, z) => {
    const offset = [x, y, z];
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.k)(model.position, offset, model.position);
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.k)(model.focalPoint, offset, model.focalPoint);
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.applyTransform = transformMat4 => {
    const vuOld = [...model.viewUp, 1.0];
    const posNew = [];
    const fpNew = [];
    const vuNew = [];
    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(posNew, [...model.position, 1.0], transformMat4);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(vuNew, vuOld, transformMat4);
    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];
    publicAPI.setPosition(...posNew.slice(0, 3));
    publicAPI.setFocalPoint(...fpNew.slice(0, 3));
    publicAPI.setViewUp(...vuNew.slice(0, 3));
  };
  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];
  publicAPI.setThickness = thickness => {
    let t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro('Thickness is set to minimum.');
    }
    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
  };
  publicAPI.setThicknessFromFocalPoint = thickness => {
    let t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro('Thickness is set to minimum.');
    }
    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
  };

  // Unimplemented functions
  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html
  publicAPI.getRoll = () => {};
  publicAPI.setObliqueAngles = (alpha, beta) => {};
  publicAPI.getOrientation = () => {};
  publicAPI.getOrientationWXYZ = () => {};
  publicAPI.getFrustumPlanes = aspect => {
    // Return array of 24 params (4 params for each of 6 plane equations)
  };
  publicAPI.getCameraLightTransformMatrix = matrix => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(matrix, model.cameraLightTransform);
    return matrix;
  };
  publicAPI.computeCameraLightTransform = () => {
    // not sure if this is the correct transformation, based on the same funciton in VTK
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(tmpMatrix, publicAPI.getViewMatrix());
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(tmpMatrix, tmpMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromScaling */ .pB.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(model.cameraLightTransform);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);
  };
  publicAPI.deepCopy = sourceCamera => {};
  publicAPI.physicalOrientationToWorldDirection = ori => {
    // push the x axis through the orientation quat
    const oriq = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.fromValues */ .Yu.fromValues(ori[0], ori[1], ori[2], ori[3]);
    const coriq = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create();
    const qdir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.fromValues */ .Yu.fromValues(0.0, 0.0, 1.0, 0.0);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.conjugate */ .Yu.conjugate(coriq, oriq);

    // rotate the z axis by the quat
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.multiply */ .Yu.multiply(qdir, oriq, qdir);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.multiply */ .Yu.multiply(qdir, qdir, coriq);

    // return the z axis in world coords
    return [qdir[0], qdir[1], qdir[2]];
  };
  publicAPI.getPhysicalToWorldMatrix = result => {
    publicAPI.getWorldToPhysicalMatrix(result);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(result, result);
  };
  publicAPI.getWorldToPhysicalMatrix = result => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(result);

    // now the physical to vtk world rotation tform
    const physVRight = [3];
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.j)(model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(result, result);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.scale */ .pB.scale(result, result, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(result, result, model.physicalTranslation);
  };
  publicAPI.computeViewParametersFromViewMatrix = vmat => {
    // invert to get view to world
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(tmpMatrix, vmat);

    // note with glmatrix operations happen in
    // the reverse order
    // mat.scale
    // mat.translate
    // will result in the translation then the scale
    // mat.mult(a,b)
    // results in perform the B transformation then A

    // then extract the params position, orientation
    // push 0,0,0 through to get a translation
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(tmpvec1, origin, tmpMatrix);
    publicAPI.computeDistance();
    const oldDist = model.distance;
    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);

    // push basis vectors to get orientation
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(tmpvec2, dopbasis, tmpMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(tmpvec2, tmpvec2, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(tmpvec3, upbasis, tmpMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(tmpvec3, tmpvec3, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
    publicAPI.setDistance(oldDist);
  };

  // the provided matrix should include
  // translation and orientation only
  // mat is physical to view
  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {
    // get the WorldToPhysicalMatrix
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);

    // first convert the physical -> view matrix to be
    // world -> view
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(tmpMatrix, mat, tmpMatrix);
    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };
  publicAPI.setViewMatrix = mat => {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.viewMatrix, model.viewMatrix);
    }
  };
  publicAPI.getViewMatrix = () => {
    if (model.viewMatrix) {
      return model.viewMatrix;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.lookAt */ .pB.lookAt(tmpMatrix, model.position,
    // eye
    model.focalPoint,
    // at
    model.viewUp // up
    );

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(tmpMatrix, tmpMatrix);
    const result = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.setProjectionMatrix = mat => {
    model.projectionMatrix = mat;
  };
  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
    const result = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(result);
    if (model.projectionMatrix) {
      const scale = 1 / model.physicalScale;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(tmpvec1, scale, scale, scale);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(result, model.projectionMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.scale */ .pB.scale(result, result, tmpvec1);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(result, result);
      return result;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(tmpMatrix);

    // FIXME: Not sure what to do about adjust z buffer here
    // adjust Z-buffer range
    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );
    const cWidth = model.clippingRange[1] - model.clippingRange[0];
    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];
    if (model.parallelProjection) {
      // set up a rectangular parallelipiped
      const width = model.parallelScale * aspect;
      const height = model.parallelScale;
      const xmin = (model.windowCenter[0] - 1.0) * width;
      const xmax = (model.windowCenter[0] + 1.0) * width;
      const ymin = (model.windowCenter[1] - 1.0) * height;
      const ymax = (model.windowCenter[1] + 1.0) * height;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.ortho */ .pB.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error('Off-Axis projection is not supported at this time');
    } else {
      const tmp = Math.tan((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(model.viewAngle) / 2.0);
      let width;
      let height;
      if (model.useHorizontalViewAngle === true) {
        width = model.clippingRange[0] * tmp;
        height = model.clippingRange[0] * tmp / aspect;
      } else {
        width = model.clippingRange[0] * tmp * aspect;
        height = model.clippingRange[0] * tmp;
      }
      const xmin = (model.windowCenter[0] - 1.0) * width;
      const xmax = (model.windowCenter[0] + 1.0) * width;
      const ymin = (model.windowCenter[1] - 1.0) * height;
      const ymax = (model.windowCenter[1] + 1.0) * height;
      const znear = cRange[0];
      const zfar = cRange[1];
      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);
      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);
      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1.0;
      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0.0;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {
    const vMat = publicAPI.getViewMatrix();
    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    // mats are transposed so the order is A then B
    // we reuse pMat as it is a copy so we can do what we want with it
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(pMat, vMat, pMat);
    return pMat;
  };
  publicAPI.setDirectionOfProjection = (x, y, z) => {
    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
      return;
    }
    model.directionOfProjection[0] = x;
    model.directionOfProjection[1] = y;
    model.directionOfProjection[2] = z;
    const vec = model.directionOfProjection;

    // recalculate FocalPoint
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };

  // used to handle convert js device orientation angles
  // when you use this method the camera will adjust to the
  // device orientation such that the physicalViewUp you set
  // in world coordinates looks up, and the physicalViewNorth
  // you set in world coorindates will (maybe) point north
  //
  // NOTE WARNING - much of the documentation out there on how
  // orientation works is seriously wrong. Even worse the Chrome
  // device orientation simulator is completely wrong and should
  // never be used. OMG it is so messed up.
  //
  // how it seems to work on iOS is that the device orientation
  // is specified in extrinsic angles with a alpha, beta, gamma
  // convention with axes of Z, X, Y (the code below substitutes
  // the physical coordinate system for these axes to get the right
  // modified coordinate system.
  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {
    const physVRight = [3];
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.j)(model.physicalViewNorth, model.physicalViewUp, physVRight);

    // phone to physical coordinates
    const rotmat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotmat, rotmat, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(alpha), model.physicalViewUp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotmat, rotmat, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(beta), physVRight);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotmat, rotmat, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(gamma), model.physicalViewNorth);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotmat, rotmat, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(-screen), model.physicalViewUp);
    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
    const vup = new Float64Array(model.physicalViewNorth);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(dop, dop, rotmat);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(vup, vup, rotmat);
    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };
  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {
    const quatMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {
      // convert to radians
      const angle = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(degrees);
      const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.setAxisAngle */ .Yu.setAxisAngle(q, [x, y, z], angle);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromQuat */ .pB.fromQuat(quatMat, q);
    }
    const newdop = new Float64Array(3);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);
    const newvup = new Float64Array(3);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);
    publicAPI.setDirectionOfProjection(...newdop);
    publicAPI.setViewUp(...newvup);
    publicAPI.modified();
  };
  publicAPI.computeClippingRange = bounds => {
    let vn = null;
    let position = null;
    vn = model.viewPlaneNormal;
    position = model.position;
    const a = -vn[0];
    const b = -vn[1];
    const c = -vn[2];
    const d = -(a * position[0] + b * position[1] + c * position[2]);

    // Set the max near clipping plane and the min far clipping plane
    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];

    // Find the closest / farthest bounding box vertex
    for (let k = 0; k < 2; k++) {
      for (let j = 0; j < 2; j++) {
        for (let i = 0; i < 2; i++) {
          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
          range[0] = dist < range[0] ? dist : range[0];
          range[1] = dist > range[1] ? dist : range[1];
        }
      }
    }
    return range;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  viewUp: [0, 1, 0],
  directionOfProjection: [0, 0, -1],
  parallelProjection: false,
  useHorizontalViewAngle: false,
  viewAngle: 30,
  parallelScale: 1,
  clippingRange: [0.01, 1000.01],
  windowCenter: [0, 0],
  viewPlaneNormal: [0, 0, 1],
  useOffAxisProjection: false,
  screenBottomLeft: [-0.5, -0.5, -0.5],
  screenBottomRight: [0.5, -0.5, -0.5],
  screenTopRight: [0.5, 0.5, -0.5],
  freezeFocalPoint: false,
  projectionMatrix: null,
  viewMatrix: null,
  cameraLightTransform: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.create */ .pB.create(),
  // used for world to physical transformations
  physicalTranslation: [0, 0, 0],
  physicalScale: 1.0,
  physicalViewUp: [0, 1, 0],
  physicalViewNorth: [0, 0, -1]
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.get(publicAPI, model, ['distance']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);

  // Object methods
  vtkCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.newInstance(extend, 'vtkCamera');

// ----------------------------------------------------------------------------

var vtkCamera$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 33739:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkColorTransferFunction$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
var ScalarsToColors = __webpack_require__(80993);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/Constants.js
const ColorSpace = {
  RGB: 0,
  HSV: 1,
  LAB: 2,
  DIVERGING: 3
};
const Scale = {
  LINEAR: 0,
  LOG10: 1
};
var Constants = {
  ColorSpace,
  Scale
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js





const {
  ColorSpace: ColorTransferFunction_ColorSpace,
  Scale: ColorTransferFunction_Scale
} = Constants;
const {
  ScalarMappingTarget
} = ScalarsToColors/* default */.Ay;
const {
  vtkDebugMacro,
  vtkErrorMacro,
  vtkWarningMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
/* eslint-disable no-continue                                                */

// Convert to and from a special polar version of CIELAB (useful for creating
// continuous diverging color maps).
function vtkColorTransferFunctionLabToMsh(lab, msh) {
  const L = lab[0];
  const a = lab[1];
  const b = lab[2];
  const M = Math.sqrt(L * L + a * a + b * b);
  const s = M > 0.001 ? Math.acos(L / M) : 0.0;
  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;
  msh[0] = M;
  msh[1] = s;
  msh[2] = h;
}
function vtkColorTransferFunctionMshToLab(msh, lab) {
  const M = msh[0];
  const s = msh[1];
  const h = msh[2];
  lab[0] = M * Math.cos(s);
  lab[1] = M * Math.sin(s) * Math.cos(h);
  lab[2] = M * Math.sin(s) * Math.sin(h);
}

// For the case when interpolating from a saturated color to an unsaturated
// color, find a hue for the unsaturated color that makes sense.
function vtkColorTransferFunctionAdjustHue(msh, unsatM) {
  if (msh[0] >= unsatM - 0.1) {
    // The best we can do is hold hue constant.
    return msh[2];
  }

  // This equation is designed to make the perceptual change of the
  // interpolation to be close to constant.
  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));
  // Spin hue away from 0 except in purple hues.
  if (msh[2] > -0.3 * Math.PI) {
    return msh[2] + hueSpin;
  }
  return msh[2] - hueSpin;
}
function vtkColorTransferFunctionAngleDiff(a1, a2) {
  let adiff = a1 - a2;
  if (adiff < 0.0) {
    adiff = -adiff;
  }
  while (adiff >= 2.0 * Math.PI) {
    adiff -= 2.0 * Math.PI;
  }
  if (adiff > Math.PI) {
    adiff = 2.0 * Math.PI - adiff;
  }
  return adiff;
}

// Interpolate a diverging color map.
function vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {
  const lab1 = [];
  const lab2 = [];
  (0,Core_Math.L)(rgb1, lab1);
  (0,Core_Math.L)(rgb2, lab2);
  const msh1 = [];
  const msh2 = [];
  vtkColorTransferFunctionLabToMsh(lab1, msh1);
  vtkColorTransferFunctionLabToMsh(lab2, msh2);

  // If the endpoints are distinct saturated colors, then place white in between
  // them.
  let localS = s;
  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {
    // Insert the white midpoint by setting one end to white and adjusting the
    // scalar value.
    let Mmid = Math.max(msh1[0], msh2[0]);
    Mmid = Math.max(88.0, Mmid);
    if (s < 0.5) {
      msh2[0] = Mmid;
      msh2[1] = 0.0;
      msh2[2] = 0.0;
      localS *= 2.0;
    } else {
      msh1[0] = Mmid;
      msh1[1] = 0.0;
      msh1[2] = 0.0;
      localS = 2.0 * localS - 1.0;
    }
  }

  // If one color has no saturation, then its hue value is invalid.  In this
  // case, we want to set it to something logical so that the interpolation of
  // hue makes sense.
  if (msh1[1] < 0.05 && msh2[1] > 0.05) {
    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);
  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {
    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);
  }
  const mshTmp = [];
  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];
  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];
  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];

  // Now convert back to RGB
  const labTmp = [];
  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);
  (0,Core_Math.M)(labTmp, result);
}

// ----------------------------------------------------------------------------
// vtkColorTransferFunction methods
// ----------------------------------------------------------------------------

function vtkColorTransferFunction(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkColorTransferFunction');

  // Return the number of points which specify this function
  publicAPI.getSize = () => model.nodes.length;

  //----------------------------------------------------------------------------
  // Add a point defined in RGB
  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);

  //----------------------------------------------------------------------------
  // Add a point defined in RGB
  publicAPI.addRGBPointLong = function (x, r, g, b) {
    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;
    // Error check
    if (midpoint < 0.0 || midpoint > 1.0) {
      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');
      return -1;
    }
    if (sharpness < 0.0 || sharpness > 1.0) {
      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');
      return -1;
    }

    // remove any node already at this X location
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }

    // Create the new node
    const node = {
      x,
      r,
      g,
      b,
      midpoint,
      sharpness
    };

    // Add it, then sort to get everything in order
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();

    // We need to find the index of the node we just added in order
    // to return this value
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }

    // If we didn't find it, something went horribly wrong so
    // return -1
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };

  //----------------------------------------------------------------------------
  // Add a point defined in HSV
  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);

  //----------------------------------------------------------------------------
  // Add a point defined in HSV
  publicAPI.addHSVPointLong = function (x, h, s, v) {
    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;
    const rgb = [];
    const hsv = [h, s, v];
    (0,Core_Math.h)(hsv, rgb);
    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);
  };

  //----------------------------------------------------------------------------
  // Set nodes directly
  publicAPI.setNodes = nodes => {
    if (model.nodes !== nodes) {
      const before = JSON.stringify(model.nodes);
      model.nodes = nodes;
      const after = JSON.stringify(model.nodes);
      if (publicAPI.sortAndUpdateRange() || before !== after) {
        publicAPI.modified();
        return true;
      }
    }
    return false;
  };

  //----------------------------------------------------------------------------
  // Sort the vector in increasing order, then fill in
  // the Range
  publicAPI.sortAndUpdateRange = () => {
    const before = JSON.stringify(model.nodes);
    model.nodes.sort((a, b) => a.x - b.x);
    const after = JSON.stringify(model.nodes);
    const modifiedInvoked = publicAPI.updateRange();
    // If range is updated, Modified() has been called, don't call it again.
    if (!modifiedInvoked && before !== after) {
      publicAPI.modified();
      return true;
    }
    return modifiedInvoked;
  };

  //----------------------------------------------------------------------------
  publicAPI.updateRange = () => {
    const oldRange = [2];
    oldRange[0] = model.mappingRange[0];
    oldRange[1] = model.mappingRange[1];
    const size = model.nodes.length;
    if (size) {
      model.mappingRange[0] = model.nodes[0].x;
      model.mappingRange[1] = model.nodes[size - 1].x;
    } else {
      model.mappingRange[0] = 0;
      model.mappingRange[1] = 0;
    }

    // If the range is the same, then no need to call Modified()
    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };

  //----------------------------------------------------------------------------
  // Remove a point
  publicAPI.removePoint = x => {
    // First find the node since we need to know its
    // index as our return value
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    const retVal = i;

    // If the node doesn't exist, we return -1
    if (i >= model.nodes.length) {
      return -1;
    }

    // If the first or last point has been removed, then we update the range
    // No need to sort here as the order of points hasn't changed.
    let modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };

  //----------------------------------------------------------------------------
  publicAPI.movePoint = (oldX, newX) => {
    if (oldX === newX) {
      // Nothing to do.
      return;
    }
    publicAPI.removePoint(newX);
    for (let i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === oldX) {
        model.nodes[i].x = newX;
        publicAPI.sortAndUpdateRange();
        break;
      }
    }
  };

  //----------------------------------------------------------------------------
  // Remove all points
  publicAPI.removeAllPoints = () => {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };

  //----------------------------------------------------------------------------
  // Add a line defined in RGB
  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {
    // First, find all points in this range and remove them
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length;) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }

    // Now add the points
    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);
    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  // Add a line defined in HSV
  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {
    const hsv1 = [h1, s1, v1];
    const hsv2 = [h2, s2, v2];
    const rgb1 = [];
    const rgb2 = [];
    (0,Core_Math.h)(hsv1, rgb1);
    (0,Core_Math.h)(hsv2, rgb2);
    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);
  };

  //----------------------------------------------------------------------------
  // Returns the RGBA color evaluated at the specified location
  publicAPI.mapValue = x => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];
  };

  //----------------------------------------------------------------------------
  // Returns the RGB color evaluated at the specified location
  publicAPI.getColor = (x, rgb) => {
    if (model.indexedLookup) {
      const numNodes = publicAPI.getSize();
      // todo
      const idx = publicAPI.getAnnotatedValueIndexInternal(x);
      if (idx < 0 || numNodes === 0) {
        const nanColor = publicAPI.getNanColorByReference();
        rgb[0] = nanColor[0];
        rgb[1] = nanColor[1];
        rgb[2] = nanColor[2];
      } else {
        const nodeVal = [];
        publicAPI.getNodeValue(idx % numNodes, nodeVal);
        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.
        rgb[0] = nodeVal[1];
        rgb[1] = nodeVal[2];
        rgb[2] = nodeVal[3];
      }
      return;
    }
    publicAPI.getTable(x, x, 1, rgb);
  };

  //----------------------------------------------------------------------------
  // Returns the red color evaluated at the specified location
  publicAPI.getRedValue = x => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[0];
  };

  //----------------------------------------------------------------------------
  // Returns the green color evaluated at the specified location
  publicAPI.getGreenValue = x => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[1];
  };

  //----------------------------------------------------------------------------
  // Returns the blue color evaluated at the specified location
  publicAPI.getBlueValue = x => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[2];
  };

  //----------------------------------------------------------------------------
  // Returns a table of RGB colors at regular intervals along the function
  publicAPI.getTable = (xStart_, xEnd_, size, table) => {
    // To handle BigInt limitation
    const xStart = Number(xStart_);
    const xEnd = Number(xEnd_);

    // Special case: If either the start or end is a NaN, then all any
    // interpolation done on them is also a NaN.  Therefore, fill the table with
    // the NaN color.
    if ((0,Core_Math.i)(xStart) || (0,Core_Math.i)(xEnd)) {
      for (let i = 0; i < size; i++) {
        table[i * 3 + 0] = model.nanColor[0];
        table[i * 3 + 1] = model.nanColor[1];
        table[i * 3 + 2] = model.nanColor[2];
      }
      return;
    }
    let idx = 0;
    const numNodes = model.nodes.length;

    // Need to keep track of the last value so that
    // we can fill in table locations past this with
    // this value if Clamping is On.
    let lastR = 0.0;
    let lastG = 0.0;
    let lastB = 0.0;
    if (numNodes !== 0) {
      lastR = model.nodes[numNodes - 1].r;
      lastG = model.nodes[numNodes - 1].g;
      lastB = model.nodes[numNodes - 1].b;
    }
    let x = 0.0;
    let x1 = 0.0;
    let x2 = 0.0;
    const rgb1 = [0.0, 0.0, 0.0];
    const rgb2 = [0.0, 0.0, 0.0];
    let midpoint = 0.0;
    let sharpness = 0.0;
    const tmpVec = [];

    // If the scale is logarithmic, make sure the range is valid.
    let usingLogScale = model.scale === ColorTransferFunction_Scale.LOG10;
    if (usingLogScale) {
      // Note: This requires range[0] <= range[1].
      usingLogScale = model.mappingRange[0] > 0.0;
    }
    let logStart = 0.0;
    let logEnd = 0.0;
    let logX = 0.0;
    if (usingLogScale) {
      logStart = Math.log10(xStart);
      logEnd = Math.log10(xEnd);
    }

    // For each table entry
    for (let i = 0; i < size; i++) {
      // Find our location in the table
      const tidx = 3 * i;

      // Find our X location. If we are taking only 1 sample, make
      // it halfway between start and end (usually start and end will
      // be the same in this case)
      if (size > 1) {
        if (usingLogScale) {
          logX = logStart + i / (size - 1.0) * (logEnd - logStart);
          x = 10.0 ** logX;
        } else {
          x = xStart + i / (size - 1.0) * (xEnd - xStart);
        }
      } else if (usingLogScale) {
        logX = 0.5 * (logStart + logEnd);
        x = 10.0 ** logX;
      } else {
        x = 0.5 * (xStart + xEnd);
      }

      // Linearly map x from mappingRange to [0, numberOfValues-1],
      // discretize (round down to the closest integer),
      // then map back to mappingRange
      if (model.discretize) {
        const range = model.mappingRange;
        if (x >= range[0] && x <= range[1]) {
          const numberOfValues = model.numberOfValues;
          const deltaRange = range[1] - range[0];
          if (numberOfValues <= 1) {
            x = range[0] + deltaRange / 2.0;
          } else {
            // normalize x
            const xn = (x - range[0]) / deltaRange;
            // discretize
            const discretizeIndex = (0,Core_Math.I)(numberOfValues * xn);
            // get discretized x
            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;
          }
        }
      }

      // Do we need to move to the next node?
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        // If we are at a valid point index, fill in
        // the value at this node, and the one before (the
        // two that surround our current sample location)
        // idx cannot be 0 since we just incremented it.
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          if (usingLogScale) {
            x1 = Math.log10(x1);
            x2 = Math.log10(x2);
          }
          rgb1[0] = model.nodes[idx - 1].r;
          rgb2[0] = model.nodes[idx].r;
          rgb1[1] = model.nodes[idx - 1].g;
          rgb2[1] = model.nodes[idx].g;
          rgb1[2] = model.nodes[idx - 1].b;
          rgb2[2] = model.nodes[idx].b;

          // We only need the previous midpoint and sharpness
          // since these control this region
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;

          // Move midpoint away from extreme ends of range to avoid
          // degenerate math
          if (midpoint < 0.00001) {
            midpoint = 0.00001;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }

      // Are we at or past the end? If so, just use the last value
      if (x > model.mappingRange[1]) {
        table[tidx] = 0.0;
        table[tidx + 1] = 0.0;
        table[tidx + 2] = 0.0;
        if (model.clamping) {
          if (publicAPI.getUseAboveRangeColor()) {
            table[tidx] = model.aboveRangeColor[0];
            table[tidx + 1] = model.aboveRangeColor[1];
            table[tidx + 2] = model.aboveRangeColor[2];
          } else {
            table[tidx] = lastR;
            table[tidx + 1] = lastG;
            table[tidx + 2] = lastB;
          }
        }
      } else if (x < model.mappingRange[0] || (0,Core_Math.J)(x) && x < 0) {
        // we are before the first node? If so, duplicate this node's values.
        // We have to deal with -inf here
        table[tidx] = 0.0;
        table[tidx + 1] = 0.0;
        table[tidx + 2] = 0.0;
        if (model.clamping) {
          if (publicAPI.getUseBelowRangeColor()) {
            table[tidx] = model.belowRangeColor[0];
            table[tidx + 1] = model.belowRangeColor[1];
            table[tidx + 2] = model.belowRangeColor[2];
          } else if (numNodes > 0) {
            table[tidx] = model.nodes[0].r;
            table[tidx + 1] = model.nodes[0].g;
            table[tidx + 2] = model.nodes[0].b;
          }
        }
      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {
        if (numNodes > 0) {
          table[tidx] = model.nodes[0].r;
          table[tidx + 1] = model.nodes[0].g;
          table[tidx + 2] = model.nodes[0].b;
        } else {
          table[tidx] = 0.0;
          table[tidx + 1] = 0.0;
          table[tidx + 2] = 0.0;
        }
      } else {
        // OK, we are between two nodes - interpolate
        // Our first attempt at a normalized location [0,1] -
        // we will be modifying this based on midpoint and
        // sharpness to get the curve shape we want and to have
        // it pass through (y1+y2)/2 at the midpoint.
        let s = 0.0;
        if (usingLogScale) {
          s = (logX - x1) / (x2 - x1);
        } else {
          s = (x - x1) / (x2 - x1);
        }

        // Readjust based on the midpoint - linear adjustment
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);
        }

        // override for sharpness > 0.99
        // In this case we just want piecewise constant
        if (sharpness > 0.99) {
          // Use the first value since we are below the midpoint
          if (s < 0.5) {
            table[tidx] = rgb1[0];
            table[tidx + 1] = rgb1[1];
            table[tidx + 2] = rgb1[2];
            continue;
          } else {
            // Use the second value at or above the midpoint
            table[tidx] = rgb2[0];
            table[tidx + 1] = rgb2[1];
            table[tidx + 2] = rgb2[2];
            continue;
          }
        }

        // Override for sharpness < 0.01
        // In this case we want piecewise linear
        if (sharpness < 0.01) {
          // Simple linear interpolation
          if (model.colorSpace === ColorTransferFunction_ColorSpace.RGB) {
            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];
            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];
            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];
          } else if (model.colorSpace === ColorTransferFunction_ColorSpace.HSV) {
            const hsv1 = [];
            const hsv2 = [];
            (0,Core_Math.K)(rgb1, hsv1);
            (0,Core_Math.K)(rgb2, hsv2);
            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
              if (hsv1[0] > hsv2[0]) {
                hsv1[0] -= 1.0;
              } else {
                hsv2[0] -= 1.0;
              }
            }
            const hsvTmp = [];
            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];
            if (hsvTmp[0] < 0.0) {
              hsvTmp[0] += 1.0;
            }
            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];
            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];

            // Now convert this back to RGB
            (0,Core_Math.h)(hsvTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorTransferFunction_ColorSpace.LAB) {
            const lab1 = [];
            const lab2 = [];
            (0,Core_Math.L)(rgb1, lab1);
            (0,Core_Math.L)(rgb2, lab2);
            const labTmp = [];
            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];
            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];
            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];

            // Now convert back to RGB
            (0,Core_Math.M)(labTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorTransferFunction_ColorSpace.DIVERGING) {
            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else {
            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);
          }
          continue;
        }

        // We have a sharpness between [0.01, 0.99] - we will
        // used a modified hermite curve interpolation where we
        // derive the slope based on the sharpness, and we compress
        // the curve non-linearly based on the sharpness

        // First, we will adjust our position based on sharpness in
        // order to make the curve sharper (closer to piecewise constant)
        if (s < 0.5) {
          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);
        } else if (s > 0.5) {
          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);
        }

        // Compute some coefficients we will need for the hermite curve
        const ss = s * s;
        const sss = ss * s;
        const h1 = 2.0 * sss - 3 * ss + 1;
        const h2 = -2 * sss + 3 * ss;
        const h3 = sss - 2 * ss + s;
        const h4 = sss - ss;
        let slope;
        let t;
        if (model.colorSpace === ColorTransferFunction_ColorSpace.RGB) {
          for (let j = 0; j < 3; j++) {
            // Use one slope for both end points
            slope = rgb2[j] - rgb1[j];
            t = (1.0 - sharpness) * slope;

            // Compute the value
            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;
          }
        } else if (model.colorSpace === ColorTransferFunction_ColorSpace.HSV) {
          const hsv1 = [];
          const hsv2 = [];
          (0,Core_Math.K)(rgb1, hsv1);
          (0,Core_Math.K)(rgb2, hsv2);
          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
            if (hsv1[0] > hsv2[0]) {
              hsv1[0] -= 1.0;
            } else {
              hsv2[0] -= 1.0;
            }
          }
          const hsvTmp = [];
          for (let j = 0; j < 3; j++) {
            // Use one slope for both end points
            slope = hsv2[j] - hsv1[j];
            t = (1.0 - sharpness) * slope;

            // Compute the value
            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;
            if (j === 0 && hsvTmp[j] < 0.0) {
              hsvTmp[j] += 1.0;
            }
          }
          // Now convert this back to RGB
          (0,Core_Math.h)(hsvTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorTransferFunction_ColorSpace.LAB) {
          const lab1 = [];
          const lab2 = [];
          (0,Core_Math.L)(rgb1, lab1);
          (0,Core_Math.L)(rgb2, lab2);
          const labTmp = [];
          for (let j = 0; j < 3; j++) {
            // Use one slope for both end points
            slope = lab2[j] - lab1[j];
            t = (1.0 - sharpness) * slope;

            // Compute the value
            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;
          }
          // Now convert this back to RGB
          (0,Core_Math.M)(labTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorTransferFunction_ColorSpace.DIVERGING) {
          // I have not implemented proper interpolation by a hermite curve for
          // the diverging color map, but I cannot think of a good use case for
          // that anyway.
          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else {
          vtkErrorMacro('ColorSpace set to invalid value.');
        }

        // Final error check to make sure we don't go outside [0,1]
        for (let j = 0; j < 3; j++) {
          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];
          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];
        }
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getUint8Table = function (xStart, xEnd, size) {
    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {
      return model.table;
    }
    if (model.nodes.length === 0) {
      vtkErrorMacro('Attempting to lookup a value with no points in the function');
      return model.table;
    }
    const nbChannels = withAlpha ? 4 : 3;
    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {
      model.table = new Uint8Array(size * nbChannels);
      model.tableSize = size;
      model.tableWithAlpha = withAlpha;
    }
    const tmpTable = [];
    publicAPI.getTable(xStart, xEnd, size, tmpTable);
    for (let i = 0; i < size; i++) {
      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);
      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);
      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);
      if (withAlpha) {
        model.table[i * nbChannels + 3] = 255;
      }
    }
    model.buildTime.modified();
    return model.table;
  };
  publicAPI.buildFunctionFromArray = array => {
    publicAPI.removeAllPoints();
    const numComponents = array.getNumberOfComponents();
    for (let i = 0; i < array.getNumberOfTuples(); i++) {
      switch (numComponents) {
        case 3:
          {
            model.nodes.push({
              x: i,
              r: array.getComponent(i, 0),
              g: array.getComponent(i, 1),
              b: array.getComponent(i, 2),
              midpoint: 0.5,
              sharpness: 0.0
            });
            break;
          }
        case 4:
          {
            model.nodes.push({
              x: array.getComponent(i, 0),
              r: array.getComponent(i, 1),
              g: array.getComponent(i, 2),
              b: array.getComponent(i, 3),
              midpoint: 0.5,
              sharpness: 0.0
            });
            break;
          }
        case 5:
          {
            model.nodes.push({
              x: i,
              r: array.getComponent(i, 0),
              g: array.getComponent(i, 1),
              b: array.getComponent(i, 2),
              midpoint: array.getComponent(i, 4),
              sharpness: array.getComponent(i, 5)
            });
            break;
          }
        case 6:
          {
            model.nodes.push({
              x: array.getComponent(i, 0),
              r: array.getComponent(i, 1),
              g: array.getComponent(i, 2),
              b: array.getComponent(i, 3),
              midpoint: array.getComponent(i, 4),
              sharpness: array.getComponent(i, 5)
            });
            break;
          }
      }
    }
    publicAPI.sortAndUpdateRange();
  };

  //----------------------------------------------------------------------------
  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {
    let inc = 0.0;
    publicAPI.removeAllPoints();
    if (size > 1) {
      inc = (xEnd - xStart) / (size - 1.0);
    }
    for (let i = 0; i < size; i++) {
      const node = {
        x: xStart + inc * i,
        r: table[i * 3],
        g: table[i * 3 + 1],
        b: table[i * 3 + 2],
        sharpness: 0.0,
        midpoint: 0.5
      };
      model.nodes.push(node);
    }
    publicAPI.sortAndUpdateRange();
  };

  //----------------------------------------------------------------------------
  // For a specified index value, get the node parameters
  publicAPI.getNodeValue = (index, val) => {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro('Index out of range!');
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].r;
    val[2] = model.nodes[index].g;
    val[3] = model.nodes[index].b;
    val[4] = model.nodes[index].midpoint;
    val[5] = model.nodes[index].sharpness;
    return 1;
  };

  //----------------------------------------------------------------------------
  // For a specified index value, get the node parameters
  publicAPI.setNodeValue = (index, val) => {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro('Index out of range!');
      return -1;
    }
    const oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].r = val[1];
    model.nodes[index].g = val[2];
    model.nodes[index].b = val[3];
    model.nodes[index].midpoint = val[4];
    model.nodes[index].sharpness = val[5];
    if (oldX !== val[0]) {
      // The point has been moved, the order of points or the range might have
      // been modified.
      publicAPI.sortAndUpdateRange();
      // No need to call Modified() here because SortAndUpdateRange() has done it
      // already.
    } else {
      publicAPI.modified();
    }
    return 1;
  };

  //----------------------------------------------------------------------------
  publicAPI.getNumberOfAvailableColors = () => {
    if (model.indexedLookup && publicAPI.getSize()) {
      return publicAPI.getSize();
    }
    if (model.tableSize) {
      // Not sure if this is correct since it is only set if
      // "const unsigned char *::GetTable(double xStart, double xEnd,int size)"
      // has been called.
      return model.tableSize;
    }
    const nNodes = model.nodes?.length ?? 0;
    // The minimum is 4094 colors so that it fills in the 4096 texels texture in `mapScalarsToTexture`
    return Math.max(4094, nNodes);
  };

  //----------------------------------------------------------------------------
  publicAPI.getIndexedColor = (idx, rgba) => {
    const n = publicAPI.getSize();
    if (n > 0 && idx >= 0) {
      const nodeValue = [];
      publicAPI.getNodeValue(idx % n, nodeValue);
      for (let j = 0; j < 3; ++j) {
        rgba[j] = nodeValue[j + 1];
      }
      rgba[3] = 1.0; // NodeColor is RGB-only.
      return;
    }
    const nanColor = publicAPI.getNanColorByReference();
    rgba[0] = nanColor[0];
    rgba[1] = nanColor[1];
    rgba[2] = nanColor[2];
    rgba[3] = 1.0; // NanColor is RGB-only.
  };

  //----------------------------------------------------------------------------
  publicAPI.fillFromDataPointer = (nb, ptr) => {
    if (nb <= 0 || !ptr) {
      return;
    }
    publicAPI.removeAllPoints();
    for (let i = 0; i < nb; i++) {
      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.setMappingRange = (min, max) => {
    const range = [min, max];
    const originalRange = publicAPI.getRange();
    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {
      return;
    }
    if (range[1] === range[0]) {
      vtkErrorMacro('attempt to set zero width color range');
      return;
    }
    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);
    const shift = range[0] - originalRange[0] * scale;
    for (let i = 0; i < model.nodes.length; ++i) {
      model.nodes[i].x = model.nodes[i].x * scale + shift;
    }
    model.mappingRange[0] = range[0];
    model.mappingRange[1] = range[1];
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.adjustRange = range => {
    const functionRange = publicAPI.getRange();

    // Make sure we have points at each end of the range
    const rgb = [];
    if (functionRange[0] < range[0]) {
      publicAPI.getColor(range[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    }
    if (functionRange[1] > range[1]) {
      publicAPI.getColor(range[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    }

    // Remove all points out-of-range
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length;) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    return 1;
  };

  //--------------------------------------------------------------------------
  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
    const d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };

  //----------------------------------------------------------------------------
  publicAPI.findMinimumXDistance = () => {
    if (model.nodes.length < 2) {
      return -1.0;
    }
    let distance = Number.MAX_VALUE;
    for (let i = 0; i < model.nodes.length - 1; i++) {
      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    if (publicAPI.getSize() === 0) {
      vtkDebugMacro('Transfer Function Has No Points!');
      return;
    }
    if (model.indexedLookup) {
      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);
    } else {
      publicAPI.mapData(input, output, outFormat, inputOffset);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.mapData = (input, output, outFormat, inputOffset) => {
    if (publicAPI.getSize() === 0) {
      vtkWarningMacro('Transfer Function Has No Points!');
      return;
    }
    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    const rgb = [];
    if (outFormat === ScalarMappingTarget.RGBA) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);
        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);
        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);
        outputV[i * 4 + 3] = alpha;
      }
    }
    if (outFormat === ScalarMappingTarget.RGB) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);
        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);
        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
        outputV[i * 2 + 1] = alpha;
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.applyColorMap = colorMap => {
    const oldColorSpace = JSON.stringify(model.colorSpace);
    if (colorMap.ColorSpace) {
      model.colorSpace = ColorTransferFunction_ColorSpace[colorMap.ColorSpace.toUpperCase()];
      if (model.colorSpace === undefined) {
        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);
        model.colorSpace = ColorTransferFunction_ColorSpace.RGB;
      }
    }
    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);
    const oldNanColor = isModified || JSON.stringify(model.nanColor);
    if (colorMap.NanColor) {
      model.nanColor = [].concat(colorMap.NanColor);
      while (model.nanColor.length < 4) {
        model.nanColor.push(1.0);
      }
    }
    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);
    const oldNodes = isModified || JSON.stringify(model.nodes);
    if (colorMap.RGBPoints) {
      const size = colorMap.RGBPoints.length;
      model.nodes = [];
      const midpoint = 0.5;
      const sharpness = 0.0;
      for (let i = 0; i < size; i += 4) {
        model.nodes.push({
          x: colorMap.RGBPoints[i],
          r: colorMap.RGBPoints[i + 1],
          g: colorMap.RGBPoints[i + 2],
          b: colorMap.RGBPoints[i + 3],
          midpoint,
          sharpness
        });
      }
    }
    const modifiedInvoked = publicAPI.sortAndUpdateRange();
    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));
    if (callModified) publicAPI.modified();
    return modifiedInvoked || callModified;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  clamping: true,
  colorSpace: ColorTransferFunction_ColorSpace.RGB,
  hSVWrap: true,
  scale: ColorTransferFunction_Scale.LINEAR,
  nanColor: null,
  belowRangeColor: null,
  aboveRangeColor: null,
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  allowDuplicateScalars: false,
  table: null,
  tableSize: 0,
  buildTime: null,
  nodes: null,
  discretize: false,
  numberOfValues: 256
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  ScalarsToColors/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // Internal objects initialization
  model.table = [];
  model.nodes = [];
  model.nanColor = [0.5, 0.0, 0.0, 1.0];
  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];
  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];
  model.buildTime = {};
  macros2.m.obj(model.buildTime);

  // Create get-only macros
  macros2.m.get(publicAPI, model, ['buildTime', 'mappingRange']);

  // Create get-set macros
  macros2.m.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'discretize', 'numberOfValues', {
    type: 'enum',
    name: 'colorSpace',
    enum: ColorTransferFunction_ColorSpace
  }, {
    type: 'enum',
    name: 'scale',
    enum: ColorTransferFunction_Scale
  }]);
  macros2.m.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);

  // Create get macros for array
  macros2.m.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkColorTransferFunction(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkColorTransferFunction');

// ----------------------------------------------------------------------------

var vtkColorTransferFunction$1 = {
  newInstance,
  extend,
  ...Constants
};




/***/ }),

/***/ 660:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ ColorMaps_vtkColorMaps)
});

;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.json.js
var vtkColorMaps = [
	{
		Name: "KAAMS",
		IndexedColors: [
			1,
			1,
			1,
			1,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			1,
			1,
			1,
			0,
			1,
			0,
			1,
			0,
			1,
			1,
			0.63,
			0.63,
			1,
			0.67,
			0.5,
			0.33,
			1,
			0.5,
			0.75,
			0.53,
			0.35,
			0.7,
			1,
			0.75,
			0.5
		],
		Annotations: [
			0,
			0,
			1,
			1,
			2,
			2,
			3,
			3,
			4,
			4,
			5,
			5,
			6,
			6,
			7,
			7,
			8,
			8,
			9,
			9,
			10,
			10,
			11,
			11
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Cool to Warm",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0.23137254902,
			0.298039215686,
			0.752941176471,
			0.5,
			0.865,
			0.865,
			0.865,
			1,
			0.705882352941,
			0.0156862745098,
			0.149019607843
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Cool to Warm (Extended)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0.34902,
			0.03125,
			0.039216,
			0.062745,
			0.380392,
			0.0625,
			0.062745,
			0.117647,
			0.411765,
			0.09375,
			0.090196,
			0.184314,
			0.45098,
			0.125,
			0.12549,
			0.262745,
			0.501961,
			0.15625,
			0.160784,
			0.337255,
			0.541176,
			0.1875,
			0.2,
			0.396078,
			0.568627,
			0.21875,
			0.239216,
			0.454902,
			0.6,
			0.25,
			0.286275,
			0.521569,
			0.65098,
			0.28125,
			0.337255,
			0.592157,
			0.701961,
			0.3125,
			0.388235,
			0.654902,
			0.74902,
			0.34375,
			0.466667,
			0.737255,
			0.819608,
			0.375,
			0.572549,
			0.819608,
			0.878431,
			0.40625,
			0.654902,
			0.866667,
			0.909804,
			0.4375,
			0.752941,
			0.917647,
			0.941176,
			0.46875,
			0.823529,
			0.956863,
			0.968627,
			0.5,
			0.988235,
			0.960784,
			0.901961,
			0.5,
			0.941176,
			0.984314,
			0.988235,
			0.52,
			0.988235,
			0.945098,
			0.85098,
			0.54,
			0.980392,
			0.898039,
			0.784314,
			0.5625,
			0.968627,
			0.835294,
			0.698039,
			0.59375,
			0.94902,
			0.733333,
			0.588235,
			0.625,
			0.929412,
			0.65098,
			0.509804,
			0.65625,
			0.909804,
			0.564706,
			0.435294,
			0.6875,
			0.878431,
			0.458824,
			0.352941,
			0.71875,
			0.839216,
			0.388235,
			0.286275,
			0.75,
			0.760784,
			0.294118,
			0.211765,
			0.78125,
			0.701961,
			0.211765,
			0.168627,
			0.8125,
			0.65098,
			0.156863,
			0.129412,
			0.84375,
			0.6,
			0.094118,
			0.094118,
			0.875,
			0.54902,
			0.066667,
			0.098039,
			0.90625,
			0.501961,
			0.05098,
			0.12549,
			0.9375,
			0.45098,
			0.054902,
			0.172549,
			0.96875,
			0.4,
			0.054902,
			0.192157,
			1,
			0.34902,
			0.070588,
			0.211765
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Warm to Cool",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0.705882352941,
			0.0156862745098,
			0.149019607843,
			0.5,
			0.865,
			0.865,
			0.865,
			1,
			0.23137254902,
			0.298039215686,
			0.752941176471
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Warm to Cool (Extended)",
		NanColor: [
			0.250004,
			0,
			0
		],
		RGBPoints: [
			0,
			0.34902,
			0,
			0.129412,
			0.025,
			0.4,
			0.00392157,
			0.101961,
			0.05,
			0.470588,
			0.0156863,
			0.0901961,
			0.075,
			0.54902,
			0.027451,
			0.0705882,
			0.1,
			0.619608,
			0.0627451,
			0.0431373,
			0.125,
			0.690196,
			0.12549,
			0.0627451,
			0.15,
			0.741176,
			0.184314,
			0.0745098,
			0.175,
			0.788235,
			0.266667,
			0.0941176,
			0.2,
			0.811765,
			0.345098,
			0.113725,
			0.225,
			0.831373,
			0.411765,
			0.133333,
			0.25,
			0.85098,
			0.47451,
			0.145098,
			0.275,
			0.870588,
			0.54902,
			0.156863,
			0.3,
			0.878431,
			0.619608,
			0.168627,
			0.325,
			0.890196,
			0.658824,
			0.196078,
			0.35,
			0.909804,
			0.717647,
			0.235294,
			0.375,
			0.929412,
			0.776471,
			0.278431,
			0.395522,
			0.94902,
			0.823529,
			0.321569,
			0.418905,
			0.968627,
			0.87451,
			0.407843,
			0.444278,
			0.980392,
			0.917647,
			0.509804,
			0.470149,
			0.988235,
			0.956863,
			0.643137,
			0.483582,
			0.992157,
			0.964706,
			0.713725,
			0.499,
			0.988235,
			0.980392,
			0.870588,
			0.5,
			1,
			1,
			1,
			0.501,
			0.913725,
			0.988235,
			0.937255,
			0.516418,
			0.827451,
			0.980392,
			0.886275,
			0.531343,
			0.764706,
			0.980392,
			0.866667,
			0.546766,
			0.658824,
			0.980392,
			0.843137,
			0.564179,
			0.572549,
			0.964706,
			0.835294,
			0.587562,
			0.423529,
			0.941176,
			0.87451,
			0.60597,
			0.262745,
			0.901961,
			0.862745,
			0.629851,
			0.0705882,
			0.854902,
			0.870588,
			0.651741,
			0.0509804,
			0.8,
			0.85098,
			0.681592,
			0.0235294,
			0.709804,
			0.831373,
			0.712935,
			0.0313725,
			0.615686,
			0.811765,
			0.75,
			0.0313725,
			0.537255,
			0.788235,
			0.775,
			0.0392157,
			0.466667,
			0.768627,
			0.8,
			0.0509804,
			0.396078,
			0.741176,
			0.825,
			0.054902,
			0.317647,
			0.709804,
			0.85,
			0.054902,
			0.243137,
			0.678431,
			0.875,
			0.0431373,
			0.164706,
			0.639216,
			0.9,
			0.0313725,
			0.0980392,
			0.6,
			0.925,
			0.0392157,
			0.0392157,
			0.560784,
			0.95,
			0.105882,
			0.0509804,
			0.509804,
			0.975,
			0.113725,
			0.0235294,
			0.45098,
			1,
			0.12549,
			0,
			0.380392
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Rainbow Desaturated",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0.278431372549,
			0.278431372549,
			0.858823529412,
			0.143,
			0,
			0,
			0.360784313725,
			0.285,
			0,
			1,
			1,
			0.429,
			0,
			0.501960784314,
			0,
			0.571,
			1,
			1,
			0,
			0.714,
			1,
			0.380392156863,
			0,
			0.857,
			0.419607843137,
			0,
			0,
			1,
			0.878431372549,
			0.301960784314,
			0.301960784314
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Cold and Hot",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			1,
			1,
			0.45,
			0,
			0,
			1,
			0.5,
			0,
			0,
			0.501960784314,
			0.55,
			1,
			0,
			0,
			1,
			1,
			1,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Black-Body Radiation",
		NanColor: [
			0,
			0.498039215686,
			1
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			0.4,
			0.901960784314,
			0,
			0,
			0.8,
			0.901960784314,
			0.901960784314,
			0,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "X Ray",
		NanColor: [
			1,
			0,
			0
		],
		RGBPoints: [
			0,
			1,
			1,
			1,
			1,
			0,
			0,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Grayscale",
		NanColor: [
			1,
			0,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkRd",
		NanColor: [
			0,
			1,
			1
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkGn",
		NanColor: [
			1,
			0,
			1
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			0,
			1,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkBu",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			0,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkMa",
		NanColor: [
			0,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			1,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkCy",
		NanColor: [
			0,
			1,
			1
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			0,
			1,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Black, Blue and White",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			0.333,
			0,
			0,
			0.501960784314,
			0.666,
			0,
			0.501960784314,
			1,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Black, Orange and White",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			0.333,
			0.501960784314,
			0,
			0,
			0.666,
			1,
			0.501960784314,
			0,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Linear YGB 1211g",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			1,
			0.988235,
			0.968627,
			0.02,
			1,
			0.952941,
			0.878431,
			0.05,
			0.968627,
			0.905882,
			0.776471,
			0.1,
			0.94902,
			0.898039,
			0.647059,
			0.15,
			0.901961,
			0.878431,
			0.556863,
			0.2,
			0.847059,
			0.858824,
			0.482353,
			0.25,
			0.690196,
			0.819608,
			0.435294,
			0.3,
			0.513725,
			0.768627,
			0.384314,
			0.35,
			0.337255,
			0.721569,
			0.337255,
			0.4,
			0.278431,
			0.658824,
			0.392157,
			0.45,
			0.231373,
			0.639216,
			0.435294,
			0.5,
			0.203922,
			0.6,
			0.486275,
			0.55,
			0.172549,
			0.568627,
			0.537255,
			0.6,
			0.141176,
			0.517647,
			0.54902,
			0.65,
			0.133333,
			0.458824,
			0.541176,
			0.7,
			0.12549,
			0.396078,
			0.529412,
			0.75,
			0.117647,
			0.321569,
			0.521569,
			0.8,
			0.121569,
			0.258824,
			0.509804,
			0.85,
			0.133333,
			0.227451,
			0.501961,
			0.9,
			0.145098,
			0.192157,
			0.490196,
			0.95,
			0.188235,
			0.164706,
			0.470588,
			1,
			0.258824,
			0.196078,
			0.439216
		]
	},
	{
		ColorSpace: "CIELAB",
		Creator: "Francesca Samsel",
		Name: "Linear Green (Gr4L)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.054902,
			0.109804,
			0.121569,
			0.05,
			0.07451,
			0.172549,
			0.180392,
			0.1,
			0.086275,
			0.231373,
			0.219608,
			0.15,
			0.094118,
			0.278431,
			0.25098,
			0.2,
			0.109804,
			0.34902,
			0.278431,
			0.25,
			0.113725,
			0.4,
			0.278431,
			0.3,
			0.117647,
			0.45098,
			0.270588,
			0.35,
			0.117647,
			0.490196,
			0.243137,
			0.4,
			0.113725,
			0.521569,
			0.203922,
			0.45,
			0.109804,
			0.54902,
			0.152941,
			0.5,
			0.082353,
			0.588235,
			0.082353,
			0.55,
			0.109804,
			0.631373,
			0.05098,
			0.6,
			0.211765,
			0.678431,
			0.082353,
			0.65,
			0.317647,
			0.721569,
			0.113725,
			0.7,
			0.431373,
			0.760784,
			0.160784,
			0.75,
			0.556863,
			0.8,
			0.239216,
			0.8,
			0.666667,
			0.839216,
			0.294118,
			0.85,
			0.784314,
			0.878431,
			0.396078,
			0.9,
			0.886275,
			0.921569,
			0.533333,
			0.95,
			0.960784,
			0.94902,
			0.670588,
			1,
			1,
			0.984314,
			0.901961
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Linear Blue (8_31f)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.960784,
			1,
			0.980392,
			0.05,
			0.815686,
			0.960784,
			0.913725,
			0.1,
			0.670588,
			0.929412,
			0.870588,
			0.15,
			0.556863,
			0.901961,
			0.843137,
			0.2,
			0.478431,
			0.870588,
			0.823529,
			0.25,
			0.439216,
			0.831373,
			0.803922,
			0.3,
			0.4,
			0.8,
			0.788235,
			0.35,
			0.376471,
			0.768627,
			0.768627,
			0.4,
			0.34902,
			0.709804,
			0.729412,
			0.45,
			0.32549,
			0.654902,
			0.690196,
			0.5,
			0.301961,
			0.607843,
			0.658824,
			0.55,
			0.247059,
			0.545098,
			0.619608,
			0.6,
			0.239216,
			0.494118,
			0.580392,
			0.65,
			0.227451,
			0.439216,
			0.541176,
			0.7,
			0.227451,
			0.403922,
			0.521569,
			0.75,
			0.231373,
			0.368627,
			0.501961,
			0.8,
			0.227451,
			0.321569,
			0.470588,
			0.85,
			0.219608,
			0.282353,
			0.439216,
			0.9,
			0.192157,
			0.235294,
			0.4,
			0.95,
			0.160784,
			0.184314,
			0.34902,
			1,
			0.133333,
			0.12549,
			0.301961
		]
	},
	{
		ColorSpace: "HSV",
		Name: "Blue to Red Rainbow",
		NanColor: [
			0.498039215686,
			0.498039215686,
			0.498039215686
		],
		RGBPoints: [
			0,
			0,
			0,
			1,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "HSV",
		Name: "Red to Blue Rainbow",
		NanColor: [
			0.498039215686,
			0.498039215686,
			0.498039215686
		],
		RGBPoints: [
			0,
			1,
			0,
			0,
			1,
			0,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Rainbow Blended White",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			1,
			1,
			1,
			0.17,
			0,
			0,
			1,
			0.34,
			0,
			1,
			1,
			0.5,
			0,
			1,
			0,
			0.67,
			1,
			1,
			0,
			0.84,
			1,
			0,
			0,
			1,
			0.878431372549,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Rainbow Blended Grey",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0.317647058824,
			0.341176470588,
			0.43137254902,
			0.17,
			0,
			0,
			1,
			0.34,
			0,
			1,
			1,
			0.5,
			0,
			1,
			0,
			0.67,
			1,
			1,
			0,
			0.84,
			1,
			0,
			0,
			1,
			0.878431372549,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Rainbow Blended Black",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			0.17,
			0,
			0,
			1,
			0.34,
			0,
			1,
			1,
			0.5,
			0,
			1,
			0,
			0.67,
			1,
			1,
			0,
			0.84,
			1,
			0,
			0,
			1,
			0.878431372549,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Blue to Yellow",
		NanColor: [
			1,
			0,
			0
		],
		RGBPoints: [
			0,
			0.0392156862745,
			0.0392156862745,
			0.949019607843,
			1,
			0.949019607843,
			0.949019607843,
			0.0392156862745
		]
	},
	{
		ColorSpace: "HSV",
		Name: "blot",
		RGBPoints: [
			0,
			0,
			0,
			1,
			0.166,
			0,
			0,
			1,
			0.167,
			1,
			0,
			1,
			0.332,
			1,
			0,
			1,
			0.333,
			0,
			1,
			1,
			0.5,
			0,
			1,
			1,
			0.501,
			0,
			1,
			0,
			0.666,
			0,
			1,
			0,
			0.667,
			1,
			1,
			0,
			0.832,
			1,
			1,
			0,
			0.833,
			1,
			0,
			0,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "CIELab Blue to Red",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0.6,
			0.749019607843,
			1,
			0.76862745098,
			0.466666666667,
			0.341176470588
		]
	},
	{
		ColorSpace: "RGB",
		Name: "jet",
		RGBPoints: [
			-1,
			0,
			0,
			0.5625,
			-0.777778,
			0,
			0,
			1,
			-0.269841,
			0,
			1,
			1,
			-0.015873,
			0.5,
			1,
			0.5,
			0.238095,
			1,
			1,
			0,
			0.746032,
			1,
			0,
			0,
			1,
			0.5,
			0,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "rainbow",
		RGBPoints: [
			-1,
			0,
			0,
			1,
			-0.5,
			0,
			1,
			1,
			0,
			0,
			1,
			0,
			0.5,
			1,
			1,
			0,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_rainbow_bright",
		RGBPoints: [
			-1,
			0.32549,
			0.14902,
			0.960784,
			-0.866221,
			0.297047,
			0.375586,
			0.963836,
			-0.732441,
			0.180302,
			0.536818,
			0.964627,
			-0.598662,
			0.1302,
			0.649207,
			0.929647,
			-0.464883,
			0.0445143,
			0.749654,
			0.855998,
			-0.331104,
			0.0271325,
			0.830713,
			0.721527,
			-0.197324,
			0.259504,
			0.866145,
			0.543555,
			-0.0635452,
			0.428364,
			0.890725,
			0.329819,
			0.0702341,
			0.568503,
			0.898508,
			0.187623,
			0.204013,
			0.738259,
			0.890317,
			0.0825461,
			0.337793,
			0.84546,
			0.86136,
			0.0147555,
			0.471572,
			0.912191,
			0.808018,
			0,
			0.605351,
			0.962848,
			0.710445,
			0,
			0.73913,
			0.999469,
			0.600258,
			0.0176284,
			0.87291,
			0.994156,
			0.445975,
			0.193912,
			1,
			0.980407,
			0.247105,
			0.262699
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_rainbow_dark",
		RGBPoints: [
			-1,
			0,
			0,
			0.423499,
			-0.866221,
			0,
			0.119346,
			0.529237,
			-0.732441,
			0,
			0.238691,
			0.634976,
			-0.598662,
			0,
			0.346852,
			0.68788,
			-0.464883,
			0,
			0.45022,
			0.718141,
			-0.331104,
			0,
			0.553554,
			0.664839,
			-0.197324,
			0,
			0.651082,
			0.519303,
			-0.0635452,
			0.115841,
			0.72479,
			0.352857,
			0.0702341,
			0.326771,
			0.781195,
			0.140187,
			0.204013,
			0.522765,
			0.798524,
			0.0284624,
			0.337793,
			0.703162,
			0.788685,
			0.00885756,
			0.471572,
			0.845118,
			0.751133,
			0,
			0.605351,
			0.955734,
			0.690825,
			0,
			0.73913,
			0.995402,
			0.567916,
			0.0618524,
			0.87291,
			0.987712,
			0.403398,
			0.164851,
			1,
			0.980407,
			0.247105,
			0.262699
		]
	},
	{
		ColorSpace: "Lab",
		Name: "nic_CubicL",
		RGBPoints: [
			-1,
			0.479965,
			0.0118108,
			0.5307,
			-0.87451,
			0.522213,
			0.0551282,
			0.706919,
			-0.74902,
			0.50839,
			0.237278,
			0.867764,
			-0.623529,
			0.451617,
			0.373834,
			0.987255,
			-0.498039,
			0.39365,
			0.497255,
			0.97506,
			-0.372549,
			0.328631,
			0.599639,
			0.891843,
			-0.247059,
			0.250043,
			0.690286,
			0.778553,
			-0.121569,
			0.249656,
			0.764905,
			0.645857,
			0.00392157,
			0.297954,
			0.821466,
			0.50449,
			0.129412,
			0.337509,
			0.872595,
			0.358447,
			0.254902,
			0.430011,
			0.913789,
			0.297079,
			0.380392,
			0.587191,
			0.931381,
			0.333353,
			0.505882,
			0.727937,
			0.93591,
			0.353742,
			0.631373,
			0.826403,
			0.921081,
			0.365066,
			0.756863,
			0.893201,
			0.846317,
			0.372662,
			0.882353,
			0.965347,
			0.73884,
			0.378506,
			1,
			0.983235,
			0.597451,
			0.366856
		]
	},
	{
		ColorSpace: "Lab",
		Name: "nic_CubicYF",
		RGBPoints: [
			-1,
			0.5151,
			0.0482,
			0.6697,
			-0.87451,
			0.520711,
			0.168955,
			0.800574,
			-0.74902,
			0.493694,
			0.278596,
			0.911824,
			-0.623529,
			0.440026,
			0.369475,
			0.984978,
			-0.498039,
			0.398932,
			0.457593,
			0.987053,
			-0.372549,
			0.350651,
			0.540644,
			0.929608,
			-0.247059,
			0.298827,
			0.615625,
			0.857729,
			-0.121569,
			0.239928,
			0.685061,
			0.769531,
			0.00392157,
			0.228832,
			0.739349,
			0.673287,
			0.129412,
			0.263297,
			0.78608,
			0.569988,
			0.254902,
			0.298107,
			0.828337,
			0.460214,
			0.380392,
			0.33092,
			0.864071,
			0.352674,
			0.505882,
			0.38306,
			0.898169,
			0.287309,
			0.631373,
			0.49023,
			0.917481,
			0.307961,
			0.756863,
			0.62372,
			0.926026,
			0.332309,
			0.882353,
			0.717458,
			0.92527,
			0.342476,
			1,
			0.8,
			0.9255,
			0.3529
		]
	},
	{
		ColorSpace: "Lab",
		Name: "gist_earth",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.239216,
			0.027451,
			0.415686,
			-0.74902,
			0.0901961,
			0.254902,
			0.556863,
			-0.623529,
			0.0941176,
			0.352941,
			0.54902,
			-0.498039,
			0.105882,
			0.435294,
			0.533333,
			-0.372549,
			0.12549,
			0.52549,
			0.501961,
			-0.247059,
			0.156863,
			0.596078,
			0.443137,
			-0.121569,
			0.196078,
			0.65098,
			0.380392,
			0.00392157,
			0.282353,
			0.717647,
			0.301961,
			0.129412,
			0.466667,
			0.772549,
			0.27451,
			0.254902,
			0.678431,
			0.784314,
			0.309804,
			0.380392,
			0.901961,
			0.756863,
			0.376471,
			0.505882,
			0.992157,
			0.705882,
			0.521569,
			0.631373,
			1,
			0.721569,
			0.701961,
			0.756863,
			1,
			0.784314,
			0.784314,
			0.882353,
			1,
			0.866667,
			0.866667,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "2hot",
		RGBPoints: [
			-1,
			0.0416667,
			0,
			0,
			-0.873016,
			0.208333,
			0,
			0,
			-0.746032,
			0.375,
			0,
			0,
			-0.619048,
			0.541667,
			0,
			0,
			-0.492063,
			0.708333,
			0,
			0,
			-0.365079,
			0.854137,
			0,
			0,
			-0.238095,
			0.937488,
			0.039062,
			0,
			-0.111111,
			1,
			0.208333,
			0,
			0.015873,
			1,
			0.375,
			0,
			0.142857,
			1,
			0.541667,
			0,
			0.269841,
			1,
			0.708333,
			0,
			0.396825,
			1,
			0.858805,
			0.03125,
			0.52381,
			1,
			0.947392,
			0.15625,
			0.650794,
			1,
			1,
			0.3125,
			0.777778,
			1,
			1,
			0.5625,
			0.904762,
			1,
			1,
			0.8125,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_red2yellow_BW",
		RGBPoints: [
			-1,
			7.54296e-7,
			0,
			0.0000109827,
			-0.87451,
			0.18285,
			0.0264094,
			0,
			-0.74902,
			0.3066,
			0,
			0,
			-0.623529,
			0.422841,
			0,
			0,
			-0.498039,
			0.522945,
			0,
			0,
			-0.372549,
			0.605721,
			0,
			0,
			-0.247059,
			0.672502,
			0.14168,
			0,
			-0.121569,
			0.728167,
			0.244025,
			0,
			0.00392157,
			0.781215,
			0.333454,
			0,
			0.129412,
			0.825,
			0.423586,
			0,
			0.254902,
			0.855893,
			0.516793,
			0,
			0.380392,
			0.880491,
			0.608846,
			0,
			0.505882,
			0.910305,
			0.695505,
			0,
			0.631373,
			0.94109,
			0.779067,
			0.223528,
			0.756863,
			0.967873,
			0.858572,
			0.473521,
			0.882353,
			0.986815,
			0.933211,
			0.751583,
			1,
			1,
			1,
			0.999997
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_marine2gold_BW",
		RGBPoints: [
			-1,
			1.11641e-7,
			0,
			0.00000162551,
			-0.87451,
			0.0413146,
			0.0619808,
			0.209857,
			-0.74902,
			0.0185557,
			0.101341,
			0.350684,
			-0.623529,
			0.00486405,
			0.149847,
			0.461054,
			-0.498039,
			0.0836345,
			0.210845,
			0.517906,
			-0.372549,
			0.173222,
			0.276134,
			0.541793,
			-0.247059,
			0.259857,
			0.343877,
			0.535869,
			-0.121569,
			0.362299,
			0.408124,
			0.504293,
			0.00392157,
			0.468266,
			0.468276,
			0.468257,
			0.129412,
			0.582781,
			0.527545,
			0.374914,
			0.254902,
			0.691591,
			0.585251,
			0.274266,
			0.380392,
			0.784454,
			0.645091,
			0.247332,
			0.505882,
			0.862299,
			0.710383,
			0.27518,
			0.631373,
			0.920863,
			0.782923,
			0.351563,
			0.756863,
			0.955792,
			0.859699,
			0.533541,
			0.882353,
			0.976162,
			0.93433,
			0.780671,
			1,
			1,
			1,
			0.999983
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2gold_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.0742735,
			0.0440331,
			0.230013,
			-0.74902,
			0.125276,
			0.0258685,
			0.415826,
			-0.623529,
			0.143879,
			0.0163031,
			0.591346,
			-0.498039,
			0.212261,
			0.0627855,
			0.705239,
			-0.372549,
			0.306048,
			0.141178,
			0.763636,
			-0.247059,
			0.391537,
			0.232286,
			0.773263,
			-0.121569,
			0.461734,
			0.336633,
			0.708321,
			0.00392157,
			0.54209,
			0.427581,
			0.590007,
			0.129412,
			0.61704,
			0.508623,
			0.460978,
			0.254902,
			0.702703,
			0.579586,
			0.309117,
			0.380392,
			0.790336,
			0.644811,
			0.170397,
			0.505882,
			0.870173,
			0.710733,
			0.117134,
			0.631373,
			0.93656,
			0.781991,
			0.157144,
			0.756863,
			0.965672,
			0.862068,
			0.409836,
			0.882353,
			0.985751,
			0.936296,
			0.714162,
			1,
			1,
			1,
			0.999999
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_sapphire2gold_BW",
		RGBPoints: [
			-1,
			0.107704,
			0.107708,
			0.107694,
			-0.87451,
			0.1851,
			0.112354,
			0.308554,
			-0.74902,
			0.236782,
			0.114233,
			0.48788,
			-0.623529,
			0.28296,
			0.126187,
			0.639464,
			-0.498039,
			0.344787,
			0.171643,
			0.739713,
			-0.372549,
			0.413325,
			0.242371,
			0.76913,
			-0.247059,
			0.481863,
			0.3131,
			0.719841,
			-0.121569,
			0.550402,
			0.383829,
			0.612222,
			0.00392157,
			0.61894,
			0.454558,
			0.51126,
			0.129412,
			0.687478,
			0.525287,
			0.39993,
			0.254902,
			0.756017,
			0.596016,
			0.289923,
			0.380392,
			0.824555,
			0.666745,
			0.255498,
			0.505882,
			0.892979,
			0.736822,
			0.27696,
			0.631373,
			0.938851,
			0.804966,
			0.351734,
			0.756863,
			0.966491,
			0.874853,
			0.53572,
			0.882353,
			0.982105,
			0.94153,
			0.782579,
			1,
			1,
			1,
			0.999986
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_red2purple_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.167793,
			0.0166271,
			0.0431278,
			-0.74902,
			0.262608,
			0.0107595,
			0.0791181,
			-0.623529,
			0.351902,
			0.0101858,
			0.100926,
			-0.498039,
			0.441257,
			0.0160835,
			0.131919,
			-0.372549,
			0.5221,
			0.0555972,
			0.195625,
			-0.247059,
			0.593852,
			0.104294,
			0.310234,
			-0.121569,
			0.654628,
			0.158115,
			0.448486,
			0.00392157,
			0.707443,
			0.220914,
			0.570253,
			0.129412,
			0.749504,
			0.293268,
			0.67897,
			0.254902,
			0.781587,
			0.370517,
			0.779269,
			0.380392,
			0.809951,
			0.451099,
			0.855831,
			0.505882,
			0.84424,
			0.531462,
			0.900451,
			0.631373,
			0.865174,
			0.620901,
			0.91606,
			0.756863,
			0.875041,
			0.714054,
			0.910284,
			0.882353,
			0.880764,
			0.80554,
			0.896276,
			1,
			0.887572,
			0.887591,
			0.887556
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_purple2pink_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.117562,
			0.0291202,
			0.175876,
			-0.74902,
			0.178368,
			0.0458476,
			0.285454,
			-0.623529,
			0.237731,
			0.0680173,
			0.387717,
			-0.498039,
			0.300877,
			0.0956291,
			0.484802,
			-0.372549,
			0.370929,
			0.136858,
			0.554985,
			-0.247059,
			0.449033,
			0.189273,
			0.58863,
			-0.121569,
			0.529971,
			0.245796,
			0.598587,
			0.00392157,
			0.609914,
			0.300643,
			0.610244,
			0.129412,
			0.697079,
			0.351286,
			0.616371,
			0.254902,
			0.785858,
			0.401991,
			0.617376,
			0.380392,
			0.862517,
			0.45745,
			0.64463,
			0.505882,
			0.91359,
			0.525462,
			0.705336,
			0.631373,
			0.932583,
			0.61064,
			0.767412,
			0.756863,
			0.922478,
			0.706966,
			0.817522,
			0.882353,
			0.901302,
			0.803071,
			0.856311,
			1,
			0.887571,
			0.887591,
			0.887549
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_pbj_lin",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.091821,
			0.0611476,
			0.10617,
			-0.74902,
			0.160311,
			0.0900022,
			0.192713,
			-0.623529,
			0.22484,
			0.12126,
			0.272128,
			-0.498039,
			0.291263,
			0.157469,
			0.340828,
			-0.372549,
			0.360015,
			0.200388,
			0.388903,
			-0.247059,
			0.437497,
			0.250058,
			0.387201,
			-0.121569,
			0.512636,
			0.304969,
			0.355955,
			0.00392157,
			0.582603,
			0.360874,
			0.33488,
			0.129412,
			0.655126,
			0.416374,
			0.306351,
			0.254902,
			0.725889,
			0.473329,
			0.279051,
			0.380392,
			0.778125,
			0.537928,
			0.302697,
			0.505882,
			0.815894,
			0.606931,
			0.382431,
			0.631373,
			0.839159,
			0.679308,
			0.497608,
			0.756863,
			0.854748,
			0.751666,
			0.631792,
			0.882353,
			0.869483,
			0.822508,
			0.768592,
			1,
			0.887572,
			0.887589,
			0.887565
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2green_muted",
		RGBPoints: [
			-1,
			0.107704,
			0.107708,
			0.107695,
			-0.87451,
			0.141522,
			0.13066,
			0.270741,
			-0.74902,
			0.180123,
			0.146119,
			0.42308,
			-0.623529,
			0.210161,
			0.169674,
			0.551795,
			-0.498039,
			0.239701,
			0.212939,
			0.634969,
			-0.372549,
			0.253916,
			0.282947,
			0.653641,
			-0.247059,
			0.242791,
			0.366933,
			0.608521,
			-0.121569,
			0.226302,
			0.446776,
			0.52693,
			0.00392157,
			0.236237,
			0.514689,
			0.458798,
			0.129412,
			0.274641,
			0.577589,
			0.376069,
			0.254902,
			0.349625,
			0.633993,
			0.288131,
			0.380392,
			0.4437,
			0.683677,
			0.260497,
			0.505882,
			0.536247,
			0.731214,
			0.285424,
			0.631373,
			0.628472,
			0.777128,
			0.349151,
			0.756863,
			0.718259,
			0.819287,
			0.496825,
			0.882353,
			0.804768,
			0.856164,
			0.703299,
			1,
			0.887571,
			0.887591,
			0.887548
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2green_BW",
		RGBPoints: [
			-1,
			3.63578e-7,
			0,
			0.00000529374,
			-0.87451,
			0.0539915,
			0.0577948,
			0.212806,
			-0.74902,
			0.0620393,
			0.0758942,
			0.388959,
			-0.623529,
			0.0697499,
			0.102032,
			0.54177,
			-0.498039,
			0.113295,
			0.156156,
			0.64334,
			-0.372549,
			0.152047,
			0.243196,
			0.670283,
			-0.247059,
			0.158096,
			0.344084,
			0.622864,
			-0.121569,
			0.151142,
			0.43922,
			0.532767,
			0.00392157,
			0.17155,
			0.521588,
			0.457719,
			0.129412,
			0.225861,
			0.599141,
			0.363997,
			0.254902,
			0.32328,
			0.67007,
			0.259083,
			0.380392,
			0.442344,
			0.733697,
			0.223754,
			0.505882,
			0.558409,
			0.794941,
			0.257411,
			0.631373,
			0.673875,
			0.854344,
			0.340822,
			0.756863,
			0.787244,
			0.909326,
			0.524717,
			0.882353,
			0.896483,
			0.958063,
			0.775914,
			1,
			1,
			1,
			0.999982
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GREEN-WHITE_LINEAR",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0,
			0.062745,
			0,
			-0.74902,
			0,
			0.12549,
			0,
			-0.623529,
			0,
			0.188235,
			0,
			-0.498039,
			0,
			0.25098,
			0,
			-0.372549,
			0,
			0.313725,
			0,
			-0.247059,
			0,
			0.376471,
			0,
			-0.121569,
			0.094118,
			0.439216,
			0,
			0.00392157,
			0.196078,
			0.501961,
			0,
			0.129412,
			0.294118,
			0.564706,
			0,
			0.254902,
			0.396078,
			0.627451,
			0,
			0.380392,
			0.498039,
			0.690196,
			0,
			0.505882,
			0.6,
			0.752941,
			0.145098,
			0.631373,
			0.701961,
			0.815686,
			0.364706,
			0.756863,
			0.8,
			0.878431,
			0.580392,
			0.882353,
			0.901961,
			0.941176,
			0.796078,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_green2yellow_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0,
			0.105542,
			0.0603919,
			-0.74902,
			0,
			0.159454,
			0.104148,
			-0.623529,
			0,
			0.219502,
			0.15542,
			-0.498039,
			0,
			0.282276,
			0.203811,
			-0.372549,
			0,
			0.346331,
			0.235652,
			-0.247059,
			0,
			0.411765,
			0.235428,
			-0.121569,
			0,
			0.477177,
			0.217977,
			0.00392157,
			0.0593644,
			0.541635,
			0.21361,
			0.129412,
			0.233081,
			0.604722,
			0.210591,
			0.254902,
			0.369803,
			0.664942,
			0.226536,
			0.380392,
			0.498446,
			0.722367,
			0.288237,
			0.505882,
			0.601929,
			0.782244,
			0.380815,
			0.631373,
			0.703207,
			0.840497,
			0.512134,
			0.756863,
			0.803186,
			0.896433,
			0.674462,
			0.882353,
			0.903834,
			0.950266,
			0.846715,
			1,
			1,
			1,
			0.999981
		]
	},
	{
		ColorSpace: "Lab",
		Name: "blue2cyan",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0,
			0.152941,
			0.364706,
			-0.74902,
			0,
			0.254902,
			0.470588,
			-0.623529,
			0,
			0.34902,
			0.572549,
			-0.498039,
			0,
			0.443137,
			0.670588,
			-0.372549,
			0,
			0.537255,
			0.772549,
			-0.247059,
			0,
			0.627451,
			0.870588,
			-0.121569,
			0,
			0.717647,
			0.964706,
			0.00392157,
			0.0784314,
			0.772549,
			1,
			0.129412,
			0.207843,
			0.858824,
			1,
			0.254902,
			0.32549,
			0.941176,
			1,
			0.380392,
			0.45098,
			1,
			1,
			0.505882,
			0.560784,
			1,
			1,
			0.631373,
			0.662745,
			1,
			1,
			0.756863,
			0.760784,
			1,
			1,
			0.882353,
			0.870588,
			1,
			1,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2cyan_BW",
		RGBPoints: [
			-1,
			4.05298e-7,
			0,
			0.0000059012,
			-0.87451,
			0.0207526,
			0.0740933,
			0.18093,
			-0.74902,
			0,
			0.121033,
			0.30343,
			-0.623529,
			0,
			0.166892,
			0.416095,
			-0.498039,
			0,
			0.216768,
			0.524796,
			-0.372549,
			0.0164769,
			0.275471,
			0.608585,
			-0.247059,
			0.0544527,
			0.344824,
			0.659267,
			-0.121569,
			0.0880643,
			0.419118,
			0.688675,
			0.00392157,
			0.127938,
			0.492556,
			0.720256,
			0.129412,
			0.149476,
			0.566946,
			0.756918,
			0.254902,
			0.188961,
			0.641333,
			0.792122,
			0.380392,
			0.245482,
			0.715336,
			0.827609,
			0.505882,
			0.329216,
			0.786235,
			0.874761,
			0.631373,
			0.453558,
			0.852803,
			0.918466,
			0.756863,
			0.626281,
			0.910493,
			0.954,
			0.882353,
			0.82257,
			0.958709,
			0.980146,
			1,
			1,
			1,
			0.999989
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.0425591,
			0.0763529,
			0.150682,
			-0.74902,
			0.0569472,
			0.119154,
			0.275403,
			-0.623529,
			0.0635978,
			0.164772,
			0.395427,
			-0.498039,
			0.0774342,
			0.213851,
			0.510014,
			-0.372549,
			0.106815,
			0.267034,
			0.615102,
			-0.247059,
			0.122093,
			0.324649,
			0.720068,
			-0.121569,
			0.160851,
			0.387068,
			0.806956,
			0.00392157,
			0.213754,
			0.453516,
			0.878012,
			0.129412,
			0.26722,
			0.524656,
			0.932436,
			0.254902,
			0.326844,
			0.599279,
			0.968038,
			0.380392,
			0.403403,
			0.674712,
			0.984784,
			0.505882,
			0.499703,
			0.745519,
			1,
			0.631373,
			0.615055,
			0.813983,
			1,
			0.756863,
			0.74405,
			0.879228,
			1,
			0.882353,
			0.877909,
			0.941913,
			1,
			1,
			1,
			1,
			0.999996
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BLUE-WHITE",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0,
			0,
			0.082353,
			-0.74902,
			0,
			0,
			0.168627,
			-0.623529,
			0,
			0,
			0.254902,
			-0.498039,
			0,
			0,
			0.337255,
			-0.372549,
			0,
			0,
			0.423529,
			-0.247059,
			0,
			0,
			0.509804,
			-0.121569,
			0,
			0.101961,
			0.592157,
			0.00392157,
			0,
			0.203922,
			0.678431,
			0.129412,
			0,
			0.301961,
			0.764706,
			0.254902,
			0,
			0.403922,
			0.85098,
			0.380392,
			0,
			0.505882,
			0.933333,
			0.505882,
			0,
			0.603922,
			1,
			0.631373,
			0.254902,
			0.705882,
			1,
			0.756863,
			0.509804,
			0.807843,
			1,
			0.882353,
			0.764706,
			0.905882,
			1,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_purple_BW",
		RGBPoints: [
			-1,
			4.264e-8,
			0,
			6.20844e-7,
			-0.87451,
			0.100579,
			0.0593111,
			0.145666,
			-0.74902,
			0.167794,
			0.0889224,
			0.254953,
			-0.623529,
			0.231446,
			0.123339,
			0.360511,
			-0.498039,
			0.296699,
			0.163027,
			0.461278,
			-0.372549,
			0.363211,
			0.209286,
			0.55306,
			-0.247059,
			0.431136,
			0.260776,
			0.637195,
			-0.121569,
			0.498202,
			0.320012,
			0.705799,
			0.00392157,
			0.567456,
			0.380459,
			0.778091,
			0.129412,
			0.629381,
			0.445284,
			0.8448,
			0.254902,
			0.688373,
			0.517374,
			0.895694,
			0.380392,
			0.74891,
			0.590906,
			0.93976,
			0.505882,
			0.805017,
			0.667956,
			0.977626,
			0.631373,
			0.850914,
			0.752618,
			0.992396,
			0.756863,
			0.89724,
			0.838454,
			0.994093,
			0.882353,
			0.948461,
			0.922603,
			0.994449,
			1,
			1,
			1,
			0.999967
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_magenta_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0.0000254023,
			-0.87451,
			0.128696,
			0.0456782,
			0.11635,
			-0.74902,
			0.228133,
			0.0476299,
			0.201452,
			-0.623529,
			0.327273,
			0.0374065,
			0.282107,
			-0.498039,
			0.420953,
			0.0408166,
			0.35709,
			-0.372549,
			0.511562,
			0.0642203,
			0.430511,
			-0.247059,
			0.599552,
			0.102686,
			0.504257,
			-0.121569,
			0.684646,
			0.150536,
			0.579429,
			0.00392157,
			0.765817,
			0.205978,
			0.656062,
			0.129412,
			0.839176,
			0.27229,
			0.731807,
			0.254902,
			0.89536,
			0.357594,
			0.797309,
			0.380392,
			0.930238,
			0.457825,
			0.846984,
			0.505882,
			0.945921,
			0.564536,
			0.880571,
			0.631373,
			0.948995,
			0.670753,
			0.902279,
			0.756863,
			0.947124,
			0.772819,
			0.918171,
			0.882353,
			0.947265,
			0.869424,
			0.934352,
			1,
			0.954719,
			0.95475,
			0.954726
		]
	},
	{
		ColorSpace: "Lab",
		Name: "magenta",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.364706,
			0,
			0.152941,
			-0.74902,
			0.470588,
			0,
			0.254902,
			-0.623529,
			0.572549,
			0,
			0.34902,
			-0.498039,
			0.670588,
			0,
			0.443137,
			-0.372549,
			0.772549,
			0,
			0.537255,
			-0.247059,
			0.870588,
			0,
			0.627451,
			-0.121569,
			0.964706,
			0,
			0.717647,
			0.00392157,
			1,
			0.0784314,
			0.772549,
			0.129412,
			1,
			0.207843,
			0.858824,
			0.254902,
			1,
			0.32549,
			0.941176,
			0.380392,
			1,
			0.45098,
			1,
			0.505882,
			1,
			0.560784,
			1,
			0.631373,
			1,
			0.662745,
			1,
			0.756863,
			1,
			0.760784,
			1,
			0.882353,
			1,
			0.870588,
			1,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RED-PURPLE",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.188235,
			0,
			0.007843,
			-0.74902,
			0.345098,
			0,
			0.035294,
			-0.623529,
			0.439216,
			0,
			0.098039,
			-0.498039,
			0.533333,
			0,
			0.152941,
			-0.372549,
			0.627451,
			0.015686,
			0.211765,
			-0.247059,
			0.721569,
			0.031373,
			0.266667,
			-0.121569,
			0.8,
			0.047059,
			0.329412,
			0.00392157,
			0.862745,
			0.047059,
			0.403922,
			0.129412,
			0.941176,
			0.062745,
			0.466667,
			0.254902,
			0.988235,
			0.078431,
			0.54902,
			0.380392,
			0.988235,
			0.141176,
			0.643137,
			0.505882,
			0.988235,
			0.25098,
			0.729412,
			0.631373,
			0.988235,
			0.376471,
			0.811765,
			0.756863,
			0.988235,
			0.54902,
			0.886275,
			0.882353,
			0.988235,
			0.752941,
			0.952941,
			1,
			0.996078,
			0.996078,
			0.996078
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_red_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.147204,
			0.0480135,
			0.0401815,
			-0.74902,
			0.253411,
			0.0617478,
			0.0301333,
			-0.623529,
			0.356059,
			0.0746331,
			0.0446897,
			-0.498039,
			0.457731,
			0.0934935,
			0.0636931,
			-0.372549,
			0.557199,
			0.122714,
			0.0860013,
			-0.247059,
			0.665179,
			0.144238,
			0.105585,
			-0.121569,
			0.763833,
			0.187056,
			0.138326,
			0.00392157,
			0.847035,
			0.254558,
			0.189407,
			0.129412,
			0.905663,
			0.345937,
			0.258215,
			0.254902,
			0.941431,
			0.447111,
			0.346277,
			0.380392,
			0.962608,
			0.546927,
			0.457571,
			0.505882,
			0.987833,
			0.637276,
			0.569944,
			0.631373,
			0.994202,
			0.732176,
			0.687958,
			0.756863,
			0.993304,
			0.826268,
			0.800567,
			0.882353,
			0.994413,
			0.917205,
			0.906393,
			1,
			1,
			1,
			0.999979
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RED_TEMPERATURE",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.090196,
			0,
			0,
			-0.74902,
			0.180392,
			0,
			0,
			-0.623529,
			0.270588,
			0,
			0,
			-0.498039,
			0.360784,
			0,
			0,
			-0.372549,
			0.45098,
			0,
			0,
			-0.247059,
			0.545098,
			0,
			0,
			-0.121569,
			0.635294,
			0,
			0,
			0.00392157,
			0.72549,
			0.058824,
			0,
			0.129412,
			0.815686,
			0.176471,
			0,
			0.254902,
			0.905882,
			0.294118,
			0,
			0.380392,
			1,
			0.411765,
			0,
			0.505882,
			1,
			0.533333,
			0.027451,
			0.631373,
			1,
			0.65098,
			0.27451,
			0.756863,
			1,
			0.768627,
			0.521569,
			0.882353,
			1,
			0.886275,
			0.768627,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_orange_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0.0000253806,
			-0.87451,
			0.135871,
			0.0593824,
			0,
			-0.74902,
			0.224328,
			0.0907216,
			0,
			-0.623529,
			0.318083,
			0.119647,
			0,
			-0.498039,
			0.414443,
			0.150246,
			0,
			-0.372549,
			0.511077,
			0.184884,
			0,
			-0.247059,
			0.605501,
			0.226033,
			0,
			-0.121569,
			0.695274,
			0.275491,
			0,
			0.00392157,
			0.777826,
			0.334445,
			0,
			0.129412,
			0.851498,
			0.402441,
			0,
			0.254902,
			0.915899,
			0.47759,
			0.000602975,
			0.380392,
			0.971984,
			0.557882,
			0.0361443,
			0.505882,
			1,
			0.641287,
			0.135967,
			0.631373,
			1,
			0.725198,
			0.27997,
			0.756863,
			1,
			0.808205,
			0.438135,
			0.882353,
			1,
			0.89306,
			0.587036,
			1,
			1,
			0.977928,
			0.721599
		]
	},
	{
		ColorSpace: "Lab",
		Name: "heated_object",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.34902,
			0.0862745,
			0,
			-0.74902,
			0.45098,
			0.172549,
			0,
			-0.623529,
			0.52549,
			0.231373,
			0,
			-0.498039,
			0.580392,
			0.278431,
			0,
			-0.372549,
			0.623529,
			0.313725,
			0,
			-0.247059,
			0.670588,
			0.352941,
			0,
			-0.121569,
			0.717647,
			0.392157,
			0,
			0.00392157,
			0.772549,
			0.439216,
			0,
			0.129412,
			0.839216,
			0.494118,
			0,
			0.254902,
			0.901961,
			0.541176,
			0,
			0.380392,
			0.968627,
			0.6,
			0,
			0.505882,
			1,
			0.658824,
			0,
			0.631373,
			1,
			0.721569,
			0,
			0.756863,
			1,
			0.827451,
			0.298039,
			0.882353,
			1,
			0.976471,
			0.72549,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_gold_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0.0000190933,
			-0.87451,
			0.128363,
			0.0636265,
			0,
			-0.74902,
			0.193795,
			0.111057,
			0,
			-0.623529,
			0.25976,
			0.15987,
			0,
			-0.498039,
			0.328546,
			0.210589,
			0,
			-0.372549,
			0.399726,
			0.26332,
			0,
			-0.247059,
			0.472969,
			0.318261,
			0,
			-0.121569,
			0.546245,
			0.375827,
			0,
			0.00392157,
			0.61745,
			0.436719,
			0,
			0.129412,
			0.685545,
			0.501113,
			0,
			0.254902,
			0.749578,
			0.568799,
			0,
			0.380392,
			0.80962,
			0.6394,
			0,
			0.505882,
			0.865572,
			0.712699,
			0.10257,
			0.631373,
			0.917709,
			0.787569,
			0.233665,
			0.756863,
			0.966914,
			0.863138,
			0.369608,
			0.882353,
			1,
			0.939405,
			0.496104,
			1,
			0.999225,
			1,
			0.612275
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_brown_BW",
		RGBPoints: [
			-1,
			3.3216e-7,
			0,
			0.00000483629,
			-0.87451,
			0.14693,
			0.0518172,
			0,
			-0.74902,
			0.225806,
			0.0814996,
			0,
			-0.623529,
			0.301681,
			0.111452,
			0,
			-0.498039,
			0.370487,
			0.150664,
			0,
			-0.372549,
			0.43108,
			0.199477,
			0,
			-0.247059,
			0.4849,
			0.255107,
			0,
			-0.121569,
			0.536798,
			0.313486,
			0,
			0.00392157,
			0.59286,
			0.371167,
			0,
			0.129412,
			0.653119,
			0.428135,
			0,
			0.254902,
			0.714589,
			0.485917,
			0.0379541,
			0.380392,
			0.774667,
			0.54565,
			0.116634,
			0.505882,
			0.831222,
			0.608047,
			0.183895,
			0.631373,
			0.880305,
			0.674199,
			0.260298,
			0.756863,
			0.922314,
			0.742472,
			0.367086,
			0.882353,
			0.959408,
			0.811222,
			0.497258,
			1,
			0.993548,
			0.875183,
			0.622093
		]
	},
	{
		ColorSpace: "Lab",
		Name: "copper_Matlab",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.0784314,
			0.0501961,
			0.0313725,
			-0.74902,
			0.156863,
			0.100392,
			0.0627451,
			-0.623529,
			0.235294,
			0.150588,
			0.0941176,
			-0.498039,
			0.313725,
			0.200784,
			0.12549,
			-0.372549,
			0.392157,
			0.25098,
			0.156863,
			-0.247059,
			0.470588,
			0.301176,
			0.188235,
			-0.121569,
			0.54902,
			0.351373,
			0.219608,
			0.00392157,
			0.627451,
			0.401569,
			0.25098,
			0.129412,
			0.705882,
			0.451765,
			0.282353,
			0.254902,
			0.784314,
			0.501961,
			0.313725,
			0.380392,
			0.862745,
			0.552157,
			0.345098,
			0.505882,
			0.941176,
			0.602353,
			0.376471,
			0.631373,
			1,
			0.652549,
			0.407843,
			0.756863,
			1,
			0.702745,
			0.439216,
			0.882353,
			1,
			0.752941,
			0.470588,
			1,
			1,
			0.8,
			0.5
		]
	},
	{
		ColorSpace: "Lab",
		Name: "pink_Matlab",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.312416,
			0.204524,
			0.204524,
			-0.74902,
			0.441822,
			0.289241,
			0.289241,
			-0.623529,
			0.54112,
			0.354246,
			0.354246,
			-0.498039,
			0.624831,
			0.409048,
			0.409048,
			-0.372549,
			0.698582,
			0.45733,
			0.45733,
			-0.247059,
			0.764404,
			0.502282,
			0.500979,
			-0.121569,
			0.791292,
			0.591516,
			0.54112,
			0.00392157,
			0.817297,
			0.66895,
			0.578481,
			0.129412,
			0.842499,
			0.738308,
			0.613572,
			0.254902,
			0.866968,
			0.801687,
			0.646762,
			0.380392,
			0.890766,
			0.86041,
			0.678329,
			0.505882,
			0.913944,
			0.913944,
			0.711254,
			0.631373,
			0.936549,
			0.936549,
			0.79459,
			0.756863,
			0.958621,
			0.958621,
			0.869979,
			0.882353,
			0.980196,
			0.980196,
			0.939336,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "bone_Matlab",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.054902,
			0.054902,
			0.075817,
			-0.74902,
			0.109804,
			0.109804,
			0.151634,
			-0.623529,
			0.164706,
			0.164706,
			0.227451,
			-0.498039,
			0.219608,
			0.219608,
			0.303268,
			-0.372549,
			0.27451,
			0.27451,
			0.379085,
			-0.247059,
			0.329412,
			0.329902,
			0.454412,
			-0.121569,
			0.384314,
			0.405719,
			0.509314,
			0.00392157,
			0.439216,
			0.481536,
			0.564216,
			0.129412,
			0.494118,
			0.557353,
			0.619118,
			0.254902,
			0.54902,
			0.63317,
			0.67402,
			0.380392,
			0.603922,
			0.708987,
			0.728922,
			0.505882,
			0.660294,
			0.783824,
			0.783824,
			0.631373,
			0.746569,
			0.838725,
			0.838725,
			0.756863,
			0.832843,
			0.893627,
			0.893627,
			0.882353,
			0.919118,
			0.948529,
			0.948529,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "gray_Matlab",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.0627451,
			0.0627451,
			0.0627451,
			-0.74902,
			0.12549,
			0.12549,
			0.12549,
			-0.623529,
			0.188235,
			0.188235,
			0.188235,
			-0.498039,
			0.25098,
			0.25098,
			0.25098,
			-0.372549,
			0.313725,
			0.313725,
			0.313725,
			-0.247059,
			0.376471,
			0.376471,
			0.376471,
			-0.121569,
			0.439216,
			0.439216,
			0.439216,
			0.00392157,
			0.501961,
			0.501961,
			0.501961,
			0.129412,
			0.564706,
			0.564706,
			0.564706,
			0.254902,
			0.627451,
			0.627451,
			0.627451,
			0.380392,
			0.690196,
			0.690196,
			0.690196,
			0.505882,
			0.752941,
			0.752941,
			0.752941,
			0.631373,
			0.815686,
			0.815686,
			0.815686,
			0.756863,
			0.878431,
			0.878431,
			0.878431,
			0.882353,
			0.941176,
			0.941176,
			0.941176,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Purples",
		RGBPoints: [
			-1,
			0.247059,
			0,
			0.490196,
			-0.87451,
			0.288397,
			0.07677,
			0.525629,
			-0.74902,
			0.32975,
			0.153587,
			0.561092,
			-0.623529,
			0.373057,
			0.236263,
			0.600461,
			-0.498039,
			0.416363,
			0.319,
			0.639923,
			-0.372549,
			0.459669,
			0.405613,
			0.685198,
			-0.247059,
			0.503345,
			0.491534,
			0.730058,
			-0.121569,
			0.562399,
			0.54862,
			0.757616,
			0.00392157,
			0.621453,
			0.606075,
			0.785544,
			0.129412,
			0.680508,
			0.674971,
			0.824914,
			0.254902,
			0.739562,
			0.743406,
			0.863899,
			0.380392,
			0.798616,
			0.800492,
			0.893426,
			0.505882,
			0.85684,
			0.856655,
			0.922491,
			0.631373,
			0.898178,
			0.894056,
			0.942176,
			0.756863,
			0.938654,
			0.930919,
			0.961646,
			0.882353,
			0.964245,
			0.958478,
			0.977393,
			1,
			0.988235,
			0.984314,
			0.992157
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Blues",
		RGBPoints: [
			-1,
			0.031373,
			0.188235,
			0.419608,
			-0.87451,
			0.031373,
			0.253195,
			0.516063,
			-0.74902,
			0.031757,
			0.318139,
			0.612149,
			-0.623529,
			0.080969,
			0.38113,
			0.661361,
			-0.498039,
			0.130427,
			0.444152,
			0.710327,
			-0.372549,
			0.195386,
			0.509112,
			0.743791,
			-0.247059,
			0.260715,
			0.573841,
			0.777209,
			-0.121569,
			0.341423,
			0.628958,
			0.808704,
			0.00392157,
			0.422745,
			0.684075,
			0.839892,
			0.129412,
			0.523137,
			0.739193,
			0.861546,
			0.254902,
			0.622684,
			0.793464,
			0.883429,
			0.380392,
			0.701423,
			0.826928,
			0.910988,
			0.505882,
			0.778685,
			0.8603,
			0.937993,
			0.631373,
			0.825928,
			0.891795,
			0.953741,
			0.756863,
			0.87328,
			0.923291,
			0.969489,
			0.882353,
			0.922491,
			0.954787,
			0.985236,
			1,
			0.968627,
			0.984314,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Greens",
		RGBPoints: [
			-1,
			0,
			0.266667,
			0.105882,
			-0.87451,
			0,
			0.347374,
			0.139346,
			-0.74902,
			0.000538,
			0.427912,
			0.172933,
			-0.623529,
			0.069435,
			0.486967,
			0.222145,
			-0.498039,
			0.138178,
			0.546082,
			0.271326,
			-0.372549,
			0.197232,
			0.609073,
			0.31857,
			-0.247059,
			0.257255,
			0.671742,
			0.365859,
			-0.121569,
			0.357647,
			0.720953,
			0.415071,
			0.00392157,
			0.45767,
			0.769919,
			0.465021,
			0.129412,
			0.546251,
			0.811257,
			0.537855,
			0.254902,
			0.634295,
			0.852211,
			0.610688,
			0.380392,
			0.709097,
			0.883706,
			0.683522,
			0.505882,
			0.78316,
			0.914833,
			0.755894,
			0.631373,
			0.842215,
			0.938454,
			0.818885,
			0.756863,
			0.899977,
			0.961538,
			0.880692,
			0.882353,
			0.935409,
			0.975317,
			0.92203,
			1,
			0.968627,
			0.988235,
			0.960784
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PuBu",
		RGBPoints: [
			-1,
			0.301961,
			0,
			0.294118,
			-0.87451,
			0.404321,
			0.029527,
			0.390573,
			-0.74902,
			0.50599,
			0.059592,
			0.486782,
			-0.623529,
			0.519769,
			0.158016,
			0.551742,
			-0.498039,
			0.533456,
			0.256194,
			0.616301,
			-0.372549,
			0.54133,
			0.33887,
			0.655671,
			-0.247059,
			0.54902,
			0.421592,
			0.695087,
			-0.121569,
			0.54902,
			0.506236,
			0.736424,
			0.00392157,
			0.550127,
			0.590573,
			0.777701,
			0.129412,
			0.585559,
			0.665375,
			0.81707,
			0.254902,
			0.622145,
			0.739023,
			0.855825,
			0.380392,
			0.687105,
			0.784298,
			0.879446,
			0.505882,
			0.752065,
			0.829758,
			0.903253,
			0.631373,
			0.817024,
			0.87897,
			0.930811,
			0.756863,
			0.880907,
			0.927213,
			0.957832,
			0.882353,
			0.926182,
			0.958708,
			0.975548,
			1,
			0.968627,
			0.988235,
			0.992157
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BuPu",
		RGBPoints: [
			-1,
			0.007843,
			0.219608,
			0.345098,
			-0.87451,
			0.01178,
			0.286536,
			0.449427,
			-0.74902,
			0.015702,
			0.35328,
			0.553479,
			-0.623529,
			0.01767,
			0.396586,
			0.622376,
			-0.498039,
			0.021115,
			0.4402,
			0.690688,
			-0.372549,
			0.11757,
			0.503191,
			0.722184,
			-0.247059,
			0.214625,
			0.565859,
			0.753633,
			-0.121569,
			0.336671,
			0.615071,
			0.78316,
			0.00392157,
			0.457978,
			0.663975,
			0.812503,
			0.129412,
			0.556401,
			0.703345,
			0.836125,
			0.254902,
			0.65421,
			0.742714,
			0.859669,
			0.380392,
			0.736886,
			0.782084,
			0.881323,
			0.505882,
			0.81827,
			0.821638,
			0.903068,
			0.631373,
			0.873387,
			0.864944,
			0.92669,
			0.756863,
			0.927536,
			0.907605,
			0.949988,
			0.882353,
			0.964937,
			0.9391,
			0.967705,
			1,
			1,
			0.968627,
			0.984314
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BuGn",
		RGBPoints: [
			-1,
			0.031373,
			0.25098,
			0.505882,
			-0.87451,
			0.031373,
			0.329719,
			0.590527,
			-0.74902,
			0.031911,
			0.408397,
			0.674787,
			-0.623529,
			0.100807,
			0.479262,
			0.710219,
			-0.498039,
			0.169704,
			0.550219,
			0.745744,
			-0.372549,
			0.238601,
			0.62699,
			0.787082,
			-0.247059,
			0.307958,
			0.703114,
			0.826759,
			-0.121569,
			0.39654,
			0.752326,
			0.797232,
			0.00392157,
			0.485121,
			0.801046,
			0.767705,
			0.129412,
			0.573702,
			0.83451,
			0.738178,
			0.254902,
			0.661592,
			0.867743,
			0.711034,
			0.380392,
			0.732457,
			0.895302,
			0.74253,
			0.505882,
			0.801845,
			0.922307,
			0.774579,
			0.631373,
			0.841215,
			0.938055,
			0.817885,
			0.756863,
			0.880907,
			0.95391,
			0.861084,
			0.882353,
			0.926182,
			0.971626,
			0.902422,
			1,
			0.968627,
			0.988235,
			0.941176
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GnBu",
		RGBPoints: [
			-1,
			0,
			0.266667,
			0.105882,
			-0.87451,
			0,
			0.347374,
			0.139346,
			-0.74902,
			0.000538,
			0.427912,
			0.172933,
			-0.623529,
			0.069435,
			0.486967,
			0.222145,
			-0.498039,
			0.138178,
			0.546175,
			0.272095,
			-0.372549,
			0.197232,
			0.615071,
			0.368551,
			-0.247059,
			0.256609,
			0.683276,
			0.464867,
			-0.121569,
			0.329443,
			0.722645,
			0.555417,
			0.00392157,
			0.403137,
			0.762138,
			0.645413,
			0.129412,
			0.503529,
			0.805444,
			0.718247,
			0.254902,
			0.603922,
			0.848597,
			0.790465,
			0.380392,
			0.704314,
			0.887966,
			0.847551,
			0.505882,
			0.802307,
			0.926321,
			0.903714,
			0.631373,
			0.851519,
			0.944037,
			0.941115,
			0.756863,
			0.899977,
			0.961538,
			0.976901,
			0.882353,
			0.935409,
			0.975317,
			0.984775,
			1,
			0.968627,
			0.988235,
			0.992157
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GnBuPu",
		RGBPoints: [
			-1,
			0.003922,
			0.27451,
			0.211765,
			-0.87451,
			0.003922,
			0.349312,
			0.280661,
			-0.74902,
			0.003937,
			0.423852,
			0.349773,
			-0.623529,
			0.005905,
			0.46519,
			0.446228,
			-0.498039,
			0.009443,
			0.506344,
			0.542837,
			-0.372549,
			0.111803,
			0.535871,
			0.649135,
			-0.247059,
			0.214025,
			0.565859,
			0.753633,
			-0.121569,
			0.310481,
			0.615071,
			0.78316,
			0.00392157,
			0.407797,
			0.663975,
			0.812503,
			0.129412,
			0.531811,
			0.703345,
			0.836125,
			0.254902,
			0.65421,
			0.742714,
			0.859669,
			0.380392,
			0.736886,
			0.782084,
			0.881323,
			0.505882,
			0.81827,
			0.821176,
			0.902884,
			0.631373,
			0.873387,
			0.854641,
			0.922568,
			0.756863,
			0.927536,
			0.888535,
			0.942361,
			0.882353,
			0.964937,
			0.929873,
			0.964014,
			1,
			1,
			0.968627,
			0.984314
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BuGnYl",
		RGBPoints: [
			-1,
			0.031373,
			0.113725,
			0.345098,
			-0.87451,
			0.088458,
			0.159,
			0.463206,
			-0.74902,
			0.145052,
			0.204567,
			0.5807,
			-0.623529,
			0.139146,
			0.287243,
			0.620069,
			-0.498039,
			0.13318,
			0.370196,
			0.659562,
			-0.372549,
			0.123337,
			0.470588,
			0.706805,
			-0.247059,
			0.115386,
			0.570335,
			0.753126,
			-0.121569,
			0.186251,
			0.643168,
			0.761,
			0.00392157,
			0.258716,
			0.71514,
			0.768074,
			0.129412,
			0.380761,
			0.760415,
			0.750358,
			0.254902,
			0.503576,
			0.806075,
			0.732795,
			0.380392,
			0.645306,
			0.861192,
			0.719016,
			0.505882,
			0.783899,
			0.91511,
			0.705606,
			0.631373,
			0.858701,
			0.944637,
			0.6997,
			0.756863,
			0.931349,
			0.973303,
			0.698424,
			0.882353,
			0.966782,
			0.987082,
			0.777163,
			1,
			1,
			1,
			0.85098
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PuRd",
		RGBPoints: [
			-1,
			0.286275,
			0,
			0.415686,
			-0.87451,
			0.38273,
			0.001968,
			0.441276,
			-0.74902,
			0.479231,
			0.003922,
			0.466774,
			-0.623529,
			0.581592,
			0.003922,
			0.480554,
			-0.498039,
			0.683799,
			0.00549,
			0.494887,
			-0.372549,
			0.776317,
			0.105882,
			0.544098,
			-0.247059,
			0.867866,
			0.206321,
			0.592618,
			-0.121569,
			0.919047,
			0.308681,
			0.612303,
			0.00392157,
			0.968812,
			0.411226,
			0.632603,
			0.129412,
			0.974717,
			0.519493,
			0.671972,
			0.254902,
			0.980546,
			0.626451,
			0.71065,
			0.380392,
			0.984483,
			0.701253,
			0.732303,
			0.505882,
			0.988328,
			0.77504,
			0.755617,
			0.631373,
			0.990296,
			0.828189,
			0.812703,
			0.756863,
			0.992372,
			0.880907,
			0.869035,
			0.882353,
			0.996309,
			0.926182,
			0.912341,
			1,
			1,
			0.968627,
			0.952941
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RdPu",
		RGBPoints: [
			-1,
			0.403922,
			0,
			0.121569,
			-0.87451,
			0.500377,
			0,
			0.192434,
			-0.74902,
			0.596909,
			0.000277,
			0.263037,
			-0.623529,
			0.703206,
			0.035709,
			0.300438,
			-0.498039,
			0.808612,
			0.071296,
			0.338854,
			-0.372549,
			0.857824,
			0.116571,
			0.441215,
			-0.247059,
			0.905513,
			0.163552,
			0.54293,
			-0.121569,
			0.889765,
			0.281661,
			0.617732,
			0.00392157,
			0.873156,
			0.39897,
			0.691611,
			0.129412,
			0.82985,
			0.491488,
			0.736886,
			0.254902,
			0.789081,
			0.583237,
			0.781853,
			0.380392,
			0.810734,
			0.656071,
			0.819254,
			0.505882,
			0.833126,
			0.729181,
			0.85684,
			0.631373,
			0.870527,
			0.80792,
			0.898178,
			0.756863,
			0.907605,
			0.884398,
			0.938331,
			0.882353,
			0.9391,
			0.921799,
			0.958016,
			1,
			0.968627,
			0.956863,
			0.976471
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Oranges",
		RGBPoints: [
			-1,
			0.498039,
			0.152941,
			0.015686,
			-0.87451,
			0.57481,
			0.182468,
			0.013718,
			-0.74902,
			0.651765,
			0.212042,
			0.011734,
			-0.623529,
			0.752157,
			0.247474,
			0.007797,
			-0.498039,
			0.851719,
			0.283368,
			0.004475,
			-0.372549,
			0.898962,
			0.348328,
			0.039908,
			-0.247059,
			0.945652,
			0.413426,
			0.076401,
			-0.121569,
			0.969273,
			0.484291,
			0.157109,
			0.00392157,
			0.992157,
			0.554971,
			0.238185,
			0.129412,
			0.992157,
			0.619931,
			0.330704,
			0.254902,
			0.992157,
			0.684967,
			0.423837,
			0.380392,
			0.992157,
			0.751895,
			0.532103,
			0.505882,
			0.992249,
			0.817716,
			0.639354,
			0.631373,
			0.994218,
			0.861023,
			0.725967,
			0.756863,
			0.996186,
			0.903576,
			0.810965,
			0.882353,
			0.998155,
			0.933103,
			0.868051,
			1,
			1,
			0.960784,
			0.921569
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Reds",
		RGBPoints: [
			-1,
			0.403922,
			0,
			0.05098,
			-0.87451,
			0.525967,
			0.029527,
			0.066728,
			-0.74902,
			0.647643,
			0.058962,
			0.082476,
			-0.623529,
			0.722445,
			0.076678,
			0.098224,
			-0.498039,
			0.797186,
			0.095194,
			0.114187,
			-0.372549,
			0.868051,
			0.164091,
			0.143714,
			-0.247059,
			0.937809,
			0.233541,
			0.173933,
			-0.121569,
			0.96143,
			0.326059,
			0.232987,
			0.00392157,
			0.984375,
			0.418147,
			0.292657,
			0.129412,
			0.986344,
			0.496886,
			0.371396,
			0.254902,
			0.988235,
			0.575702,
			0.450673,
			0.380392,
			0.988235,
			0.656409,
			0.543191,
			0.505882,
			0.98842,
			0.736747,
			0.635894,
			0.631373,
			0.992357,
			0.809581,
			0.732349,
			0.756863,
			0.996186,
			0.880692,
			0.826759,
			0.882353,
			0.998155,
			0.92203,
			0.885813,
			1,
			1,
			0.960784,
			0.941176
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RdOr",
		RGBPoints: [
			-1,
			0.498039,
			0,
			0,
			-0.87451,
			0.6004,
			0,
			0,
			-0.74902,
			0.702514,
			0.000738,
			0.000477,
			-0.623529,
			0.773379,
			0.095225,
			0.061499,
			-0.498039,
			0.843875,
			0.189865,
			0.12283,
			-0.372549,
			0.891119,
			0.294195,
			0.203537,
			-0.247059,
			0.937855,
			0.397924,
			0.283137,
			-0.121569,
			0.963445,
			0.476663,
			0.316601,
			0.00392157,
			0.988297,
			0.555771,
			0.351665,
			0.129412,
			0.990265,
			0.646321,
			0.436309,
			0.254902,
			0.992157,
			0.735256,
			0.519646,
			0.380392,
			0.992157,
			0.784468,
			0.570827,
			0.505882,
			0.992249,
			0.833218,
			0.623483,
			0.631373,
			0.994218,
			0.872587,
			0.706159,
			0.756863,
			0.996186,
			0.911419,
			0.788189,
			0.882353,
			0.998155,
			0.940946,
			0.859054,
			1,
			1,
			0.968627,
			0.92549
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BrOrYl",
		RGBPoints: [
			-1,
			0.4,
			0.145098,
			0.023529,
			-0.87451,
			0.500392,
			0.174625,
			0.019592,
			-0.74902,
			0.600784,
			0.204291,
			0.015656,
			-0.623529,
			0.701176,
			0.251534,
			0.011719,
			-0.498039,
			0.800984,
			0.299146,
			0.008397,
			-0.372549,
			0.863975,
			0.370012,
			0.043829,
			-0.247059,
			0.926321,
			0.441107,
			0.0794,
			-0.121569,
			0.961753,
			0.521815,
			0.120738,
			0.00392157,
			0.996078,
			0.602645,
			0.163122,
			0.129412,
			0.996078,
			0.68729,
			0.237924,
			0.254902,
			0.996078,
			0.771011,
			0.314879,
			0.380392,
			0.996078,
			0.832034,
			0.444798,
			0.505882,
			0.996171,
			0.892042,
			0.572595,
			0.631373,
			0.998139,
			0.931411,
			0.65724,
			0.756863,
			1,
			0.969489,
			0.741669,
			0.882353,
			1,
			0.985236,
			0.822376,
			1,
			1,
			1,
			0.898039
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RdOrYl",
		RGBPoints: [
			-1,
			0.501961,
			0,
			0.14902,
			-0.87451,
			0.622038,
			0,
			0.14902,
			-0.74902,
			0.741761,
			0.0004,
			0.148866,
			-0.623529,
			0.816563,
			0.05158,
			0.129181,
			-0.498039,
			0.890965,
			0.10356,
			0.110235,
			-0.372549,
			0.940177,
			0.205921,
			0.137793,
			-0.247059,
			0.988281,
			0.308789,
			0.165536,
			-0.121569,
			0.99025,
			0.432803,
			0.200969,
			0.00392157,
			0.992218,
			0.555217,
			0.236278,
			0.129412,
			0.994187,
			0.628051,
			0.267774,
			0.254902,
			0.996078,
			0.701038,
			0.301269,
			0.380392,
			0.996078,
			0.777809,
			0.383945,
			0.505882,
			0.996171,
			0.852826,
			0.466621,
			0.631373,
			0.998139,
			0.892195,
			0.549296,
			0.756863,
			1,
			0.931349,
			0.632188,
			0.882353,
			1,
			0.966782,
			0.7188,
			1,
			1,
			1,
			0.8
		]
	},
	{
		ColorSpace: "Lab",
		Name: "CIELab_blue2red",
		RGBPoints: [
			-1,
			0,
			0.6,
			0.74902,
			1,
			0.76863,
			0.46667,
			0.34118
		]
	},
	{
		ColorSpace: "Lab",
		Name: "blue2yellow",
		RGBPoints: [
			-1,
			0,
			0,
			1,
			0,
			0.5,
			0.5,
			0.5,
			1,
			1,
			1,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2gold",
		RGBPoints: [
			-1,
			0.175119,
			0.0438468,
			1,
			-0.874016,
			0.22383,
			0.159771,
			0.94557,
			-0.748031,
			0.27254,
			0.233611,
			0.891216,
			-0.622047,
			0.321251,
			0.296526,
			0.836857,
			-0.496063,
			0.369962,
			0.354296,
			0.782359,
			-0.370079,
			0.418672,
			0.409139,
			0.72754,
			-0.244094,
			0.467383,
			0.462152,
			0.672148,
			-0.11811,
			0.51609,
			0.51396,
			0.615825,
			0.00787402,
			0.572863,
			0.55452,
			0.559172,
			0.133858,
			0.630269,
			0.593822,
			0.517729,
			0.259843,
			0.689588,
			0.624668,
			0.47446,
			0.385827,
			0.745394,
			0.656113,
			0.428638,
			0.511811,
			0.798624,
			0.688104,
			0.379105,
			0.637795,
			0.849926,
			0.720593,
			0.323834,
			0.76378,
			0.899765,
			0.753543,
			0.258657,
			0.889764,
			0.948487,
			0.78692,
			0.171778,
			1,
			0.990413,
			0.816451,
			0.00729848
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2yellow",
		RGBPoints: [
			-1,
			0.0830122,
			0,
			0.495617,
			-0.87451,
			0.141973,
			0.0551288,
			0.57363,
			-0.74902,
			0.193048,
			0.110258,
			0.604561,
			-0.623529,
			0.234231,
			0.165386,
			0.57643,
			-0.498039,
			0.275413,
			0.220515,
			0.548299,
			-0.372549,
			0.316596,
			0.275644,
			0.520169,
			-0.247059,
			0.357778,
			0.330773,
			0.492038,
			-0.121569,
			0.398961,
			0.385901,
			0.463908,
			0.00392157,
			0.449929,
			0.438487,
			0.426815,
			0.129412,
			0.511572,
			0.488299,
			0.379944,
			0.254902,
			0.581222,
			0.53603,
			0.325741,
			0.380392,
			0.650871,
			0.583761,
			0.271538,
			0.505882,
			0.720521,
			0.631493,
			0.217335,
			0.631373,
			0.79017,
			0.679224,
			0.163132,
			0.756863,
			0.85982,
			0.726955,
			0.108929,
			0.882353,
			0.910254,
			0.774159,
			0.14112,
			1,
			0.927513,
			0.81759,
			0.306289
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_cyan2orange",
		RGBPoints: [
			-1,
			0.0471513,
			0.213874,
			0.414329,
			-0.87451,
			0.0674702,
			0.256648,
			0.439027,
			-0.74902,
			0.0959957,
			0.299331,
			0.462089,
			-0.623529,
			0.132428,
			0.341872,
			0.483212,
			-0.498039,
			0.188743,
			0.38277,
			0.500597,
			-0.372549,
			0.268511,
			0.420229,
			0.512179,
			-0.247059,
			0.352945,
			0.455602,
			0.519101,
			-0.121569,
			0.43893,
			0.489368,
			0.521538,
			0.00392157,
			0.522445,
			0.522495,
			0.522436,
			0.129412,
			0.600089,
			0.555682,
			0.53205,
			0.254902,
			0.67988,
			0.587981,
			0.539163,
			0.380392,
			0.761011,
			0.619586,
			0.544439,
			0.505882,
			0.84278,
			0.650741,
			0.548567,
			0.631373,
			0.910713,
			0.687347,
			0.557822,
			0.756863,
			0.952232,
			0.734972,
			0.577775,
			0.882353,
			0.975642,
			0.789858,
			0.604868,
			1,
			0.990752,
			0.843643,
			0.632857
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_purple2green",
		RGBPoints: [
			-1,
			0.235006,
			0.0483128,
			0.530899,
			-0.87451,
			0.302968,
			0.108419,
			0.552391,
			-0.74902,
			0.360241,
			0.166059,
			0.569502,
			-0.623529,
			0.406746,
			0.226782,
			0.579373,
			-0.498039,
			0.444073,
			0.28964,
			0.582094,
			-0.372549,
			0.473648,
			0.353774,
			0.577947,
			-0.247059,
			0.497636,
			0.418154,
			0.567911,
			-0.121569,
			0.519086,
			0.481741,
			0.553968,
			0.00392157,
			0.542884,
			0.542914,
			0.542875,
			0.129412,
			0.566303,
			0.603989,
			0.527499,
			0.254902,
			0.595218,
			0.662965,
			0.516857,
			0.380392,
			0.628641,
			0.720701,
			0.510673,
			0.505882,
			0.665373,
			0.777849,
			0.508165,
			0.631373,
			0.704182,
			0.834921,
			0.508303,
			0.756863,
			0.743846,
			0.892328,
			0.50999,
			0.882353,
			0.783158,
			0.950422,
			0.512181,
			1,
			0.818617,
			1,
			0.513888
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_purple2green_dark",
		RGBPoints: [
			-1,
			0.107656,
			0,
			0.428682,
			-0.87451,
			0.1924,
			0,
			0.449799,
			-0.74902,
			0.255118,
			0.0648939,
			0.466726,
			-0.623529,
			0.304256,
			0.133066,
			0.476703,
			-0.498039,
			0.343202,
			0.19716,
			0.479793,
			-0.372549,
			0.373876,
			0.260353,
			0.476241,
			-0.247059,
			0.398497,
			0.322872,
			0.466953,
			-0.121569,
			0.420016,
			0.384252,
			0.453785,
			0.00392157,
			0.44319,
			0.443216,
			0.443186,
			0.129412,
			0.465553,
			0.502139,
			0.428233,
			0.254902,
			0.492959,
			0.559151,
			0.417591,
			0.380392,
			0.524654,
			0.615092,
			0.411016,
			0.505882,
			0.55959,
			0.670583,
			0.40779,
			0.631373,
			0.596614,
			0.726102,
			0.406948,
			0.756863,
			0.634544,
			0.782032,
			0.407439,
			0.882353,
			0.672183,
			0.838703,
			0.408237,
			1,
			0.706131,
			0.892759,
			0.408452
		]
	},
	{
		ColorSpace: "Lab",
		Name: "coolwarm",
		RGBPoints: [
			-1,
			0.229806,
			0.298718,
			0.753683,
			-0.875,
			0.303869,
			0.406535,
			0.844959,
			-0.75,
			0.383013,
			0.509419,
			0.917388,
			-0.625,
			0.466667,
			0.604563,
			0.968155,
			-0.5,
			0.552953,
			0.688929,
			0.995376,
			-0.375,
			0.639176,
			0.7596,
			0.998151,
			-0.25,
			0.722193,
			0.813953,
			0.976575,
			-0.125,
			0.798692,
			0.849786,
			0.931689,
			0,
			0.865395,
			0.86541,
			0.865396,
			0.125,
			0.924128,
			0.827385,
			0.774508,
			0.25,
			0.958853,
			0.769768,
			0.678008,
			0.375,
			0.969954,
			0.694267,
			0.579375,
			0.5,
			0.958003,
			0.602842,
			0.481776,
			0.625,
			0.923945,
			0.497309,
			0.38797,
			0.75,
			0.869187,
			0.378313,
			0.300267,
			0.875,
			0.795632,
			0.241284,
			0.220526,
			1,
			0.705673,
			0.0155562,
			0.150233
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BuRd",
		RGBPoints: [
			-1,
			0.019608,
			0.188235,
			0.380392,
			-0.87451,
			0.088504,
			0.321107,
			0.564937,
			-0.74902,
			0.163399,
			0.444983,
			0.697501,
			-0.623529,
			0.247059,
			0.555709,
			0.754095,
			-0.498039,
			0.420684,
			0.676432,
			0.818685,
			-0.372549,
			0.606459,
			0.789773,
			0.880277,
			-0.247059,
			0.761476,
			0.868512,
			0.924567,
			-0.121569,
			0.878047,
			0.925721,
			0.951942,
			0.00392157,
			0.969089,
			0.966474,
			0.964937,
			0.129412,
			0.983852,
			0.897578,
			0.846828,
			0.254902,
			0.982468,
			0.800692,
			0.706113,
			0.380392,
			0.960323,
			0.66782,
			0.536332,
			0.505882,
			0.894579,
			0.503806,
			0.399769,
			0.631373,
			0.81707,
			0.33218,
			0.281046,
			0.756863,
			0.728489,
			0.155017,
			0.197386,
			0.882353,
			0.576932,
			0.055363,
			0.14925,
			1,
			0.403922,
			0,
			0.121569
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Spectral_lowBlue",
		RGBPoints: [
			-1,
			0.368627,
			0.309804,
			0.635294,
			-0.87451,
			0.260361,
			0.450058,
			0.70173,
			-0.74902,
			0.248058,
			0.591311,
			0.717186,
			-0.623529,
			0.376009,
			0.734025,
			0.658132,
			-0.498039,
			0.537947,
			0.814764,
			0.64506,
			-0.372549,
			0.702345,
			0.879585,
			0.636678,
			-0.247059,
			0.84752,
			0.938639,
			0.607151,
			-0.121569,
			0.940408,
			0.976163,
			0.656055,
			0.00392157,
			0.999923,
			0.997616,
			0.745021,
			0.129412,
			0.997463,
			0.921338,
			0.61707,
			0.254902,
			0.995002,
			0.824606,
			0.499885,
			0.380392,
			0.992541,
			0.701576,
			0.39654,
			0.505882,
			0.973472,
			0.547405,
			0.318108,
			0.631373,
			0.937793,
			0.398539,
			0.270127,
			0.756863,
			0.861515,
			0.282891,
			0.299654,
			0.882353,
			0.746482,
			0.144637,
			0.288812,
			1,
			0.619608,
			0.003922,
			0.258824
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GnRP",
		RGBPoints: [
			-1,
			0,
			0.266667,
			0.105882,
			-0.87451,
			0.066436,
			0.394617,
			0.174779,
			-0.74902,
			0.168858,
			0.524567,
			0.25767,
			-0.623529,
			0.323875,
			0.657439,
			0.361015,
			-0.498039,
			0.504883,
			0.772318,
			0.506344,
			-0.372549,
			0.678431,
			0.870127,
			0.654902,
			-0.247059,
			0.803922,
			0.921799,
			0.780392,
			-0.121569,
			0.897116,
			0.951942,
			0.882814,
			0.00392157,
			0.967397,
			0.965936,
			0.967474,
			0.129412,
			0.928028,
			0.879815,
			0.930565,
			0.254902,
			0.866052,
			0.780777,
			0.882891,
			0.380392,
			0.77501,
			0.665129,
			0.821376,
			0.505882,
			0.675663,
			0.537024,
			0.737024,
			0.631373,
			0.57847,
			0.396155,
			0.645982,
			0.756863,
			0.492349,
			0.223914,
			0.547559,
			0.882353,
			0.375548,
			0.096886,
			0.423299,
			1,
			0.25098,
			0,
			0.294118
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GYPi",
		RGBPoints: [
			-1,
			0.152941,
			0.392157,
			0.098039,
			-0.87451,
			0.246444,
			0.505344,
			0.117724,
			-0.74902,
			0.351942,
			0.614533,
			0.161399,
			-0.623529,
			0.474971,
			0.717878,
			0.240138,
			-0.498039,
			0.611995,
			0.811226,
			0.392849,
			-0.372549,
			0.746328,
			0.893118,
			0.565321,
			-0.247059,
			0.859516,
			0.94233,
			0.747405,
			-0.121569,
			0.928105,
			0.96386,
			0.875663,
			0.00392157,
			0.969089,
			0.966859,
			0.968012,
			0.129412,
			0.983852,
			0.910265,
			0.948328,
			0.254902,
			0.979239,
			0.833218,
			0.914648,
			0.380392,
			0.949712,
			0.729873,
			0.862976,
			0.505882,
			0.905652,
			0.58293,
			0.763552,
			0.631373,
			0.85521,
			0.410073,
			0.652211,
			0.756863,
			0.793695,
			0.183699,
			0.531642,
			0.882353,
			0.683737,
			0.063899,
			0.420761,
			1,
			0.556863,
			0.003922,
			0.321569
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GnYlRd",
		RGBPoints: [
			-1,
			0,
			0.407843,
			0.215686,
			-0.87451,
			0.063975,
			0.525952,
			0.277201,
			-0.74902,
			0.177932,
			0.633064,
			0.332718,
			-0.623529,
			0.364937,
			0.724106,
			0.379469,
			-0.498039,
			0.527951,
			0.797155,
			0.40223,
			-0.372549,
			0.678431,
			0.862822,
			0.433449,
			-0.247059,
			0.803922,
			0.916955,
			0.514648,
			-0.121569,
			0.909419,
			0.961861,
			0.625067,
			0.00392157,
			0.999923,
			0.997616,
			0.745021,
			0.129412,
			0.997463,
			0.921338,
			0.61707,
			0.254902,
			0.995002,
			0.824606,
			0.499885,
			0.380392,
			0.992541,
			0.701576,
			0.39654,
			0.505882,
			0.973472,
			0.547405,
			0.318108,
			0.631373,
			0.939023,
			0.389927,
			0.245521,
			0.756863,
			0.867666,
			0.239831,
			0.176624,
			0.882353,
			0.762399,
			0.110727,
			0.151326,
			1,
			0.647059,
			0,
			0.14902
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GBBr",
		RGBPoints: [
			-1,
			0,
			0.235294,
			0.188235,
			-0.87451,
			0.002461,
			0.338639,
			0.301423,
			-0.74902,
			0.055902,
			0.448981,
			0.417609,
			-0.623529,
			0.183852,
			0.56955,
			0.538178,
			-0.498039,
			0.357785,
			0.700115,
			0.660746,
			-0.372549,
			0.540177,
			0.819531,
			0.77624,
			-0.247059,
			0.714879,
			0.890888,
			0.864821,
			-0.121569,
			0.851134,
			0.934564,
			0.922645,
			0.00392157,
			0.960861,
			0.959785,
			0.95694,
			0.129412,
			0.963322,
			0.927797,
			0.83391,
			0.254902,
			0.939946,
			0.868897,
			0.68935,
			0.380392,
			0.883353,
			0.775394,
			0.517109,
			0.505882,
			0.808074,
			0.625836,
			0.324106,
			0.631373,
			0.717647,
			0.476355,
			0.15494,
			0.756863,
			0.592157,
			0.358247,
			0.06882,
			0.882353,
			0.458593,
			0.26436,
			0.031142,
			1,
			0.329412,
			0.188235,
			0.019608
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PuOr",
		RGBPoints: [
			-1,
			0.498039,
			0.231373,
			0.031373,
			-0.87451,
			0.62599,
			0.30273,
			0.026451,
			-0.74902,
			0.746943,
			0.387082,
			0.037524,
			-0.623529,
			0.85767,
			0.490427,
			0.071972,
			-0.498039,
			0.936409,
			0.617762,
			0.236371,
			-0.372549,
			0.992695,
			0.743099,
			0.43291,
			-0.247059,
			0.995156,
			0.841523,
			0.63714,
			-0.121569,
			0.985313,
			0.913802,
			0.813687,
			0.00392157,
			0.966244,
			0.966398,
			0.967705,
			0.129412,
			0.889965,
			0.89504,
			0.938178,
			0.254902,
			0.806151,
			0.804306,
			0.894656,
			0.380392,
			0.712649,
			0.688658,
			0.833141,
			0.505882,
			0.594233,
			0.554325,
			0.744637,
			0.631373,
			0.474894,
			0.404229,
			0.652364,
			0.756863,
			0.366628,
			0.217224,
			0.563783,
			0.882353,
			0.266436,
			0.089965,
			0.434833,
			1,
			0.176471,
			0,
			0.294118
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PRGn",
		RGBPoints: [
			-1,
			0.25098,
			0,
			0.294118,
			-0.87451,
			0.383852,
			0.103345,
			0.431911,
			-0.74902,
			0.497732,
			0.234679,
			0.55371,
			-0.623529,
			0.583852,
			0.40692,
			0.652134,
			-0.498039,
			0.681968,
			0.545175,
			0.742561,
			-0.372549,
			0.7807,
			0.672357,
			0.825221,
			-0.247059,
			0.871742,
			0.788005,
			0.886736,
			-0.121569,
			0.930488,
			0.885198,
			0.932872,
			0.00392157,
			0.966321,
			0.968089,
			0.965859,
			0.129412,
			0.892503,
			0.950865,
			0.877278,
			0.254902,
			0.796078,
			0.91857,
			0.772549,
			0.380392,
			0.670588,
			0.866897,
			0.647059,
			0.505882,
			0.493195,
			0.765398,
			0.496655,
			0.631373,
			0.314187,
			0.649135,
			0.354556,
			0.756863,
			0.15917,
			0.516263,
			0.251211,
			0.882353,
			0.062284,
			0.386621,
			0.170473,
			1,
			0,
			0.266667,
			0.105882
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PiYG",
		RGBPoints: [
			-1,
			0.556863,
			0.003922,
			0.321569,
			-0.87451,
			0.692195,
			0.067897,
			0.427374,
			-0.74902,
			0.797539,
			0.197847,
			0.539177,
			-0.623529,
			0.859054,
			0.424221,
			0.659746,
			-0.498039,
			0.908574,
			0.592618,
			0.770319,
			-0.372549,
			0.951557,
			0.736332,
			0.866205,
			-0.247059,
			0.981084,
			0.839677,
			0.917878,
			-0.121569,
			0.98293,
			0.913802,
			0.949558,
			0.00392157,
			0.96732,
			0.968474,
			0.965629,
			0.129412,
			0.92549,
			0.963552,
			0.869666,
			0.254902,
			0.852441,
			0.939254,
			0.736025,
			0.380392,
			0.739254,
			0.890042,
			0.553941,
			0.505882,
			0.60323,
			0.805536,
			0.382238,
			0.631373,
			0.467282,
			0.711419,
			0.235217,
			0.756863,
			0.344252,
			0.608074,
			0.156478,
			0.882353,
			0.2406,
			0.49827,
			0.116494,
			1,
			0.152941,
			0.392157,
			0.098039
		]
	},
	{
		ColorSpace: "Lab",
		Name: "OrPu",
		RGBPoints: [
			-1,
			0.176471,
			0,
			0.294118,
			-0.87451,
			0.272434,
			0.095963,
			0.444214,
			-0.74902,
			0.373395,
			0.228912,
			0.56932,
			-0.623529,
			0.481661,
			0.415917,
			0.657901,
			-0.498039,
			0.601922,
			0.562937,
			0.750481,
			-0.372549,
			0.718493,
			0.695886,
			0.836986,
			-0.247059,
			0.811995,
			0.811534,
			0.898501,
			-0.121569,
			0.894733,
			0.8995,
			0.940023,
			0.00392157,
			0.969166,
			0.966859,
			0.963629,
			0.129412,
			0.98639,
			0.910265,
			0.803691,
			0.254902,
			0.995002,
			0.835371,
			0.624375,
			0.380392,
			0.992541,
			0.736947,
			0.420146,
			0.505882,
			0.931949,
			0.609458,
			0.224221,
			0.631373,
			0.85075,
			0.483968,
			0.069819,
			0.756863,
			0.740023,
			0.380623,
			0.035371,
			0.882353,
			0.617993,
			0.29827,
			0.026759,
			1,
			0.498039,
			0.231373,
			0.031373
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BrBG",
		RGBPoints: [
			-1,
			0.329412,
			0.188235,
			0.019608,
			-0.87451,
			0.467205,
			0.269435,
			0.031911,
			-0.74902,
			0.6,
			0.365629,
			0.074202,
			-0.623529,
			0.72549,
			0.483737,
			0.160323,
			-0.498039,
			0.812995,
			0.635832,
			0.336409,
			-0.372549,
			0.88689,
			0.781238,
			0.527874,
			-0.247059,
			0.943483,
			0.87474,
			0.700115,
			-0.121569,
			0.963168,
			0.929796,
			0.841599,
			0.00392157,
			0.957247,
			0.959938,
			0.959554,
			0.129412,
			0.84406,
			0.932872,
			0.920185,
			0.254902,
			0.70396,
			0.886428,
			0.859285,
			0.380392,
			0.529258,
			0.815071,
			0.770704,
			0.505882,
			0.346251,
			0.691811,
			0.653057,
			0.631373,
			0.175855,
			0.562015,
			0.530642,
			0.756863,
			0.047905,
			0.441446,
			0.410073,
			0.882353,
			0.002307,
			0.33218,
			0.294348,
			1,
			0,
			0.235294,
			0.188235
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GyRd",
		RGBPoints: [
			-1,
			0.101961,
			0.101961,
			0.101961,
			-0.87451,
			0.227451,
			0.227451,
			0.227451,
			-0.74902,
			0.359939,
			0.359939,
			0.359939,
			-0.623529,
			0.502653,
			0.502653,
			0.502653,
			-0.498039,
			0.631373,
			0.631373,
			0.631373,
			-0.372549,
			0.749865,
			0.749865,
			0.749865,
			-0.247059,
			0.843368,
			0.843368,
			0.843368,
			-0.121569,
			0.926105,
			0.926105,
			0.926105,
			0.00392157,
			0.999846,
			0.997232,
			0.995694,
			0.129412,
			0.994925,
			0.908651,
			0.857901,
			0.254902,
			0.982468,
			0.800692,
			0.706113,
			0.380392,
			0.960323,
			0.66782,
			0.536332,
			0.505882,
			0.894579,
			0.503806,
			0.399769,
			0.631373,
			0.81707,
			0.33218,
			0.281046,
			0.756863,
			0.728489,
			0.155017,
			0.197386,
			0.882353,
			0.576932,
			0.055363,
			0.14925,
			1,
			0.403922,
			0,
			0.121569
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_divHi_purpleGreen",
		RGBPoints: [
			-1,
			0.297553,
			0,
			0.489074,
			-0.87451,
			0.40259,
			0.151146,
			0.567754,
			-0.74902,
			0.516038,
			0.284843,
			0.658231,
			-0.623529,
			0.629783,
			0.423646,
			0.750938,
			-0.498039,
			0.735198,
			0.563697,
			0.835956,
			-0.372549,
			0.82408,
			0.695541,
			0.903582,
			-0.247059,
			0.889091,
			0.807454,
			0.944862,
			-0.121569,
			0.92334,
			0.886917,
			0.951839,
			0.00392157,
			0.921045,
			0.921084,
			0.921003,
			0.129412,
			0.877324,
			0.907455,
			0.845381,
			0.254902,
			0.797649,
			0.849713,
			0.734695,
			0.380392,
			0.691646,
			0.75964,
			0.600532,
			0.505882,
			0.568981,
			0.649159,
			0.453807,
			0.631373,
			0.438945,
			0.529756,
			0.304259,
			0.756863,
			0.30973,
			0.412001,
			0.158303,
			0.882353,
			0.187078,
			0.305111,
			0.00251458,
			1,
			0.101655,
			0.220836,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_divHi_purpleGreen_dim",
		RGBPoints: [
			-1,
			0.404088,
			0.131038,
			0.592767,
			-0.87451,
			0.486469,
			0.230957,
			0.651243,
			-0.74902,
			0.575165,
			0.339335,
			0.717723,
			-0.623529,
			0.662741,
			0.454332,
			0.784263,
			-0.498039,
			0.742071,
			0.570213,
			0.842918,
			-0.372549,
			0.806935,
			0.678992,
			0.886227,
			-0.247059,
			0.852219,
			0.771315,
			0.90763,
			-0.121569,
			0.873345,
			0.837327,
			0.901572,
			0.00392157,
			0.866783,
			0.86682,
			0.866745,
			0.129412,
			0.82839,
			0.858225,
			0.796812,
			0.254902,
			0.762578,
			0.814287,
			0.700202,
			0.380392,
			0.676429,
			0.744229,
			0.585735,
			0.505882,
			0.577033,
			0.65732,
			0.461526,
			0.631373,
			0.47128,
			0.562476,
			0.33476,
			0.756863,
			0.365461,
			0.467957,
			0.21076,
			0.882353,
			0.264758,
			0.381138,
			0.0878313,
			1,
			0.182591,
			0.312249,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_divLow_icePeach",
		RGBPoints: [
			-1,
			0.480048,
			0.817441,
			0.998056,
			-0.87451,
			0.425898,
			0.726921,
			0.883187,
			-0.74902,
			0.366682,
			0.629445,
			0.761936,
			-0.623529,
			0.308756,
			0.531002,
			0.640217,
			-0.498039,
			0.258021,
			0.43705,
			0.523433,
			-0.372549,
			0.219244,
			0.352381,
			0.416348,
			-0.247059,
			0.195127,
			0.281032,
			0.322979,
			-0.121569,
			0.186286,
			0.22627,
			0.246525,
			0.00392157,
			0.192352,
			0.19236,
			0.192364,
			0.129412,
			0.255927,
			0.214469,
			0.191756,
			0.254902,
			0.340459,
			0.254426,
			0.206666,
			0.380392,
			0.444655,
			0.309315,
			0.234029,
			0.505882,
			0.565353,
			0.376004,
			0.270969,
			0.631373,
			0.697917,
			0.450748,
			0.314293,
			0.756863,
			0.836657,
			0.529064,
			0.360227,
			0.882353,
			0.972695,
			0.614884,
			0.413123,
			1,
			1,
			0.705904,
			0.472699
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_divLow_purpleGreen",
		RGBPoints: [
			-1,
			0.956034,
			0.666487,
			0.952663,
			-0.87451,
			0.874457,
			0.572698,
			0.936352,
			-0.74902,
			0.753465,
			0.488253,
			0.909063,
			-0.623529,
			0.63309,
			0.413507,
			0.763833,
			-0.498039,
			0.514491,
			0.345878,
			0.620015,
			-0.372549,
			0.405008,
			0.288141,
			0.484376,
			-0.247059,
			0.311388,
			0.241986,
			0.363556,
			-0.121569,
			0.238722,
			0.209044,
			0.263449,
			0.00392157,
			0.192352,
			0.192366,
			0.192362,
			0.129412,
			0.200379,
			0.233201,
			0.168618,
			0.254902,
			0.230151,
			0.291737,
			0.165227,
			0.380392,
			0.279481,
			0.366076,
			0.178607,
			0.505882,
			0.344927,
			0.453267,
			0.205703,
			0.631373,
			0.421554,
			0.549449,
			0.242643,
			0.756863,
			0.503334,
			0.649999,
			0.284377,
			0.882353,
			0.583497,
			0.749672,
			0.324969,
			1,
			0.650705,
			0.837228,
			0.356264
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Haze_green",
		RGBPoints: [
			-1,
			1,
			0.835294,
			0.886275,
			-0.87451,
			0.937255,
			0.756863,
			0.870443,
			-0.74902,
			0.875817,
			0.666376,
			0.857807,
			-0.623529,
			0.778359,
			0.583007,
			0.808134,
			-0.498039,
			0.676253,
			0.494118,
			0.745098,
			-0.372549,
			0.561365,
			0.390123,
			0.682353,
			-0.247059,
			0.438344,
			0.262745,
			0.621496,
			-0.121569,
			0.321133,
			0.141031,
			0.558751,
			0.00392157,
			0.203922,
			0.0217865,
			0.495861,
			0.129412,
			0.265505,
			0.129412,
			0.433261,
			0.254902,
			0.311692,
			0.255338,
			0.37008,
			0.380392,
			0.356282,
			0.377342,
			0.310821,
			0.505882,
			0.39971,
			0.488889,
			0.258243,
			0.631373,
			0.442556,
			0.604357,
			0.205519,
			0.756863,
			0.48671,
			0.71968,
			0.152941,
			0.882353,
			0.529847,
			0.830356,
			0.100944,
			1,
			0.572549,
			0.933333,
			0.054902
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Haze_lime",
		RGBPoints: [
			-1,
			0.704034,
			0.784196,
			1,
			-0.87451,
			0.633111,
			0.691418,
			0.956078,
			-0.74902,
			0.564021,
			0.600606,
			0.912157,
			-0.623529,
			0.496827,
			0.51189,
			0.868235,
			-0.498039,
			0.43157,
			0.425416,
			0.824314,
			-0.372549,
			0.368248,
			0.341347,
			0.780392,
			-0.247059,
			0.306767,
			0.259855,
			0.736471,
			-0.121569,
			0.246862,
			0.181069,
			0.692549,
			0.00392157,
			0.191619,
			0.109542,
			0.648627,
			0.129412,
			0.257404,
			0.194031,
			0.604706,
			0.254902,
			0.321794,
			0.278775,
			0.560784,
			0.380392,
			0.387909,
			0.364617,
			0.516863,
			0.505882,
			0.456569,
			0.451881,
			0.472941,
			0.631373,
			0.527424,
			0.540773,
			0.42902,
			0.756863,
			0.599759,
			0.631427,
			0.385098,
			0.882353,
			0.673065,
			0.723898,
			0.341176,
			1,
			0.742751,
			0.812252,
			0.3
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Haze",
		RGBPoints: [
			-1,
			1,
			0.835294,
			0.996078,
			-0.00392157,
			0.023529,
			0.141176,
			0.498039,
			0.00392157,
			0.015686,
			0.137255,
			0.494118,
			1,
			0.984314,
			0.764706,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Haze_cyan",
		RGBPoints: [
			-1,
			0.956863,
			1,
			0.835294,
			-0.87451,
			0.933188,
			0.921714,
			0.760784,
			-0.74902,
			0.870588,
			0.803486,
			0.671605,
			-0.623529,
			0.807843,
			0.684096,
			0.583297,
			-0.498039,
			0.745098,
			0.569208,
			0.494118,
			-0.372549,
			0.682353,
			0.437763,
			0.390123,
			-0.247059,
			0.621496,
			0.288163,
			0.262745,
			-0.121569,
			0.558751,
			0.144517,
			0.141031,
			0.00392157,
			0.495861,
			0.0217865,
			0.0413943,
			0.129412,
			0.433261,
			0.137255,
			0.129412,
			0.254902,
			0.37008,
			0.263181,
			0.255338,
			0.380392,
			0.306318,
			0.381845,
			0.372694,
			0.505882,
			0.243137,
			0.503994,
			0.494263,
			0.631373,
			0.180392,
			0.629484,
			0.619753,
			0.756863,
			0.117647,
			0.754975,
			0.747131,
			0.882353,
			0.054902,
			0.876398,
			0.866812,
			1,
			0,
			0.988235,
			0.976471
		]
	},
	{
		ColorSpace: "Lab",
		Name: "nic_Edge",
		RGBPoints: [
			-1,
			0.191208,
			0.191208,
			0.191208,
			-0.87451,
			0.239484,
			0.00545035,
			0.614821,
			-0.74902,
			0.220593,
			0.0617459,
			0.863547,
			-0.623529,
			0.17509,
			0.278988,
			0.97794,
			-0.498039,
			0.143526,
			0.576069,
			0.998553,
			-0.372549,
			0.166456,
			0.871883,
			0.96594,
			-0.247059,
			0.376202,
			0.993555,
			0.981833,
			-0.121569,
			0.681996,
			0.991297,
			0.999239,
			0.00392157,
			0.954172,
			0.952734,
			0.94374,
			0.129412,
			0.999735,
			0.99301,
			0.662896,
			0.254902,
			0.979399,
			0.991466,
			0.357973,
			0.380392,
			0.968771,
			0.854967,
			0.162659,
			0.505882,
			0.999245,
			0.556697,
			0.144323,
			0.631373,
			0.973959,
			0.26223,
			0.177946,
			0.756863,
			0.852358,
			0.0526707,
			0.222974,
			0.882353,
			0.593889,
			0.00912724,
			0.238855,
			1,
			0.191208,
			0.191208,
			0.191208
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_iceFire_H",
		RGBPoints: [
			-1,
			4.05432e-7,
			0,
			0.00000590122,
			-0.87451,
			0,
			0.120401,
			0.302675,
			-0.74902,
			0,
			0.216583,
			0.524574,
			-0.623529,
			0.0552475,
			0.345025,
			0.6595,
			-0.498039,
			0.128047,
			0.492588,
			0.720288,
			-0.372549,
			0.188955,
			0.641309,
			0.792092,
			-0.247059,
			0.327673,
			0.784935,
			0.873434,
			-0.121569,
			0.60824,
			0.892164,
			0.935547,
			0.00392157,
			0.881371,
			0.912178,
			0.818099,
			0.129412,
			0.951407,
			0.835621,
			0.449279,
			0.254902,
			0.904481,
			0.690489,
			0,
			0.380392,
			0.85407,
			0.510864,
			0,
			0.505882,
			0.777093,
			0.33018,
			0.00088199,
			0.631373,
			0.672862,
			0.139087,
			0.00269398,
			0.756863,
			0.508815,
			0,
			0,
			0.882353,
			0.299417,
			0.000366289,
			0.000547829,
			1,
			0.0157519,
			0.00332021,
			4.55569e-8
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_iceFire_L",
		RGBPoints: [
			-1,
			0.870485,
			0.913768,
			0.832905,
			-0.87451,
			0.586919,
			0.887865,
			0.934003,
			-0.74902,
			0.31583,
			0.776442,
			0.867858,
			-0.623529,
			0.18302,
			0.632034,
			0.787722,
			-0.498039,
			0.117909,
			0.484134,
			0.713825,
			-0.372549,
			0.0507239,
			0.335979,
			0.654741,
			-0.247059,
			0,
			0.209874,
			0.511832,
			-0.121569,
			0,
			0.114689,
			0.28935,
			0.00392157,
			0.0157519,
			0.00332021,
			4.55569e-8,
			0.129412,
			0.312914,
			0,
			0,
			0.254902,
			0.520865,
			0,
			0,
			0.380392,
			0.680105,
			0.15255,
			0.0025996,
			0.505882,
			0.785109,
			0.339479,
			0.000797922,
			0.631373,
			0.857354,
			0.522494,
			0,
			0.756863,
			0.910974,
			0.699774,
			0,
			0.882353,
			0.951921,
			0.842817,
			0.478545,
			1,
			0.881371,
			0.912178,
			0.818099
		]
	},
	{
		ColorSpace: "RGB",
		Name: "hsv",
		RGBPoints: [
			-1,
			1,
			0,
			0,
			-0.666666,
			1,
			0,
			1,
			-0.333333,
			0,
			0,
			1,
			0,
			0,
			1,
			1,
			0.33333,
			0,
			1,
			0,
			0.66666,
			1,
			1,
			0,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "hue_L60",
		RGBPoints: [
			-1,
			0.964784,
			0.400592,
			0.349549,
			-0.87451,
			0.964915,
			0.372498,
			0.53785,
			-0.74902,
			0.892353,
			0.401039,
			0.759569,
			-0.623529,
			0.79263,
			0.446956,
			0.903017,
			-0.498039,
			0.682208,
			0.49954,
			0.966673,
			-0.372549,
			0.56392,
			0.553082,
			0.968836,
			-0.247059,
			0.442031,
			0.606396,
			0.901601,
			-0.121569,
			0.305499,
			0.65701,
			0.765784,
			0.00392157,
			0.197251,
			0.687914,
			0.620914,
			0.129412,
			0.193882,
			0.701887,
			0.472654,
			0.254902,
			0.249866,
			0.706123,
			0.320005,
			0.380392,
			0.35132,
			0.697417,
			0.202919,
			0.505882,
			0.498097,
			0.669467,
			0.125232,
			0.631373,
			0.637477,
			0.626239,
			0.107431,
			0.756863,
			0.762115,
			0.56872,
			0.155812,
			0.882353,
			0.889434,
			0.481116,
			0.240445,
			1,
			0.964784,
			0.400592,
			0.349549
		]
	},
	{
		IndexedColors: [
			0,
			0,
			0,
			0.8941176470588236,
			0.1019607843137255,
			0.1098039215686274,
			0.2156862745098039,
			0.4941176470588236,
			0.7215686274509804,
			0.3019607843137255,
			0.6862745098039216,
			0.2901960784313726,
			0.596078431372549,
			0.3058823529411765,
			0.6392156862745098,
			1,
			0.4980392156862745,
			0,
			0.6509803921568628,
			0.3372549019607843,
			0.1568627450980392
		],
		Name: "Spectrum",
		NanColor: [
			0.6509803921568628,
			0.3372549019607843,
			0.1568627450980392
		]
	},
	{
		IndexedColors: [
			0.4745098039215686,
			0.09019607843137255,
			0.09019607843137255,
			0.7098039215686275,
			0.00392156862745098,
			0.00392156862745098,
			0.9372549019607843,
			0.2784313725490196,
			0.09803921568627451,
			0.9764705882352941,
			0.5137254901960784,
			0.1411764705882353,
			1,
			0.7058823529411765,
			0,
			1,
			0.8980392156862745,
			0.02352941176470588
		],
		Name: "Warm",
		NanColor: [
			1,
			0.8980392156862745,
			0.02352941176470588
		]
	},
	{
		IndexedColors: [
			0.4588235294117647,
			0.6941176470588235,
			0.00392156862745098,
			0.3450980392156863,
			0.5019607843137255,
			0.1607843137254902,
			0.3137254901960784,
			0.8431372549019608,
			0.7490196078431373,
			0.1098039215686274,
			0.5843137254901961,
			0.803921568627451,
			0.2313725490196079,
			0.407843137254902,
			0.6705882352941176,
			0.6039215686274509,
			0.407843137254902,
			1,
			0.3725490196078431,
			0.2,
			0.5019607843137255
		],
		Name: "Cool",
		NanColor: [
			0.3725490196078431,
			0.2,
			0.5019607843137255
		]
	},
	{
		IndexedColors: [
			0.2313725490196079,
			0.407843137254902,
			0.6705882352941176,
			0.1098039215686274,
			0.5843137254901961,
			0.803921568627451,
			0.3058823529411765,
			0.8509803921568627,
			0.9176470588235294,
			0.4509803921568628,
			0.6039215686274509,
			0.8352941176470589,
			0.2588235294117647,
			0.2392156862745098,
			0.6627450980392157,
			0.3137254901960784,
			0.3294117647058823,
			0.5294117647058824,
			0.06274509803921569,
			0.1647058823529412,
			0.3215686274509804
		],
		Name: "Blues",
		NanColor: [
			0.06274509803921569,
			0.1647058823529412,
			0.3215686274509804
		]
	},
	{
		IndexedColors: [
			0.1098039215686274,
			0.5843137254901961,
			0.803921568627451,
			0.2313725490196079,
			0.407843137254902,
			0.6705882352941176,
			0.4,
			0.2431372549019608,
			0.7176470588235294,
			0.6352941176470588,
			0.3294117647058823,
			0.8117647058823529,
			0.8705882352941177,
			0.3803921568627451,
			0.807843137254902,
			0.8627450980392157,
			0.3803921568627451,
			0.5843137254901961,
			0.2392156862745098,
			0.06274509803921569,
			0.3215686274509804
		],
		Name: "Wild Flower",
		NanColor: [
			0.2392156862745098,
			0.06274509803921569,
			0.3215686274509804
		]
	},
	{
		IndexedColors: [
			0.396078431372549,
			0.4862745098039216,
			0.2156862745098039,
			0.4588235294117647,
			0.6941176470588235,
			0.00392156862745098,
			0.6980392156862745,
			0.7294117647058823,
			0.1882352941176471,
			1,
			0.8980392156862745,
			0.02352941176470588,
			1,
			0.7058823529411765,
			0,
			0.9764705882352941,
			0.5137254901960784,
			0.1411764705882353
		],
		Name: "Citrus",
		NanColor: [
			0.9764705882352941,
			0.5137254901960784,
			0.1411764705882353
		]
	},
	{
		IndexedColors: [
			0.4980392156862745,
			0.2313725490196079,
			0.03137254901960784,
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.8784313725490196,
			0.5098039215686274,
			0.0784313725490196,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.5019607843137255,
			0.4509803921568628,
			0.6745098039215687,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333,
			0.1764705882352941,
			0,
			0.2941176470588235
		],
		Name: "Brewer Diverging Purple-Orange (11)",
		NanColor: [
			0.1764705882352941,
			0,
			0.2941176470588235
		]
	},
	{
		IndexedColors: [
			0.4980392156862745,
			0.2313725490196079,
			0.03137254901960784,
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.8784313725490196,
			0.5098039215686274,
			0.0784313725490196,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.5019607843137255,
			0.4509803921568628,
			0.6745098039215687,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333,
			0.1764705882352941,
			0,
			0.2941176470588235
		],
		Name: "Brewer Diverging Purple-Orange (10)",
		NanColor: [
			0.1764705882352941,
			0,
			0.2941176470588235
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.8784313725490196,
			0.5098039215686274,
			0.0784313725490196,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.5019607843137255,
			0.4509803921568628,
			0.6745098039215687,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		],
		Name: "Brewer Diverging Purple-Orange (9)",
		NanColor: [
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.8784313725490196,
			0.5098039215686274,
			0.0784313725490196,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.5019607843137255,
			0.4509803921568628,
			0.6745098039215687,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		],
		Name: "Brewer Diverging Purple-Orange (8)",
		NanColor: [
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.9450980392156862,
			0.6392156862745098,
			0.2509803921568627,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6,
			0.5568627450980392,
			0.7647058823529411,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		],
		Name: "Brewer Diverging Purple-Orange (7)",
		NanColor: [
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.9450980392156862,
			0.6392156862745098,
			0.2509803921568627,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6,
			0.5568627450980392,
			0.7647058823529411,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		],
		Name: "Brewer Diverging Purple-Orange (6)",
		NanColor: [
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		]
	},
	{
		IndexedColors: [
			0.9019607843137255,
			0.3803921568627451,
			0.00392156862745098,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.3686274509803922,
			0.2352941176470588,
			0.6
		],
		Name: "Brewer Diverging Purple-Orange (5)",
		NanColor: [
			0.3686274509803922,
			0.2352941176470588,
			0.6
		]
	},
	{
		IndexedColors: [
			0.9019607843137255,
			0.3803921568627451,
			0.00392156862745098,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.3686274509803922,
			0.2352941176470588,
			0.6
		],
		Name: "Brewer Diverging Purple-Orange (4)",
		NanColor: [
			0.3686274509803922,
			0.2352941176470588,
			0.6
		]
	},
	{
		IndexedColors: [
			0.9450980392156862,
			0.6392156862745098,
			0.2509803921568627,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.6,
			0.5568627450980392,
			0.7647058823529411
		],
		Name: "Brewer Diverging Purple-Orange (3)",
		NanColor: [
			0.6,
			0.5568627450980392,
			0.7647058823529411
		]
	},
	{
		IndexedColors: [
			0.6196078431372549,
			0.00392156862745098,
			0.2588235294117647,
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9568627450980393,
			0.4274509803921568,
			0.2627450980392157,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			1,
			1,
			0.7490196078431373,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353,
			0.3686274509803922,
			0.3098039215686275,
			0.6352941176470588
		],
		Name: "Brewer Diverging Spectral (11)",
		NanColor: [
			0.3686274509803922,
			0.3098039215686275,
			0.6352941176470588
		]
	},
	{
		IndexedColors: [
			0.6196078431372549,
			0.00392156862745098,
			0.2588235294117647,
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9568627450980393,
			0.4274509803921568,
			0.2627450980392157,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353,
			0.3686274509803922,
			0.3098039215686275,
			0.6352941176470588
		],
		Name: "Brewer Diverging Spectral (10)",
		NanColor: [
			0.3686274509803922,
			0.3098039215686275,
			0.6352941176470588
		]
	},
	{
		IndexedColors: [
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9568627450980393,
			0.4274509803921568,
			0.2627450980392157,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			1,
			1,
			0.7490196078431373,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		],
		Name: "Brewer Diverging Spectral (9)",
		NanColor: [
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		]
	},
	{
		IndexedColors: [
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9568627450980393,
			0.4274509803921568,
			0.2627450980392157,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		],
		Name: "Brewer Diverging Spectral (8)",
		NanColor: [
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		]
	},
	{
		IndexedColors: [
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9882352941176471,
			0.5529411764705883,
			0.3490196078431372,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			1,
			1,
			0.7490196078431373,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6,
			0.8352941176470589,
			0.5803921568627451,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		],
		Name: "Brewer Diverging Spectral (7)",
		NanColor: [
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		]
	},
	{
		IndexedColors: [
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9882352941176471,
			0.5529411764705883,
			0.3490196078431372,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6,
			0.8352941176470589,
			0.5803921568627451,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		],
		Name: "Brewer Diverging Spectral (6)",
		NanColor: [
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		]
	},
	{
		IndexedColors: [
			0.8431372549019608,
			0.09803921568627451,
			0.1098039215686274,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			1,
			1,
			0.7490196078431373,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.1686274509803922,
			0.5137254901960784,
			0.7294117647058823
		],
		Name: "Brewer Diverging Spectral (5)",
		NanColor: [
			0.1686274509803922,
			0.5137254901960784,
			0.7294117647058823
		]
	},
	{
		IndexedColors: [
			0.8431372549019608,
			0.09803921568627451,
			0.1098039215686274,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.1686274509803922,
			0.5137254901960784,
			0.7294117647058823
		],
		Name: "Brewer Diverging Spectral (4)",
		NanColor: [
			0.1686274509803922,
			0.5137254901960784,
			0.7294117647058823
		]
	},
	{
		IndexedColors: [
			0.9882352941176471,
			0.5529411764705883,
			0.3490196078431372,
			1,
			1,
			0.7490196078431373,
			0.6,
			0.8352941176470589,
			0.5803921568627451
		],
		Name: "Brewer Diverging Spectral (3)",
		NanColor: [
			0.6,
			0.8352941176470589,
			0.5803921568627451
		]
	},
	{
		IndexedColors: [
			0.3294117647058823,
			0.1882352941176471,
			0.0196078431372549,
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.7490196078431373,
			0.5058823529411764,
			0.1764705882352941,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.207843137254902,
			0.592156862745098,
			0.5607843137254902,
			0.00392156862745098,
			0.4,
			0.3686274509803922,
			0,
			0.2352941176470588,
			0.1882352941176471
		],
		Name: "Brewer Diverging Brown-Blue-Green (11)",
		NanColor: [
			0,
			0.2352941176470588,
			0.1882352941176471
		]
	},
	{
		IndexedColors: [
			0.3294117647058823,
			0.1882352941176471,
			0.0196078431372549,
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.7490196078431373,
			0.5058823529411764,
			0.1764705882352941,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.207843137254902,
			0.592156862745098,
			0.5607843137254902,
			0.00392156862745098,
			0.4,
			0.3686274509803922,
			0,
			0.2352941176470588,
			0.1882352941176471
		],
		Name: "Brewer Diverging Brown-Blue-Green (10)",
		NanColor: [
			0,
			0.2352941176470588,
			0.1882352941176471
		]
	},
	{
		IndexedColors: [
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.7490196078431373,
			0.5058823529411764,
			0.1764705882352941,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.207843137254902,
			0.592156862745098,
			0.5607843137254902,
			0.00392156862745098,
			0.4,
			0.3686274509803922
		],
		Name: "Brewer Diverging Brown-Blue-Green (9)",
		NanColor: [
			0.00392156862745098,
			0.4,
			0.3686274509803922
		]
	},
	{
		IndexedColors: [
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.7490196078431373,
			0.5058823529411764,
			0.1764705882352941,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.207843137254902,
			0.592156862745098,
			0.5607843137254902,
			0.00392156862745098,
			0.4,
			0.3686274509803922
		],
		Name: "Brewer Diverging Brown-Blue-Green (8)",
		NanColor: [
			0.00392156862745098,
			0.4,
			0.3686274509803922
		]
	},
	{
		IndexedColors: [
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.8470588235294118,
			0.7019607843137254,
			0.396078431372549,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.3529411764705883,
			0.7058823529411765,
			0.6745098039215687,
			0.00392156862745098,
			0.4,
			0.3686274509803922
		],
		Name: "Brewer Diverging Brown-Blue-Green (7)",
		NanColor: [
			0.00392156862745098,
			0.4,
			0.3686274509803922
		]
	},
	{
		IndexedColors: [
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.8470588235294118,
			0.7019607843137254,
			0.396078431372549,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.3529411764705883,
			0.7058823529411765,
			0.6745098039215687,
			0.00392156862745098,
			0.4,
			0.3686274509803922
		],
		Name: "Brewer Diverging Brown-Blue-Green (6)",
		NanColor: [
			0.00392156862745098,
			0.4,
			0.3686274509803922
		]
	},
	{
		IndexedColors: [
			0.6509803921568628,
			0.3803921568627451,
			0.1019607843137255,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.00392156862745098,
			0.5215686274509804,
			0.4431372549019608
		],
		Name: "Brewer Diverging Brown-Blue-Green (5)",
		NanColor: [
			0.00392156862745098,
			0.5215686274509804,
			0.4431372549019608
		]
	},
	{
		IndexedColors: [
			0.6509803921568628,
			0.3803921568627451,
			0.1019607843137255,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.00392156862745098,
			0.5215686274509804,
			0.4431372549019608
		],
		Name: "Brewer Diverging Brown-Blue-Green (4)",
		NanColor: [
			0.00392156862745098,
			0.5215686274509804,
			0.4431372549019608
		]
	},
	{
		IndexedColors: [
			0.8470588235294118,
			0.7019607843137254,
			0.396078431372549,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.3529411764705883,
			0.7058823529411765,
			0.6745098039215687
		],
		Name: "Brewer Diverging Brown-Blue-Green (3)",
		NanColor: [
			0.3529411764705883,
			0.7058823529411765,
			0.6745098039215687
		]
	},
	{
		IndexedColors: [
			0.9686274509803922,
			0.9882352941176471,
			0.9921568627450981,
			0.8980392156862745,
			0.9607843137254902,
			0.9764705882352941,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.6,
			0.8470588235294118,
			0.788235294117647,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.2549019607843137,
			0.6823529411764706,
			0.4627450980392157,
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176,
			0,
			0.4274509803921568,
			0.1725490196078431,
			0,
			0.2666666666666667,
			0.1058823529411765
		],
		Name: "Brewer Sequential Blue-Green (9)",
		NanColor: [
			0,
			0.2666666666666667,
			0.1058823529411765
		]
	},
	{
		IndexedColors: [
			0.9686274509803922,
			0.9882352941176471,
			0.9921568627450981,
			0.8980392156862745,
			0.9607843137254902,
			0.9764705882352941,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.6,
			0.8470588235294118,
			0.788235294117647,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.2549019607843137,
			0.6823529411764706,
			0.4627450980392157,
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176,
			0,
			0.3450980392156863,
			0.1411764705882353
		],
		Name: "Brewer Sequential Blue-Green (8)",
		NanColor: [
			0,
			0.3450980392156863,
			0.1411764705882353
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.2549019607843137,
			0.6823529411764706,
			0.4627450980392157,
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176,
			0,
			0.3450980392156863,
			0.1411764705882353
		],
		Name: "Brewer Sequential Blue-Green (7)",
		NanColor: [
			0,
			0.3450980392156863,
			0.1411764705882353
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.6,
			0.8470588235294118,
			0.788235294117647,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.1725490196078431,
			0.6352941176470588,
			0.3725490196078431,
			0,
			0.4274509803921568,
			0.1725490196078431
		],
		Name: "Brewer Sequential Blue-Green (6)",
		NanColor: [
			0,
			0.4274509803921568,
			0.1725490196078431
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.6980392156862745,
			0.8862745098039215,
			0.8862745098039215,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.1725490196078431,
			0.6352941176470588,
			0.3725490196078431,
			0,
			0.4274509803921568,
			0.1725490196078431
		],
		Name: "Brewer Sequential Blue-Green (5)",
		NanColor: [
			0,
			0.4274509803921568,
			0.1725490196078431
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.6980392156862745,
			0.8862745098039215,
			0.8862745098039215,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176
		],
		Name: "Brewer Sequential Blue-Green (4)",
		NanColor: [
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176
		]
	},
	{
		IndexedColors: [
			0.8980392156862745,
			0.9607843137254902,
			0.9764705882352941,
			0.6,
			0.8470588235294118,
			0.788235294117647,
			0.1725490196078431,
			0.6352941176470588,
			0.3725490196078431
		],
		Name: "Brewer Sequential Blue-Green (3)",
		NanColor: [
			0.1725490196078431,
			0.6352941176470588,
			0.3725490196078431
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8980392156862745,
			1,
			0.9686274509803922,
			0.7372549019607844,
			0.996078431372549,
			0.8901960784313725,
			0.5686274509803921,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.9254901960784314,
			0.4392156862745098,
			0.0784313725490196,
			0.8,
			0.2980392156862745,
			0.00784313725490196,
			0.6,
			0.203921568627451,
			0.01568627450980392,
			0.4,
			0.1450980392156863,
			0.02352941176470588
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (9)",
		NanColor: [
			0.4,
			0.1450980392156863,
			0.02352941176470588
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8980392156862745,
			1,
			0.9686274509803922,
			0.7372549019607844,
			0.996078431372549,
			0.8901960784313725,
			0.5686274509803921,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.9254901960784314,
			0.4392156862745098,
			0.0784313725490196,
			0.8,
			0.2980392156862745,
			0.00784313725490196,
			0.5490196078431373,
			0.1764705882352941,
			0.01568627450980392
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (8)",
		NanColor: [
			0.5490196078431373,
			0.1764705882352941,
			0.01568627450980392
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8313725490196079,
			0.996078431372549,
			0.8901960784313725,
			0.5686274509803921,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.9254901960784314,
			0.4392156862745098,
			0.0784313725490196,
			0.8,
			0.2980392156862745,
			0.00784313725490196,
			0.5490196078431373,
			0.1764705882352941,
			0.01568627450980392
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (7)",
		NanColor: [
			0.5490196078431373,
			0.1764705882352941,
			0.01568627450980392
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8313725490196079,
			0.996078431372549,
			0.8901960784313725,
			0.5686274509803921,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.8509803921568627,
			0.3725490196078431,
			0.05490196078431372,
			0.6,
			0.203921568627451,
			0.01568627450980392
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (6)",
		NanColor: [
			0.6,
			0.203921568627451,
			0.01568627450980392
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8313725490196079,
			0.996078431372549,
			0.8509803921568627,
			0.5568627450980392,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.8509803921568627,
			0.3725490196078431,
			0.05490196078431372,
			0.6,
			0.203921568627451,
			0.01568627450980392
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (5)",
		NanColor: [
			0.6,
			0.203921568627451,
			0.01568627450980392
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8313725490196079,
			0.996078431372549,
			0.8509803921568627,
			0.5568627450980392,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.8,
			0.2980392156862745,
			0.00784313725490196
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (4)",
		NanColor: [
			0.8,
			0.2980392156862745,
			0.00784313725490196
		]
	},
	{
		IndexedColors: [
			1,
			0.9686274509803922,
			0.7372549019607844,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.8509803921568627,
			0.3725490196078431,
			0.05490196078431372
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (3)",
		NanColor: [
			0.8509803921568627,
			0.3725490196078431,
			0.05490196078431372
		]
	},
	{
		IndexedColors: [
			0.9686274509803922,
			0.9882352941176471,
			0.9921568627450981,
			0.8784313725490196,
			0.9254901960784314,
			0.9568627450980393,
			0.7490196078431373,
			0.8274509803921568,
			0.9019607843137255,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5490196078431373,
			0.4196078431372549,
			0.6941176470588235,
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804,
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216,
			0.3019607843137255,
			0,
			0.2941176470588235
		],
		Name: "Brewer Sequential Blue-Purple (9)",
		NanColor: [
			0.3019607843137255,
			0,
			0.2941176470588235
		]
	},
	{
		IndexedColors: [
			0.9686274509803922,
			0.9882352941176471,
			0.9921568627450981,
			0.8784313725490196,
			0.9254901960784314,
			0.9568627450980393,
			0.7490196078431373,
			0.8274509803921568,
			0.9019607843137255,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5490196078431373,
			0.4196078431372549,
			0.6941176470588235,
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804,
			0.4313725490196079,
			0.00392156862745098,
			0.4196078431372549
		],
		Name: "Brewer Sequential Blue-Purple (8)",
		NanColor: [
			0.4313725490196079,
			0.00392156862745098,
			0.4196078431372549
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.7490196078431373,
			0.8274509803921568,
			0.9019607843137255,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5490196078431373,
			0.4196078431372549,
			0.6941176470588235,
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804,
			0.4313725490196079,
			0.00392156862745098,
			0.4196078431372549
		],
		Name: "Brewer Sequential Blue-Purple (7)",
		NanColor: [
			0.4313725490196079,
			0.00392156862745098,
			0.4196078431372549
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.7490196078431373,
			0.8274509803921568,
			0.9019607843137255,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5333333333333333,
			0.3372549019607843,
			0.6549019607843137,
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216
		],
		Name: "Brewer Sequential Blue-Purple (6)",
		NanColor: [
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.7019607843137254,
			0.803921568627451,
			0.8901960784313725,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5333333333333333,
			0.3372549019607843,
			0.6549019607843137,
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216
		],
		Name: "Brewer Sequential Blue-Purple (5)",
		NanColor: [
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.7019607843137254,
			0.803921568627451,
			0.8901960784313725,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804
		],
		Name: "Brewer Sequential Blue-Purple (4)",
		NanColor: [
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804
		]
	},
	{
		IndexedColors: [
			0.8784313725490196,
			0.9254901960784314,
			0.9568627450980393,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5333333333333333,
			0.3372549019607843,
			0.6549019607843137
		],
		Name: "Brewer Sequential Blue-Purple (3)",
		NanColor: [
			0.5333333333333333,
			0.3372549019607843,
			0.6549019607843137
		]
	},
	{
		IndexedColors: [
			0.4980392156862745,
			0.788235294117647,
			0.4980392156862745,
			0.7450980392156863,
			0.6823529411764706,
			0.8313725490196079,
			0.9921568627450981,
			0.7529411764705882,
			0.5254901960784314,
			1,
			1,
			0.6,
			0.2196078431372549,
			0.4235294117647059,
			0.6901960784313725,
			0.9411764705882353,
			0.00784313725490196,
			0.4980392156862745,
			0.7490196078431373,
			0.3568627450980392,
			0.09019607843137255,
			0.4,
			0.4,
			0.4
		],
		Name: "Brewer Qualitative Accent",
		NanColor: [
			0.4,
			0.4,
			0.4
		]
	},
	{
		IndexedColors: [
			0.1058823529411765,
			0.6196078431372549,
			0.4666666666666667,
			0.8509803921568627,
			0.3725490196078431,
			0.00784313725490196,
			0.4588235294117647,
			0.4392156862745098,
			0.7019607843137254,
			0.9058823529411765,
			0.1607843137254902,
			0.5411764705882353,
			0.4,
			0.6509803921568628,
			0.1176470588235294,
			0.9019607843137255,
			0.6705882352941176,
			0.00784313725490196,
			0.6509803921568628,
			0.4627450980392157,
			0.1137254901960784,
			0.4,
			0.4,
			0.4
		],
		Name: "Brewer Qualitative Dark2",
		NanColor: [
			0.4,
			0.4,
			0.4
		]
	},
	{
		IndexedColors: [
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.9882352941176471,
			0.5529411764705883,
			0.3843137254901961,
			0.5529411764705883,
			0.6274509803921569,
			0.796078431372549,
			0.9058823529411765,
			0.5411764705882353,
			0.7647058823529411,
			0.6509803921568628,
			0.8470588235294118,
			0.3294117647058823,
			1,
			0.8509803921568627,
			0.1843137254901961,
			0.8980392156862745,
			0.7686274509803922,
			0.5803921568627451,
			0.7019607843137254,
			0.7019607843137254,
			0.7019607843137254
		],
		Name: "Brewer Qualitative Set2",
		NanColor: [
			0.7019607843137254,
			0.7019607843137254,
			0.7019607843137254
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.8862745098039215,
			0.803921568627451,
			0.9921568627450981,
			0.803921568627451,
			0.6745098039215687,
			0.796078431372549,
			0.8352941176470589,
			0.9098039215686274,
			0.9568627450980393,
			0.792156862745098,
			0.8941176470588236,
			0.9019607843137255,
			0.9607843137254902,
			0.788235294117647,
			1,
			0.9490196078431372,
			0.6823529411764706,
			0.9450980392156862,
			0.8862745098039215,
			0.8,
			0.8,
			0.8,
			0.8
		],
		Name: "Brewer Qualitative Pastel2",
		NanColor: [
			0.8,
			0.8,
			0.8
		]
	},
	{
		IndexedColors: [
			0.984313725490196,
			0.7058823529411765,
			0.6823529411764706,
			0.7019607843137254,
			0.803921568627451,
			0.8901960784313725,
			0.8,
			0.9215686274509803,
			0.7725490196078432,
			0.8705882352941177,
			0.796078431372549,
			0.8941176470588236,
			0.996078431372549,
			0.8509803921568627,
			0.6509803921568628,
			1,
			1,
			0.8,
			0.8980392156862745,
			0.8470588235294118,
			0.7411764705882353,
			0.9921568627450981,
			0.8549019607843137,
			0.9254901960784314,
			0.9490196078431372,
			0.9490196078431372,
			0.9490196078431372
		],
		Name: "Brewer Qualitative Pastel1",
		NanColor: [
			0.9490196078431372,
			0.9490196078431372,
			0.9490196078431372
		]
	},
	{
		IndexedColors: [
			0.8941176470588236,
			0.1019607843137255,
			0.1098039215686274,
			0.2156862745098039,
			0.4941176470588236,
			0.7215686274509804,
			0.3019607843137255,
			0.6862745098039216,
			0.2901960784313726,
			0.596078431372549,
			0.3058823529411765,
			0.6392156862745098,
			1,
			0.4980392156862745,
			0,
			1,
			1,
			0.2,
			0.6509803921568628,
			0.3372549019607843,
			0.1568627450980392,
			0.9686274509803922,
			0.5058823529411764,
			0.7490196078431373,
			0.6,
			0.6,
			0.6
		],
		Name: "Brewer Qualitative Set1",
		NanColor: [
			0.6,
			0.6,
			0.6
		]
	},
	{
		IndexedColors: [
			0.6509803921568628,
			0.807843137254902,
			0.8901960784313725,
			0.1215686274509804,
			0.4705882352941176,
			0.7058823529411765,
			0.6980392156862745,
			0.8745098039215686,
			0.5411764705882353,
			0.2,
			0.6274509803921569,
			0.1725490196078431,
			0.984313725490196,
			0.6039215686274509,
			0.6,
			0.8901960784313725,
			0.1019607843137255,
			0.1098039215686274,
			0.9921568627450981,
			0.7490196078431373,
			0.4352941176470588,
			1,
			0.4980392156862745,
			0,
			0.792156862745098,
			0.6980392156862745,
			0.8392156862745098,
			0.4156862745098039,
			0.2392156862745098,
			0.6039215686274509,
			1,
			1,
			0.6
		],
		Name: "Brewer Qualitative Paired",
		NanColor: [
			1,
			1,
			0.6
		]
	},
	{
		IndexedColors: [
			0.5529411764705883,
			0.8274509803921568,
			0.7803921568627451,
			1,
			1,
			0.7019607843137254,
			0.7450980392156863,
			0.7294117647058823,
			0.8549019607843137,
			0.984313725490196,
			0.5019607843137255,
			0.4470588235294118,
			0.5019607843137255,
			0.6941176470588235,
			0.8274509803921568,
			0.9921568627450981,
			0.7058823529411765,
			0.3843137254901961,
			0.7019607843137254,
			0.8705882352941177,
			0.4117647058823529,
			0.9882352941176471,
			0.803921568627451,
			0.8980392156862745,
			0.8509803921568627,
			0.8509803921568627,
			0.8509803921568627,
			0.7372549019607844,
			0.5019607843137255,
			0.7411764705882353,
			0.8,
			0.9215686274509803,
			0.7725490196078432,
			1,
			0.9294117647058824,
			0.4352941176470588
		],
		Name: "Brewer Qualitative Set3",
		NanColor: [
			1,
			0.9294117647058824,
			0.4352941176470588
		]
	},
	{
		IndexedColors: [
			1,
			0,
			0,
			1,
			0.862745,
			0,
			0,
			0.695201,
			0
		],
		Name: "Traffic Lights",
		NanColor: [
			0.803922,
			0,
			0.803922
		]
	},
	{
		IndexedColors: [
			0.908659,
			0.604013,
			0.581857,
			1,
			0.862745,
			0,
			0,
			0.695201,
			0
		],
		Name: "Traffic Lights For Deuteranopes",
		NanColor: [
			0.803922,
			0,
			0.803922
		]
	},
	{
		IndexedColors: [
			0.4196078431372549,
			0,
			0.07058823529411765,
			0.9019607843137255,
			0.9411764705882353,
			0.0196078431372549,
			0.01568627450980392,
			0.6196078431372549,
			0.00784313725490196
		],
		Name: "Traffic Lights For Deuteranopes 2",
		NanColor: [
			0.803922,
			0,
			0.803922
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Muted Blue-Green",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.109804,
			0.27451,
			0.301961,
			0.02,
			0.129412,
			0.309804,
			0.341176,
			0.05,
			0.14902,
			0.341176,
			0.380392,
			0.1,
			0.188235,
			0.403922,
			0.458824,
			0.15,
			0.227451,
			0.447059,
			0.521569,
			0.2,
			0.290196,
			0.494118,
			0.588235,
			0.25,
			0.368627,
			0.552941,
			0.670588,
			0.3,
			0.458824,
			0.619608,
			0.74902,
			0.35,
			0.588235,
			0.713725,
			0.85098,
			0.4,
			0.72549,
			0.815686,
			0.941176,
			0.45,
			0.831373,
			0.882353,
			0.980392,
			0.475,
			0.909804,
			0.933333,
			1,
			0.5,
			0.980392,
			0.984314,
			1,
			0.5,
			0.996078,
			1,
			0.94902,
			0.5,
			1,
			1,
			0.980392,
			0.5,
			0.980392,
			0.984314,
			1,
			0.525,
			0.972549,
			0.988235,
			0.890196,
			0.55,
			0.917647,
			0.960784,
			0.835294,
			0.6,
			0.835294,
			0.921569,
			0.772549,
			0.65,
			0.768627,
			0.901961,
			0.737255,
			0.7,
			0.670588,
			0.831373,
			0.654902,
			0.75,
			0.576471,
			0.760784,
			0.584314,
			0.8,
			0.498039,
			0.678431,
			0.521569,
			0.85,
			0.392157,
			0.560784,
			0.427451,
			0.9,
			0.294118,
			0.45098,
			0.333333,
			0.95,
			0.211765,
			0.34902,
			0.254902,
			1,
			0.152941,
			0.278431,
			0.196078
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Green-Blue Asymmetric Divergent (62Blbc)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.121569,
			0.2,
			0.145098,
			0.05,
			0.196078,
			0.301961,
			0.223529,
			0.1,
			0.258824,
			0.4,
			0.278431,
			0.2,
			0.341176,
			0.54902,
			0.341176,
			0.25,
			0.419608,
			0.619608,
			0.376471,
			0.3,
			0.545098,
			0.701961,
			0.392157,
			0.35,
			0.643137,
			0.780392,
			0.403922,
			0.4,
			0.729412,
			0.819608,
			0.45098,
			0.45,
			0.811765,
			0.870588,
			0.521569,
			0.5,
			0.898039,
			0.909804,
			0.564706,
			0.55,
			0.941176,
			0.92549,
			0.686275,
			0.6,
			0.960784,
			0.94902,
			0.776471,
			0.64,
			1,
			1,
			1,
			0.65,
			0.890196,
			0.988235,
			0.972549,
			0.7,
			0.721569,
			0.894118,
			0.901961,
			0.75,
			0.631373,
			0.823529,
			0.839216,
			0.8,
			0.517647,
			0.662745,
			0.701961,
			0.85,
			0.384314,
			0.494118,
			0.54902,
			0.9,
			0.298039,
			0.360784,
			0.45098,
			0.95,
			0.223529,
			0.25098,
			0.34902,
			0.99,
			0.156863,
			0.172549,
			0.25098,
			1,
			0.137255,
			0.137255,
			0.188235
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Asymmtrical Earth Tones (6_21b)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.141176,
			0.14902,
			0.2,
			0.05,
			0.215686,
			0.258824,
			0.321569,
			0.1,
			0.243137,
			0.368627,
			0.380392,
			0.15,
			0.27451,
			0.439216,
			0.4,
			0.2,
			0.32549,
			0.501961,
			0.384314,
			0.25,
			0.403922,
			0.6,
			0.419608,
			0.3,
			0.486275,
			0.701961,
			0.454902,
			0.35,
			0.556863,
			0.74902,
			0.494118,
			0.4,
			0.670588,
			0.8,
			0.545098,
			0.5,
			0.854902,
			0.901961,
			0.631373,
			0.55,
			0.92549,
			0.941176,
			0.694118,
			0.6,
			0.960784,
			0.94902,
			0.776471,
			0.65,
			0.988235,
			0.968627,
			0.909804,
			0.7,
			0.839216,
			0.815686,
			0.772549,
			0.75,
			0.701961,
			0.662745,
			0.615686,
			0.8,
			0.6,
			0.529412,
			0.478431,
			0.85,
			0.501961,
			0.403922,
			0.360784,
			0.9,
			0.439216,
			0.313725,
			0.290196,
			1,
			0.301961,
			0.164706,
			0.176471
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Yellow 15",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			1,
			1,
			0.988235,
			0.002,
			1,
			1,
			0.988235,
			0.05,
			0.984314,
			0.988235,
			0.843137,
			0.1,
			0.988235,
			0.988235,
			0.741176,
			0.15,
			0.980392,
			0.968627,
			0.654902,
			0.2,
			0.980392,
			0.945098,
			0.576471,
			0.25,
			0.968627,
			0.905882,
			0.486275,
			0.3,
			0.968627,
			0.862745,
			0.388235,
			0.35,
			0.960784,
			0.803922,
			0.286275,
			0.4,
			0.94902,
			0.741176,
			0.219608,
			0.45,
			0.941176,
			0.678431,
			0.14902,
			0.5,
			0.929412,
			0.607843,
			0.094118,
			0.55,
			0.921569,
			0.545098,
			0.054902,
			0.6,
			0.909804,
			0.486275,
			0.035294,
			0.65,
			0.890196,
			0.411765,
			0.019608,
			0.7,
			0.8,
			0.305882,
			0,
			0.75,
			0.760784,
			0.239216,
			0,
			0.8,
			0.678431,
			0.180392,
			0.011765,
			0.85,
			0.6,
			0.121569,
			0.023529,
			0.9,
			0.501961,
			0.054902,
			0.031373,
			0.95,
			0.4,
			0.039216,
			0.058824,
			1,
			0.301961,
			0.047059,
			0.090196
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Magma (matplotlib)",
		NanColor: [
			0,
			1,
			0
		],
		Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
		License: "CC0",
		Creator: "Nathaniel J. Smith & Stefan van der Walt",
		RGBPoints: [
			0,
			0.001462,
			0.000466,
			0.013866,
			0.003922,
			0.002258,
			0.001295,
			0.018331,
			0.007843,
			0.003279,
			0.002305,
			0.023708,
			0.011765,
			0.004512,
			0.00349,
			0.029965,
			0.015686,
			0.00595,
			0.004843,
			0.03713,
			0.019608,
			0.007588,
			0.006356,
			0.044973,
			0.023529,
			0.009426,
			0.008022,
			0.052844,
			0.027451,
			0.011465,
			0.009828,
			0.06075,
			0.031373,
			0.013708,
			0.011771,
			0.068667,
			0.035294,
			0.016156,
			0.01384,
			0.076603,
			0.039216,
			0.018815,
			0.016026,
			0.084584,
			0.043137,
			0.021692,
			0.01832,
			0.09261,
			0.047059,
			0.024792,
			0.020715,
			0.100676,
			0.05098,
			0.028123,
			0.023201,
			0.108787,
			0.054902,
			0.031696,
			0.025765,
			0.116965,
			0.058824,
			0.03552,
			0.028397,
			0.125209,
			0.062745,
			0.039608,
			0.03109,
			0.133515,
			0.066667,
			0.04383,
			0.03383,
			0.141886,
			0.070588,
			0.048062,
			0.036607,
			0.150327,
			0.07451,
			0.05232,
			0.039407,
			0.158841,
			0.078431,
			0.056615,
			0.04216,
			0.167446,
			0.082353,
			0.060949,
			0.044794,
			0.176129,
			0.086275,
			0.06533,
			0.047318,
			0.184892,
			0.090196,
			0.069764,
			0.049726,
			0.193735,
			0.094118,
			0.074257,
			0.052017,
			0.20266,
			0.098039,
			0.078815,
			0.054184,
			0.211667,
			0.101961,
			0.083446,
			0.056225,
			0.220755,
			0.105882,
			0.088155,
			0.058133,
			0.229922,
			0.109804,
			0.092949,
			0.059904,
			0.239164,
			0.113725,
			0.097833,
			0.061531,
			0.248477,
			0.117647,
			0.102815,
			0.06301,
			0.257854,
			0.121569,
			0.107899,
			0.064335,
			0.267289,
			0.12549,
			0.113094,
			0.065492,
			0.276784,
			0.129412,
			0.118405,
			0.066479,
			0.286321,
			0.133333,
			0.123833,
			0.067295,
			0.295879,
			0.137255,
			0.12938,
			0.067935,
			0.305443,
			0.141176,
			0.135053,
			0.068391,
			0.315,
			0.145098,
			0.140858,
			0.068654,
			0.324538,
			0.14902,
			0.146785,
			0.068738,
			0.334011,
			0.152941,
			0.152839,
			0.068637,
			0.343404,
			0.156863,
			0.159018,
			0.068354,
			0.352688,
			0.160784,
			0.165308,
			0.067911,
			0.361816,
			0.164706,
			0.171713,
			0.067305,
			0.370771,
			0.168627,
			0.178212,
			0.066576,
			0.379497,
			0.172549,
			0.184801,
			0.065732,
			0.387973,
			0.176471,
			0.19146,
			0.064818,
			0.396152,
			0.180392,
			0.198177,
			0.063862,
			0.404009,
			0.184314,
			0.204935,
			0.062907,
			0.411514,
			0.188235,
			0.211718,
			0.061992,
			0.418647,
			0.192157,
			0.218512,
			0.061158,
			0.425392,
			0.196078,
			0.225302,
			0.060445,
			0.431742,
			0.2,
			0.232077,
			0.059889,
			0.437695,
			0.203922,
			0.238826,
			0.059517,
			0.443256,
			0.207843,
			0.245543,
			0.059352,
			0.448436,
			0.211765,
			0.25222,
			0.059415,
			0.453248,
			0.215686,
			0.258857,
			0.059706,
			0.45771,
			0.219608,
			0.265447,
			0.060237,
			0.46184,
			0.223529,
			0.271994,
			0.060994,
			0.46566,
			0.227451,
			0.278493,
			0.061978,
			0.46919,
			0.231373,
			0.284951,
			0.063168,
			0.472451,
			0.235294,
			0.291366,
			0.064553,
			0.475462,
			0.239216,
			0.29774,
			0.066117,
			0.478243,
			0.243137,
			0.304081,
			0.067835,
			0.480812,
			0.247059,
			0.310382,
			0.069702,
			0.483186,
			0.25098,
			0.316654,
			0.07169,
			0.48538,
			0.254902,
			0.322899,
			0.073782,
			0.487408,
			0.258824,
			0.329114,
			0.075972,
			0.489287,
			0.262745,
			0.335308,
			0.078236,
			0.491024,
			0.266667,
			0.341482,
			0.080564,
			0.492631,
			0.270588,
			0.347636,
			0.082946,
			0.494121,
			0.27451,
			0.353773,
			0.085373,
			0.495501,
			0.278431,
			0.359898,
			0.087831,
			0.496778,
			0.282353,
			0.366012,
			0.090314,
			0.49796,
			0.286275,
			0.372116,
			0.092816,
			0.499053,
			0.290196,
			0.378211,
			0.095332,
			0.500067,
			0.294118,
			0.384299,
			0.097855,
			0.501002,
			0.298039,
			0.390384,
			0.100379,
			0.501864,
			0.301961,
			0.396467,
			0.102902,
			0.502658,
			0.305882,
			0.402548,
			0.10542,
			0.503386,
			0.309804,
			0.408629,
			0.10793,
			0.504052,
			0.313725,
			0.414709,
			0.110431,
			0.504662,
			0.317647,
			0.420791,
			0.11292,
			0.505215,
			0.321569,
			0.426877,
			0.115395,
			0.505714,
			0.32549,
			0.432967,
			0.117855,
			0.50616,
			0.329412,
			0.439062,
			0.120298,
			0.506555,
			0.333333,
			0.445163,
			0.122724,
			0.506901,
			0.337255,
			0.451271,
			0.125132,
			0.507198,
			0.341176,
			0.457386,
			0.127522,
			0.507448,
			0.345098,
			0.463508,
			0.129893,
			0.507652,
			0.34902,
			0.46964,
			0.132245,
			0.507809,
			0.352941,
			0.47578,
			0.134577,
			0.507921,
			0.356863,
			0.481929,
			0.136891,
			0.507989,
			0.360784,
			0.488088,
			0.139186,
			0.508011,
			0.364706,
			0.494258,
			0.141462,
			0.507988,
			0.368627,
			0.500438,
			0.143719,
			0.50792,
			0.372549,
			0.506629,
			0.145958,
			0.507806,
			0.376471,
			0.512831,
			0.148179,
			0.507648,
			0.380392,
			0.519045,
			0.150383,
			0.507443,
			0.384314,
			0.52527,
			0.152569,
			0.507192,
			0.388235,
			0.531507,
			0.154739,
			0.506895,
			0.392157,
			0.537755,
			0.156894,
			0.506551,
			0.396078,
			0.544015,
			0.159033,
			0.506159,
			0.4,
			0.550287,
			0.161158,
			0.505719,
			0.403922,
			0.556571,
			0.163269,
			0.50523,
			0.407843,
			0.562866,
			0.165368,
			0.504692,
			0.411765,
			0.569172,
			0.167454,
			0.504105,
			0.415686,
			0.57549,
			0.16953,
			0.503466,
			0.419608,
			0.581819,
			0.171596,
			0.502777,
			0.423529,
			0.588158,
			0.173652,
			0.502035,
			0.427451,
			0.594508,
			0.175701,
			0.501241,
			0.431373,
			0.600868,
			0.177743,
			0.500394,
			0.435294,
			0.607238,
			0.179779,
			0.499492,
			0.439216,
			0.613617,
			0.181811,
			0.498536,
			0.443137,
			0.620005,
			0.18384,
			0.497524,
			0.447059,
			0.626401,
			0.185867,
			0.496456,
			0.45098,
			0.632805,
			0.187893,
			0.495332,
			0.454902,
			0.639216,
			0.189921,
			0.49415,
			0.458824,
			0.645633,
			0.191952,
			0.49291,
			0.462745,
			0.652056,
			0.193986,
			0.491611,
			0.466667,
			0.658483,
			0.196027,
			0.490253,
			0.470588,
			0.664915,
			0.198075,
			0.488836,
			0.47451,
			0.671349,
			0.200133,
			0.487358,
			0.478431,
			0.677786,
			0.202203,
			0.485819,
			0.482353,
			0.684224,
			0.204286,
			0.484219,
			0.486275,
			0.690661,
			0.206384,
			0.482558,
			0.490196,
			0.697098,
			0.208501,
			0.480835,
			0.494118,
			0.703532,
			0.210638,
			0.479049,
			0.498039,
			0.709962,
			0.212797,
			0.477201,
			0.501961,
			0.716387,
			0.214982,
			0.47529,
			0.505882,
			0.722805,
			0.217194,
			0.473316,
			0.509804,
			0.729216,
			0.219437,
			0.471279,
			0.513725,
			0.735616,
			0.221713,
			0.46918,
			0.517647,
			0.742004,
			0.224025,
			0.467018,
			0.521569,
			0.748378,
			0.226377,
			0.464794,
			0.52549,
			0.754737,
			0.228772,
			0.462509,
			0.529412,
			0.761077,
			0.231214,
			0.460162,
			0.533333,
			0.767398,
			0.233705,
			0.457755,
			0.537255,
			0.773695,
			0.236249,
			0.455289,
			0.541176,
			0.779968,
			0.238851,
			0.452765,
			0.545098,
			0.786212,
			0.241514,
			0.450184,
			0.54902,
			0.792427,
			0.244242,
			0.447543,
			0.552941,
			0.798608,
			0.24704,
			0.444848,
			0.556863,
			0.804752,
			0.249911,
			0.442102,
			0.560784,
			0.810855,
			0.252861,
			0.439305,
			0.564706,
			0.816914,
			0.255895,
			0.436461,
			0.568627,
			0.822926,
			0.259016,
			0.433573,
			0.572549,
			0.828886,
			0.262229,
			0.430644,
			0.576471,
			0.834791,
			0.26554,
			0.427671,
			0.580392,
			0.840636,
			0.268953,
			0.424666,
			0.584314,
			0.846416,
			0.272473,
			0.421631,
			0.588235,
			0.852126,
			0.276106,
			0.418573,
			0.592157,
			0.857763,
			0.279857,
			0.415496,
			0.596078,
			0.86332,
			0.283729,
			0.412403,
			0.6,
			0.868793,
			0.287728,
			0.409303,
			0.603922,
			0.874176,
			0.291859,
			0.406205,
			0.607843,
			0.879464,
			0.296125,
			0.403118,
			0.611765,
			0.884651,
			0.30053,
			0.400047,
			0.615686,
			0.889731,
			0.305079,
			0.397002,
			0.619608,
			0.8947,
			0.309773,
			0.393995,
			0.623529,
			0.899552,
			0.314616,
			0.391037,
			0.627451,
			0.904281,
			0.31961,
			0.388137,
			0.631373,
			0.908884,
			0.324755,
			0.385308,
			0.635294,
			0.913354,
			0.330052,
			0.382563,
			0.639216,
			0.917689,
			0.3355,
			0.379915,
			0.643137,
			0.921884,
			0.341098,
			0.377376,
			0.647059,
			0.925937,
			0.346844,
			0.374959,
			0.65098,
			0.929845,
			0.352734,
			0.372677,
			0.654902,
			0.933606,
			0.358764,
			0.370541,
			0.658824,
			0.937221,
			0.364929,
			0.368567,
			0.662745,
			0.940687,
			0.371224,
			0.366762,
			0.666667,
			0.944006,
			0.377643,
			0.365136,
			0.670588,
			0.94718,
			0.384178,
			0.363701,
			0.67451,
			0.95021,
			0.39082,
			0.362468,
			0.678431,
			0.953099,
			0.397563,
			0.361438,
			0.682353,
			0.955849,
			0.4044,
			0.360619,
			0.686275,
			0.958464,
			0.411324,
			0.360014,
			0.690196,
			0.960949,
			0.418323,
			0.35963,
			0.694118,
			0.96331,
			0.42539,
			0.359469,
			0.698039,
			0.965549,
			0.432519,
			0.359529,
			0.701961,
			0.967671,
			0.439703,
			0.35981,
			0.705882,
			0.96968,
			0.446936,
			0.360311,
			0.709804,
			0.971582,
			0.45421,
			0.36103,
			0.713725,
			0.973381,
			0.46152,
			0.361965,
			0.717647,
			0.975082,
			0.468861,
			0.363111,
			0.721569,
			0.97669,
			0.476226,
			0.364466,
			0.72549,
			0.97821,
			0.483612,
			0.366025,
			0.729412,
			0.979645,
			0.491014,
			0.367783,
			0.733333,
			0.981,
			0.498428,
			0.369734,
			0.737255,
			0.982279,
			0.505851,
			0.371874,
			0.741176,
			0.983485,
			0.51328,
			0.374198,
			0.745098,
			0.984622,
			0.520713,
			0.376698,
			0.74902,
			0.985693,
			0.528148,
			0.379371,
			0.752941,
			0.9867,
			0.535582,
			0.38221,
			0.756863,
			0.987646,
			0.543015,
			0.38521,
			0.760784,
			0.988533,
			0.550446,
			0.388365,
			0.764706,
			0.989363,
			0.557873,
			0.391671,
			0.768627,
			0.990138,
			0.565296,
			0.395122,
			0.772549,
			0.990871,
			0.572706,
			0.398714,
			0.776471,
			0.991558,
			0.580107,
			0.402441,
			0.780392,
			0.992196,
			0.587502,
			0.406299,
			0.784314,
			0.992785,
			0.594891,
			0.410283,
			0.788235,
			0.993326,
			0.602275,
			0.41439,
			0.792157,
			0.993834,
			0.609644,
			0.418613,
			0.796078,
			0.994309,
			0.616999,
			0.42295,
			0.8,
			0.994738,
			0.62435,
			0.427397,
			0.803922,
			0.995122,
			0.631696,
			0.431951,
			0.807843,
			0.99548,
			0.639027,
			0.436607,
			0.811765,
			0.99581,
			0.646344,
			0.441361,
			0.815686,
			0.996096,
			0.653659,
			0.446213,
			0.819608,
			0.996341,
			0.660969,
			0.45116,
			0.823529,
			0.99658,
			0.668256,
			0.456192,
			0.827451,
			0.996775,
			0.675541,
			0.461314,
			0.831373,
			0.996925,
			0.682828,
			0.466526,
			0.835294,
			0.997077,
			0.690088,
			0.471811,
			0.839216,
			0.997186,
			0.697349,
			0.477182,
			0.843137,
			0.997254,
			0.704611,
			0.482635,
			0.847059,
			0.997325,
			0.711848,
			0.488154,
			0.85098,
			0.997351,
			0.719089,
			0.493755,
			0.854902,
			0.997351,
			0.726324,
			0.499428,
			0.858824,
			0.997341,
			0.733545,
			0.505167,
			0.862745,
			0.997285,
			0.740772,
			0.510983,
			0.866667,
			0.997228,
			0.747981,
			0.516859,
			0.870588,
			0.997138,
			0.75519,
			0.522806,
			0.87451,
			0.997019,
			0.762398,
			0.528821,
			0.878431,
			0.996898,
			0.769591,
			0.534892,
			0.882353,
			0.996727,
			0.776795,
			0.541039,
			0.886275,
			0.996571,
			0.783977,
			0.547233,
			0.890196,
			0.996369,
			0.791167,
			0.553499,
			0.894118,
			0.996162,
			0.798348,
			0.55982,
			0.898039,
			0.995932,
			0.805527,
			0.566202,
			0.901961,
			0.99568,
			0.812706,
			0.572645,
			0.905882,
			0.995424,
			0.819875,
			0.57914,
			0.909804,
			0.995131,
			0.827052,
			0.585701,
			0.913725,
			0.994851,
			0.834213,
			0.592307,
			0.917647,
			0.994524,
			0.841387,
			0.598983,
			0.921569,
			0.994222,
			0.84854,
			0.605696,
			0.92549,
			0.993866,
			0.855711,
			0.612482,
			0.929412,
			0.993545,
			0.862859,
			0.619299,
			0.933333,
			0.99317,
			0.870024,
			0.626189,
			0.937255,
			0.992831,
			0.877168,
			0.633109,
			0.941176,
			0.99244,
			0.88433,
			0.640099,
			0.945098,
			0.992089,
			0.89147,
			0.647116,
			0.94902,
			0.991688,
			0.898627,
			0.654202,
			0.952941,
			0.991332,
			0.905763,
			0.661309,
			0.956863,
			0.99093,
			0.912915,
			0.668481,
			0.960784,
			0.99057,
			0.920049,
			0.675675,
			0.964706,
			0.990175,
			0.927196,
			0.682926,
			0.968627,
			0.989815,
			0.934329,
			0.690198,
			0.972549,
			0.989434,
			0.94147,
			0.697519,
			0.976471,
			0.989077,
			0.948604,
			0.704863,
			0.980392,
			0.988717,
			0.955742,
			0.712242,
			0.984314,
			0.988367,
			0.962878,
			0.719649,
			0.988235,
			0.988033,
			0.970012,
			0.727077,
			0.992157,
			0.987691,
			0.977154,
			0.734536,
			0.996078,
			0.987387,
			0.984288,
			0.742002,
			1,
			0.987053,
			0.991438,
			0.749504
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Inferno (matplotlib)",
		NanColor: [
			0,
			1,
			0
		],
		Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
		License: "CC0",
		Creator: "Nathaniel J. Smith & Stefan van der Walt",
		RGBPoints: [
			0,
			0.001462,
			0.000466,
			0.013866,
			0.003922,
			0.002267,
			0.00127,
			0.01857,
			0.007843,
			0.003299,
			0.002249,
			0.024239,
			0.011765,
			0.004547,
			0.003392,
			0.030909,
			0.015686,
			0.006006,
			0.004692,
			0.038558,
			0.019608,
			0.007676,
			0.006136,
			0.046836,
			0.023529,
			0.009561,
			0.007713,
			0.055143,
			0.027451,
			0.011663,
			0.009417,
			0.06346,
			0.031373,
			0.013995,
			0.011225,
			0.071862,
			0.035294,
			0.016561,
			0.013136,
			0.080282,
			0.039216,
			0.019373,
			0.015133,
			0.088767,
			0.043137,
			0.022447,
			0.017199,
			0.097327,
			0.047059,
			0.025793,
			0.019331,
			0.10593,
			0.05098,
			0.029432,
			0.021503,
			0.114621,
			0.054902,
			0.033385,
			0.023702,
			0.123397,
			0.058824,
			0.037668,
			0.025921,
			0.132232,
			0.062745,
			0.042253,
			0.028139,
			0.141141,
			0.066667,
			0.046915,
			0.030324,
			0.150164,
			0.070588,
			0.051644,
			0.032474,
			0.159254,
			0.07451,
			0.056449,
			0.034569,
			0.168414,
			0.078431,
			0.06134,
			0.03659,
			0.177642,
			0.082353,
			0.066331,
			0.038504,
			0.186962,
			0.086275,
			0.071429,
			0.040294,
			0.196354,
			0.090196,
			0.076637,
			0.041905,
			0.205799,
			0.094118,
			0.081962,
			0.043328,
			0.215289,
			0.098039,
			0.087411,
			0.044556,
			0.224813,
			0.101961,
			0.09299,
			0.045583,
			0.234358,
			0.105882,
			0.098702,
			0.046402,
			0.243904,
			0.109804,
			0.104551,
			0.047008,
			0.25343,
			0.113725,
			0.110536,
			0.047399,
			0.262912,
			0.117647,
			0.116656,
			0.047574,
			0.272321,
			0.121569,
			0.122908,
			0.047536,
			0.281624,
			0.12549,
			0.129285,
			0.047293,
			0.290788,
			0.129412,
			0.135778,
			0.046856,
			0.299776,
			0.133333,
			0.142378,
			0.046242,
			0.308553,
			0.137255,
			0.149073,
			0.045468,
			0.317085,
			0.141176,
			0.15585,
			0.044559,
			0.325338,
			0.145098,
			0.162689,
			0.043554,
			0.333277,
			0.14902,
			0.169575,
			0.042489,
			0.340874,
			0.152941,
			0.176493,
			0.041402,
			0.348111,
			0.156863,
			0.183429,
			0.040329,
			0.354971,
			0.160784,
			0.190367,
			0.039309,
			0.361447,
			0.164706,
			0.197297,
			0.0384,
			0.367535,
			0.168627,
			0.204209,
			0.037632,
			0.373238,
			0.172549,
			0.211095,
			0.03703,
			0.378563,
			0.176471,
			0.217949,
			0.036615,
			0.383522,
			0.180392,
			0.224763,
			0.036405,
			0.388129,
			0.184314,
			0.231538,
			0.036405,
			0.3924,
			0.188235,
			0.238273,
			0.036621,
			0.396353,
			0.192157,
			0.244967,
			0.037055,
			0.400007,
			0.196078,
			0.25162,
			0.037705,
			0.403378,
			0.2,
			0.258234,
			0.038571,
			0.406485,
			0.203922,
			0.26481,
			0.039647,
			0.409345,
			0.207843,
			0.271347,
			0.040922,
			0.411976,
			0.211765,
			0.27785,
			0.042353,
			0.414392,
			0.215686,
			0.284321,
			0.043933,
			0.416608,
			0.219608,
			0.290763,
			0.045644,
			0.418637,
			0.223529,
			0.297178,
			0.04747,
			0.420491,
			0.227451,
			0.303568,
			0.049396,
			0.422182,
			0.231373,
			0.309935,
			0.051407,
			0.423721,
			0.235294,
			0.316282,
			0.05349,
			0.425116,
			0.239216,
			0.32261,
			0.055634,
			0.426377,
			0.243137,
			0.328921,
			0.057827,
			0.427511,
			0.247059,
			0.335217,
			0.06006,
			0.428524,
			0.25098,
			0.3415,
			0.062325,
			0.429425,
			0.254902,
			0.347771,
			0.064616,
			0.430217,
			0.258824,
			0.354032,
			0.066925,
			0.430906,
			0.262745,
			0.360284,
			0.069247,
			0.431497,
			0.266667,
			0.366529,
			0.071579,
			0.431994,
			0.270588,
			0.372768,
			0.073915,
			0.4324,
			0.27451,
			0.379001,
			0.076253,
			0.432719,
			0.278431,
			0.385228,
			0.078591,
			0.432955,
			0.282353,
			0.391453,
			0.080927,
			0.433109,
			0.286275,
			0.397674,
			0.083257,
			0.433183,
			0.290196,
			0.403894,
			0.08558,
			0.433179,
			0.294118,
			0.410113,
			0.087896,
			0.433098,
			0.298039,
			0.416331,
			0.090203,
			0.432943,
			0.301961,
			0.422549,
			0.092501,
			0.432714,
			0.305882,
			0.428768,
			0.09479,
			0.432412,
			0.309804,
			0.434987,
			0.097069,
			0.432039,
			0.313725,
			0.441207,
			0.099338,
			0.431594,
			0.317647,
			0.447428,
			0.101597,
			0.43108,
			0.321569,
			0.453651,
			0.103848,
			0.430498,
			0.32549,
			0.459875,
			0.106089,
			0.429846,
			0.329412,
			0.4661,
			0.108322,
			0.429125,
			0.333333,
			0.472328,
			0.110547,
			0.428334,
			0.337255,
			0.478558,
			0.112764,
			0.427475,
			0.341176,
			0.484789,
			0.114974,
			0.426548,
			0.345098,
			0.491022,
			0.117179,
			0.425552,
			0.34902,
			0.497257,
			0.119379,
			0.424488,
			0.352941,
			0.503493,
			0.121575,
			0.423356,
			0.356863,
			0.50973,
			0.123769,
			0.422156,
			0.360784,
			0.515967,
			0.12596,
			0.420887,
			0.364706,
			0.522206,
			0.12815,
			0.419549,
			0.368627,
			0.528444,
			0.130341,
			0.418142,
			0.372549,
			0.534683,
			0.132534,
			0.416667,
			0.376471,
			0.54092,
			0.134729,
			0.415123,
			0.380392,
			0.547157,
			0.136929,
			0.413511,
			0.384314,
			0.553392,
			0.139134,
			0.411829,
			0.388235,
			0.559624,
			0.141346,
			0.410078,
			0.392157,
			0.565854,
			0.143567,
			0.408258,
			0.396078,
			0.572081,
			0.145797,
			0.406369,
			0.4,
			0.578304,
			0.148039,
			0.404411,
			0.403922,
			0.584521,
			0.150294,
			0.402385,
			0.407843,
			0.590734,
			0.152563,
			0.40029,
			0.411765,
			0.59694,
			0.154848,
			0.398125,
			0.415686,
			0.603139,
			0.157151,
			0.395891,
			0.419608,
			0.60933,
			0.159474,
			0.393589,
			0.423529,
			0.615513,
			0.161817,
			0.391219,
			0.427451,
			0.621685,
			0.164184,
			0.388781,
			0.431373,
			0.627847,
			0.166575,
			0.386276,
			0.435294,
			0.633998,
			0.168992,
			0.383704,
			0.439216,
			0.640135,
			0.171438,
			0.381065,
			0.443137,
			0.64626,
			0.173914,
			0.378359,
			0.447059,
			0.652369,
			0.176421,
			0.375586,
			0.45098,
			0.658463,
			0.178962,
			0.372748,
			0.454902,
			0.66454,
			0.181539,
			0.369846,
			0.458824,
			0.670599,
			0.184153,
			0.366879,
			0.462745,
			0.676638,
			0.186807,
			0.363849,
			0.466667,
			0.682656,
			0.189501,
			0.360757,
			0.470588,
			0.688653,
			0.192239,
			0.357603,
			0.47451,
			0.694627,
			0.195021,
			0.354388,
			0.478431,
			0.700576,
			0.197851,
			0.351113,
			0.482353,
			0.7065,
			0.200728,
			0.347777,
			0.486275,
			0.712396,
			0.203656,
			0.344383,
			0.490196,
			0.718264,
			0.206636,
			0.340931,
			0.494118,
			0.724103,
			0.20967,
			0.337424,
			0.498039,
			0.729909,
			0.212759,
			0.333861,
			0.501961,
			0.735683,
			0.215906,
			0.330245,
			0.505882,
			0.741423,
			0.219112,
			0.326576,
			0.509804,
			0.747127,
			0.222378,
			0.322856,
			0.513725,
			0.752794,
			0.225706,
			0.319085,
			0.517647,
			0.758422,
			0.229097,
			0.315266,
			0.521569,
			0.76401,
			0.232554,
			0.311399,
			0.52549,
			0.769556,
			0.236077,
			0.307485,
			0.529412,
			0.775059,
			0.239667,
			0.303526,
			0.533333,
			0.780517,
			0.243327,
			0.299523,
			0.537255,
			0.785929,
			0.247056,
			0.295477,
			0.541176,
			0.791293,
			0.250856,
			0.29139,
			0.545098,
			0.796607,
			0.254728,
			0.287264,
			0.54902,
			0.801871,
			0.258674,
			0.283099,
			0.552941,
			0.807082,
			0.262692,
			0.278898,
			0.556863,
			0.812239,
			0.266786,
			0.274661,
			0.560784,
			0.817341,
			0.270954,
			0.27039,
			0.564706,
			0.822386,
			0.275197,
			0.266085,
			0.568627,
			0.827372,
			0.279517,
			0.26175,
			0.572549,
			0.832299,
			0.283913,
			0.257383,
			0.576471,
			0.837165,
			0.288385,
			0.252988,
			0.580392,
			0.841969,
			0.292933,
			0.248564,
			0.584314,
			0.846709,
			0.297559,
			0.244113,
			0.588235,
			0.851384,
			0.30226,
			0.239636,
			0.592157,
			0.855992,
			0.307038,
			0.235133,
			0.596078,
			0.860533,
			0.311892,
			0.230606,
			0.6,
			0.865006,
			0.316822,
			0.226055,
			0.603922,
			0.869409,
			0.321827,
			0.221482,
			0.607843,
			0.873741,
			0.326906,
			0.216886,
			0.611765,
			0.878001,
			0.33206,
			0.212268,
			0.615686,
			0.882188,
			0.337287,
			0.207628,
			0.619608,
			0.886302,
			0.342586,
			0.202968,
			0.623529,
			0.890341,
			0.347957,
			0.198286,
			0.627451,
			0.894305,
			0.353399,
			0.193584,
			0.631373,
			0.898192,
			0.358911,
			0.18886,
			0.635294,
			0.902003,
			0.364492,
			0.184116,
			0.639216,
			0.905735,
			0.37014,
			0.17935,
			0.643137,
			0.90939,
			0.375856,
			0.174563,
			0.647059,
			0.912966,
			0.381636,
			0.169755,
			0.65098,
			0.916462,
			0.387481,
			0.164924,
			0.654902,
			0.919879,
			0.393389,
			0.16007,
			0.658824,
			0.923215,
			0.399359,
			0.155193,
			0.662745,
			0.92647,
			0.405389,
			0.150292,
			0.666667,
			0.929644,
			0.411479,
			0.145367,
			0.670588,
			0.932737,
			0.417627,
			0.140417,
			0.67451,
			0.935747,
			0.423831,
			0.13544,
			0.678431,
			0.938675,
			0.430091,
			0.130438,
			0.682353,
			0.941521,
			0.436405,
			0.125409,
			0.686275,
			0.944285,
			0.442772,
			0.120354,
			0.690196,
			0.946965,
			0.449191,
			0.115272,
			0.694118,
			0.949562,
			0.45566,
			0.110164,
			0.698039,
			0.952075,
			0.462178,
			0.105031,
			0.701961,
			0.954506,
			0.468744,
			0.099874,
			0.705882,
			0.956852,
			0.475356,
			0.094695,
			0.709804,
			0.959114,
			0.482014,
			0.089499,
			0.713725,
			0.961293,
			0.488716,
			0.084289,
			0.717647,
			0.963387,
			0.495462,
			0.079073,
			0.721569,
			0.965397,
			0.502249,
			0.073859,
			0.72549,
			0.967322,
			0.509078,
			0.068659,
			0.729412,
			0.969163,
			0.515946,
			0.063488,
			0.733333,
			0.970919,
			0.522853,
			0.058367,
			0.737255,
			0.97259,
			0.529798,
			0.053324,
			0.741176,
			0.974176,
			0.53678,
			0.048392,
			0.745098,
			0.975677,
			0.543798,
			0.043618,
			0.74902,
			0.977092,
			0.55085,
			0.03905,
			0.752941,
			0.978422,
			0.557937,
			0.034931,
			0.756863,
			0.979666,
			0.565057,
			0.031409,
			0.760784,
			0.980824,
			0.572209,
			0.028508,
			0.764706,
			0.981895,
			0.579392,
			0.02625,
			0.768627,
			0.982881,
			0.586606,
			0.024661,
			0.772549,
			0.983779,
			0.593849,
			0.02377,
			0.776471,
			0.984591,
			0.601122,
			0.023606,
			0.780392,
			0.985315,
			0.608422,
			0.024202,
			0.784314,
			0.985952,
			0.61575,
			0.025592,
			0.788235,
			0.986502,
			0.623105,
			0.027814,
			0.792157,
			0.986964,
			0.630485,
			0.030908,
			0.796078,
			0.987337,
			0.63789,
			0.034916,
			0.8,
			0.987622,
			0.64532,
			0.039886,
			0.803922,
			0.987819,
			0.652773,
			0.045581,
			0.807843,
			0.987926,
			0.66025,
			0.05175,
			0.811765,
			0.987945,
			0.667748,
			0.058329,
			0.815686,
			0.987874,
			0.675267,
			0.065257,
			0.819608,
			0.987714,
			0.682807,
			0.072489,
			0.823529,
			0.987464,
			0.690366,
			0.07999,
			0.827451,
			0.987124,
			0.697944,
			0.087731,
			0.831373,
			0.986694,
			0.70554,
			0.095694,
			0.835294,
			0.986175,
			0.713153,
			0.103863,
			0.839216,
			0.985566,
			0.720782,
			0.112229,
			0.843137,
			0.984865,
			0.728427,
			0.120785,
			0.847059,
			0.984075,
			0.736087,
			0.129527,
			0.85098,
			0.983196,
			0.743758,
			0.138453,
			0.854902,
			0.982228,
			0.751442,
			0.147565,
			0.858824,
			0.981173,
			0.759135,
			0.156863,
			0.862745,
			0.980032,
			0.766837,
			0.166353,
			0.866667,
			0.978806,
			0.774545,
			0.176037,
			0.870588,
			0.977497,
			0.782258,
			0.185923,
			0.87451,
			0.976108,
			0.789974,
			0.196018,
			0.878431,
			0.974638,
			0.797692,
			0.206332,
			0.882353,
			0.973088,
			0.805409,
			0.216877,
			0.886275,
			0.971468,
			0.813122,
			0.227658,
			0.890196,
			0.969783,
			0.820825,
			0.238686,
			0.894118,
			0.968041,
			0.828515,
			0.249972,
			0.898039,
			0.966243,
			0.836191,
			0.261534,
			0.901961,
			0.964394,
			0.843848,
			0.273391,
			0.905882,
			0.962517,
			0.851476,
			0.285546,
			0.909804,
			0.960626,
			0.859069,
			0.29801,
			0.913725,
			0.95872,
			0.866624,
			0.31082,
			0.917647,
			0.956834,
			0.874129,
			0.323974,
			0.921569,
			0.954997,
			0.881569,
			0.337475,
			0.92549,
			0.953215,
			0.888942,
			0.351369,
			0.929412,
			0.951546,
			0.896226,
			0.365627,
			0.933333,
			0.950018,
			0.903409,
			0.380271,
			0.937255,
			0.948683,
			0.910473,
			0.395289,
			0.941176,
			0.947594,
			0.917399,
			0.410665,
			0.945098,
			0.946809,
			0.924168,
			0.426373,
			0.94902,
			0.946392,
			0.930761,
			0.442367,
			0.952941,
			0.946403,
			0.937159,
			0.458592,
			0.956863,
			0.946903,
			0.943348,
			0.47497,
			0.960784,
			0.947937,
			0.949318,
			0.491426,
			0.964706,
			0.949545,
			0.955063,
			0.50786,
			0.968627,
			0.95174,
			0.960587,
			0.524203,
			0.972549,
			0.954529,
			0.965896,
			0.540361,
			0.976471,
			0.957896,
			0.971003,
			0.556275,
			0.980392,
			0.961812,
			0.975924,
			0.571925,
			0.984314,
			0.966249,
			0.980678,
			0.587206,
			0.988235,
			0.971162,
			0.985282,
			0.602154,
			0.992157,
			0.976511,
			0.989753,
			0.61676,
			0.996078,
			0.982257,
			0.994109,
			0.631017,
			1,
			0.988362,
			0.998364,
			0.644924
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Plasma (matplotlib)",
		NanColor: [
			0,
			1,
			0
		],
		Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
		License: "CC0",
		Creator: "Nathaniel J. Smith & Stefan van der Walt",
		RGBPoints: [
			0,
			0.050383,
			0.029803,
			0.527975,
			0.003922,
			0.063536,
			0.028426,
			0.533124,
			0.007843,
			0.075353,
			0.027206,
			0.538007,
			0.011765,
			0.086222,
			0.026125,
			0.542658,
			0.015686,
			0.096379,
			0.025165,
			0.547103,
			0.019608,
			0.10598,
			0.024309,
			0.551368,
			0.023529,
			0.115124,
			0.023556,
			0.555468,
			0.027451,
			0.123903,
			0.022878,
			0.559423,
			0.031373,
			0.132381,
			0.022258,
			0.56325,
			0.035294,
			0.140603,
			0.021687,
			0.566959,
			0.039216,
			0.148607,
			0.021154,
			0.570562,
			0.043137,
			0.156421,
			0.020651,
			0.574065,
			0.047059,
			0.16407,
			0.020171,
			0.577478,
			0.05098,
			0.171574,
			0.019706,
			0.580806,
			0.054902,
			0.17895,
			0.019252,
			0.584054,
			0.058824,
			0.186213,
			0.018803,
			0.587228,
			0.062745,
			0.193374,
			0.018354,
			0.59033,
			0.066667,
			0.200445,
			0.017902,
			0.593364,
			0.070588,
			0.207435,
			0.017442,
			0.596333,
			0.07451,
			0.21435,
			0.016973,
			0.599239,
			0.078431,
			0.221197,
			0.016497,
			0.602083,
			0.082353,
			0.227983,
			0.016007,
			0.604867,
			0.086275,
			0.234715,
			0.015502,
			0.607592,
			0.090196,
			0.241396,
			0.014979,
			0.610259,
			0.094118,
			0.248032,
			0.014439,
			0.612868,
			0.098039,
			0.254627,
			0.013882,
			0.615419,
			0.101961,
			0.261183,
			0.013308,
			0.617911,
			0.105882,
			0.267703,
			0.012716,
			0.620346,
			0.109804,
			0.274191,
			0.012109,
			0.622722,
			0.113725,
			0.280648,
			0.011488,
			0.625038,
			0.117647,
			0.287076,
			0.010855,
			0.627295,
			0.121569,
			0.293478,
			0.010213,
			0.62949,
			0.12549,
			0.299855,
			0.009561,
			0.631624,
			0.129412,
			0.30621,
			0.008902,
			0.633694,
			0.133333,
			0.312543,
			0.008239,
			0.6357,
			0.137255,
			0.318856,
			0.007576,
			0.63764,
			0.141176,
			0.32515,
			0.006915,
			0.639512,
			0.145098,
			0.331426,
			0.006261,
			0.641316,
			0.14902,
			0.337683,
			0.005618,
			0.643049,
			0.152941,
			0.343925,
			0.004991,
			0.64471,
			0.156863,
			0.35015,
			0.004382,
			0.646298,
			0.160784,
			0.356359,
			0.003798,
			0.64781,
			0.164706,
			0.362553,
			0.003243,
			0.649245,
			0.168627,
			0.368733,
			0.002724,
			0.650601,
			0.172549,
			0.374897,
			0.002245,
			0.651876,
			0.176471,
			0.381047,
			0.001814,
			0.653068,
			0.180392,
			0.387183,
			0.001434,
			0.654177,
			0.184314,
			0.393304,
			0.001114,
			0.655199,
			0.188235,
			0.399411,
			0.000859,
			0.656133,
			0.192157,
			0.405503,
			0.000678,
			0.656977,
			0.196078,
			0.41158,
			0.000577,
			0.65773,
			0.2,
			0.417642,
			0.000564,
			0.65839,
			0.203922,
			0.423689,
			0.000646,
			0.658956,
			0.207843,
			0.429719,
			0.000831,
			0.659425,
			0.211765,
			0.435734,
			0.001127,
			0.659797,
			0.215686,
			0.441732,
			0.00154,
			0.660069,
			0.219608,
			0.447714,
			0.00208,
			0.66024,
			0.223529,
			0.453677,
			0.002755,
			0.66031,
			0.227451,
			0.459623,
			0.003574,
			0.660277,
			0.231373,
			0.46555,
			0.004545,
			0.660139,
			0.235294,
			0.471457,
			0.005678,
			0.659897,
			0.239216,
			0.477344,
			0.00698,
			0.659549,
			0.243137,
			0.48321,
			0.00846,
			0.659095,
			0.247059,
			0.489055,
			0.010127,
			0.658534,
			0.25098,
			0.494877,
			0.01199,
			0.657865,
			0.254902,
			0.500678,
			0.014055,
			0.657088,
			0.258824,
			0.506454,
			0.016333,
			0.656202,
			0.262745,
			0.512206,
			0.018833,
			0.655209,
			0.266667,
			0.517933,
			0.021563,
			0.654109,
			0.270588,
			0.523633,
			0.024532,
			0.652901,
			0.27451,
			0.529306,
			0.027747,
			0.651586,
			0.278431,
			0.534952,
			0.031217,
			0.650165,
			0.282353,
			0.54057,
			0.03495,
			0.64864,
			0.286275,
			0.546157,
			0.038954,
			0.64701,
			0.290196,
			0.551715,
			0.043136,
			0.645277,
			0.294118,
			0.557243,
			0.047331,
			0.643443,
			0.298039,
			0.562738,
			0.051545,
			0.641509,
			0.301961,
			0.568201,
			0.055778,
			0.639477,
			0.305882,
			0.573632,
			0.060028,
			0.637349,
			0.309804,
			0.579029,
			0.064296,
			0.635126,
			0.313725,
			0.584391,
			0.068579,
			0.632812,
			0.317647,
			0.589719,
			0.072878,
			0.630408,
			0.321569,
			0.595011,
			0.07719,
			0.627917,
			0.32549,
			0.600266,
			0.081516,
			0.625342,
			0.329412,
			0.605485,
			0.085854,
			0.622686,
			0.333333,
			0.610667,
			0.090204,
			0.619951,
			0.337255,
			0.615812,
			0.094564,
			0.61714,
			0.341176,
			0.620919,
			0.098934,
			0.614257,
			0.345098,
			0.625987,
			0.103312,
			0.611305,
			0.34902,
			0.631017,
			0.107699,
			0.608287,
			0.352941,
			0.636008,
			0.112092,
			0.605205,
			0.356863,
			0.640959,
			0.116492,
			0.602065,
			0.360784,
			0.645872,
			0.120898,
			0.598867,
			0.364706,
			0.650746,
			0.125309,
			0.595617,
			0.368627,
			0.65558,
			0.129725,
			0.592317,
			0.372549,
			0.660374,
			0.134144,
			0.588971,
			0.376471,
			0.665129,
			0.138566,
			0.585582,
			0.380392,
			0.669845,
			0.142992,
			0.582154,
			0.384314,
			0.674522,
			0.147419,
			0.578688,
			0.388235,
			0.67916,
			0.151848,
			0.575189,
			0.392157,
			0.683758,
			0.156278,
			0.57166,
			0.396078,
			0.688318,
			0.160709,
			0.568103,
			0.4,
			0.69284,
			0.165141,
			0.564522,
			0.403922,
			0.697324,
			0.169573,
			0.560919,
			0.407843,
			0.701769,
			0.174005,
			0.557296,
			0.411765,
			0.706178,
			0.178437,
			0.553657,
			0.415686,
			0.710549,
			0.182868,
			0.550004,
			0.419608,
			0.714883,
			0.187299,
			0.546338,
			0.423529,
			0.719181,
			0.191729,
			0.542663,
			0.427451,
			0.723444,
			0.196158,
			0.538981,
			0.431373,
			0.72767,
			0.200586,
			0.535293,
			0.435294,
			0.731862,
			0.205013,
			0.531601,
			0.439216,
			0.736019,
			0.209439,
			0.527908,
			0.443137,
			0.740143,
			0.213864,
			0.524216,
			0.447059,
			0.744232,
			0.218288,
			0.520524,
			0.45098,
			0.748289,
			0.222711,
			0.516834,
			0.454902,
			0.752312,
			0.227133,
			0.513149,
			0.458824,
			0.756304,
			0.231555,
			0.509468,
			0.462745,
			0.760264,
			0.235976,
			0.505794,
			0.466667,
			0.764193,
			0.240396,
			0.502126,
			0.470588,
			0.76809,
			0.244817,
			0.498465,
			0.47451,
			0.771958,
			0.249237,
			0.494813,
			0.478431,
			0.775796,
			0.253658,
			0.491171,
			0.482353,
			0.779604,
			0.258078,
			0.487539,
			0.486275,
			0.783383,
			0.2625,
			0.483918,
			0.490196,
			0.787133,
			0.266922,
			0.480307,
			0.494118,
			0.790855,
			0.271345,
			0.476706,
			0.498039,
			0.794549,
			0.27577,
			0.473117,
			0.501961,
			0.798216,
			0.280197,
			0.469538,
			0.505882,
			0.801855,
			0.284626,
			0.465971,
			0.509804,
			0.805467,
			0.289057,
			0.462415,
			0.513725,
			0.809052,
			0.293491,
			0.45887,
			0.517647,
			0.812612,
			0.297928,
			0.455338,
			0.521569,
			0.816144,
			0.302368,
			0.451816,
			0.52549,
			0.819651,
			0.306812,
			0.448306,
			0.529412,
			0.823132,
			0.311261,
			0.444806,
			0.533333,
			0.826588,
			0.315714,
			0.441316,
			0.537255,
			0.830018,
			0.320172,
			0.437836,
			0.541176,
			0.833422,
			0.324635,
			0.434366,
			0.545098,
			0.836801,
			0.329105,
			0.430905,
			0.54902,
			0.840155,
			0.33358,
			0.427455,
			0.552941,
			0.843484,
			0.338062,
			0.424013,
			0.556863,
			0.846788,
			0.342551,
			0.420579,
			0.560784,
			0.850066,
			0.347048,
			0.417153,
			0.564706,
			0.853319,
			0.351553,
			0.413734,
			0.568627,
			0.856547,
			0.356066,
			0.410322,
			0.572549,
			0.85975,
			0.360588,
			0.406917,
			0.576471,
			0.862927,
			0.365119,
			0.403519,
			0.580392,
			0.866078,
			0.36966,
			0.400126,
			0.584314,
			0.869203,
			0.374212,
			0.396738,
			0.588235,
			0.872303,
			0.378774,
			0.393355,
			0.592157,
			0.875376,
			0.383347,
			0.389976,
			0.596078,
			0.878423,
			0.387932,
			0.3866,
			0.6,
			0.881443,
			0.392529,
			0.383229,
			0.603922,
			0.884436,
			0.397139,
			0.37986,
			0.607843,
			0.887402,
			0.401762,
			0.376494,
			0.611765,
			0.89034,
			0.406398,
			0.37313,
			0.615686,
			0.89325,
			0.411048,
			0.369768,
			0.619608,
			0.896131,
			0.415712,
			0.366407,
			0.623529,
			0.898984,
			0.420392,
			0.363047,
			0.627451,
			0.901807,
			0.425087,
			0.359688,
			0.631373,
			0.904601,
			0.429797,
			0.356329,
			0.635294,
			0.907365,
			0.434524,
			0.35297,
			0.639216,
			0.910098,
			0.439268,
			0.34961,
			0.643137,
			0.9128,
			0.444029,
			0.346251,
			0.647059,
			0.915471,
			0.448807,
			0.34289,
			0.65098,
			0.918109,
			0.453603,
			0.339529,
			0.654902,
			0.920714,
			0.458417,
			0.336166,
			0.658824,
			0.923287,
			0.463251,
			0.332801,
			0.662745,
			0.925825,
			0.468103,
			0.329435,
			0.666667,
			0.928329,
			0.472975,
			0.326067,
			0.670588,
			0.930798,
			0.477867,
			0.322697,
			0.67451,
			0.933232,
			0.48278,
			0.319325,
			0.678431,
			0.93563,
			0.487712,
			0.315952,
			0.682353,
			0.93799,
			0.492667,
			0.312575,
			0.686275,
			0.940313,
			0.497642,
			0.309197,
			0.690196,
			0.942598,
			0.502639,
			0.305816,
			0.694118,
			0.944844,
			0.507658,
			0.302433,
			0.698039,
			0.947051,
			0.512699,
			0.299049,
			0.701961,
			0.949217,
			0.517763,
			0.295662,
			0.705882,
			0.951344,
			0.52285,
			0.292275,
			0.709804,
			0.953428,
			0.52796,
			0.288883,
			0.713725,
			0.95547,
			0.533093,
			0.28549,
			0.717647,
			0.957469,
			0.53825,
			0.282096,
			0.721569,
			0.959424,
			0.543431,
			0.278701,
			0.72549,
			0.961336,
			0.548636,
			0.275305,
			0.729412,
			0.963203,
			0.553865,
			0.271909,
			0.733333,
			0.965024,
			0.559118,
			0.268513,
			0.737255,
			0.966798,
			0.564396,
			0.265118,
			0.741176,
			0.968526,
			0.5697,
			0.261721,
			0.745098,
			0.970205,
			0.575028,
			0.258325,
			0.74902,
			0.971835,
			0.580382,
			0.254931,
			0.752941,
			0.973416,
			0.585761,
			0.25154,
			0.756863,
			0.974947,
			0.591165,
			0.248151,
			0.760784,
			0.976428,
			0.596595,
			0.244767,
			0.764706,
			0.977856,
			0.602051,
			0.241387,
			0.768627,
			0.979233,
			0.607532,
			0.238013,
			0.772549,
			0.980556,
			0.613039,
			0.234646,
			0.776471,
			0.981826,
			0.618572,
			0.231287,
			0.780392,
			0.983041,
			0.624131,
			0.227937,
			0.784314,
			0.984199,
			0.629718,
			0.224595,
			0.788235,
			0.985301,
			0.63533,
			0.221265,
			0.792157,
			0.986345,
			0.640969,
			0.217948,
			0.796078,
			0.987332,
			0.646633,
			0.214648,
			0.8,
			0.98826,
			0.652325,
			0.211364,
			0.803922,
			0.989128,
			0.658043,
			0.2081,
			0.807843,
			0.989935,
			0.663787,
			0.204859,
			0.811765,
			0.990681,
			0.669558,
			0.201642,
			0.815686,
			0.991365,
			0.675355,
			0.198453,
			0.819608,
			0.991985,
			0.681179,
			0.195295,
			0.823529,
			0.992541,
			0.68703,
			0.19217,
			0.827451,
			0.993032,
			0.692907,
			0.189084,
			0.831373,
			0.993456,
			0.69881,
			0.186041,
			0.835294,
			0.993814,
			0.704741,
			0.183043,
			0.839216,
			0.994103,
			0.710698,
			0.180097,
			0.843137,
			0.994324,
			0.716681,
			0.177208,
			0.847059,
			0.994474,
			0.722691,
			0.174381,
			0.85098,
			0.994553,
			0.728728,
			0.171622,
			0.854902,
			0.994561,
			0.734791,
			0.168938,
			0.858824,
			0.994495,
			0.74088,
			0.166335,
			0.862745,
			0.994355,
			0.746995,
			0.163821,
			0.866667,
			0.994141,
			0.753137,
			0.161404,
			0.870588,
			0.993851,
			0.759304,
			0.159092,
			0.87451,
			0.993482,
			0.765499,
			0.156891,
			0.878431,
			0.993033,
			0.77172,
			0.154808,
			0.882353,
			0.992505,
			0.777967,
			0.152855,
			0.886275,
			0.991897,
			0.784239,
			0.151042,
			0.890196,
			0.991209,
			0.790537,
			0.149377,
			0.894118,
			0.990439,
			0.796859,
			0.14787,
			0.898039,
			0.989587,
			0.803205,
			0.146529,
			0.901961,
			0.988648,
			0.809579,
			0.145357,
			0.905882,
			0.987621,
			0.815978,
			0.144363,
			0.909804,
			0.986509,
			0.822401,
			0.143557,
			0.913725,
			0.985314,
			0.828846,
			0.142945,
			0.917647,
			0.984031,
			0.835315,
			0.142528,
			0.921569,
			0.982653,
			0.841812,
			0.142303,
			0.92549,
			0.98119,
			0.848329,
			0.142279,
			0.929412,
			0.979644,
			0.854866,
			0.142453,
			0.933333,
			0.977995,
			0.861432,
			0.142808,
			0.937255,
			0.976265,
			0.868016,
			0.143351,
			0.941176,
			0.974443,
			0.874622,
			0.144061,
			0.945098,
			0.97253,
			0.88125,
			0.144923,
			0.94902,
			0.970533,
			0.887896,
			0.145919,
			0.952941,
			0.968443,
			0.894564,
			0.147014,
			0.956863,
			0.966271,
			0.901249,
			0.14818,
			0.960784,
			0.964021,
			0.90795,
			0.14937,
			0.964706,
			0.961681,
			0.914672,
			0.15052,
			0.968627,
			0.959276,
			0.921407,
			0.151566,
			0.972549,
			0.956808,
			0.928152,
			0.152409,
			0.976471,
			0.954287,
			0.934908,
			0.152921,
			0.980392,
			0.951726,
			0.941671,
			0.152925,
			0.984314,
			0.949151,
			0.948435,
			0.152178,
			0.988235,
			0.946602,
			0.95519,
			0.150328,
			0.992157,
			0.944152,
			0.961916,
			0.146861,
			0.996078,
			0.941896,
			0.96859,
			0.140956,
			1,
			0.940015,
			0.975158,
			0.131326
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Viridis (matplotlib)",
		NanColor: [
			1,
			0,
			0
		],
		Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
		License: "CC0",
		Creator: "Eric Firing",
		RGBPoints: [
			0,
			0.267004,
			0.004874,
			0.329415,
			0.003922,
			0.26851,
			0.009605,
			0.335427,
			0.007843,
			0.269944,
			0.014625,
			0.341379,
			0.011765,
			0.271305,
			0.019942,
			0.347269,
			0.015686,
			0.272594,
			0.025563,
			0.353093,
			0.019608,
			0.273809,
			0.031497,
			0.358853,
			0.023529,
			0.274952,
			0.037752,
			0.364543,
			0.027451,
			0.276022,
			0.044167,
			0.370164,
			0.031373,
			0.277018,
			0.050344,
			0.375715,
			0.035294,
			0.277941,
			0.056324,
			0.381191,
			0.039216,
			0.278791,
			0.062145,
			0.386592,
			0.043137,
			0.279566,
			0.067836,
			0.391917,
			0.047059,
			0.280267,
			0.073417,
			0.397163,
			0.05098,
			0.280894,
			0.078907,
			0.402329,
			0.054902,
			0.281446,
			0.08432,
			0.407414,
			0.058824,
			0.281924,
			0.089666,
			0.412415,
			0.062745,
			0.282327,
			0.094955,
			0.417331,
			0.066667,
			0.282656,
			0.100196,
			0.42216,
			0.070588,
			0.28291,
			0.105393,
			0.426902,
			0.07451,
			0.283091,
			0.110553,
			0.431554,
			0.078431,
			0.283197,
			0.11568,
			0.436115,
			0.082353,
			0.283229,
			0.120777,
			0.440584,
			0.086275,
			0.283187,
			0.125848,
			0.44496,
			0.090196,
			0.283072,
			0.130895,
			0.449241,
			0.094118,
			0.282884,
			0.13592,
			0.453427,
			0.098039,
			0.282623,
			0.140926,
			0.457517,
			0.101961,
			0.28229,
			0.145912,
			0.46151,
			0.105882,
			0.281887,
			0.150881,
			0.465405,
			0.109804,
			0.281412,
			0.155834,
			0.469201,
			0.113725,
			0.280868,
			0.160771,
			0.472899,
			0.117647,
			0.280255,
			0.165693,
			0.476498,
			0.121569,
			0.279574,
			0.170599,
			0.479997,
			0.12549,
			0.278826,
			0.17549,
			0.483397,
			0.129412,
			0.278012,
			0.180367,
			0.486697,
			0.133333,
			0.277134,
			0.185228,
			0.489898,
			0.137255,
			0.276194,
			0.190074,
			0.493001,
			0.141176,
			0.275191,
			0.194905,
			0.496005,
			0.145098,
			0.274128,
			0.199721,
			0.498911,
			0.14902,
			0.273006,
			0.20452,
			0.501721,
			0.152941,
			0.271828,
			0.209303,
			0.504434,
			0.156863,
			0.270595,
			0.214069,
			0.507052,
			0.160784,
			0.269308,
			0.218818,
			0.509577,
			0.164706,
			0.267968,
			0.223549,
			0.512008,
			0.168627,
			0.26658,
			0.228262,
			0.514349,
			0.172549,
			0.265145,
			0.232956,
			0.516599,
			0.176471,
			0.263663,
			0.237631,
			0.518762,
			0.180392,
			0.262138,
			0.242286,
			0.520837,
			0.184314,
			0.260571,
			0.246922,
			0.522828,
			0.188235,
			0.258965,
			0.251537,
			0.524736,
			0.192157,
			0.257322,
			0.25613,
			0.526563,
			0.196078,
			0.255645,
			0.260703,
			0.528312,
			0.2,
			0.253935,
			0.265254,
			0.529983,
			0.203922,
			0.252194,
			0.269783,
			0.531579,
			0.207843,
			0.250425,
			0.27429,
			0.533103,
			0.211765,
			0.248629,
			0.278775,
			0.534556,
			0.215686,
			0.246811,
			0.283237,
			0.535941,
			0.219608,
			0.244972,
			0.287675,
			0.53726,
			0.223529,
			0.243113,
			0.292092,
			0.538516,
			0.227451,
			0.241237,
			0.296485,
			0.539709,
			0.231373,
			0.239346,
			0.300855,
			0.540844,
			0.235294,
			0.237441,
			0.305202,
			0.541921,
			0.239216,
			0.235526,
			0.309527,
			0.542944,
			0.243137,
			0.233603,
			0.313828,
			0.543914,
			0.247059,
			0.231674,
			0.318106,
			0.544834,
			0.25098,
			0.229739,
			0.322361,
			0.545706,
			0.254902,
			0.227802,
			0.326594,
			0.546532,
			0.258824,
			0.225863,
			0.330805,
			0.547314,
			0.262745,
			0.223925,
			0.334994,
			0.548053,
			0.266667,
			0.221989,
			0.339161,
			0.548752,
			0.270588,
			0.220057,
			0.343307,
			0.549413,
			0.27451,
			0.21813,
			0.347432,
			0.550038,
			0.278431,
			0.21621,
			0.351535,
			0.550627,
			0.282353,
			0.214298,
			0.355619,
			0.551184,
			0.286275,
			0.212395,
			0.359683,
			0.55171,
			0.290196,
			0.210503,
			0.363727,
			0.552206,
			0.294118,
			0.208623,
			0.367752,
			0.552675,
			0.298039,
			0.206756,
			0.371758,
			0.553117,
			0.301961,
			0.204903,
			0.375746,
			0.553533,
			0.305882,
			0.203063,
			0.379716,
			0.553925,
			0.309804,
			0.201239,
			0.38367,
			0.554294,
			0.313725,
			0.19943,
			0.387607,
			0.554642,
			0.317647,
			0.197636,
			0.391528,
			0.554969,
			0.321569,
			0.19586,
			0.395433,
			0.555276,
			0.32549,
			0.1941,
			0.399323,
			0.555565,
			0.329412,
			0.192357,
			0.403199,
			0.555836,
			0.333333,
			0.190631,
			0.407061,
			0.556089,
			0.337255,
			0.188923,
			0.41091,
			0.556326,
			0.341176,
			0.187231,
			0.414746,
			0.556547,
			0.345098,
			0.185556,
			0.41857,
			0.556753,
			0.34902,
			0.183898,
			0.422383,
			0.556944,
			0.352941,
			0.182256,
			0.426184,
			0.55712,
			0.356863,
			0.180629,
			0.429975,
			0.557282,
			0.360784,
			0.179019,
			0.433756,
			0.55743,
			0.364706,
			0.177423,
			0.437527,
			0.557565,
			0.368627,
			0.175841,
			0.44129,
			0.557685,
			0.372549,
			0.174274,
			0.445044,
			0.557792,
			0.376471,
			0.172719,
			0.448791,
			0.557885,
			0.380392,
			0.171176,
			0.45253,
			0.557965,
			0.384314,
			0.169646,
			0.456262,
			0.55803,
			0.388235,
			0.168126,
			0.459988,
			0.558082,
			0.392157,
			0.166617,
			0.463708,
			0.558119,
			0.396078,
			0.165117,
			0.467423,
			0.558141,
			0.4,
			0.163625,
			0.471133,
			0.558148,
			0.403922,
			0.162142,
			0.474838,
			0.55814,
			0.407843,
			0.160665,
			0.47854,
			0.558115,
			0.411765,
			0.159194,
			0.482237,
			0.558073,
			0.415686,
			0.157729,
			0.485932,
			0.558013,
			0.419608,
			0.15627,
			0.489624,
			0.557936,
			0.423529,
			0.154815,
			0.493313,
			0.55784,
			0.427451,
			0.153364,
			0.497,
			0.557724,
			0.431373,
			0.151918,
			0.500685,
			0.557587,
			0.435294,
			0.150476,
			0.504369,
			0.55743,
			0.439216,
			0.149039,
			0.508051,
			0.55725,
			0.443137,
			0.147607,
			0.511733,
			0.557049,
			0.447059,
			0.14618,
			0.515413,
			0.556823,
			0.45098,
			0.144759,
			0.519093,
			0.556572,
			0.454902,
			0.143343,
			0.522773,
			0.556295,
			0.458824,
			0.141935,
			0.526453,
			0.555991,
			0.462745,
			0.140536,
			0.530132,
			0.555659,
			0.466667,
			0.139147,
			0.533812,
			0.555298,
			0.470588,
			0.13777,
			0.537492,
			0.554906,
			0.47451,
			0.136408,
			0.541173,
			0.554483,
			0.478431,
			0.135066,
			0.544853,
			0.554029,
			0.482353,
			0.133743,
			0.548535,
			0.553541,
			0.486275,
			0.132444,
			0.552216,
			0.553018,
			0.490196,
			0.131172,
			0.555899,
			0.552459,
			0.494118,
			0.129933,
			0.559582,
			0.551864,
			0.498039,
			0.128729,
			0.563265,
			0.551229,
			0.501961,
			0.127568,
			0.566949,
			0.550556,
			0.505882,
			0.126453,
			0.570633,
			0.549841,
			0.509804,
			0.125394,
			0.574318,
			0.549086,
			0.513725,
			0.124395,
			0.578002,
			0.548287,
			0.517647,
			0.123463,
			0.581687,
			0.547445,
			0.521569,
			0.122606,
			0.585371,
			0.546557,
			0.52549,
			0.121831,
			0.589055,
			0.545623,
			0.529412,
			0.121148,
			0.592739,
			0.544641,
			0.533333,
			0.120565,
			0.596422,
			0.543611,
			0.537255,
			0.120092,
			0.600104,
			0.54253,
			0.541176,
			0.119738,
			0.603785,
			0.5414,
			0.545098,
			0.119512,
			0.607464,
			0.540218,
			0.54902,
			0.119423,
			0.611141,
			0.538982,
			0.552941,
			0.119483,
			0.614817,
			0.537692,
			0.556863,
			0.119699,
			0.61849,
			0.536347,
			0.560784,
			0.120081,
			0.622161,
			0.534946,
			0.564706,
			0.120638,
			0.625828,
			0.533488,
			0.568627,
			0.12138,
			0.629492,
			0.531973,
			0.572549,
			0.122312,
			0.633153,
			0.530398,
			0.576471,
			0.123444,
			0.636809,
			0.528763,
			0.580392,
			0.12478,
			0.640461,
			0.527068,
			0.584314,
			0.126326,
			0.644107,
			0.525311,
			0.588235,
			0.128087,
			0.647749,
			0.523491,
			0.592157,
			0.130067,
			0.651384,
			0.521608,
			0.596078,
			0.132268,
			0.655014,
			0.519661,
			0.6,
			0.134692,
			0.658636,
			0.517649,
			0.603922,
			0.137339,
			0.662252,
			0.515571,
			0.607843,
			0.14021,
			0.665859,
			0.513427,
			0.611765,
			0.143303,
			0.669459,
			0.511215,
			0.615686,
			0.146616,
			0.67305,
			0.508936,
			0.619608,
			0.150148,
			0.676631,
			0.506589,
			0.623529,
			0.153894,
			0.680203,
			0.504172,
			0.627451,
			0.157851,
			0.683765,
			0.501686,
			0.631373,
			0.162016,
			0.687316,
			0.499129,
			0.635294,
			0.166383,
			0.690856,
			0.496502,
			0.639216,
			0.170948,
			0.694384,
			0.493803,
			0.643137,
			0.175707,
			0.6979,
			0.491033,
			0.647059,
			0.180653,
			0.701402,
			0.488189,
			0.65098,
			0.185783,
			0.704891,
			0.485273,
			0.654902,
			0.19109,
			0.708366,
			0.482284,
			0.658824,
			0.196571,
			0.711827,
			0.479221,
			0.662745,
			0.202219,
			0.715272,
			0.476084,
			0.666667,
			0.20803,
			0.718701,
			0.472873,
			0.670588,
			0.214,
			0.722114,
			0.469588,
			0.67451,
			0.220124,
			0.725509,
			0.466226,
			0.678431,
			0.226397,
			0.728888,
			0.462789,
			0.682353,
			0.232815,
			0.732247,
			0.459277,
			0.686275,
			0.239374,
			0.735588,
			0.455688,
			0.690196,
			0.24607,
			0.73891,
			0.452024,
			0.694118,
			0.252899,
			0.742211,
			0.448284,
			0.698039,
			0.259857,
			0.745492,
			0.444467,
			0.701961,
			0.266941,
			0.748751,
			0.440573,
			0.705882,
			0.274149,
			0.751988,
			0.436601,
			0.709804,
			0.281477,
			0.755203,
			0.432552,
			0.713725,
			0.288921,
			0.758394,
			0.428426,
			0.717647,
			0.296479,
			0.761561,
			0.424223,
			0.721569,
			0.304148,
			0.764704,
			0.419943,
			0.72549,
			0.311925,
			0.767822,
			0.415586,
			0.729412,
			0.319809,
			0.770914,
			0.411152,
			0.733333,
			0.327796,
			0.77398,
			0.40664,
			0.737255,
			0.335885,
			0.777018,
			0.402049,
			0.741176,
			0.344074,
			0.780029,
			0.397381,
			0.745098,
			0.35236,
			0.783011,
			0.392636,
			0.74902,
			0.360741,
			0.785964,
			0.387814,
			0.752941,
			0.369214,
			0.788888,
			0.382914,
			0.756863,
			0.377779,
			0.791781,
			0.377939,
			0.760784,
			0.386433,
			0.794644,
			0.372886,
			0.764706,
			0.395174,
			0.797475,
			0.367757,
			0.768627,
			0.404001,
			0.800275,
			0.362552,
			0.772549,
			0.412913,
			0.803041,
			0.357269,
			0.776471,
			0.421908,
			0.805774,
			0.35191,
			0.780392,
			0.430983,
			0.808473,
			0.346476,
			0.784314,
			0.440137,
			0.811138,
			0.340967,
			0.788235,
			0.449368,
			0.813768,
			0.335384,
			0.792157,
			0.458674,
			0.816363,
			0.329727,
			0.796078,
			0.468053,
			0.818921,
			0.323998,
			0.8,
			0.477504,
			0.821444,
			0.318195,
			0.803922,
			0.487026,
			0.823929,
			0.312321,
			0.807843,
			0.496615,
			0.826376,
			0.306377,
			0.811765,
			0.506271,
			0.828786,
			0.300362,
			0.815686,
			0.515992,
			0.831158,
			0.294279,
			0.819608,
			0.525776,
			0.833491,
			0.288127,
			0.823529,
			0.535621,
			0.835785,
			0.281908,
			0.827451,
			0.545524,
			0.838039,
			0.275626,
			0.831373,
			0.555484,
			0.840254,
			0.269281,
			0.835294,
			0.565498,
			0.84243,
			0.262877,
			0.839216,
			0.575563,
			0.844566,
			0.256415,
			0.843137,
			0.585678,
			0.846661,
			0.249897,
			0.847059,
			0.595839,
			0.848717,
			0.243329,
			0.85098,
			0.606045,
			0.850733,
			0.236712,
			0.854902,
			0.616293,
			0.852709,
			0.230052,
			0.858824,
			0.626579,
			0.854645,
			0.223353,
			0.862745,
			0.636902,
			0.856542,
			0.21662,
			0.866667,
			0.647257,
			0.8584,
			0.209861,
			0.870588,
			0.657642,
			0.860219,
			0.203082,
			0.87451,
			0.668054,
			0.861999,
			0.196293,
			0.878431,
			0.678489,
			0.863742,
			0.189503,
			0.882353,
			0.688944,
			0.865448,
			0.182725,
			0.886275,
			0.699415,
			0.867117,
			0.175971,
			0.890196,
			0.709898,
			0.868751,
			0.169257,
			0.894118,
			0.720391,
			0.87035,
			0.162603,
			0.898039,
			0.730889,
			0.871916,
			0.156029,
			0.901961,
			0.741388,
			0.873449,
			0.149561,
			0.905882,
			0.751884,
			0.874951,
			0.143228,
			0.909804,
			0.762373,
			0.876424,
			0.137064,
			0.913725,
			0.772852,
			0.877868,
			0.131109,
			0.917647,
			0.783315,
			0.879285,
			0.125405,
			0.921569,
			0.79376,
			0.880678,
			0.120005,
			0.92549,
			0.804182,
			0.882046,
			0.114965,
			0.929412,
			0.814576,
			0.883393,
			0.110347,
			0.933333,
			0.82494,
			0.88472,
			0.106217,
			0.937255,
			0.83527,
			0.886029,
			0.102646,
			0.941176,
			0.845561,
			0.887322,
			0.099702,
			0.945098,
			0.85581,
			0.888601,
			0.097452,
			0.94902,
			0.866013,
			0.889868,
			0.095953,
			0.952941,
			0.876168,
			0.891125,
			0.09525,
			0.956863,
			0.886271,
			0.892374,
			0.095374,
			0.960784,
			0.89632,
			0.893616,
			0.096335,
			0.964706,
			0.906311,
			0.894855,
			0.098125,
			0.968627,
			0.916242,
			0.896091,
			0.100717,
			0.972549,
			0.926106,
			0.89733,
			0.104071,
			0.976471,
			0.935904,
			0.89857,
			0.108131,
			0.980392,
			0.945636,
			0.899815,
			0.112838,
			0.984314,
			0.9553,
			0.901065,
			0.118128,
			0.988235,
			0.964894,
			0.902323,
			0.123941,
			0.992157,
			0.974417,
			0.90359,
			0.130215,
			0.996078,
			0.983868,
			0.904867,
			0.136897,
			1,
			0.993248,
			0.906157,
			0.143936
		]
	},
	{
		ShowIndexedColorActiveValues: 1,
		IndexedColors: [
			0.07,
			0.5,
			0.7,
			1,
			1,
			1,
			0.85,
			1,
			1,
			0.8,
			0.5,
			1,
			0.76,
			1,
			0,
			1,
			0.71,
			0.71,
			0.5,
			0.5,
			0.5,
			0.05,
			0.05,
			1,
			1,
			0.05,
			0.05,
			0.7,
			1,
			1,
			0.7,
			0.89,
			0.96,
			0.67,
			0.36,
			0.95,
			0.54,
			1,
			0,
			0.75,
			0.65,
			0.65,
			0.5,
			0.6,
			0.6,
			1,
			0.5,
			0,
			1,
			1,
			0.19,
			0.12,
			0.94,
			0.12,
			0.5,
			0.82,
			0.89,
			0.56,
			0.25,
			0.83,
			0.24,
			1,
			0,
			0.9,
			0.9,
			0.9,
			0.75,
			0.76,
			0.78,
			0.65,
			0.65,
			0.67,
			0.54,
			0.6,
			0.78,
			0.61,
			0.48,
			0.78,
			0.5,
			0.48,
			0.78,
			0.44,
			0.48,
			0.78,
			0.36,
			0.48,
			0.76,
			1,
			0.48,
			0.38,
			0.49,
			0.5,
			0.69,
			0.76,
			0.56,
			0.56,
			0.4,
			0.56,
			0.56,
			0.74,
			0.5,
			0.89,
			1,
			0.63,
			0,
			0.65,
			0.16,
			0.16,
			0.36,
			0.72,
			0.82,
			0.44,
			0.18,
			0.69,
			0,
			1,
			0,
			0.58,
			1,
			1,
			0.58,
			0.88,
			0.88,
			0.45,
			0.76,
			0.79,
			0.33,
			0.71,
			0.71,
			0.23,
			0.62,
			0.62,
			0.14,
			0.56,
			0.56,
			0.04,
			0.49,
			0.55,
			0,
			0.41,
			0.52,
			0.88,
			0.88,
			1,
			1,
			0.85,
			0.56,
			0.65,
			0.46,
			0.45,
			0.4,
			0.5,
			0.5,
			0.62,
			0.39,
			0.71,
			0.83,
			0.48,
			0,
			0.58,
			0,
			0.58,
			0.26,
			0.62,
			0.69,
			0.34,
			0.09,
			0.56,
			0,
			0.79,
			0,
			0.44,
			0.83,
			1,
			1,
			1,
			0.78,
			0.85,
			1,
			0.78,
			0.78,
			1,
			0.78,
			0.64,
			1,
			0.78,
			0.56,
			1,
			0.78,
			0.38,
			1,
			0.78,
			0.27,
			1,
			0.78,
			0.19,
			1,
			0.78,
			0.12,
			1,
			0.78,
			0,
			1,
			0.61,
			0,
			0.9,
			0.46,
			0,
			0.83,
			0.32,
			0,
			0.75,
			0.22,
			0,
			0.67,
			0.14,
			0.3,
			0.76,
			1,
			0.3,
			0.65,
			1,
			0.13,
			0.58,
			0.84,
			0.15,
			0.49,
			0.67,
			0.15,
			0.4,
			0.59,
			0.09,
			0.33,
			0.53,
			0.96,
			0.93,
			0.82,
			0.8,
			0.82,
			0.12,
			0.71,
			0.71,
			0.76,
			0.65,
			0.33,
			0.3,
			0.34,
			0.35,
			0.38,
			0.62,
			0.31,
			0.71,
			0.67,
			0.36,
			0,
			0.46,
			0.31,
			0.27,
			0.26,
			0.51,
			0.59,
			0.26,
			0,
			0.4,
			0,
			0.49,
			0,
			0.44,
			0.67,
			0.98,
			0,
			0.73,
			1,
			0,
			0.63,
			1,
			0,
			0.56,
			1,
			0,
			0.5,
			1,
			0,
			0.42,
			1,
			0.33,
			0.36,
			0.95,
			0.47,
			0.36,
			0.89,
			0.54,
			0.31,
			0.89,
			0.63,
			0.21,
			0.83,
			0.7,
			0.12,
			0.83,
			0.7,
			0.12,
			0.73,
			0.7,
			0.05,
			0.65,
			0.74,
			0.05,
			0.53,
			0.78,
			0,
			0.4,
			0.8,
			0,
			0.35,
			0.82,
			0,
			0.31,
			0.85,
			0,
			0.27,
			0.88,
			0,
			0.22,
			0.9,
			0,
			0.18,
			0.91,
			0,
			0.15,
			0.92,
			0,
			0.14,
			0.93,
			0,
			0.13,
			0.94,
			0,
			0.12,
			0.95,
			0,
			0.11,
			0.96,
			0,
			0.1,
			0.97,
			0,
			0.09,
			0.98,
			0,
			0.08,
			0.99,
			0,
			0.07,
			1,
			0,
			0.06
		],
		Annotations: [
			0,
			"Xx",
			1,
			"H",
			2,
			"He",
			3,
			"Li",
			4,
			"Be",
			5,
			"B",
			6,
			"C",
			7,
			"N",
			8,
			"O",
			9,
			"F",
			10,
			"Ne",
			11,
			"Na",
			12,
			"Mg",
			13,
			"Al",
			14,
			"Si",
			15,
			"P",
			16,
			"S",
			17,
			"Cl",
			18,
			"Ar",
			19,
			"K",
			20,
			"Ca",
			21,
			"Sc",
			22,
			"Ti",
			23,
			"V",
			24,
			"Cr",
			25,
			"Mn",
			26,
			"Fe",
			27,
			"Co",
			28,
			"Ni",
			29,
			"Cu",
			30,
			"Zn",
			31,
			"Ga",
			32,
			"Ge",
			33,
			"As",
			34,
			"Se",
			35,
			"Br",
			36,
			"Kr",
			37,
			"Rb",
			38,
			"Sr",
			39,
			"Y",
			40,
			"Zr",
			41,
			"Nb",
			42,
			"Mo",
			43,
			"Tc",
			44,
			"Ru",
			45,
			"Rh",
			46,
			"Pd",
			47,
			"Ag",
			48,
			"Cd",
			49,
			"In",
			50,
			"Sn",
			51,
			"Sb",
			52,
			"Te",
			53,
			"I",
			54,
			"Xe",
			55,
			"Cs",
			56,
			"Ba",
			57,
			"La",
			58,
			"Ce",
			59,
			"Pr",
			60,
			"Nd",
			61,
			"Pm",
			62,
			"Sm",
			63,
			"Eu",
			64,
			"Gd",
			65,
			"Tb",
			66,
			"Dy",
			67,
			"Ho",
			68,
			"Er",
			69,
			"Tm",
			70,
			"Yb",
			71,
			"Lu",
			72,
			"Hf",
			73,
			"Ta",
			74,
			"W",
			75,
			"Re",
			76,
			"Os",
			77,
			"Ir",
			78,
			"Pt",
			79,
			"Au",
			80,
			"Hg",
			81,
			"Tl",
			82,
			"Pb",
			83,
			"Bi",
			84,
			"Po",
			85,
			"At",
			86,
			"Rn",
			87,
			"Fr",
			88,
			"Ra",
			89,
			"Ac",
			90,
			"Th",
			91,
			"Pa",
			92,
			"U",
			93,
			"Np",
			94,
			"Pu",
			95,
			"Am",
			96,
			"Cm",
			97,
			"Bk",
			98,
			"Cf",
			99,
			"Es",
			100,
			"Fm",
			101,
			"Md",
			102,
			"No",
			103,
			"Lr",
			104,
			"Rf",
			105,
			"Db",
			106,
			"Sg",
			107,
			"Bh",
			108,
			"Hs",
			109,
			"Mt",
			110,
			"Ds",
			111,
			"Rg",
			112,
			"Cn",
			113,
			"Uut",
			114,
			"Uuq",
			115,
			"Uup",
			116,
			"Uuh",
			117,
			"Uus",
			118,
			"Uuo"
		],
		Name: "BlueObeliskElements"
	}
];



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js


const presetMap = Object.create(null);
vtkColorMaps.filter(p => p.RGBPoints).filter(p => p.ColorSpace !== 'CIELAB').forEach(p => {
  presetMap[p.Name] = p;
});

// ----------------------------------------------------------------------------

const rgbPresetNames = Object.keys(presetMap);
rgbPresetNames.sort();

// ----------------------------------------------------------------------------

function getPresetByName(name) {
  return presetMap[name];
}

// ----------------------------------------------------------------------------

function addPreset(preset) {
  if (!preset.RGBPoints || preset.ColorSpace === 'CIELAB') {
    return;
  }
  if (!presetMap[preset.Name]) {
    rgbPresetNames.push(preset.Name);
    rgbPresetNames.sort();
  }
  presetMap[preset.Name] = preset;
}

// ----------------------------------------------------------------------------

function removePresetByName(name) {
  const index = rgbPresetNames.indexOf(name);
  if (index > -1) {
    rgbPresetNames.splice(index, 1);
  }
  delete presetMap[name];
}

// ----------------------------------------------------------------------------

var ColorMaps_vtkColorMaps = {
  addPreset,
  removePresetByName,
  getPresetByName,
  rgbPresetNames
};




/***/ }),

/***/ 94520:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Constants)
/* harmony export */ });
/* unused harmony export SlicingMode */
const SlicingMode = {
  NONE: -1,
  I: 0,
  J: 1,
  K: 2,
  X: 3,
  Y: 4,
  Z: 5
};
var Constants = {
  SlicingMode
};




/***/ }),

/***/ 91732:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Constants),
/* harmony export */   V: () => (/* binding */ InterpolationType)
/* harmony export */ });
const InterpolationType = {
  NEAREST: 0,
  LINEAR: 1
};
var Constants = {
  InterpolationType
};




/***/ }),

/***/ 82409:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkMapper$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _AbstractMapper3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68076);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42008);
/* harmony import */ var _Common_DataModel_ImageData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58498);
/* harmony import */ var _Common_Core_LookupTable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(72879);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(16632);
/* harmony import */ var _Common_Core_ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62955);
/* harmony import */ var _Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(57285);
/* harmony import */ var _Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(33395);
/* harmony import */ var _Common_DataModel_DataSet_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(69147);
/* harmony import */ var _OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(57703);












const {
  FieldAssociations
} = _Common_DataModel_DataSet_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Ay;
const {
  staticOffsetAPI,
  otherStaticMethods
} = _Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Ay;
const {
  ColorMode,
  ScalarMode,
  GetArray
} = _Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Ay;
const {
  VectorMode
} = _Common_Core_ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Ay;
const {
  VtkDataTypes
} = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay;

// ----------------------------------------------------------------------------

function notImplemented(method) {
  return () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
}

/**
 * Increase by one the 3D coordinates
 * It will follow a zigzag pattern so that each coordinate is the neighbor of the next coordinate
 * This enables interpolation between two texels without issues
 * Note: texture coordinates can't be interpolated using this pattern
 * @param {vec3} coordinates The 3D coordinates using integers for each coorinate
 * @param {vec3} dimensions The 3D dimensions of the volume
 */
function updateZigzaggingCoordinates(coordinates, dimensions) {
  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;
  coordinates[0] += directionX;
  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {
    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;
    coordinates[0] -= directionX;
    coordinates[1] += directionY;
    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {
      coordinates[1] -= directionY;
      coordinates[2]++;
    }
  }
}

/**
 * Returns the index in the array representing the volume from a 3D coordinate
 * @param {vec3} coordinates The 3D integer coordinates
 * @param {vec3} dimensions The 3D dimensions of the volume
 * @returns The index in a flat array representing the volume
 */
function getIndexFromCoordinates(coordinates, dimensions) {
  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);
}

/**
 * Write texture coordinates for the given `texelIndexPosition` in `textureCoordinate`.
 * The `texelIndexPosition` is a floating point number that represents the distance in index space
 * from the center of the first texel to the final output position.
 * The output is given in texture coordinates and not in index coordinates (this is done at the very end of the function)
 * @param {vec3} textureCoordinate The output texture coordinates (to avoid allocating a new Array)
 * @param {Number} texelIndexPosition The floating point distance from the center of the first texel, following a zigzag pattern
 * @param {vec3} dimensions The 3D dimensions of the volume
 */
function getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {
  // First compute the integer textureCoordinate
  const intTexelIndex = Math.floor(texelIndexPosition);
  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);
  let xDirection;
  let xEndFlag;
  if (xCoordBeforeWrap < dimensions[0]) {
    textureCoordinate[0] = xCoordBeforeWrap;
    xDirection = 1;
    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;
  } else {
    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;
    xDirection = -1;
    xEndFlag = textureCoordinate[0] === 0;
  }
  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);
  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);
  let yDirection;
  let yEndFlag;
  if (yCoordBeforeWrap < dimensions[1]) {
    textureCoordinate[1] = yCoordBeforeWrap;
    yDirection = 1;
    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;
  } else {
    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;
    yDirection = -1;
    yEndFlag = textureCoordinate[1] === 0;
  }
  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);

  // Now add the remainder either in x, y or z
  const remainder = texelIndexPosition - intTexelIndex;
  if (xEndFlag) {
    if (yEndFlag) {
      textureCoordinate[2] += remainder;
    } else {
      textureCoordinate[1] += yDirection * remainder;
    }
  } else {
    textureCoordinate[0] += xDirection * remainder;
  }

  // textureCoordinates are in index space, convert to texture space
  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];
  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];
  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];
}

// Associate an input vtkDataArray to an object { stringHash, textureCoordinates }
// A single dataArray only caches one array of texture coordinates, so this cache is useless when
// the input data array is used with two different lookup tables (which is very unlikely)
const colorTextureCoordinatesCache = new WeakMap();
/**
 * The minimum of the range is mapped to the center of the first texel excluding min texel (texel at index distance 1)
 * The maximum of the range is mapped to the center of the last texel excluding max and NaN texels (texel at index distance numberOfColorsInRange)
 * The result is cached, and is reused if the arguments are the same and the input doesn't change
 * @param {vtkDataArray} input The input data array used for coloring
 * @param {Number} component The component of the input data array that is used for coloring (-1 for magnitude of the vectors)
 * @param {Range} range The range of the scalars
 * @param {Number} numberOfColorsInRange The number of colors that are used in the range
 * @param {vec3} dimensions The dimensions of the texture
 * @param {boolean} useLogScale If log scale should be used to transform input scalars
 * @param {boolean} useZigzagPattern If a zigzag pattern should be used. Otherwise 1 row for colors (including min and max) and 1 row for NaN are used.
 * @returns A vtkDataArray containing the texture coordinates (2D or 3D)
 */
function getOrCreateColorTextureCoordinates(input, component, range, numberOfColorsInRange, dimensions, useLogScale, useZigzagPattern) {
  // Caching using the "arguments" special object (because it is a pure function)
  const argStrings = new Array(arguments.length);
  for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {
    // eslint-disable-next-line prefer-rest-params
    const arg = arguments[argIndex];
    argStrings[argIndex] = arg.getMTime?.() ?? arg;
  }
  const stringHash = argStrings.join('/');
  const cachedResult = colorTextureCoordinatesCache.get(input);
  if (cachedResult && cachedResult.stringHash === stringHash) {
    return cachedResult.textureCoordinates;
  }

  // The range used for computing coordinates have to change
  // slightly to accommodate the special above- and below-range
  // colors that are the first and last texels, respectively.
  const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);
  const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];

  // Use the center of the voxel
  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;
  const textureSCoeff = 1.0 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);

  // Compute in index space first
  const texelIndexOrigin = paddedRangeMin;
  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);
  const inputV = input.getData();
  const numScalars = input.getNumberOfTuples();
  const numComps = input.getNumberOfComponents();
  const useMagnitude = component < 0 || component >= numComps;
  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;
  const output = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
    numberOfComponents: numberOfOutputComponents,
    values: new Float32Array(numScalars * numberOfOutputComponents)
  });
  const outputV = output.getData();
  const nanTextureCoordinate = [0, 0, 0];
  // Distance of NaN from the beginning:
  // min: 0, ...colorsInRange, max: numberOfColorsInRange + 1, NaN = numberOfColorsInRange + 2
  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);

  // Set a texture coordinate in the output for each tuple in the input
  let inputIdx = 0;
  let outputIdx = 0;
  const textureCoordinate = [0.5, 0.5, 0.5];
  for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
    // Get scalar value from magnitude or a single component
    let scalarValue;
    if (useMagnitude) {
      let sum = 0;
      for (let compIdx = 0; compIdx < numComps; ++compIdx) {
        const compValue = inputV[inputIdx + compIdx];
        sum += compValue * compValue;
      }
      scalarValue = Math.sqrt(sum);
    } else {
      scalarValue = inputV[inputIdx + component];
    }
    inputIdx += numComps;

    // Apply log scale if necessary
    if (useLogScale) {
      scalarValue = _Common_Core_LookupTable_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.applyLogScale(scalarValue, range, range);
    }

    // Convert to texture coordinates and update output
    if ((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_5__.i)(scalarValue)) {
      // Last texels are NaN colors (there is at least one NaN color)
      textureCoordinate[0] = nanTextureCoordinate[0];
      textureCoordinate[1] = nanTextureCoordinate[1];
      textureCoordinate[2] = nanTextureCoordinate[2];
    } else if (useZigzagPattern) {
      // Texel position is in [0, numberOfColorsInRange + 1]
      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;
      if (texelIndexPosition < 1) {
        // Use min color when smaller than range
        texelIndexPosition = 0;
      } else if (texelIndexPosition > numberOfColorsInRange) {
        // Use max color when greater than range
        texelIndexPosition = numberOfColorsInRange + 1;
      }

      // Convert the texel position into texture coordinate following a zigzag pattern
      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);
    } else {
      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?
      // Because when you are mapping scalars and you have a NaN adjacent to
      // anything else, the interpolation everywhere should be NaN.  Thus, I
      // want the NaN color everywhere except right on the non-NaN neighbors.
      // To simulate this, I set the t coord for the real numbers close to
      // the threshold so that the interpolation almost immediately looks up
      // the NaN value.
      textureCoordinate[1] = 0.49;

      // Some implementations apparently don't handle relatively large
      // numbers (compared to the range [0.0, 1.0]) very well. In fact,
      // values above 1122.0f appear to cause texture wrap-around on
      // some systems even when edge clamping is enabled. Why 1122.0f? I
      // don't know. For safety, we'll clamp at +/- 1000. This will
      // result in incorrect images when the texture value should be
      // above or below 1000, but I don't have a better solution.
      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;
      if (textureS > 1000.0) {
        textureCoordinate[0] = 1000.0;
      } else if (textureS < -1000.0) {
        textureCoordinate[0] = -1000.0;
      } else {
        textureCoordinate[0] = textureS;
      }
    }
    for (let i = 0; i < numberOfOutputComponents; ++i) {
      outputV[outputIdx++] = textureCoordinate[i];
    }
  }
  colorTextureCoordinatesCache.set(input, {
    stringHash,
    textureCoordinates: output
  });
  return output;
}

// ----------------------------------------------------------------------------
// vtkMapper methods
// ----------------------------------------------------------------------------

function vtkMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkMapper');
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_5__.F)();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.setForceCompileOnly = v => {
    model.forceCompileOnly = v;
    // make sure we do NOT call modified()
  };

  publicAPI.setSelectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds => {
    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;
    // make sure we do NOT call modified()
    // this attribute is only used when processing a selection made with the hardware selector
    // the mtime of the mapper doesn't need to be changed
  };

  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = _Common_Core_LookupTable_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].newInstance */ .Ay.newInstance();
  };
  publicAPI.getColorModeAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(ColorMode, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(ScalarMode, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    // make sure we have an input
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFlag: false
      };
    }
    let scalars = null;
    let cellFlag = false;

    // get and scalar data according to scalar mode
    if (scalarMode === ScalarMode.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.mapScalars = (input, alpha) => {
    const {
      scalars,
      cellFlag
    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    model.areScalarsMappedFromCells = cellFlag;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }

    // we want to only recompute when something has changed
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString) return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }

    // Decide between texture color or vertex color.
    // Cell data always uses vertex color.
    // Only point data can use both texture and vertex coloring.
    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {
      model.mapScalarsToTexture(scalars, cellFlag, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      const lut = publicAPI.getLookupTable();
      if (lut) {
        // Ensure that the lookup table is built
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };

  // Protected method
  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {
    const range = model.lookupTable.getRange();
    const useLogScale = model.lookupTable.usingLogScale();
    if (useLogScale) {
      // convert range to log.
      _Common_Core_LookupTable_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getLogRange(range, range);
    }
    const origAlpha = model.lookupTable.getAlpha();

    // Get rid of vertex color array.  Only texture or vertex coloring
    // can be active at one time.  The existence of the array is the
    // signal to use that technique.
    model.colorMapColors = null;

    // If the lookup table has changed, then recreate the color texture map.
    // Set a new lookup table changes this->MTime.
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;

      // Get the texture map from the lookup table.
      // Create a dummy ramp of scalars.
      // In the future, we could extend vtkScalarsToColors.
      model.lookupTable.build();
      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();

      // Maximum dimensions and number of colors in range
      const maxTextureWidthForCells = 2048;
      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3; // 3D but keep a color for min, max and NaN
      const maxTextureWidthForPoints = 4096;
      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2; // 1D but keep a color for min and max (NaN is in a different row)
      // Minimum number of colors in range (excluding special colors like minColor, maxColor and NaNColor)
      const minColorsInRange = 2;
      // Maximum number of colors, limited by the maximum possible texture size
      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;
      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);
      const numberOfColorsForCells = model.numberOfColorsInRange + 3; // Add min, max and NaN
      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2; // Add min and max ; the lower row will be used for NaN color
      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];
      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];
      const scalarsArray = new Float64Array(textureSize);

      // Colors for NaN by default
      scalarsArray.fill(NaN);

      // Colors in range
      // Add 2 to also get color for min and max
      const numberOfNonSpecialColors = model.numberOfColorsInRange;
      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;
      const textureCoordinates = [0, 0, 0];
      const rangeMin = range[0];
      const rangeDifference = range[1] - range[0];
      for (let i = 0; i < numberOfNonNaNColors; ++i) {
        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);

        // Minus 1 start at min color
        const scalarValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);
        scalarsArray[scalarsArrayIndex] = useLogScale ? 10.0 ** scalarValue : scalarValue;

        // Colors are zigzagging to allow interpolation between two neighbor colors when coloring cells
        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);
      }
      const scalarsDataArray = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 1,
        values: scalarsArray
      });
      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);
      model.colorTextureMap = _Common_DataModel_ImageData_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
      model.colorTextureMap.setDimensions(textureDimensions);
      model.colorTextureMap.getPointData().setScalars(colorsDataArray);
      model.lookupTable.setAlpha(origAlpha);
    }

    // Although I like the feature of applying magnitude to single component
    // scalars, it is not how the old MapScalars for vertex coloring works.
    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();

    // Create new coordinates if necessary, this function uses cache if possible.
    // A zigzag pattern can't be used with point data, as interpolation of texture coordinates will be wrong
    // A zigzag pattern can be used with cell data, as there will be no texture coordinates interpolation
    // The texture generated using a zigzag pattern in one dimension is the same as without zigzag
    // Therefore, the same code can be used for texture generation of point/cell data but not for texture coordinates
    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, range, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), useLogScale, cellFlag);
  };
  publicAPI.getIsOpaque = () => {
    const input = publicAPI.getInputData();
    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    const scalars = gasResult.scalars;
    if (!model.scalarVisibility || scalars == null) {
      // No scalar colors.
      return true;
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      // Ensure that the lookup table is built
      lut.build();
      return lut.areScalarsOpaque(scalars, model.colorMode, -1);
    }
    return true;
  };
  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {
    if (cellFlag && !(model.colorMode === ColorMode.DIRECT_SCALARS)) {
      return true; // cell data always use textures.
    }

    if (!model.interpolateScalarsBeforeMapping) {
      return false; // user doesn't want us to use texture maps at all.
    }

    // index color does not use textures
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    if (!scalars) {
      // no scalars on this dataset, we don't care if texture is used at all.
      return false;
    }
    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {
      // Don't use texture is direct coloring using RGB unsigned chars is
      // requested.
      return false;
    }
    return true;
  };
  publicAPI.clearColorArrays = () => {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');
  publicAPI.valueToColor = notImplemented('ValueToColor');
  publicAPI.colorToValue = notImplemented('ColorToValue');
  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');
  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    /* eslint-disable no-bitwise */
    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
      return;
    }
    const rawLowData = selector.getRawPixelBuffer(_OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_LOW24);
    const rawHighData = selector.getRawPixelBuffer(_OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_HIGH24);
    const currentPass = selector.getCurrentPass();
    const fieldAssociation = selector.getFieldAssociation();
    let idMap = null;
    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      idMap = model.selectionWebGLIdsToVTKIds.points;
    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {
      idMap = model.selectionWebGLIdsToVTKIds.cells;
    }
    if (!idMap) {
      return;
    }
    pixelOffsets.forEach(pos => {
      if (currentPass === _OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_LOW24) {
        let inValue = 0;
        if (rawHighData) {
          inValue += rawHighData[pos];
          inValue *= 256;
        }
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const lowData = selector.getPixelBuffer(_OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_LOW24);
        lowData[pos] = outValue & 0xff;
        lowData[pos + 1] = (outValue & 0xff00) >> 8;
        lowData[pos + 2] = (outValue & 0xff0000) >> 16;
      } else if (currentPass === _OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_HIGH24 && rawHighData) {
        let inValue = 0;
        inValue += rawHighData[pos];
        inValue *= 256;
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const highData = selector.getPixelBuffer(_OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_HIGH24);
        highData[pos] = (outValue & 0xff000000) >> 24;
      }
    });
    /* eslint-enable no-bitwise */
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  colorMapColors: null,
  // Same as this->Colors
  areScalarsMappedFromCells: false,
  static: false,
  lookupTable: null,
  scalarVisibility: true,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  // By_NAME

  renderTime: 0,
  colorByArrayName: null,
  fieldDataTupleId: -1,
  populateSelectionSettings: true,
  selectionWebGLIdsToVTKIds: null,
  interpolateScalarsBeforeMapping: false,
  colorCoordinates: null,
  colorTextureMap: null,
  numberOfColorsInRange: 0,
  forceCompileOnly: 0,
  useInvertibleColors: false,
  invertibleScalars: null,
  customShaderAttributes: []
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _AbstractMapper3D_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .A.extend(publicAPI, model, initialValues);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['areScalarsMappedFromCells', 'colorCoordinates', 'colorMapColors', 'colorTextureMap', 'numberOfColorsInRange', 'selectionWebGLIdsToVTKIds']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO
  ]);

  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['scalarRange'], 2);
  _Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Ay.implementCoincidentTopologyMethods(publicAPI, model);

  // Object methods
  vtkMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkMapper');

// ----------------------------------------------------------------------------

var vtkMapper$1 = {
  newInstance,
  extend,
  ...staticOffsetAPI,
  ...otherStaticMethods,
  ..._Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Ay
};




/***/ }),

/***/ 57285:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ CoincidentTopologyHelper)
/* harmony export */ });
/* unused harmony export CATEGORIES */
/* harmony import */ var _Static_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7698);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);




/* eslint-disable arrow-body-style */
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach(item => {
    publicAPI[`get${item.method}`] = () => model[item.key];
    publicAPI[`set${item.method}`] = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.objectSetterMap.object(publicAPI, model, {
      name: item.key,
      params: ['factor', 'offset']
    });
  });
}
const CATEGORIES = ['Polygon', 'Line', 'Point'];

// CoincidentTopology static methods ------------------------------------------

const staticOffsetModel = {
  Polygon: {
    factor: 2,
    offset: 0
  },
  Line: {
    factor: 1,
    offset: -1
  },
  Point: {
    factor: 0,
    offset: -2
  }
};
const staticOffsetAPI = {};
addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map(key => ({
  key,
  method: `ResolveCoincidentTopology${key}OffsetParameters`
})));
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === undefined) {
    model.resolveCoincidentTopology = false;
  }
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGet(publicAPI, model, ['resolveCoincidentTopology']);

  // Relative methods
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };

  // Add Static methods to our instance
  Object.keys(_Static_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay).forEach(methodName => {
    publicAPI[methodName] = _Static_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay[methodName];
  });
  Object.keys(staticOffsetAPI).forEach(methodName => {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map(key => ({
    key,
    method: `RelativeCoincidentTopology${key}OffsetParameters`
  })));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CoincidentTopologyHelper = {
  implementCoincidentTopologyMethods,
  staticOffsetAPI,
  otherStaticMethods: _Static_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay,
  CATEGORIES,
  Resolve: _Static_js__WEBPACK_IMPORTED_MODULE_0__/* .Resolve */ .XK
};




/***/ }),

/***/ 33395:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants)
/* harmony export */ });
/* unused harmony exports ColorMode, GetArray, ScalarMode */
const ColorMode = {
  DEFAULT: 0,
  MAP_SCALARS: 1,
  DIRECT_SCALARS: 2
};
const ScalarMode = {
  DEFAULT: 0,
  USE_POINT_DATA: 1,
  USE_CELL_DATA: 2,
  USE_POINT_FIELD_DATA: 3,
  USE_CELL_FIELD_DATA: 4,
  USE_FIELD_DATA: 5
};
const GetArray = {
  BY_ID: 0,
  BY_NAME: 1
};
var Constants = {
  ColorMode,
  GetArray,
  ScalarMode
};




/***/ }),

/***/ 7698:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ otherStaticMethods),
/* harmony export */   XK: () => (/* binding */ Resolve)
/* harmony export */ });
/* unused harmony exports RESOLVE_COINCIDENT_TOPOLOGY_MODE, getResolveCoincidentTopology, getResolveCoincidentTopologyAsString, getResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopology, setResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopologyToDefault, setResolveCoincidentTopologyToOff, setResolveCoincidentTopologyToPolygonOffset */
const Resolve = {
  Off: 0,
  PolygonOffset: 1
};
let resolveCoincidentTopologyPolygonOffsetFaces = Resolve.PolygonOffset;
let resolveCoincidentTopology = Resolve.Off;
const RESOLVE_COINCIDENT_TOPOLOGY_MODE = ['VTK_RESOLVE_OFF', 'VTK_RESOLVE_POLYGON_OFFSET'];
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  const changed = resolveCoincidentTopologyPolygonOffsetFaces === value;
  resolveCoincidentTopologyPolygonOffsetFaces = value;
  return changed;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  const changed = resolveCoincidentTopology === mode;
  resolveCoincidentTopology = mode;
  return changed;
}
function setResolveCoincidentTopologyToDefault() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToOff() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  return setResolveCoincidentTopology(Resolve.PolygonOffset);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var otherStaticMethods = {
  Resolve,
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset
};




/***/ }),

/***/ 46985:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkProp$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
const CoordinateSystem = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants = {
  CoordinateSystem
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop.js



const {
  CoordinateSystem: Prop_CoordinateSystem
} = Constants;
function notImplemented(method) {
  return () => macros2.m.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkProp methods
// ----------------------------------------------------------------------------

function vtkProp(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProp');
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    for (let index = 0; index < model.textures.length; ++index) {
      const m2 = model.textures[index].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {};
  publicAPI.getNestedProps = () => null;
  publicAPI.getActors = () => [];
  publicAPI.getActors2D = () => [];
  publicAPI.getVolumes = () => [];
  publicAPI.pick = notImplemented('pick');
  publicAPI.hasKey = notImplemented('hasKey');
  publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  publicAPI.getRedrawMTime = () => model.mtime;
  publicAPI.setEstimatedRenderTime = t => {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = () => {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = t => {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = t => {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = () => false;
  publicAPI.getTextures = () => model.textures;
  publicAPI.hasTexture = texture => model.textures.indexOf(texture) !== -1;
  publicAPI.addTexture = texture => {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = texture => {
    const newTextureList = model.textures.filter(item => item !== texture);
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = () => {
    model.textures = [];
    publicAPI.modified();
  };

  // not all mappers support all coordinate systems
  publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(Prop_CoordinateSystem.WORLD);
  publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(Prop_CoordinateSystem.DISPLAY);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // _parentProp: null,
  allocatedRenderTime: 10,
  coordinateSystem: Prop_CoordinateSystem.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['estimatedRenderTime', 'allocatedRenderTime']);
  macros2.m.setGet(publicAPI, model, ['_parentProp', 'coordinateSystem', 'dragable', 'pickable', 'renderTimeMultiplier', 'useBounds', 'visibility']);
  macros2.m.moveToProtected(publicAPI, model, ['parentProp']);

  // Object methods
  vtkProp(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkProp');

// ----------------------------------------------------------------------------

var vtkProp$1 = {
  newInstance,
  extend,
  ...Constants
};




/***/ }),

/***/ 62502:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkProp3D$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21734);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16632);
/* harmony import */ var _Prop_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46985);






const VTK_EPSILON = 1e-6;

// ----------------------------------------------------------------------------
// vtkProp3D methods
// ----------------------------------------------------------------------------

function vtkProp3D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProp3D');
  publicAPI.addPosition = deltaXYZ => {
    model.position = model.position.map((value, index) => value + deltaXYZ[index]);
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = () => {
    const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.getRotation */ .pB.getRotation(q, model.rotation);
    const oaxis = new Float64Array(3);
    const w = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.getAxisAngle */ .Yu.getAxisAngle(oaxis, q);
    return [(0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.A)(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.getOrientationQuaternion = function () {
    let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.getRotation */ .pB.getRotation(out, model.rotation);
  };
  publicAPI.rotateX = val => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateX */ .pB.rotateX(model.rotation, model.rotation, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.r)(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = val => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateY */ .pB.rotateY(model.rotation, model.rotation, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.r)(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = val => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateZ */ .pB.rotateZ(model.rotation, model.rotation, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.r)(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = (degrees, x, y, z) => {
    if (degrees === 0.0 || x === 0.0 && y === 0.0 && z === 0.0) {
      return;
    }

    // convert to radians
    const angle = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.r)(degrees);
    const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.setAxisAngle */ .Yu.setAxisAngle(q, [x, y, z], angle);
    const quatMat = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromQuat */ .pB.fromQuat(quatMat, q);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.rotateQuaternion = orientationQuaternion => {
    if (Math.abs(orientationQuaternion[3]) >= 1 - VTK_EPSILON) {
      return;
    }
    const oriQuatMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromQuat */ .pB.fromQuat(new Float64Array(16), orientationQuaternion);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.rotation, model.rotation, oriQuatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = (x, y, z) => {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setUserMatrix = matrix => {
    if ((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.a)(model.userMatrix, matrix)) {
      return false;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.userMatrix, matrix);
    publicAPI.modified();
    return true;
  };
  publicAPI.getMatrix = () => {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = () => {
    // check whether or not need to rebuild the matrix
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(model.matrix);
      if (model.userMatrix) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.matrix, model.matrix, model.origin);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.matrix, model.matrix, model.position);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.matrix, model.matrix, model.rotation);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.scale */ .pB.scale(model.matrix, model.matrix, model.scale);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.matrix, model.matrix);

      // check for identity
      model.isIdentity = true;
      for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
          if ((i === j ? 1.0 : 0.0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getCenter = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCenter */ .Ay.getCenter(model.bounds);
  publicAPI.getLength = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getLength */ .Ay.getLength(model.bounds);
  publicAPI.getXRange = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getXRange */ .Ay.getXRange(model.bounds);
  publicAPI.getYRange = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getYRange */ .Ay.getYRange(model.bounds);
  publicAPI.getZRange = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getZRange */ .Ay.getZRange(model.bounds);
  publicAPI.getUserMatrix = () => model.userMatrix;
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [1, -1, 1, -1, 1, -1],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _Prop_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.obj(model.matrixMTime);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.get(publicAPI, model, ['bounds', 'isIdentity']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.getArray(publicAPI, model, ['orientation']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGetArray(publicAPI, model, ['origin', 'position', 'scale'], 3);

  // Object internal instance
  model.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.userMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.transform = null; // FIXME

  // Object methods
  vtkProp3D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.newInstance(extend, 'vtkProp3D');

// ----------------------------------------------------------------------------

var vtkProp3D$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 89585:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkProperty$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Property_Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71995);



const {
  Representation,
  Interpolation
} = _Property_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay;
function notImplemented(method) {
  return () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkProperty methods
// ----------------------------------------------------------------------------

function vtkProperty(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProperty');
  publicAPI.setColor = (r, g, b) => {
    if (Array.isArray(r)) {
      if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
        model.color[0] = r[0];
        model.color[1] = r[1];
        model.color[2] = r[2];
        publicAPI.modified();
      }
    } else if (model.color[0] !== r || model.color[1] !== g || model.color[2] !== b) {
      model.color[0] = r;
      model.color[1] = g;
      model.color[2] = b;
      publicAPI.modified();
    }
    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };
  publicAPI.computeCompositeColor = notImplemented('ComputeCompositeColor');
  publicAPI.getColor = () => {
    // Inline computeCompositeColor
    let norm = 0.0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm = 1.0 / (model.ambient + model.diffuse + model.specular);
    }
    for (let i = 0; i < 3; i++) {
      model.color[i] = norm * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
    }
    return [].concat(model.color);
  };
  publicAPI.setSpecularPower = specularPower => {
    const roughness = 1 / Math.max(1.0, specularPower);
    if (model.roughness !== roughness || model.specularPower !== specularPower) {
      model.specularPower = specularPower; // Specular power still needs to be set as long as webgl is using it (otherwise testShaderReplacementsClear fails)
      model.roughness = roughness;
      publicAPI.modified();
    }
  };
  publicAPI.addShaderVariable = notImplemented('AddShaderVariable');
  publicAPI.setInterpolationToFlat = () => publicAPI.setInterpolation(Interpolation.FLAT);
  publicAPI.setInterpolationToGouraud = () => publicAPI.setInterpolation(Interpolation.GOURAUD);
  publicAPI.setInterpolationToPhong = () => publicAPI.setInterpolation(Interpolation.PHONG);
  publicAPI.getInterpolationAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(Interpolation, model.interpolation);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation.POINTS);
  publicAPI.getRepresentationAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(Representation, model.representation);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  color: [1, 1, 1],
  ambientColor: [1, 1, 1],
  diffuseColor: [1, 1, 1],
  specularColor: [1, 1, 1],
  edgeColor: [0, 0, 0],
  ambient: 0,
  diffuse: 1,
  metallic: 0,
  roughness: 0.6,
  normalStrength: 1,
  emission: 1,
  baseIOR: 1.45,
  specular: 0,
  specularPower: 1,
  opacity: 1,
  interpolation: Interpolation.GOURAUD,
  representation: Representation.SURFACE,
  edgeVisibility: false,
  backfaceCulling: false,
  frontfaceCulling: false,
  pointSize: 1,
  lineWidth: 1,
  lighting: true,
  shading: false,
  materialName: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['lighting', 'interpolation', 'ambient', 'diffuse', 'metallic', 'roughness', 'normalStrength', 'emission', 'baseIOR', 'specular', 'specularPower', 'opacity', 'edgeVisibility', 'lineWidth', 'pointSize', 'backfaceCulling', 'frontfaceCulling', 'representation', 'diffuseTexture', 'metallicTexture', 'roughnessTexture', 'normalTexture', 'ambientOcclusionTexture', 'emissionTexture']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['ambientColor', 'specularColor', 'diffuseColor', 'edgeColor'], 3);

  // Object methods
  vtkProperty(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkProperty');

// ----------------------------------------------------------------------------

var vtkProperty$1 = {
  newInstance,
  extend,
  ..._Property_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay
};




/***/ }),

/***/ 71995:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ PropertyConst),
/* harmony export */   YL: () => (/* binding */ Representation)
/* harmony export */ });
/* unused harmony exports Interpolation, Shading */
const Shading = {
  FLAT: 0,
  GOURAUD: 1,
  PHONG: 2
};
const Representation = {
  POINTS: 0,
  WIREFRAME: 1,
  SURFACE: 2
};
const Interpolation = Shading;
var PropertyConst = {
  Shading,
  Representation,
  Interpolation
};




/***/ }),

/***/ 50036:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkRenderer$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var Camera = __webpack_require__(26719);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Light.js




// ----------------------------------------------------------------------------

const LIGHT_TYPES = ['HeadLight', 'CameraLight', 'SceneLight'];

// ----------------------------------------------------------------------------
// vtkLight methods
// ----------------------------------------------------------------------------

function vtkLight(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLight');
  const tmpVec = new Float64Array(3);
  publicAPI.getTransformedPosition = () => {
    if (model.transformMatrix) {
      esm/* vec3.transformMat4 */.eR.transformMat4(tmpVec, model.position, model.transformMatrix);
    } else {
      esm/* vec3.set */.eR.set(tmpVec, model.position[0], model.position[1], model.position[2]);
    }
    return tmpVec;
  };
  publicAPI.getTransformedFocalPoint = () => {
    if (model.transformMatrix) {
      esm/* vec3.transformMat4 */.eR.transformMat4(tmpVec, model.focalPoint, model.transformMatrix);
    } else {
      esm/* vec3.set */.eR.set(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
    }
    return tmpVec;
  };
  publicAPI.getDirection = () => {
    if (model.directionMTime < model.mtime) {
      esm/* vec3.sub */.eR.sub(model.direction, model.focalPoint, model.position);
      (0,Core_Math.l)(model.direction);
      model.directionMTime = model.mtime;
    }
    return model.direction;
  };

  // Sets the direction from a vec3 instead of a focal point
  publicAPI.setDirection = directionVector => {
    const newFocalPoint = new Float64Array(3);
    esm/* vec3.sub */.eR.sub(newFocalPoint, model.position, directionVector);
    model.focalPoint = newFocalPoint;
  };
  publicAPI.setDirectionAngle = (elevation, azimuth) => {
    const elevationRadians = (0,Core_Math.r)(elevation);
    const azimuthRadians = (0,Core_Math.r)(azimuth);
    publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
    publicAPI.setFocalPoint(0, 0, 0);
    publicAPI.setPositional(0);
  };
  publicAPI.setLightTypeToHeadLight = () => {
    publicAPI.setLightType('HeadLight');
  };
  publicAPI.setLightTypeToCameraLight = () => {
    publicAPI.setLightType('CameraLight');
  };
  publicAPI.setLightTypeToSceneLight = () => {
    publicAPI.setTransformMatrix(null);
    publicAPI.setLightType('SceneLight');
  };
  publicAPI.lightTypeIsHeadLight = () => model.lightType === 'HeadLight';
  publicAPI.lightTypeIsSceneLight = () => model.lightType === 'SceneLight';
  publicAPI.lightTypeIsCameraLight = () => model.lightType === 'CameraLight';
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  switch: true,
  intensity: 1,
  color: [1, 1, 1],
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  positional: false,
  exponent: 1,
  coneAngle: 30,
  coneFalloff: 5,
  attenuationValues: [1, 0, 0],
  transformMatrix: null,
  lightType: 'SceneLight',
  shadowAttenuation: 1,
  direction: [0, 0, 0],
  directionMTime: 0
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['intensity', 'switch', 'positional', 'exponent', 'coneAngle', 'coneFalloff', 'transformMatrix', 'lightType', 'shadowAttenuation', 'attenuationValues']);
  macros2.m.setGetArray(publicAPI, model, ['color', 'position', 'focalPoint', 'attenuationValues'], 3);

  // Object methods
  vtkLight(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkLight');

// ----------------------------------------------------------------------------

var vtkLight$1 = {
  newInstance,
  extend,
  LIGHT_TYPES
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js


const {
  vtkErrorMacro
} = macros2.m;
function notImplemented(method) {
  return () => vtkErrorMacro(`vtkViewport::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkViewport methods
// ----------------------------------------------------------------------------

function vtkViewport(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkViewport');

  // Public API methods
  publicAPI.getViewProps = () => model.props;
  publicAPI.hasViewProp = prop => model.props.includes(prop);
  publicAPI.addViewProp = prop => {
    if (prop && !publicAPI.hasViewProp(prop)) {
      model.props.push(prop);
    }
  };
  publicAPI.removeViewProp = prop => {
    const newPropList = model.props.filter(item => item !== prop);
    if (model.props.length !== newPropList.length) {
      model.props = newPropList;
    }
  };
  publicAPI.removeAllViewProps = () => {
    model.props = [];
  };

  // this method get all the props including any nested props
  function gatherProps(prop) {
    let allProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    allProps.push(prop);
    const children = prop.getNestedProps();
    if (children && children.length) {
      for (let i = 0; i < children.length; i++) {
        gatherProps(children[i], allProps);
      }
    }
    return allProps;
  }
  publicAPI.getViewPropsWithNestedProps = () => {
    const allPropsArray = [];
    for (let i = 0; i < model.props.length; i++) {
      gatherProps(model.props[i], allPropsArray);
    }
    return allPropsArray;
  };
  publicAPI.addActor2D = publicAPI.addViewProp;
  publicAPI.removeActor2D = prop => {
    // VTK way: model.actors2D.RemoveItem(prop);
    publicAPI.removeViewProp(prop);
  };
  publicAPI.getActors2D = () => {
    model.actors2D = [];
    model.props.forEach(prop => {
      model.actors2D = model.actors2D.concat(prop.getActors2D());
    });
    return model.actors2D;
  };
  publicAPI.displayToView = () => vtkErrorMacro('call displayToView on your view instead');
  publicAPI.viewToDisplay = () => vtkErrorMacro('callviewtodisplay on your view instead');
  publicAPI.getSize = () => vtkErrorMacro('call getSize on your View instead');
  publicAPI.normalizedDisplayToProjection = (x, y, z) => {
    // first to normalized viewport
    const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);

    // then to view
    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedDisplayToNormalizedViewport = (x, y, z) => {
    const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [(x - model.viewport[0]) / scale[0], (y - model.viewport[1]) / scale[1], z];
  };
  publicAPI.normalizedViewportToProjection = (x, y, z) => [x * 2.0 - 1.0, y * 2.0 - 1.0, z * 2.0 - 1.0];
  publicAPI.projectionToNormalizedDisplay = (x, y, z) => {
    // first to nvp
    const nvp = publicAPI.projectionToNormalizedViewport(x, y, z);

    // then to ndp
    return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedViewportToNormalizedDisplay = (x, y, z) => {
    const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [x * scale[0] + model.viewport[0], y * scale[1] + model.viewport[1], z];
  };
  publicAPI.projectionToNormalizedViewport = (x, y, z) => [(x + 1.0) * 0.5, (y + 1.0) * 0.5, (z + 1.0) * 0.5];
  publicAPI.PickPropFrom = notImplemented('PickPropFrom');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Viewport_DEFAULT_VALUES = {
  // _vtkWindow: null,
  background: [0, 0, 0],
  background2: [0.2, 0.2, 0.2],
  gradientBackground: false,
  viewport: [0, 0, 1, 1],
  aspect: [1, 1],
  pixelAspect: [1, 1],
  props: [],
  actors2D: []
};

// ----------------------------------------------------------------------------

function Viewport_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Viewport_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.event(publicAPI, model, 'event');
  macros2.m.setGetArray(publicAPI, model, ['viewport'], 4);
  macros2.m.setGetArray(publicAPI, model, ['background', 'background2'], 3);
  vtkViewport(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Viewport_newInstance = macros2.m.newInstance(Viewport_extend, 'vtkViewport');

// ----------------------------------------------------------------------------

var vtkViewport$1 = {
  newInstance: Viewport_newInstance,
  extend: Viewport_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var BoundingBox = __webpack_require__(21734);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js








const {
  vtkDebugMacro,
  vtkErrorMacro: Renderer_vtkErrorMacro,
  vtkWarningMacro
} = macros2.c;
function Renderer_notImplemented(method) {
  return () => Renderer_vtkErrorMacro(`vtkRenderer::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkRenderer methods
// ----------------------------------------------------------------------------

function vtkRenderer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderer');

  // Events
  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
    type: 'ComputeVisiblePropBoundsEvent',
    renderer: publicAPI
  };
  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {
    type: 'ResetCameraClippingRangeEvent',
    renderer: publicAPI
  };
  const RESET_CAMERA_EVENT = {
    type: 'ResetCameraEvent',
    renderer: publicAPI
  };
  publicAPI.updateCamera = () => {
    if (!model.activeCamera) {
      vtkDebugMacro('No cameras are on, creating one.');
      // the get method will automagically create a camera
      // and reset it since one hasn't been specified yet.
      publicAPI.getActiveCameraAndResetIfCreated();
    }

    // update the viewing transformation
    model.activeCamera.render(publicAPI);
    return true;
  };
  publicAPI.updateLightsGeometryToFollowCamera = () => {
    // only update the light's geometry if this Renderer is tracking
    // this lights.  That allows one renderer to view the lights that
    // another renderer is setting up.
    const camera = publicAPI.getActiveCameraAndResetIfCreated();
    model.lights.forEach(light => {
      if (light.lightTypeIsSceneLight()) ; else if (light.lightTypeIsHeadLight()) {
        // update position and orientation of light to match camera.
        light.setPositionFrom(camera.getPositionByReference());
        light.setFocalPointFrom(camera.getFocalPointByReference());
        light.modified(camera.getMTime());
      } else if (light.lightTypeIsCameraLight()) {
        light.setTransformMatrix(camera.getCameraLightTransformMatrix(esm/* mat4.create */.pB.create()));
      } else {
        Renderer_vtkErrorMacro('light has unknown light type', light.get());
      }
    });
  };
  publicAPI.updateLightGeometry = () => {
    if (model.lightFollowCamera) {
      // only update the light's geometry if this Renderer is tracking
      // this lights.  That allows one renderer to view the lights that
      // another renderer is setting up.
      return publicAPI.updateLightsGeometryToFollowCamera();
    }
    return true;
  };
  publicAPI.allocateTime = Renderer_notImplemented('allocateTime');
  publicAPI.updateGeometry = Renderer_notImplemented('updateGeometry');
  publicAPI.getVTKWindow = () => model._renderWindow;
  publicAPI.setLayer = layer => {
    vtkDebugMacro(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);
    if (model.layer !== layer) {
      model.layer = layer;
      publicAPI.modified();
    }
    publicAPI.setPreserveColorBuffer(!!layer);
  };
  publicAPI.setActiveCamera = camera => {
    if (model.activeCamera === camera) {
      return false;
    }
    model.activeCamera = camera;
    publicAPI.modified();
    publicAPI.invokeEvent({
      type: 'ActiveCameraEvent',
      camera
    });
    return true;
  };
  publicAPI.makeCamera = () => {
    const camera = Camera/* default.newInstance */.Ay.newInstance();
    publicAPI.invokeEvent({
      type: 'CreateCameraEvent',
      camera
    });
    return camera;
  };

  // Replace the set/get macro method
  publicAPI.getActiveCamera = () => {
    if (!model.activeCamera) {
      model.activeCamera = publicAPI.makeCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActiveCameraAndResetIfCreated = () => {
    if (!model.activeCamera) {
      publicAPI.getActiveCamera();
      publicAPI.resetCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActors = () => {
    model.actors = [];
    model.props.forEach(prop => {
      model.actors = model.actors.concat(prop.getActors());
    });
    return model.actors;
  };
  publicAPI.addActor = publicAPI.addViewProp;
  publicAPI.removeActor = actor => {
    model.actors = model.actors.filter(a => a !== actor);
    publicAPI.removeViewProp(actor);
    publicAPI.modified();
  };
  publicAPI.removeAllActors = () => {
    const actors = publicAPI.getActors();
    actors.forEach(actor => {
      publicAPI.removeViewProp(actor);
    });
    model.actors = [];
    publicAPI.modified();
  };
  publicAPI.getVolumes = () => {
    model.volumes = [];
    model.props.forEach(prop => {
      model.volumes = model.volumes.concat(prop.getVolumes());
    });
    return model.volumes;
  };
  publicAPI.addVolume = publicAPI.addViewProp;
  publicAPI.removeVolume = volume => {
    model.volumes = model.volumes.filter(v => v !== volume);
    publicAPI.removeViewProp(volume);
    publicAPI.modified();
  };
  publicAPI.removeAllVolumes = () => {
    const volumes = publicAPI.getVolumes();
    volumes.forEach(volume => {
      publicAPI.removeViewProp(volume);
    });
    model.volumes = [];
    publicAPI.modified();
  };
  publicAPI.hasLight = light => model.lights.includes(light);
  publicAPI.addLight = light => {
    if (light && !publicAPI.hasLight(light)) {
      model.lights.push(light);
      publicAPI.modified();
    }
  };
  publicAPI.removeLight = light => {
    model.lights = model.lights.filter(l => l !== light);
    publicAPI.modified();
  };
  publicAPI.removeAllLights = () => {
    model.lights = [];
    publicAPI.modified();
  };
  publicAPI.setLightCollection = lights => {
    model.lights = lights;
    publicAPI.modified();
  };
  publicAPI.makeLight = vtkLight$1.newInstance;
  publicAPI.createLight = () => {
    if (!model.automaticLightCreation) {
      return;
    }
    if (model._createdLight) {
      publicAPI.removeLight(model._createdLight);
      model._createdLight.delete();
      model._createdLight = null;
    }
    model._createdLight = publicAPI.makeLight();
    publicAPI.addLight(model._createdLight);
    model._createdLight.setLightTypeToHeadLight();

    // set these values just to have a good default should LightFollowCamera
    // be turned off.
    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {
    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {
    let vpd = publicAPI.worldToView(x, y, z);
    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.viewToWorld = (x, y, z) => {
    if (model.activeCamera === null) {
      Renderer_vtkErrorMacro('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');
      return [0, 0, 0];
    }

    // get the view matrix from the active camera
    const matrix = model.activeCamera.getViewMatrix();
    esm/* mat4.invert */.pB.invert(matrix, matrix);
    esm/* mat4.transpose */.pB.transpose(matrix, matrix);

    // Transform point to world coordinates
    const result = new Float64Array([x, y, z]);
    esm/* vec3.transformMat4 */.eR.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.projectionToView = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      Renderer_vtkErrorMacro('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');
      return [0, 0, 0];
    }

    // get the projection transformation from the active camera
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);
    esm/* mat4.invert */.pB.invert(matrix, matrix);
    esm/* mat4.transpose */.pB.transpose(matrix, matrix);

    // Transform point to world coordinates
    const result = new Float64Array([x, y, z]);
    esm/* vec3.transformMat4 */.eR.transformMat4(result, result, matrix);
    return result;
  };

  // Convert world point coordinates to view coordinates.
  publicAPI.worldToView = (x, y, z) => {
    if (model.activeCamera === null) {
      Renderer_vtkErrorMacro('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');
      return [0, 0, 0];
    }

    // get the view transformation from the active camera
    const matrix = model.activeCamera.getViewMatrix();
    esm/* mat4.transpose */.pB.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    esm/* vec3.transformMat4 */.eR.transformMat4(result, result, matrix);
    return result;
  };

  // Convert world point coordinates to view coordinates.
  // requires the aspect ratio of the viewport as X/Y
  publicAPI.viewToProjection = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      Renderer_vtkErrorMacro('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');
      return [0, 0, 0];
    }

    // get the projeciton transformation from the active camera
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);
    esm/* mat4.transpose */.pB.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    esm/* vec3.transformMat4 */.eR.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.computeVisiblePropBounds = () => {
    model.allBounds[0] = BoundingBox/* default */.Ay.INIT_BOUNDS[0];
    model.allBounds[1] = BoundingBox/* default */.Ay.INIT_BOUNDS[1];
    model.allBounds[2] = BoundingBox/* default */.Ay.INIT_BOUNDS[2];
    model.allBounds[3] = BoundingBox/* default */.Ay.INIT_BOUNDS[3];
    model.allBounds[4] = BoundingBox/* default */.Ay.INIT_BOUNDS[4];
    model.allBounds[5] = BoundingBox/* default */.Ay.INIT_BOUNDS[5];
    let nothingVisible = true;
    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);

    // loop through all props
    for (let index = 0; index < model.props.length; ++index) {
      const prop = model.props[index];
      if (prop.getVisibility() && prop.getUseBounds()) {
        const bounds = prop.getBounds();
        if (bounds && (0,Core_Math.S)(bounds)) {
          nothingVisible = false;
          if (bounds[0] < model.allBounds[0]) {
            model.allBounds[0] = bounds[0];
          }
          if (bounds[1] > model.allBounds[1]) {
            model.allBounds[1] = bounds[1];
          }
          if (bounds[2] < model.allBounds[2]) {
            model.allBounds[2] = bounds[2];
          }
          if (bounds[3] > model.allBounds[3]) {
            model.allBounds[3] = bounds[3];
          }
          if (bounds[4] < model.allBounds[4]) {
            model.allBounds[4] = bounds[4];
          }
          if (bounds[5] > model.allBounds[5]) {
            model.allBounds[5] = bounds[5];
          }
        }
      }
    }
    if (nothingVisible) {
      (0,Core_Math.u)(model.allBounds);
      vtkDebugMacro("Can't compute bounds, no 3D props are visible");
    }
    return model.allBounds;
  };
  publicAPI.resetCamera = function () {
    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    const center = [0, 0, 0];
    if (!(0,Core_Math.S)(boundsToUse)) {
      vtkDebugMacro('Cannot reset camera!');
      return false;
    }
    let vn = null;
    if (publicAPI.getActiveCamera()) {
      vn = model.activeCamera.getViewPlaneNormal();
    } else {
      Renderer_vtkErrorMacro('Trying to reset non-existent camera');
      return false;
    }

    // Reset the perspective zoom factors, otherwise subsequent zooms will cause
    // the view angle to become very small and cause bad depth sorting.
    model.activeCamera.setViewAngle(30.0);
    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;
    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;
    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;
    let w1 = boundsToUse[1] - boundsToUse[0];
    let w2 = boundsToUse[3] - boundsToUse[2];
    let w3 = boundsToUse[5] - boundsToUse[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    let radius = w1 + w2 + w3;

    // If we have just a single point, pick a radius of 1.0
    radius = radius === 0 ? 1.0 : radius;

    // compute the radius of the enclosing sphere
    radius = Math.sqrt(radius) * 0.5;

    // default so that the bounding sphere fits within the view fustrum

    // compute the distance from the intersection of the view frustum with the
    // bounding sphere. Basically in 2D draw a circle representing the bounding
    // sphere in 2D then draw a horizontal line going out from the center of
    // the circle. That is the camera view. Then draw a line from the camera
    // position to the point where it intersects the circle. (it will be tangent
    // to the circle at this point, this is important, only go to the tangent
    // point, do not draw all the way to the view plane). Then draw the radius
    // from the tangent point to the center of the circle. You will note that
    // this forms a right triangle with one side being the radius, another being
    // the target distance for the camera, then just find the target dist using
    // a sin.
    const angle = (0,Core_Math.r)(model.activeCamera.getViewAngle());
    const parallelScale = radius;
    const distance = radius / Math.sin(angle * 0.5);

    // check view-up vector against view plane normal
    const vup = model.activeCamera.getViewUp();
    if (Math.abs((0,Core_Math.d)(vup, vn)) > 0.999) {
      vtkWarningMacro('Resetting view-up since view plane normal is parallel');
      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
    }

    // update the camera
    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);
    publicAPI.resetCameraClippingRange(boundsToUse);

    // setup default parallel scale
    model.activeCamera.setParallelScale(parallelScale);

    // update reasonable world to physical values
    model.activeCamera.setPhysicalScale(radius);
    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);

    // Here to let parallel/distributed compositing intercept
    // and do the right thing.
    publicAPI.invokeEvent(RESET_CAMERA_EVENT);
    return true;
  };
  publicAPI.resetCameraClippingRange = function () {
    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    if (!(0,Core_Math.S)(boundsToUse)) {
      vtkDebugMacro('Cannot reset camera clipping range!');
      return false;
    }

    // Make sure we have an active camera
    publicAPI.getActiveCameraAndResetIfCreated();
    if (!model.activeCamera) {
      Renderer_vtkErrorMacro('Trying to reset clipping range of non-existent camera');
      return false;
    }

    // Get the exact range for the bounds
    const range = model.activeCamera.computeClippingRange(boundsToUse);

    // do not let far - near be less than 0.1 of the window height
    // this is for cases such as 2D images which may have zero range
    let minGap = 0.0;
    if (model.activeCamera.getParallelProjection()) {
      minGap = 0.2 * model.activeCamera.getParallelScale();
    } else {
      const angle = (0,Core_Math.r)(model.activeCamera.getViewAngle());
      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];
    }
    if (range[1] - range[0] < minGap) {
      minGap = minGap - range[1] + range[0];
      range[1] += minGap / 2.0;
      range[0] -= minGap / 2.0;
    }

    // Do not let the range behind the camera throw off the calculation.
    if (range[0] < 0.0) {
      range[0] = 0.0;
    }

    // Give ourselves a little breathing room
    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;

    // Make sure near is not bigger than far
    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];

    // Make sure near is at least some fraction of far - this prevents near
    // from being behind the camera or too close in front. How close is too
    // close depends on the resolution of the depth buffer
    if (!model.nearClippingPlaneTolerance) {
      model.nearClippingPlaneTolerance = 0.01;
    }

    // make sure the front clipping range is not too far from the far clippnig
    // range, this is to make sure that the zbuffer resolution is effectively
    // used
    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
      range[0] = model.nearClippingPlaneTolerance * range[1];
    }
    model.activeCamera.setClippingRange(range[0], range[1]);

    // Here to let parallel/distributed compositing intercept
    // and do the right thing.
    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
    return false;
  };
  publicAPI.setRenderWindow = renderWindow => {
    if (renderWindow !== model._renderWindow) {
      model._vtkWindow = renderWindow;
      model._renderWindow = renderWindow;
    }
  };
  publicAPI.visibleActorCount = () => model.props.filter(prop => prop.getVisibility()).length;
  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
    if (m2 > m1) {
      m1 = m2;
    }
    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;
    if (m3 > m1) {
      m1 = m3;
    }
    return m1;
  };
  publicAPI.getTransparent = () => !!model.preserveColorBuffer;
  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Renderer_DEFAULT_VALUES = {
  pickedProp: null,
  activeCamera: null,
  allBounds: [],
  ambient: [1, 1, 1],
  allocatedRenderTime: 100,
  timeFactor: 1,
  automaticLightCreation: true,
  twoSidedLighting: true,
  lastRenderTimeInSeconds: -1,
  renderWindow: null,
  lights: [],
  actors: [],
  volumes: [],
  lightFollowCamera: true,
  numberOfPropsRendered: 0,
  propArray: null,
  pathArray: null,
  layer: 0,
  preserveColorBuffer: false,
  preserveDepthBuffer: false,
  computeVisiblePropBounds: (0,Core_Math.F)(),
  interactive: true,
  nearClippingPlaneTolerance: 0,
  clippingRangeExpansion: 0.05,
  erase: true,
  draw: true,
  useShadows: false,
  useDepthPeeling: false,
  occlusionRatio: 0,
  maximumNumberOfPeels: 4,
  selector: null,
  delegate: null,
  texturedBackground: false,
  backgroundTexture: null,
  environmentTexture: null,
  environmentTextureDiffuseStrength: 1,
  environmentTextureSpecularStrength: 1,
  useEnvironmentTextureAsBackground: false,
  pass: 0
};

// ----------------------------------------------------------------------------

function Renderer_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Renderer_DEFAULT_VALUES, initialValues);

  // Inheritance
  vtkViewport$1.extend(publicAPI, model, initialValues);

  // make sure background has 4 entries. Default to opaque black
  if (!model.background) model.background = [0, 0, 0, 1];
  while (model.background.length < 3) model.background.push(0);
  if (model.background.length === 3) model.background.push(1);

  // Build VTK API
  (0,macros2.g)(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);
  (0,macros2.e)(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);
  (0,macros2.k)(publicAPI, model, ['actors', 'volumes', 'lights']);
  (0,macros2.l)(publicAPI, model, ['background'], 4, 1.0);
  (0,macros2.i)(publicAPI, model, ['renderWindow']);

  // Object methods
  vtkRenderer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Renderer_newInstance = (0,macros2.n)(Renderer_extend, 'vtkRenderer');

// ----------------------------------------------------------------------------

var vtkRenderer$1 = {
  newInstance: Renderer_newInstance,
  extend: Renderer_extend
};




/***/ }),

/***/ 61433:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkTexture$1)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkTexture methods
// ----------------------------------------------------------------------------

function vtkTexture(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkTexture');
  publicAPI.imageLoaded = () => {
    model.image.removeEventListener('load', publicAPI.imageLoaded);
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setJsImageData = imageData => {
    if (model.jsImageData === imageData) {
      return;
    }

    // clear other entries
    if (imageData !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.canvas = null;
    }
    model.jsImageData = imageData;
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setCanvas = canvas => {
    if (model.canvas === canvas) {
      return;
    }

    // clear other entries
    if (canvas !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.jsImageData = null;
    }
    model.canvas = canvas;
    publicAPI.modified();
  };
  publicAPI.setImage = image => {
    if (model.image === image) {
      return;
    }

    // clear other entries
    if (image !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.canvas = null;
      model.jsImageData = null;
    }
    model.image = image;
    model.imageLoaded = false;
    if (image.complete) {
      publicAPI.imageLoaded();
    } else {
      image.addEventListener('load', publicAPI.imageLoaded);
    }
    publicAPI.modified();
  };
  publicAPI.getDimensionality = () => {
    let width = 0;
    let height = 0;
    let depth = 1;
    if (publicAPI.getInputData()) {
      const data = publicAPI.getInputData();
      width = data.getDimensions()[0];
      height = data.getDimensions()[1];
      depth = data.getDimensions()[2];
    }
    if (model.jsImageData) {
      width = model.jsImageData.width;
      height = model.jsImageData.height;
    }
    if (model.canvas) {
      width = model.canvas.width;
      height = model.canvas.height;
    }
    if (model.image) {
      width = model.image.width;
      height = model.image.height;
    }
    const dimensionality = (width > 1) + (height > 1) + (depth > 1);
    return dimensionality;
  };
  publicAPI.getInputAsJsImageData = () => {
    if (!model.imageLoaded || publicAPI.getInputData()) return null;
    if (model.jsImageData) {
      return model.jsImageData();
    }
    if (model.canvas) {
      const context = model.canvas.getContext('2d');
      const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);
      return imageData;
    }
    if (model.image) {
      const canvas = document.createElement('canvas');
      canvas.width = model.image.width;
      canvas.height = model.image.height;
      const context = canvas.getContext('2d');
      context.translate(0, canvas.height);
      context.scale(1, -1);
      context.drawImage(model.image, 0, 0, model.image.width, model.image.height);
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      return imageData;
    }
    return null;
  };
}

// Use nativeArray instead of self
const generateMipmaps = (nativeArray, width, height, level) => {
  // TODO: FIX UNEVEN TEXTURE MIP GENERATION:
  // When textures don't have standard ratios, higher mip levels
  // result in their color chanels getting messed up and shifting
  // 3x3 gaussian kernel
  const g3m = [1, 2, 1]; // eslint-disable-line
  const g3w = 4; // eslint-disable-line

  const kernel = g3m;
  const kernelWeight = g3w;
  const hs = nativeArray.length / (width * height); // TODO: support for textures with depth more than 1
  let currentWidth = width;
  let currentHeight = height;
  let imageData = nativeArray;
  const maps = [imageData];
  for (let i = 0; i < level; i++) {
    const oldData = [...imageData];
    currentWidth /= 2;
    currentHeight /= 2;
    imageData = new Uint8ClampedArray(currentWidth * currentHeight * hs);
    const vs = hs * currentWidth;

    // Scale down
    let shift = 0;
    for (let p = 0; p < imageData.length; p += hs) {
      if (p % vs === 0) {
        shift += 2 * hs * currentWidth;
      }
      for (let c = 0; c < hs; c++) {
        let sample = oldData[shift + c];
        sample += oldData[shift + hs + c];
        sample += oldData[shift - 2 * vs + c];
        sample += oldData[shift - 2 * vs + hs + c];
        sample /= 4;
        imageData[p + c] = sample;
      }
      shift += 2 * hs;
    }

    // Horizontal Pass
    let dataCopy = [...imageData];
    for (let p = 0; p < imageData.length; p += hs) {
      for (let c = 0; c < hs; c++) {
        let x = -(kernel.length - 1) / 2;
        let kw = kernelWeight;
        let value = 0.0;
        for (let k = 0; k < kernel.length; k++) {
          let index = p + c + x * hs;
          const lineShift = index % vs - (p + c) % vs;
          if (lineShift > hs) index += vs;
          if (lineShift < -hs) index -= vs;
          if (dataCopy[index]) {
            value += dataCopy[index] * kernel[k];
          } else {
            kw -= kernel[k];
          }
          x += 1;
        }
        imageData[p + c] = value / kw;
      }
    }
    // Vertical Pass
    dataCopy = [...imageData];
    for (let p = 0; p < imageData.length; p += hs) {
      for (let c = 0; c < hs; c++) {
        let x = -(kernel.length - 1) / 2;
        let kw = kernelWeight;
        let value = 0.0;
        for (let k = 0; k < kernel.length; k++) {
          const index = p + c + x * vs;
          if (dataCopy[index]) {
            value += dataCopy[index] * kernel[k];
          } else {
            kw -= kernel[k];
          }
          x += 1;
        }
        imageData[p + c] = value / kw;
      }
    }
    maps.push(imageData);
  }
  return maps;
};

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  image: null,
  canvas: null,
  jsImageData: null,
  imageLoaded: false,
  repeat: false,
  interpolate: false,
  edgeClamp: false,
  mipLevel: 0,
  resizable: false // must be set at construction time if the texture can be resizable
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 6, 0);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['canvas', 'image', 'jsImageData', 'imageLoaded', 'resizable']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['repeat', 'edgeClamp', 'interpolate', 'mipLevel']);
  vtkTexture(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkTexture');
const STATIC = {
  generateMipmaps
};

// ----------------------------------------------------------------------------

var vtkTexture$1 = {
  newInstance,
  extend,
  ...STATIC
};




/***/ }),

/***/ 67737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants),
/* harmony export */   Nx: () => (/* binding */ BlendMode)
/* harmony export */ });
/* unused harmony export FilterMode */
const BlendMode = {
  COMPOSITE_BLEND: 0,
  MAXIMUM_INTENSITY_BLEND: 1,
  MINIMUM_INTENSITY_BLEND: 2,
  AVERAGE_INTENSITY_BLEND: 3,
  ADDITIVE_INTENSITY_BLEND: 4,
  RADON_TRANSFORM_BLEND: 5,
  LABELMAP_EDGE_PROJECTION_BLEND: 6
};
const FilterMode = {
  OFF: 0,
  NORMALIZED: 1,
  RAW: 2
};
var Constants = {
  BlendMode,
  FilterMode
};




/***/ }),

/***/ 20433:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants),
/* harmony export */   VO: () => (/* binding */ InterpolationType),
/* harmony export */   dM: () => (/* binding */ ColorMixPreset),
/* harmony export */   tE: () => (/* binding */ OpacityMode)
/* harmony export */ });
const InterpolationType = {
  NEAREST: 0,
  LINEAR: 1,
  FAST_LINEAR: 2
};
const OpacityMode = {
  FRACTIONAL: 0,
  PROPORTIONAL: 1
};
const ColorMixPreset = {
  CUSTOM: 0,
  ADDITIVE: 1,
  COLORIZE: 2
};
var Constants = {
  InterpolationType,
  OpacityMode,
  ColorMixPreset
};




/***/ }),

/***/ 80639:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkActor)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88691);





// ----------------------------------------------------------------------------
// vtkOpenGLActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();

      // we store textures and mapper
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0; index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA('vtkOpenGLTexture')) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };

  // render both opaque and translucent actors
  publicAPI.traverseZBufferPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  // only render opaque actors
  publicAPI.traverseOpaqueZBufferPass = renderPass => publicAPI.traverseOpaquePass(renderPass);

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    // always traverse textures first, then mapper
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index = 0; index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(model._openGLRenderer.getSelector() && model.renderable.getNestedPickable());
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      if (model.renderable.getIsIdentity()) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(model.keyMatrices.normalMatrix);
      } else {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromMat4 */ .w0.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.invert */ .w0.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.transpose */ .w0.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null,
  activeTextures: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(new Float64Array(9)),
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16))
  };

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.g)(publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend);

// ----------------------------------------------------------------------------

var vtkActor = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkActor', newInstance);




/***/ }),

/***/ 58601:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkActor2D)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88691);




// ----------------------------------------------------------------------------
// vtkOpenGLActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLActor2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLActor2D');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();

      // we store textures and mapper
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0; index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA('vtkOpenGLTexture')) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOverlayActorCount();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOverlayPass = renderPass => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    // always traverse textures first, then mapper
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index = 0; index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };

  // Renders myself
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      // deactivate textures
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(false);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };

  // Renders myself
  publicAPI.overlayPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      // deactivate textures
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  activeTextures: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.extend(publicAPI, model, initialValues);

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.e)(publicAPI, model, ['context']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.g)(publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLActor2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend);

// ----------------------------------------------------------------------------

var vtkActor2D = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__/* .registerOverride */ .c9)('vtkActor2D', newInstance);




/***/ }),

/***/ 21081:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkBufferObject)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60003);



const {
  ObjectType
} = _BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {};

// ----------------------------------------------------------------------------
// vtkOpenGLBufferObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLBufferObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLBufferObject');

  // Class-specific private functions
  function convertType(type) {
    switch (type) {
      case ObjectType.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType.TEXTURE_BUFFER:
        if ('TEXTURE_BUFFER' in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      /* eslint-disable no-fallthrough */
      // Intentional fallthrough in case there is no TEXTURE_BUFFER in WebGL
      case ObjectType.ARRAY_BUFFER:
      default:
        return model.context.ARRAY_BUFFER;
      /* eslint-enable no-fallthrough */
    }
  }

  let internalType = null;
  let internalHandle = null;
  let dirty = true;
  let error = '';

  // Public API methods
  publicAPI.getType = () => internalType;
  publicAPI.setType = value => {
    internalType = value;
  };
  publicAPI.getHandle = () => internalHandle;
  publicAPI.isReady = () => dirty === false;
  publicAPI.generateBuffer = type => {
    const objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };
  publicAPI.upload = (data, type) => {
    // buffer, size, type
    const alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = 'Trying to upload array buffer to incompatible buffer.';
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
    model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;
    dirty = false;
    return true;
  };
  publicAPI.bind = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };
  publicAPI.release = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };
  publicAPI.releaseGraphicsResources = () => {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
      model.allocatedGPUMemoryInBytes = 0;
    }
  };
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getError = () => error;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  objectType: ObjectType.ARRAY_BUFFER,
  // _openGLRenderWindow: null,
  context: null,
  allocatedGPUMemoryInBytes: 0
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['_openGLRenderWindow', 'allocatedGPUMemoryInBytes']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.moveToProtected(publicAPI, model, ['openGLRenderWindow']);
  vtkOpenGLBufferObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkBufferObject = {
  newInstance,
  extend,
  ...STATIC,
  ..._BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A
};




/***/ }),

/***/ 60003:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Constants),
/* harmony export */   a: () => (/* binding */ ObjectType)
/* harmony export */ });
const ObjectType = {
  ARRAY_BUFFER: 0,
  ELEMENT_ARRAY_BUFFER: 1,
  TEXTURE_BUFFER: 2
};
var Constants = {
  ObjectType
};




/***/ }),

/***/ 38475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCamera)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88691);





// ----------------------------------------------------------------------------
// vtkOpenGLCamera methods
// ----------------------------------------------------------------------------

function vtkOpenGLCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLCamera');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
    }
  };

  // Renders myself
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.zBufferPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;
  publicAPI.getKeyMatrices = ren => {
    // has the camera changed?
    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromMat4 */ .w0.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.invert */ .w0.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
      const aspectRatio = model._openGLRenderer.getAspectRatio();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  lastRenderer: null,
  keyMatrixTime: null,
  keyMatrices: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime);

  // values always get set by the get method
  model.keyMatrices = {
    normalMatrix: new Float64Array(9),
    vcpc: new Float64Array(16),
    wcvc: new Float64Array(16),
    wcpc: new Float64Array(16)
  };

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context', 'keyMatrixTime']);

  // Object methods
  vtkOpenGLCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend);

// ----------------------------------------------------------------------------

var vtkCamera = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkCamera', newInstance);




/***/ }),

/***/ 32821:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkOpenGLFramebuffer)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1013);
/* harmony import */ var _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28914);
/* harmony import */ var _Texture_Constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52271);





// ----------------------------------------------------------------------------
// vtkFramebuffer methods
// ----------------------------------------------------------------------------
function vtkFramebuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkFramebuffer');
  publicAPI.getBothMode = () => model.context.FRAMEBUFFER;
  // publicAPI.getDrawMode = () => model.context.DRAW_FRAMEBUFFER;
  // publicAPI.getReadMode = () => model.context.READ_FRAMEBUFFER;

  publicAPI.saveCurrentBindingsAndBuffers = modeIn => {
    const mode = typeof modeIn !== 'undefined' ? modeIn : publicAPI.getBothMode();
    publicAPI.saveCurrentBindings(mode);
    publicAPI.saveCurrentBuffers(mode);
  };
  publicAPI.saveCurrentBindings = modeIn => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling saveCurrentBindings');
      return;
    }
    const gl = model.context;
    model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
    model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
  };
  publicAPI.saveCurrentBuffers = modeIn => {
    // noop on webgl 1
  };
  publicAPI.restorePreviousBindingsAndBuffers = modeIn => {
    const mode = typeof modeIn !== 'undefined' ? modeIn : publicAPI.getBothMode();
    publicAPI.restorePreviousBindings(mode);
    publicAPI.restorePreviousBuffers(mode);
  };
  publicAPI.restorePreviousBindings = modeIn => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling restorePreviousBindings');
      return;
    }
    const gl = model.context;
    gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
    model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
  };
  publicAPI.restorePreviousBuffers = modeIn => {
    // currently a noop on webgl1
  };
  publicAPI.bind = function () {
    let modeArg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let mode = modeArg;
    if (mode === null) {
      mode = model.context.FRAMEBUFFER;
    }
    model.context.bindFramebuffer(mode, model.glFramebuffer);
    for (let i = 0; i < model.colorBuffers.length; i++) {
      model.colorBuffers[i].bind();
    }
    model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
  };
  publicAPI.create = (width, height) => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling create');
      return;
    }
    model.glFramebuffer = model.context.createFramebuffer();
    model.glFramebuffer.width = width;
    model.glFramebuffer.height = height;
  };
  publicAPI.setColorBuffer = function (texture) {
    let attachment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const gl = model.context;
    if (!gl) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling setColorBuffer');
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('Using multiple framebuffer attachments requires WebGL 2');
        return;
      }
    }
    model.colorBuffers[attachment] = texture;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
  };
  publicAPI.removeColorBuffer = function () {
    let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const gl = model.context;
    if (!gl) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling removeColorBuffer');
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('Using multiple framebuffer attachments requires WebGL 2');
        return;
      }
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
    model.colorBuffers = model.colorBuffers.splice(attachment, 1);
  };
  publicAPI.setDepthBuffer = texture => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling setDepthBuffer');
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
    } else {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('Attaching depth buffer textures to fbo requires WebGL 2');
    }
  };
  publicAPI.removeDepthBuffer = () => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling removeDepthBuffer');
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
    } else {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('Attaching depth buffer textures to framebuffers requires WebGL 2');
    }
  };
  publicAPI.getGLFramebuffer = () => model.glFramebuffer;
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.glFramebuffer) {
      model.context.deleteFramebuffer(model.glFramebuffer);
    }
  };
  publicAPI.getSize = () => {
    if (model.glFramebuffer == null) return null;
    return [model.glFramebuffer.width, model.glFramebuffer.height];
  };
  publicAPI.populateFramebuffer = () => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling populateFrameBuffer');
      return;
    }
    publicAPI.bind();
    const gl = model.context;
    const texture = _Texture_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance();
    texture.setOpenGLRenderWindow(model._openGLRenderWindow);
    texture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* .Filter */ .dJ.LINEAR);
    texture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* .Filter */ .dJ.LINEAR);
    texture.create2DFromRaw(model.glFramebuffer.width, model.glFramebuffer.height, 4, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, null);
    publicAPI.setColorBuffer(texture);

    // for now do not count on having a depth buffer texture
    // as they are not standard webgl 1
    model.depthTexture = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
  };

  // For backwards compatibility. Use getColorBuffers()[0] going forward.
  publicAPI.getColorTexture = () => model.colorBuffers[0];
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const DEFAULT_VALUES = {
  // _openGLRenderWindow: null,
  glFramebuffer: null,
  colorBuffers: null,
  depthTexture: null,
  previousDrawBinding: 0,
  previousReadBinding: 0,
  previousDrawBuffer: 0,
  previousReadBuffer: 0,
  previousActiveFramebuffer: null
};

// ----------------------------------------------------------------------------
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.o)(publicAPI, model);
  if (model.colorBuffers) {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.');
  }
  model.colorBuffers = [];
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.k)(publicAPI, model, ['colorBuffers']);

  // For more macro methods, see "Sources/macros.js"
  // Object specific methods
  vtkFramebuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------
const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend, 'vtkFramebuffer');

// ----------------------------------------------------------------------------
var vtkOpenGLFramebuffer = {
  newInstance,
  extend
};




/***/ }),

/***/ 57703:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Constants),
/* harmony export */   T: () => (/* binding */ PassTypes)
/* harmony export */ });
const PassTypes = {
  MIN_KNOWN_PASS: 0,
  ACTOR_PASS: 0,
  COMPOSITE_INDEX_PASS: 1,
  ID_LOW24: 2,
  ID_HIGH24: 3,
  MAX_KNOWN_PASS: 3
};
var Constants = {
  PassTypes
};




/***/ }),

/***/ 71650:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkHelper)
});

// UNUSED EXPORTS: extend, newInstance, primTypes

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
var BufferObject = __webpack_require__(21081);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var Constants = __webpack_require__(60003);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js






const {
  vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// Static functions
// ----------------------------------------------------------------------------

function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  const inverseScale = new Float64Array(3);
  esm/* vec3.inverse */.eR.inverse(inverseScale, coordScale);
  const matrix = new Float64Array(16);
  esm/* mat4.fromRotationTranslationScale */.pB.fromRotationTranslationScale(matrix, esm/* quat.create */.Yu.create(), coordShift, inverseScale);
  return matrix;
}
function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }
  return !(esm/* vec3.exactEquals */.eR.exactEquals(coordShift, [0, 0, 0]) && esm/* vec3.exactEquals */.eR.exactEquals(coordScale, [1, 1, 1]));
}

// ----------------------------------------------------------------------------
// vtkOpenGLCellArrayBufferObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');
  publicAPI.setType(Constants/* ObjectType */.a.ARRAY_BUFFER);
  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {
    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }

    // Figure out how big each block will be, currently 6 or 7 floats.
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];
    const pointData = options.points.getData();
    let normalData = null;
    let tcoordData = null;
    let colorData = null;
    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;

    // the values of 4 below are because floats are 4 bytes

    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }
    if (options.customAttributes) {
      options.customAttributes.forEach(a => {
        if (a) {
          model.customData.push({
            data: a.getData(),
            offset: 4 * model.blockSize,
            components: a.getNumberOfComponents(),
            name: a.getName()
          });
          model.blockSize += a.getNumberOfComponents();
        }
      });
    }
    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }
    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = BufferObject/* default.newInstance */.Ay.newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;
    let pointIdx = 0;
    let normalIdx = 0;
    let tcoordIdx = 0;
    let colorIdx = 0;
    let custIdx = 0;
    let cellCount = 0;
    let addAPoint;
    const cellBuilders = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts, offset, cellId) {
        for (let i = 0; i < numPoints; ++i) {
          addAPoint(cellPts[offset + i], cellId);
        }
      },
      linesToWireframe(numPoints, cellPts, offset, cellIdx) {
        // for lines we add a bunch of segments
        for (let i = 0; i < numPoints - 1; ++i) {
          addAPoint(cellPts[offset + i], cellIdx);
          addAPoint(cellPts[offset + i + 1], cellIdx);
        }
      },
      polysToWireframe(numPoints, cellPts, offset, cellIdx) {
        // for polys we add a bunch of segments and close it
        if (numPoints > 2) {
          for (let i = 0; i < numPoints; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);
          }
        }
      },
      stripsToWireframe(numPoints, cellPts, offset, cellIdx) {
        if (numPoints > 2) {
          // for strips we add a bunch of segments and close it
          for (let i = 0; i < numPoints - 1; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 1], cellIdx);
          }
          for (let i = 0; i < numPoints - 2; i++) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 2], cellIdx);
          }
        }
      },
      polysToSurface(npts, cellPts, offset, cellIdx) {
        for (let i = 0; i < npts - 2; i++) {
          addAPoint(cellPts[offset + 0], cellIdx);
          addAPoint(cellPts[offset + i + 1], cellIdx);
          addAPoint(cellPts[offset + i + 2], cellIdx);
        }
      },
      stripsToSurface(npts, cellPts, offset, cellIdx) {
        for (let i = 0; i < npts - 2; i++) {
          addAPoint(cellPts[offset + i], cellIdx);
          addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);
          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);
        }
      }
    };
    const cellCounters = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts) {
        return numPoints;
      },
      linesToWireframe(numPoints, cellPts) {
        if (numPoints > 1) {
          return (numPoints - 1) * 2;
        }
        return 0;
      },
      polysToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 2;
        }
        return 0;
      },
      stripsToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 4 - 6;
        }
        return 0;
      },
      polysToSurface(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface(npts, cellPts, offset) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    let func = null;
    let countFunc = null;
    if (outRep === Property_Constants/* Representation */.YL.POINTS || inRep === 'verts') {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters.anythingToPoints;
    } else if (outRep === Property_Constants/* Representation */.YL.WIREFRAME || inRep === 'lines') {
      func = cellBuilders[`${inRep}ToWireframe`];
      countFunc = cellCounters[`${inRep}ToWireframe`];
    } else {
      func = cellBuilders[`${inRep}ToSurface`];
      countFunc = cellCounters[`${inRep}ToSurface`];
    }
    const array = cellArray.getData();
    const size = array.length;
    let caboCount = 0;
    for (let index = 0; index < size;) {
      caboCount += countFunc(array[index], array);
      index += array[index] + 1;
    }
    let packedUCVBO = null;
    const packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    let vboidx = 0;
    let ucidx = 0;

    // Find out if shift scale should be used
    // Compute squares of diagonal size and distance from the origin
    let diagSq = 0.0;
    let distSq = 0.0;
    for (let i = 0; i < 3; ++i) {
      const range = options.points.getRange(i);
      const delta = range[1] - range[0];
      diagSq += delta * delta;
      const distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }
    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||
    // If data is far from the origin relative to its size
    Math.abs(Math.log10(diagSq)) > 3.0 ||
    // If the size is huge when not far from the origin
    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin

    if (useShiftAndScale) {
      // Compute shift and scale vectors
      const coordShift = new Float64Array(3);
      const coordScale = new Float64Array(3);
      for (let i = 0; i < 3; ++i) {
        const range = options.points.getRange(i);
        const delta = range[1] - range[0];
        coordShift[i] = 0.5 * (range[1] + range[0]);
        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;
      }
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      // Make sure to reset
      publicAPI.setCoordShiftAndScale(null, null);
    }

    // Initialize the structures used to keep track of point ids and cell ids for selectors
    if (selectionMaps) {
      if (!selectionMaps.points && !selectionMaps.cells) {
        selectionMaps.points = new Int32Array(caboCount);
        selectionMaps.cells = new Int32Array(caboCount);
      } else {
        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);
        newPoints.set(selectionMaps.points);
        selectionMaps.points = newPoints;
        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);
        newCells.set(selectionMaps.cells);
        selectionMaps.cells = newCells;
      }
    }
    let pointCount = options.vertexOffset;
    addAPoint = function addAPointFunc(pointId, cellId) {
      // Keep track of original point and cell ids, for selection
      if (selectionMaps) {
        selectionMaps.points[pointCount] = pointId;
        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;
      }
      ++pointCount;

      // Vertices
      pointIdx = pointId * 3;
      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        // Apply shift and scale
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }
      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = pointId * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }
      model.customData.forEach(attr => {
        custIdx = pointId * attr.components;
        for (let j = 0; j < attr.components; ++j) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });
      if (tcoordData !== null) {
        if (options.useTCoordsPerCell) {
          tcoordIdx = cellId * textureComponents;
        } else {
          tcoordIdx = pointId * textureComponents;
        }
        for (let j = 0; j < textureComponents; ++j) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }
      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = pointId * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };

    // Browse the cell array: the index is at the beginning of a cell
    // The value of 'array' at the position 'index' is the number of points in the cell
    for (let index = 0; index < size; index += array[index] + 1, cellCount++) {
      func(array[index], array, index + 1, cellCount + options.cellOffset);
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, Constants/* ObjectType */.a.ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, Constants/* ObjectType */.a.ARRAY_BUFFER);
    }
    return cellCount;
  };
  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {
    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');
      return;
    }
    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');
      return;
    }
    if (model.coordShift === null || coordShift === null || !esm/* vec3.equals */.eR.equals(coordShift, model.coordShift)) {
      model.coordShift = coordShift;
    }
    if (model.coordScale === null || coordScale === null || !esm/* vec3.equals */.eR.equals(coordScale, model.coordScale)) {
      model.coordScale = coordScale;
    }
    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  elementCount: 0,
  stride: 0,
  colorBOStride: 0,
  vertexOffset: 0,
  normalOffset: 0,
  tCoordOffset: 0,
  tCoordComponents: 0,
  colorOffset: 0,
  colorComponents: 0,
  tcoordBO: null,
  customData: [],
  coordShift: null,
  coordScale: null,
  coordShiftAndScaleEnabled: false,
  inverseShiftAndScaleMatrix: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  BufferObject/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);
  macros2.m.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);

  // Object specific methods
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkCellArrayBufferObject = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
var VertexArrayObject = __webpack_require__(13926);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js






const primTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Tris: 2,
  TriStrips: 3,
  TrisEdges: 4,
  TriStripsEdges: 5,
  End: 6
};

// ----------------------------------------------------------------------------
// vtkOpenGLHelper methods
// ----------------------------------------------------------------------------

function vtkOpenGLHelper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLHelper');
  publicAPI.setOpenGLRenderWindow = win => {
    model.context = win.getContext();
    model.program.setContext(model.context);
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };
  publicAPI.releaseGraphicsResources = oglwin => {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {
    // Are there any entries
    if (model.CABO.getElementCount()) {
      // are we drawing edges
      const mode = publicAPI.getOpenGLMode(rep);
      const wideLines = publicAPI.haveWideLines(ren, actor);
      const gl = model.context;
      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
      if (model.pointPicking) {
        gl.depthMask(false);
      }
      const drawingLines = mode === gl.LINES;
      if (drawingLines && wideLines) {
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
      } else {
        gl.lineWidth(actor.getProperty().getLineWidth());
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArrays(mode, 0, model.CABO.getElementCount());
        // reset the line width
        gl.lineWidth(1);
      }
      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
      if (model.pointPicking) {
        gl.depthMask(depthMask);
      }
      return model.CABO.getElementCount() / stride;
    }
    return 0;
  };
  publicAPI.getOpenGLMode = rep => {
    if (model.pointPicking) {
      return model.context.POINTS;
    }
    const type = model.primitiveType;
    if (rep === Property_Constants/* Representation */.YL.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (rep === Property_Constants/* Representation */.YL.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };
  publicAPI.haveWideLines = (ren, actor) => {
    if (actor.getProperty().getLineWidth() > 1.0) {
      // we have wide lines, but the OpenGL implementation may
      // actually support them, check the range to see if we
      // really need have to implement our own wide lines
      if (model.CABO.getOpenGLRenderWindow()) {
        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // mapper modified (lighting complexity)
    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (ren, actor, oglMapper) => {
    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      oglMapper.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== publicAPI.getProgram()) {
        publicAPI.setProgram(newShader);
        // reset the VAO as the shader has changed
        publicAPI.getVAO().releaseGraphicsResources();
      }
      publicAPI.getShaderSourceTime().modified();
    } else {
      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
    }
    publicAPI.getVAO().bind();
    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (ren, actor, size) => {
    if (publicAPI.haveWideLines(ren, actor)) {
      publicAPI.getProgram().setUniform2f('viewportSize', size.usize, size.vsize);
      const lineWidth = parseFloat(actor.getProperty().getLineWidth());
      const halfLineWidth = lineWidth / 2.0;
      publicAPI.getProgram().setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));
      publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);
    }
    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Property_Constants/* Representation */.YL.POINTS) {
      publicAPI.getProgram().setUniformf('pointSize', actor.getProperty().getPointSize());
    } else if (model.pointPicking) {
      publicAPI.getProgram().setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;

    // Always set point size in case we need picking
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform float pointSize;']).result;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'], false).result;

    // for lines, make sure we add the width code
    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform vec2 viewportSize;', 'uniform float lineWidthStepSize;', 'uniform float halfLineWidth;']).result;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', ' if (halfLineWidth > 0.0)', '   {', '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;', '   vec4 tmpPos = gl_Position;', '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;', '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];', '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];', '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '   }']).result;
    }
    shaders.Vertex = VSSource;
  };
  publicAPI.getPointPickingPrimitiveSize = () => {
    if (model.primitiveType === primTypes.Points) {
      return 2;
    }
    if (model.primitiveType === primTypes.Lines) {
      return 4;
    }
    return 6;
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Helper_DEFAULT_VALUES = {
  context: null,
  program: null,
  shaderSourceTime: null,
  VAO: null,
  attributeUpdateTime: null,
  CABO: null,
  primitiveType: 0,
  pointPicking: false
};

// ----------------------------------------------------------------------------

function Helper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Helper_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  model.shaderSourceTime = {};
  macros2.m.obj(model.shaderSourceTime);
  model.attributeUpdateTime = {};
  macros2.m.obj(model.attributeUpdateTime);
  macros2.m.setGet(publicAPI, model, ['program', 'shaderSourceTime', 'VAO', 'attributeUpdateTime', 'CABO', 'primitiveType', 'pointPicking']);
  model.program = ShaderProgram/* default */.A.newInstance();
  model.VAO = VertexArrayObject/* default.newInstance */.Ay.newInstance();
  model.CABO = vtkCellArrayBufferObject.newInstance();

  // Object methods
  vtkOpenGLHelper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Helper_newInstance = macros2.m.newInstance(Helper_extend);

// ----------------------------------------------------------------------------

var vtkHelper = {
  newInstance: Helper_newInstance,
  extend: Helper_extend,
  primTypes
};




/***/ }),

/***/ 6814:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkImageMapper)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _Core_ImageMapper_Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94520);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42008);
/* harmony import */ var _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28914);
/* harmony import */ var _Helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(71650);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(16632);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1013);
/* harmony import */ var _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(18713);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(25196);
/* harmony import */ var _Core_Property_Constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(71995);
/* harmony import */ var _Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(52271);
/* harmony import */ var _Core_ImageProperty_Constants_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(91732);
/* harmony import */ var _RenderWindow_resourceSharingHelper_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(90919);
/* harmony import */ var _glsl_vtkPolyDataVS_glsl_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(84839);
/* harmony import */ var _glsl_vtkPolyDataFS_glsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(23159);
/* harmony import */ var _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(83534);
/* harmony import */ var _Core_Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(57285);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(88691);
/* harmony import */ var _Core_Mapper_Static_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(7698);





















const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_2__.c;
const {
  SlicingMode
} = _Core_ImageMapper_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A;

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function splitStringOnEnter(inputString) {
  // Split the input string into an array of lines based on "Enter" (newline) characters
  // Remove any leading or trailing whitespace from each line and filter out empty lines
  const lines = inputString.split('\n');
  const trimmedLines = [];
  for (let i = 0; i < lines.length; ++i) {
    const trimmedLine = lines[i].trim();
    if (trimmedLine.length > 0) {
      trimmedLines.push(trimmedLine);
    }
  }
  return trimmedLines;
}

// ----------------------------------------------------------------------------
// vtkOpenGLImageMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageMapper');
  function unregisterGraphicsResources(renderWindow) {
    // The openGLTexture is not shared
    model.openGLTexture.releaseGraphicsResources(renderWindow);
    // All these other resources are shared
    [model._colorTransferFunc, model._pwFunc, model._labelOutlineThicknessArray].forEach(coreObject => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        // Unregister the mapper when the render window changes
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      // is slice set by the camera
      if (model.renderable.isA('vtkImageMapper') && model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = prepass => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (
    // backwards compat with code that (errorneously) set this to boolean
    // eslint-disable-next-line eqeqeq
    model.renderable.getResolveCoincidentTopology() == _Core_Mapper_Static_js__WEBPACK_IMPORTED_MODULE_19__/* .Resolve */ .XK.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };

  // Renders myself
  publicAPI.render = () => {
    const actor = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = _glsl_vtkPolyDataVS_glsl_js__WEBPACK_IMPORTED_MODULE_14__.v;
    shaders.Fragment = _glsl_vtkPolyDataFS_glsl_js__WEBPACK_IMPORTED_MODULE_15__.v;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;
    VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;
    VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;
    VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordDec = ['varying vec2 tcoordVCVSOutput;',
    // color shift and scale
    'uniform float cshift0;', 'uniform float cscale0;',
    // pwf shift and scale
    'uniform float pwfshift0;', 'uniform float pwfscale0;', 'uniform sampler2D texture1;', 'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', 'uniform sampler2D labelOutlineTexture1;', 'uniform float opacity;', 'uniform float outlineOpacity;'];
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
        // color shift and scale
        `uniform float cshift${comp};`, `uniform float cscale${comp};`,
        // weighting shift and scale
        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);
      }
      // the heights defined below are the locations
      // for the up to four components of the tfuns
      // the tfuns have a height of 2XnumComps pixels so the
      // values are computed to hit the middle of the two rows
      // for that component
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat(['uniform float mix0;', '#define height0 0.5']);
          break;
        case 2:
          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);
          break;
        case 3:
          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);
          break;
        case 4:
          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);
          break;
        default:
          vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    }
    FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Dec', tcoordDec).result;

    // check for the outline thickness and opacity
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::LabelOutline::Dec', ['uniform int outlineThickness;', 'uniform float vpWidth;', 'uniform float vpHeight;', 'uniform float vpOffsetX;', 'uniform float vpOffsetY;', 'uniform mat4 PCWCMatrix;', 'uniform mat4 vWCtoIDX;', 'uniform ivec3 imageDimensions;']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::LabelOutlineHelperFunction', ['#ifdef vtkImageLabelOutlineOn', 'vec3 fragCoordToIndexSpace(vec4 fragCoord) {', '  vec4 pcPos = vec4(', '    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,', '    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,', '    (fragCoord.z - 0.5) * 2.0,', '    1.0);', '', '  vec4 worldCoord = PCWCMatrix * pcPos;', '  vec4 vertex = (worldCoord/worldCoord.w);', '', '  vec3 index = (vWCtoIDX * vertex).xyz;', '', '  // half voxel fix for labelmapOutline', '  return (index + vec3(0.5)) / vec3(imageDimensions);', '}', '#endif']).result;
    }
    if (iComps) {
      const rgba = ['r', 'g', 'b', 'a'];
      let tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];
      for (let comp = 0; comp < tNumComp; comp++) {
        tcoordImpl = tcoordImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, opacity);']);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);
          break;
        default:
          vtkErrorMacro('Unsupported number of independent coordinates.');
      }
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', tcoordImpl).result;
    } else {
      // dependent components
      switch (tNumComp) {
        case 1:
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', [...splitStringOnEnter(`
                #ifdef vtkImageLabelOutlineOn
                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);
                  float centerValue = texture2D(texture1, centerPosIS.xy).r;
                  bool pixelOnBorder = false;
                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;
                  float opacityToUse = scalarOpacity * opacity;
                  int segmentIndex = int(centerValue * 255.0);
                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;
                  int actualThickness = int(textureValue * 255.0);

                  if (segmentIndex == 0){
                    gl_FragData[0] = vec4(0.0, 1.0, 1.0, 0.0);
                    return;
                  }

                  for (int i = -actualThickness; i <= actualThickness; i++) {
                    for (int j = -actualThickness; j <= actualThickness; j++) {
                      if (i == 0 || j == 0) {
                        continue;
                      }
                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
                        gl_FragCoord.y + float(j),
                        gl_FragCoord.z, gl_FragCoord.w);
                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
                      float value = texture2D(texture1, neighborPosIS.xy).r;
                      if (value != centerValue) {
                        pixelOnBorder = true;
                        break;
                      }
                    }
                    if (pixelOnBorder == true) {
                      break;
                    }
                  }
                  if (pixelOnBorder == true) {
                    gl_FragData[0] = vec4(tColor, outlineOpacity);
                  }
                  else {
                    gl_FragData[0] = vec4(tColor, opacityToUse);
                  }
                #else
                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;
                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;
                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);
                #endif
                `)]).result;
          break;
        case 2:
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', 'float intensity = tcolor.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);']).result;
          break;
        case 3:
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']).result;
          break;
        default:
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']).result;
      }
    }
    if (model.haveSeenDepthRequest) {
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.r)('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    // render pass shader replacement changed

    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();

    // has the render pass shader replacement changed? Two options
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;

    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.

    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro('Error setting vertexMC in shader VAO.');
        }
      }
      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {
          vtkErrorMacro('Error setting tcoordMC in shader VAO.');
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('texture1', texUnit);
    const numComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; i++) {
        cellBO.getProgram().setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));
      }
    }
    const oglShiftScale = model.openGLTexture.getShiftAndScale();

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      let cw = actor.getProperty().getColorWindow();
      let cl = actor.getProperty().getColorLevel();
      const target = iComps ? i : 0;
      const cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale = oglShiftScale.scale / cw;
      const shift = (oglShiftScale.shift - cl) / cw + 0.5;
      cellBO.getProgram().setUniformf(`cshift${i}`, shift);
      cellBO.getProgram().setUniformf(`cscale${i}`, scale);
    }

    // pwf shift/scale
    for (let i = 0; i < numComp; i++) {
      let pwfScale = 1.0;
      let pwfShift = 0.0;
      const target = iComps ? i : 0;
      const pwfun = actor.getProperty().getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length;
        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;
      }
      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);
      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }

    // handle coincident
    if (cellBO.getProgram().isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (cellBO.getProgram().isUniformUsed('cfactor')) {
        cellBO.getProgram().setUniformf('cfactor', cp.factor);
      }
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);
    const outlineThicknessUnit = model.labelOutlineThicknessTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('labelOutlineTexture1', outlineThicknessUnit);
    if (model.renderable.getNumberOfClippingPlanes()) {
      // add all the clipping planes
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.r)('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(mat, mat);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(mat, mat, inverseShiftScaleMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(mat, mat);
      }

      // transform crop plane normal with transpose(inverse(worldToIndex))
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.imagemat, model.currentInput.getIndexToWorld());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);
      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);
    }

    // outline thickness and opacity
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const outlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      cellBO.getProgram().setUniformf('outlineOpacity', outlineOpacity);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const actMats = model.openGLImageSlice.getKeyMatrices();
    const image = model.currentInput;
    const i2wmat4 = image.getIndexToWorld();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.imagemat, actMats.mcwc, i2wmat4);
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.imagemat, keyMats.wcpc, model.imagemat);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    program.setUniformMatrix('MCPCMatrix', model.imagemat);
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const worldToIndex = image.getWorldToIndex();
      const imageDimensions = image.getDimensions();
      program.setUniform3i('imageDimensions', imageDimensions[0], imageDimensions[1], 1);
      program.setUniformMatrix('vWCtoIDX', worldToIndex);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);

      // Get the projection coordinate to world coordinate transformation matrix.
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);
      const size = publicAPI.getRenderTargetSize();
      program.setUniformf('vpWidth', size[0]);
      program.setUniformf('vpHeight', size[1]);
      const offset = publicAPI.getRenderTargetOffset();
      program.setUniformf('vpOffsetX', offset[0] / size[0]);
      program.setUniformf('vpOffsetY', offset[1] / size[1]);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf('opacity', opacity);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // activate the texture
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.labelOutlineThicknessTexture.activate();
    model.pwfTexture.activate();

    // draw polygons
    if (model.tris.getCABO().getElementCount()) {
      // First we do the triangles, update the shader, set uniforms, etc.
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.labelOutlineThicknessTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {};
  publicAPI.renderPiece = (ren, actor) => {
    // Make sure that we have been properly initialized.
    // if (ren.getRenderWindow().checkAbortStatus()) {
    //   return;
    // }

    publicAPI.invokeEvent({
      type: 'StartEvent'
    });
    model.renderable.update();
    model.currentInput = model.renderable.getCurrentImage();
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });
    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_6__.u)(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || !model.openGLTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.labelOutlineThicknessTexture?.getHandle() || !model.pwfTexture?.getHandle();
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const imgScalars = image.getPointData() && image.getPointData().getScalars();
    if (!imgScalars) {
      return;
    }
    const dataType = imgScalars.getDataType();
    const numComp = imgScalars.getNumberOfComponents();
    const actorProperty = actor.getProperty();
    const iType = actorProperty.getInterpolationType();
    const iComps = actorProperty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = actorProperty.getRGBTransferFunction();
    const cfunToString = (0,_RenderWindow_resourceSharingHelper_js__WEBPACK_IMPORTED_MODULE_13__/* .getTransferFunctionHash */ .gP)(colorTransferFunc, iComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== cfunToString;
    if (reBuildC) {
      model.colorTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].newInstance */ .Ay.newInstance({
        resizable: true
      });
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      // set interpolation on the texture based on property setting
      if (iType === _Core_ImageProperty_Constants_js__WEBPACK_IMPORTED_MODULE_12__/* .InterpolationType */ .V.NEAREST) {
        model.colorTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
        model.colorTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
      } else {
        model.colorTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
        model.colorTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
      }
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0; c < numIComps; c++) {
          const cfun = actorProperty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, cfunToString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }

    // Build piecewise function buffer.  This buffer is used either
    // for component weighting or opacity, depending on whether we're
    // rendering components independently or not.
    const pwFunc = actorProperty.getPiecewiseFunction();
    const pwfunToString = (0,_RenderWindow_resourceSharingHelper_js__WEBPACK_IMPORTED_MODULE_13__/* .getTransferFunctionHash */ .gP)(pwFunc, iComps, numIComps);
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    // rebuild opacity tfun?
    const reBuildPwf = !pwfTex?.oglObject?.getHandle() || pwfTex?.hash !== pwfunToString;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].newInstance */ .Ay.newInstance({
        resizable: true
      });
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // set interpolation on the texture based on property setting
      if (iType === _Core_ImageProperty_Constants_js__WEBPACK_IMPORTED_MODULE_12__/* .InterpolationType */ .V.NEAREST) {
        model.pwfTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
        model.pwfTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
      } else {
        model.pwfTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
        model.pwfTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
      }
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0; c < numIComps; ++c) {
          const pwfun = actorProperty.getPiecewiseFunction(c);
          if (pwfun === null) {
            // Piecewise constant max if no function supplied for this component
            pwfFloatTable.fill(1.0);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            // adjust for sample distance etc
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.FLOAT, pwfFloatTable);
      } else {
        // default is opaque
        pwfTable.fill(255.0);
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, pwfunToString);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = pwfTex.oglObject;
    }

    // Build outline thickness buffer
    publicAPI.updatelabelOutlineThicknessTexture(actor);

    // Find what IJK axis and what direction to slice along
    const {
      ijkMode
    } = model.renderable.getClosestIJKAxis();

    // Find the IJK slice
    let slice = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      // If not IJK slicing, get the IJK slice from the XYZ position/slice
      slice = model.renderable.getSliceAtPosition(slice);
    }

    // Use sub-Slice number/offset if mapper being used is vtkImageArrayMapper,
    // since this mapper uses a collection of vtkImageData (and not just a single vtkImageData).
    const nSlice = model.renderable.isA('vtkImageArrayMapper') ? model.renderable.getSubSlice() // get subSlice of the current (possibly multi-frame) image
    : Math.round(slice);

    // Find sliceOffset
    const ext = image.getExtent();
    let sliceOffset;
    if (ijkMode === SlicingMode.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {
      sliceOffset = nSlice - ext[4];
    }

    // rebuild the VBO if the data has changed
    const toString = `${slice}A${image.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor.getProperty().getInterpolationType()}`;
    if (model.VBOBuildString !== toString) {
      // Build the VBOs
      const dims = image.getDimensions();
      if (!model.openGLTexture) {
        model.openGLTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].newInstance */ .Ay.newInstance({
          resizable: true
        });
      }
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // Use norm16 for scalar texture if the extension is available
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));
      if (iType === _Core_ImageProperty_Constants_js__WEBPACK_IMPORTED_MODULE_12__/* .InterpolationType */ .V.NEAREST) {
        if (new Set([1, 3, 4]).has(numComp) && dataType === _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
      } else {
        if (numComp === 4 && dataType === _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR_MIPMAP_LINEAR);
        } else {
          model.openGLTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
      }
      model.openGLTexture.setWrapS(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Wrap */ .B_.CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Wrap */ .B_.CLAMP_TO_EDGE);
      const sliceSize = dims[0] * dims[1] * numComp;
      const ptsArray = new Float32Array(12);
      const tcoordArray = new Float32Array(8);
      for (let i = 0; i < 4; i++) {
        tcoordArray[i * 2] = i % 2 ? 1.0 : 0.0;
        tcoordArray[i * 2 + 1] = i > 1 ? 1.0 : 0.0;
      }

      // Determine depth position of the slicing plane in the scene.
      // Slicing modes X, Y, and Z use a continuous axis position, whereas
      // slicing modes I, J, and K should use discrete positions.
      const sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;
      const spatialExt = image.getSpatialExtent();
      const basicScalars = imgScalars.getData();
      let scalars = null;
      // Get right scalars according to slicing mode
      if (ijkMode === SlicingMode.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        let id = 0;
        for (let k = 0; k < dims[2]; k++) {
          for (let j = 0; j < dims[1]; j++) {
            let bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[1] + j) * numComp;
            const end = bsIdx + numComp;
            while (bsIdx < end) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = sliceDepth;
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = sliceDepth;
        ptsArray[4] = spatialExt[3];
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = sliceDepth;
        ptsArray[7] = spatialExt[2];
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = sliceDepth;
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        let id = 0;
        for (let k = 0; k < dims[2]; k++) {
          for (let i = 0; i < dims[0]; i++) {
            let bsIdx = (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[0] + i) * numComp;
            const end = bsIdx + numComp;
            while (bsIdx < end) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = sliceDepth;
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = sliceDepth;
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = sliceDepth;
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = sliceDepth;
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {
        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = sliceDepth;
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = spatialExt[2];
        ptsArray[5] = sliceDepth;
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = spatialExt[3];
        ptsArray[8] = sliceDepth;
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = sliceDepth;
      } else {
        vtkErrorMacro('Reformat slicing not yet supported.');
      }

      // Don't share this resource as `scalars` is created in this function
      // so it is impossible to share
      model.openGLTexture.resetFormatAndType();
      model.openGLTexture.create2DFilterableFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars, model.renderable.getPreferSizeOverAccuracy?.());
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();
      const points = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');
      const tcoords = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName('tcoords');
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, 'polys', _Core_Property_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .Representation */ .YL.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.updatelabelOutlineThicknessTexture = image => {
    const labelOutlineThicknessArray = image.getProperty().getLabelOutlineThickness();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);

    // compute the join of the labelOutlineThicknessArray so that
    // we can use it to decide whether to rebuild the labelOutlineThicknessTexture
    // or not
    const toString = `${labelOutlineThicknessArray.join('-')}`;
    const reBuildL = !lTex?.oglObject?.getHandle() || lTex?.hash !== toString;
    if (reBuildL) {
      const lWidth = 1024;
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);

      // Assuming labelOutlineThicknessArray contains the thickness for each segment
      for (let i = 0; i < lWidth; ++i) {
        // Retrieve the thickness value for the current segment index.
        // If the value is undefined, use the first element's value as a default, otherwise use the value (even if 0)
        const thickness = typeof labelOutlineThicknessArray[i] !== 'undefined' ? labelOutlineThicknessArray[i] : labelOutlineThicknessArray[0];
        lTable[i] = thickness;
      }
      model.labelOutlineThicknessTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].newInstance */ .Ay.newInstance({
        resizable: false
      });
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);

      // Create a 2D texture (acting as 1D) from the raw data
      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, lTable);
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, toString);
        if (labelOutlineThicknessArray !== model._labelOutlineThicknessArray) {
          model._openGLRenderWindow.registerGraphicsResourceUser(labelOutlineThicknessArray, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._labelOutlineThicknessArray, publicAPI);
        }
        model._labelOutlineThicknessArray = labelOutlineThicknessArray;
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.oglObject;
    }
  };
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.delete = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.h)(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  VBOBuildTime: 0,
  VBOBuildString: null,
  openGLTexture: null,
  tris: null,
  imagemat: null,
  imagematinv: null,
  colorTexture: null,
  pwfTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineThicknessTextureString: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0
  // _scalars: null,
  // _colorTransferFunc: null,
  // _pwFunc: null,
  // _labelOutlineThicknessArray: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = _Helper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].newInstance */ .Ay.newInstance();
  model.imagemat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.imagematinv = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.projectionToWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.idxToView = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.idxNormalMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(new Float64Array(9));
  model.modelToView = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.projectionToView = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.e)(publicAPI, model, []);
  model.VBOBuildTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.o)(model.VBOBuildTime);

  // Object methods
  vtkOpenGLImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.n)(extend, 'vtkOpenGLImageMapper');

// ----------------------------------------------------------------------------

var vtkImageMapper = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_18__/* .registerOverride */ .c9)('vtkAbstractImageMapper', newInstance);




/***/ }),

/***/ 64501:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkImageSlice)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88691);





// ----------------------------------------------------------------------------
// vtkOpenGLImageSlice methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageSlice(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageSlice');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseZBufferPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaqueZBufferPass = renderPass => publicAPI.traverseOpaquePass(renderPass);

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);

  // Renders myself
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16))
  };

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLImageSlice(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend, 'vtkOpenGLImageSlice');

// ----------------------------------------------------------------------------

var vtkImageSlice = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkImageSlice', newInstance);




/***/ }),

/***/ 68464:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkPixelSpaceCallbackMapper)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88691);




// import { mat4, vec3 }     from 'gl-matrix';
const {
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.c;

// ----------------------------------------------------------------------------
// vtkOpenGLPixelSpaceCallbackMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push('vtkOpenGLPixelSpaceCallbackMapper');
  publicAPI.opaquePass = (prepass, renderPass) => {
    model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
    model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
    const aspectRatio = model._openGLRenderer.getAspectRatio();
    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
    let texels = null;
    if (model.renderable.getUseZValues()) {
      const zbt = renderPass.getZBufferTexture();
      const width = Math.floor(zbt.getWidth());
      const height = Math.floor(zbt.getHeight());
      const gl = model._openGLRenderWindow.getContext();
      zbt.bind();

      // Here we need to use vtkFramebuffer to save current settings (bindings/buffers)
      const fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro('No framebuffer to save/restore');
      } else {
        // save framebuffer settings
        fb.saveCurrentBindingsAndBuffers();
      }
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }

      // Now we need to restore framebuffer bindings/buffers
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }
      gl.deleteFramebuffer(framebuffer);
    }
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.requestDepth();
      }
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend, 'vtkOpenGLPixelSpaceCallbackMapper');

// ----------------------------------------------------------------------------

var vtkPixelSpaceCallbackMapper = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__/* .registerOverride */ .c9)('vtkPixelSpaceCallbackMapper', newInstance);




/***/ }),

/***/ 62939:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkOpenGLPolyDataMapper$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71650);
/* harmony import */ var _Core_Mapper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82409);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16632);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1013);
/* harmony import */ var _Core_Prop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(46985);
/* harmony import */ var _Core_Property_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(89585);
/* harmony import */ var _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(18713);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(25196);
/* harmony import */ var _glsl_vtkPolyDataVS_glsl_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(84839);
/* harmony import */ var _glsl_vtkPolyDataFS_glsl_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23159);
/* harmony import */ var _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(83534);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(88691);
/* harmony import */ var _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(57703);
/* harmony import */ var _Common_DataModel_DataSet_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(69147);
/* harmony import */ var _Core_Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(57285);
/* harmony import */ var _Core_Mapper_Static_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(7698);



















const {
  FieldAssociations
} = _Common_DataModel_DataSet_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Ay;

/* eslint-disable no-lonely-if */

const {
  primTypes
} = _Helper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay;
const {
  Representation,
  Shading
} = _Core_Property_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Ay;
const {
  ScalarMode
} = _Core_Mapper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay;
const {
  Filter,
  Wrap
} = _Texture_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Ay;
const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.c;
const StartEvent = {
  type: 'StartEvent'
};
const EndEvent = {
  type: 'EndEvent'
};
const {
  CoordinateSystem
} = _Core_Prop_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Ay;

// ----------------------------------------------------------------------------
// vtkOpenGLPolyDataMapper methods
// ----------------------------------------------------------------------------

function getPickState(renderer) {
  const selector = renderer.getSelector();
  if (selector) {
    return selector.getCurrentPass();
  }
  return _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.MIN_KNOWN_PASS - 1;
}
function vtkOpenGLPolyDataMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLPolyDataMapper');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');
      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = prepass => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = _glsl_vtkPolyDataVS_glsl_js__WEBPACK_IMPORTED_MODULE_10__.v;
    shaders.Fragment = _glsl_vtkPolyDataFS_glsl_js__WEBPACK_IMPORTED_MODULE_11__.v;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');

    // create the material/color property declarations, and VS implementation
    // these are always defined
    let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;'];
    // add more for specular
    if (lastLightComplexity) {
      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);
    }

    // now handle the more complex fragment shader implementation
    // the following are always defined variables.  We start
    // by assigning a default value from the uniform
    let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);
    }
    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);
    }

    // add scalar vertex coloring
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;
      GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;
      GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;
    } else {
      if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;
      } else {
        if (actor.getBackfaceProperty() && !model.drawingEdges) {
          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);
          if (lastLightComplexity) {
            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);
            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);
          } else {
            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);
          }
        }
        if (model.haveCellScalars && !model.drawingEdges) {
          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);
        }
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;
      }
    }
    FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;

    // check for shadow maps
    const shadowFactor = '';
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');
    let sstring = [];
    switch (lastLightComplexity) {
      case 0:
        // no lighting or RENDER_VALUES
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;
        break;
      case 1:
        // headlight
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;
        break;
      case 2:
        // light kit
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);
        }
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Dec', sstring).result;
        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, '    {', `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, '    }']);
        }
        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;
        break;
      case 3:
        // positional
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);
        }
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Dec', sstring).result;
        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat(['  attenuation = 1.0;', `  if (lightPositional${lc} == 0)`, '    {', `      vertLightDirectionVC = lightDirectionVC${lc};`, '    }', '  else', '    {', `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, '    // per OpenGL standard cone angle is 90 or less for a spot light', `    if (lightConeAngle${lc} <= 90.0)`, '      {', `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, '      // if inside the cone', `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, '        {', `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${lc},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, '    }']);
        }
        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;
        break;
      default:
        vtkErrorMacro('bad light complexity');
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    if (lastLightComplexity > 0) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.lastBoundBO.getCABO().getNormalOffset()) {
        VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;
        VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',
        //  if (!gl_FrontFacing) does not work in intel hd4000 mac
        //  if (int(gl_FrontFacing) == 0) does not work on mesa
        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;
      } else {
        if (model.haveCellNormals) {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;
        } else {
          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {
            // generate a normal for lines, it will be perpendicular to the line
            // and maximally aligned with the camera view direction
            // no clue if this is the best way to do this.
            // the code below has been optimized a bit so what follows is
            // an explanation of the basic approach. Compute the gradient of the line
            // with respect to x and y, the the larger of the two
            // cross that with the camera view direction. That gives a vector
            // orthogonal to the camera view and the line. Note that the line and the camera
            // view are probably not orthogonal. Which is why when we cross result that with
            // the line gradient again we get a reasonable normal. It will be othogonal to
            // the line (which is a plane but maximally aligned with the camera view.
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements
            ).result;
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;
          } else {
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::UniformFlow::Impl', [
            // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',
            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',
            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements
            ).result;
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',
            // the code below is faster, but does not work on some devices
            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',
            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;
          }
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    // replace common shader code
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;

    // do we need the vertex in the shader in View Coordinates
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    if (lastLightComplexity > 0) {
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;
      GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;
      GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;
    } else {
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.drawingEdges) {
        return;
      }
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;

      // we only handle the first texture by default
      // additional textures are activated and we set the uniform
      // for the texture unit they are assigned to, but you have to
      // add in the shader code to do something with them
      const tus = model.openGLActor.getActiveTextures();
      let tNumComp = 2;
      let tcdim = 2;
      if (tus && tus.length > 0) {
        tNumComp = tus[0].getComponents();
        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
          tcdim = 3;
        }
      }
      if (model.renderable.getColorTextureMap()) {
        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();
        tcdim = 2;
      }
      if (tcdim === 2) {
        VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
        if (tus && tus.length >= 1) {
          switch (tNumComp) {
            case 1:
              FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;
              break;
            case 2:
              FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;
              break;
            default:
              FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;
          }
        }
      } else {
        VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;
        switch (tNumComp) {
          case 1:
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;
            break;
          case 2:
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;
            break;
          default:
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    // 1. ResolveCoincidentTopology is On and non zero for this primitive
    // type
    let cp = {
      factor: 0.0,
      offset: 0.0
    };
    const prop = actor.getProperty();
    if (
    // backwards compat with code that (errorneously) set this to boolean
    // eslint-disable-next-line eqeqeq
    model.renderable.getResolveCoincidentTopology() == _Core_Mapper_Static_js__WEBPACK_IMPORTED_MODULE_17__/* .Resolve */ .XK.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {
      const primType = model.lastBoundBO.getPrimitiveType();
      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {
        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {
        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
      }
      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        cp.factor /= 2.0;
        cp.offset /= 2.0;
      }
    }

    // hardware picking always offset due to saved zbuffer
    // This gets you above the saved surface depth buffer.
    const selector = model._openGLRenderer.getSelector();
    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      cp.offset -= 2.0;
    }
    return cp;
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    let VSSource = shaders.Vertex;
    FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;
    if (!model._openGLRenderer.getSelector()) {
      return;
    }
    if (model.lastSelectionState === _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_LOW24 || model.lastSelectionState === _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_HIGH24) {
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\n', 'uniform int VertexIDOffset;\n']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\n').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;
    }
    switch (model.lastSelectionState) {
      case _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_LOW24:
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;
        break;
      case _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_HIGH24:
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);').result;
        break;
      default:
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;
    }
    shaders.Fragment = FSSource;
    shaders.Vertex = VSSource;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderNormal(shaders, ren, actor);
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    let lightComplexity = 0;
    let numberOfLights = 0;
    const primType = cellBO.getPrimitiveType();
    const poly = model.currentInput;

    // different algo from C++ as of 5/2019
    let needLighting = false;
    const pointNormals = poly.getPointData().getNormals();
    const cellNormals = poly.getCellData().getNormals();
    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;
    const representation = actor.getProperty().getRepresentation();
    const mode = cellBO.getOpenGLMode(representation, primType);
    // 1) all surfaces need lighting
    if (mode === model.context.TRIANGLES) {
      needLighting = true;
      // 2) all cell normals without point normals need lighting
    } else if (cellNormals && !pointNormals) {
      needLighting = true;
      // 3) Phong + pointNormals need lighting
    } else if (!flat && pointNormals) {
      needLighting = true;
      // 4) Phong Lines need lighting
    } else if (!flat && mode === model.context.LINES) {
      needLighting = true;
    }
    // 5) everything else is unlit

    // do we need lighting?
    if (actor.getProperty().getLighting() && needLighting) {
      // consider the lighting complexity to determine which case applies
      // simple headlight, Light Kit, the whole feature set of VTK
      lightComplexity = 0;
      const lights = ren.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0) {
          numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      }
    }
    let needRebuild = false;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');
    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {
      model.lastBoundBO.set({
        lastLightComplexity: lightComplexity
      }, true);
      model.lastBoundBO.set({
        lastLightCount: numberOfLights
      }, true);
      needRebuild = true;
    }

    // has the render pass shader replacement changed? Two options
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }

    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    // render pass shader replacement changed
    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      return true;
    }
    return false;
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach(object => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.
    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {
      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {
      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro('Error setting vertexMC in shader VAO.');
        }
      }
      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro('Error setting normalMC in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('normalMC');
      }
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro('Error setting tcoordMC in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('tcoordMC');
      }
      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
          vtkErrorMacro('Error setting scalarColor in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('scalarColor');
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      // add all the clipping planes
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      const planeEquations = [];
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(mat, mat);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(mat, mat, inverseShiftScaleMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(mat, mat);
      }
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);
      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);
    }
    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {
      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());
    }
    const tus = model.openGLActor.getActiveTextures();
    if (tus) {
      for (let index = 0; index < tus.length; ++index) {
        const tex = tus[index];
        const texUnit = tex.getTextureUnit();
        const tname = `texture${texUnit + 1}`;
        if (cellBO.getProgram().isUniformUsed(tname)) {
          cellBO.getProgram().setUniformi(tname, texUnit);
        }
      }
    }

    // handle depth requests
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }

    // handle coincident
    if (cellBO.getProgram().isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (cellBO.getProgram().isUniformUsed('cfactor')) {
        cellBO.getProgram().setUniformf('cfactor', cp.factor);
      }
    }

    // handle wide lines
    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
    const selector = model._openGLRenderer.getSelector();
    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);
    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    // for unlit and headlight there are no lighting parameters
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    if (lastLightComplexity < 2) {
      return;
    }
    const program = cellBO.getProgram();

    // bind some light settings
    let numberOfLights = 0;
    const lights = ren.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0.0) {
        const dColor = light.getColorByReference();
        const intensity = light.getIntensity();
        model.lightColor[0] = dColor[0] * intensity;
        model.lightColor[1] = dColor[1] * intensity;
        model.lightColor[2] = dColor[2] * intensity;
        // get required info from light
        const ld = light.getDirection();
        const transform = ren.getActiveCamera().getViewMatrix();
        const newLightDirection = [...ld];
        if (light.lightTypeIsSceneLight()) {
          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
          (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.l)(newLightDirection);
        }
        model.lightDirection[0] = newLightDirection[0];
        model.lightDirection[1] = newLightDirection[1];
        model.lightDirection[2] = newLightDirection[2];
        (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.l)(model.lightDirection);
        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);
        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);
        numberOfLights++;
      }
    }

    // we are done unless we have positional lights
    if (lastLightComplexity < 3) {
      return;
    }

    // for lightkit case there are some parameters to set
    const cam = ren.getActiveCamera();
    const viewTF = cam.getViewMatrix();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(viewTF, viewTF);
    numberOfLights = 0;
    for (let index = 0; index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0.0) {
        const lp = light.getTransformedPosition();
        const np = new Float64Array(3);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(np, lp, viewTF);
        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());
        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());
        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());
        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());
        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);
        numberOfLights++;
      }
    }
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index) => {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    // [WMVP]C == {world, model, view, projection} coordinates
    // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const cam = ren.getActiveCamera();
    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();
    const progm = program.getLastCameraMTime();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const actorIsIdentity = actor.getIsIdentity();
    const actMats = actorIsIdentity ? {
      mcwc: null,
      normalMatrix: null
    } : model.openGLActor.getKeyMatrices();
    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {
      const size = model._openGLRenderer.getTiledSizeAndOrigin();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(model.tmpMat4);
      model.tmpMat4[0] = 2.0 / size.usize;
      model.tmpMat4[12] = -1.0;
      model.tmpMat4[5] = 2.0 / size.vsize;
      model.tmpMat4[13] = -1.0;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);
    } else {
      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4 */ .pB, model.tmpMat4));
    }
    if (program.isUniformUsed('MCVCMatrix')) {
      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4 */ .pB, model.tmpMat4));
    }
    if (program.isUniformUsed('normalMatrix')) {
      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3 */ .w0, model.tmpMat3));
    }
    if (progm !== camm) {
      if (program.isUniformUsed('cameraParallel')) {
        program.setUniformi('cameraParallel', cam.getParallelProjection());
      }
      program.setLastCameraMTime(camm);
    }
    if (!actorIsIdentity) {
      // reset the cam mtime as actor modified the shader values
      program.setLastCameraMTime(0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    let ppty = actor.getProperty();
    let opacity = ppty.getOpacity();
    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();
    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();
    let aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();
    let dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();
    let sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();
    const specularPower = ppty.getSpecularPower();
    program.setUniformf('opacityUniform', opacity);
    program.setUniform3fArray('ambientColorUniform', aColor);
    program.setUniform3fArray('diffuseColorUniform', dColor);
    program.setUniformf('ambient', aIntensity);
    program.setUniformf('diffuse', dIntensity);

    // we are done unless we have lighting
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    if (lastLightComplexity < 1) {
      return;
    }
    let sColor = ppty.getSpecularColorByReference();
    program.setUniform3fArray('specularColorUniform', sColor);
    program.setUniformf('specularPowerUniform', specularPower);
    program.setUniformf('specular', sIntensity);

    // now set the backface properties if we have them
    if (program.isUniformUsed('ambientIntensityBF')) {
      ppty = actor.getBackfaceProperty();
      opacity = ppty.getOpacity();
      aColor = ppty.getAmbientColor();
      aIntensity = ppty.getAmbient();
      dColor = ppty.getDiffuseColor();
      dIntensity = ppty.getDiffuse();
      sColor = ppty.getSpecularColor();
      sIntensity = ppty.getSpecular();
      program.setUniformf('ambientIntensityBF', aIntensity);
      program.setUniformf('diffuseIntensityBF', dIntensity);
      program.setUniformf('opacityUniformBF', opacity);
      program.setUniform3fArray('ambientColorUniformBF', aColor);
      program.setUniform3fArray('diffuseColorUniformBF', dColor);

      // we are done unless we have lighting
      if (lastLightComplexity < 1) {
        return;
      }
      program.setUniformf('specularIntensityBF', sIntensity);
      program.setUniform3fArray('specularColorUniformBF', sColor);
      program.setUniformf('specularPowerUniformBF', specularPower);
    }
  };
  publicAPI.updateMaximumPointCellIds = (ren, actor) => {
    const selector = model._openGLRenderer.getSelector();
    if (!selector) {
      return;
    }
    if (model.selectionWebGLIdsToVTKIds?.points?.length) {
      const length = model.selectionWebGLIdsToVTKIds.points.length;
      selector.setMaximumPointId(length - 1);
    }
    if (model.selectionWebGLIdsToVTKIds?.cells?.length) {
      const length = model.selectionWebGLIdsToVTKIds.cells.length;
      selector.setMaximumCellId(length - 1);
    }
    const fieldAssociation = selector.getFieldAssociation();
    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      model.pointPicking = true;
    }
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    model.vertexIDOffset = 0;
    const picking = getPickState(model._openGLRenderer);
    if (model.lastSelectionState !== picking) {
      model.selectionStateChanged.modified();
      model.lastSelectionState = picking;
    }
    if (model._openGLRenderer.getSelector()) {
      switch (picking) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }

    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // If we are coloring by texture, then load the texture map.
    // Use Map as indicator, because texture hangs around.
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;
    const selector = model._openGLRenderer.getSelector();
    // If we are picking points, we need to tell it to the helper
    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_LOW24 || model.lastSelectionState === _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_HIGH24);

    // for every primitive type
    for (let i = primTypes.Start; i < primTypes.End; i++) {
      model.primitives[i].setPointPicking(pointPicking);
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        // are we drawing edges
        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);
        // don't draw edges when rendering depth or rendering for picking
        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {
          model.lastBoundBO = model.primitives[i];
          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();
        }
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.LastBoundBO) {
      model.LastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    // Make sure that we have been properly initialized.
    // if (ren.getRenderWindow().checkAbortStatus()) {
    //   return;
    // }

    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }

    // if there are no points then we are done
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }

    // apply faceCulling
    const gl = model.context;
    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.u)(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
    // Always call this function as the selector can change
    publicAPI.updateMaximumPointCellIds();
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      // We must figure out how the scalars should be mapped to the polydata.
      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }

    // Do we have normals?
    let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;
    if (n === null && poly.getCellData().getNormals()) {
      model.haveCellNormals = true;
      n = poly.getCellData().getNormals();
    }

    // rebuild the VBO if the data has changed we create a string for the VBO what
    // can change the VBO? points normals tcoords colors so what can change those?
    // the input data is clearly one as it can change all four items tcoords may
    // haveTextures or not colors may change based on quite a few mapping
    // parameters in the mapper

    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor.getActiveTextures()) {
      tcoords = null;
    }

    // Flag to check if tcoords are per cell instead of per point
    let useTCoordsPerCell = false;
    // handle color mapping via texture
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
      if (!model.internalColorTexture) {
        model.internalColorTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].newInstance */ .Ay.newInstance({
          resizable: true
        });
      }
      const tex = model.internalColorTexture;
      // the following 4 lines allow for NPOT textures
      tex.setMinificationFilter(Filter.NEAREST);
      tex.setMagnificationFilter(Filter.NEAREST);
      tex.setWrapS(Wrap.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model._openGLRenderWindow);
      const input = model.renderable.getColorTextureMap();
      const ext = input.getExtent();
      const inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}`;
    if (model.VBOBuildString !== toString) {
      // Build the VBOs
      const points = poly.getPoints();
      const options = {
        points,
        normals: n,
        tcoords,
        colors: c,
        cellOffset: 0,
        vertexOffset: 0,
        // Used to keep track of vertex ids across primitives for selection
        useTCoordsPerCell,
        haveCellScalars: model.haveCellScalars,
        haveCellNormals: model.haveCellNormals,
        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))
      };
      if (model.renderable.getPopulateSelectionSettings()) {
        model.selectionWebGLIdsToVTKIds = {
          points: null,
          cells: null
        };
      }
      const primitives = [{
        inRep: 'verts',
        cells: poly.getVerts()
      }, {
        inRep: 'lines',
        cells: poly.getLines()
      }, {
        inRep: 'polys',
        cells: poly.getPolys()
      }, {
        inRep: 'strips',
        cells: poly.getStrips()
      }, {
        inRep: 'polys',
        cells: poly.getPolys()
      }, {
        inRep: 'strips',
        cells: poly.getStrips()
      }];
      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {
          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);
          options.vertexOffset += model.primitives[i].getCABO().getElementCount();
        } else {
          // if we have edge visibility build the edge VBOs
          if (drawSurfaceWithEdges) {
            // VBOs for edges in "surface with edges" are the last to be built,
            // they are not used when picking with a hardware selector so they
            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset
            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, {
              ...options,
              tcoords: null,
              colors: null,
              haveCellScalars: false,
              haveCellNormals: false
            });
          } else {
            // otherwise free them
            model.primitives[i].releaseGraphicsResources();
          }
        }
      }
      if (model.renderable.getPopulateSelectionSettings()) {
        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);
      }
      model.VBOBuildString = toString;
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach(prim => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    // Return in MB
    return memUsed;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null,
  tmpMat4: null,
  ambientColor: [],
  // used internally
  diffuseColor: [],
  // used internally
  specularColor: [],
  // used internally
  lightColor: [],
  // used internally
  lightDirection: [],
  // used internally
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastSelectionState: _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.MIN_KNOWN_PASS - 1,
  selectionStateChanged: null,
  selectionWebGLIdsToVTKIds: null,
  pointPicking: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes;
  model.tmpMat3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(new Float64Array(9));
  model.tmpMat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  for (let i = primTypes.Start; i < primTypes.End; i++) {
    model.primitives[i] = _Helper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);
  model.VBOBuildTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.VBOBuildTime, {
    mtime: 0
  });
  model.selectionStateChanged = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.selectionStateChanged, {
    mtime: 0
  });

  // Object methods
  vtkOpenGLPolyDataMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend, 'vtkOpenGLPolyDataMapper');

// ----------------------------------------------------------------------------

var vtkOpenGLPolyDataMapper$1 = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_13__/* .registerOverride */ .c9)('vtkMapper', newInstance);




/***/ }),

/***/ 90919:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eS: () => (/* binding */ getImageDataHash),
/* harmony export */   gP: () => (/* binding */ getTransferFunctionHash)
/* harmony export */ });
/* unused harmony export default */
// See typescript header for documentation

function getTransferFunctionHash(transferFunction, useIndependentComponents, numberOfComponents) {
  return transferFunction ? `${transferFunction.getMTime()}-${useIndependentComponents}-${numberOfComponents}` : '0';
}
function getImageDataHash(image, scalars) {
  return `${image.getMTime()}A${scalars.getMTime()}`;
}
var resourceSharingHelper = {
  getTransferFunctionHash,
  getImageDataHash
};




/***/ }),

/***/ 63819:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkRenderer)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88691);




const {
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.c;

// ----------------------------------------------------------------------------
// vtkOpenGLRenderer methods
// ----------------------------------------------------------------------------
/* eslint-disable no-bitwise */

function vtkOpenGLRenderer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLRenderer');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0.0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro('No lights are on, creating one.');
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.zBufferPass = prepass => {
    if (prepass) {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1.0, 0.0, 0.0, 1.0);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1.0);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.colorMask(true, true, true, true);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
    }
  };
  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);

  // Renders myself
  publicAPI.cameraPass = prepass => {
    if (prepass) {
      publicAPI.clear();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();

    // if there is no window assume 0 1
    const tileViewPort = [0.0, 0.0, 1.0, 1.0];

    // find the lower left corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];

    // store the result as a pixel value
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);

    // find the upper right corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);

    // now compute the size of the intersection of the viewport with the
    // current tile
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.clear = () => {
    let clearMask = 0;
    const gl = model.context;
    if (!model.renderable.getTransparent()) {
      const background = model.renderable.getBackgroundByReference();
      // renderable ensures that background has 4 entries.
      gl.clearColor(background[0], background[1], background[2], background[3]);
      clearMask |= gl.COLOR_BUFFER_BIT;
    }
    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1.0);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      gl.depthMask(true);
    }
    gl.colorMask(true, true, true, true);
    const ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    if (clearMask) {
      gl.clear(clearMask);
    }
    gl.enable(gl.DEPTH_TEST);
    /* eslint-enable no-bitwise */
  };

  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
    // Releasing resources means that the next render should re-create resources
    if (model.renderable) {
      model.renderable.getViewProps().forEach(prop => {
        prop.modified();
      });
    }
  };
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  _openGLRenderWindow: null,
  selector: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.extend(publicAPI, model, initialValues);

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.g)(publicAPI, model, ['shaderCache']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.e)(publicAPI, model, ['selector']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.i)(publicAPI, model, ['openGLRenderWindow']);

  // Object methods
  vtkOpenGLRenderer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend, 'vtkOpenGLRenderer');

// ----------------------------------------------------------------------------

var vtkRenderer = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__/* .registerOverride */ .c9)('vtkRenderer', newInstance);




/***/ }),

/***/ 83534:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkReplacementShaderMapper)
/* harmony export */ });
/* harmony import */ var _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18713);


function implementReplaceShaderCoincidentOffset(publicAPI, model) {
  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
    const cp = publicAPI.getCoincidentParameters(ren, actor);

    // if we need an offset handle it here
    // The value of .000016 is suitable for depth buffers
    // of at least 16 bit depth. We do not query the depth
    // right now because we would need some mechanism to
    // cache the result taking into account FBO changes etc.
    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {
      let FSSource = shaders.Fragment;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;
      if (model.context.getExtension('EXT_frag_depth')) {
        if (cp.factor !== 0.0) {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;
        } else {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;
        }
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0.0) {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;
        } else {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
function implementBuildShadersWithReplacements(publicAPI, model) {
  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {
    let shaderReplacements = null;
    if (viewSpec) {
      shaderReplacements = viewSpec.ShaderReplacements;
    }
    if (shaderReplacements) {
      for (let i = 0; i < shaderReplacements.length; i++) {
        const currReplacement = shaderReplacements[i];
        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {
          const shaderType = currReplacement.shaderType;
          const ssrc = shaders[shaderType];
          const substituteRes = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
          shaders[shaderType] = substituteRes.result;
        }
      }
    }
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);
    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;

    // apply any renderPassReplacements
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;

    // user specified pre replacements
    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);
    publicAPI.replaceShaderValues(shaders, ren, actor);

    // user specified post replacements
    publicAPI.applyShaderReplacements(shaders, openGLSpec);
  };
  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {
    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.getShaderTemplate(shaders, ren, actor);
    let vertexShaderCode = shaders.Vertex;
    if (openGLSpecProp) {
      const vertexSpecProp = openGLSpecProp.VertexShaderCode;
      if (vertexSpecProp !== undefined && vertexSpecProp !== '') {
        vertexShaderCode = vertexSpecProp;
      }
    }
    shaders.Vertex = vertexShaderCode;
    let fragmentShaderCode = shaders.Fragment;
    if (openGLSpecProp) {
      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
      if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {
        fragmentShaderCode = fragmentSpecProp;
      }
    }
    shaders.Fragment = fragmentShaderCode;
    let geometryShaderCode = shaders.Geometry;
    if (openGLSpecProp) {
      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
      if (geometrySpecProp !== undefined) {
        geometryShaderCode = geometrySpecProp;
      }
    }
    shaders.Geometry = geometryShaderCode;
  };
}
var vtkReplacementShaderMapper = {
  implementReplaceShaderCoincidentOffset,
  implementBuildShadersWithReplacements
};




/***/ }),

/***/ 18713:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ vtkShaderProgram$1)
});

// UNUSED EXPORTS: substitute

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js


const {
  vtkErrorMacro
} = macros2.m;

// export const SHADER_TYPES = ['Vertex', 'Fragment', 'Geometry', 'Unknown'];

// ----------------------------------------------------------------------------
// vtkShader methods
// ----------------------------------------------------------------------------

function vtkShader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShader');
  publicAPI.compile = () => {
    let stype = model.context.VERTEX_SHADER;
    if (!model.source || !model.source.length || model.shaderType === 'Unknown') {
      return false;
    }

    // Ensure we delete the previous shader if necessary.
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }
    switch (model.shaderType) {
      // case vtkShader::Geometry:
      //   type = GL_GEOMETRY_SHADER;
      //   break;
      case 'Fragment':
        stype = model.context.FRAGMENT_SHADER;
        break;
      case 'Vertex':
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }
    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro(`Error compiling shader '${model.source}': ${lastError}`);
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }

    // The shader compiled, store its handle and return success.
    return true;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === 'Unknown' || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  shaderType: 'Unknown',
  source: '',
  error: '',
  handle: 0,
  dirty: false,
  context: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['shaderType', 'source', 'error', 'handle', 'context']);

  // Object methods
  vtkShader(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkShader');

// ----------------------------------------------------------------------------

var vtkShader$1 = {
  newInstance,
  extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js



const {
  vtkErrorMacro: ShaderProgram_vtkErrorMacro
} = macros2.m;

// perform in place string substitutions, indicate if a substitution was done
// this is useful for building up shader strings which typically involve
// lots of string substitutions. Return true if a substitution was done.
function substitute(source, search, replace, all) {
  // We only accept strings or array of strings, typeof is faster than Array.isArray
  const replaceStr = typeof replace === 'string' ? replace : replace.join('\n');

  // We don't need to instantiate a RegExp if we don't want a global substitution.
  // In all other cases, we need to take the provided string or RegExp and
  // instantiate a new one to add the `g` flag.
  // Argument defaults are transpiled to slow `arguments`-based operations
  // better assume undefined as flag to know if the value is set or not
  const replaceSearch = all === false ? search : new RegExp(search, 'g');
  const resultstr = source.replace(replaceSearch, replaceStr);
  return {
    // If the result is different than the input, we did perform a replacement
    replace: resultstr !== replaceStr,
    result: resultstr
  };
}

// ----------------------------------------------------------------------------
// vtkShaderProgram methods
// ----------------------------------------------------------------------------

function vtkShaderProgram(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShaderProgram');
  publicAPI.compileShader = () => {
    if (!model.vertexShader.compile()) {
      ShaderProgram_vtkErrorMacro(model.vertexShader.getSource().split('\n').map((line, index) => `${index}: ${line}`).join('\n'));
      ShaderProgram_vtkErrorMacro(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      ShaderProgram_vtkErrorMacro(model.fragmentShader.getSource().split('\n').map((line, index) => `${index}: ${line}`).join('\n'));
      ShaderProgram_vtkErrorMacro(model.fragmentShader.getError());
      return 0;
    }
    // skip geometry for now
    if (!publicAPI.attachShader(model.vertexShader)) {
      ShaderProgram_vtkErrorMacro(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      ShaderProgram_vtkErrorMacro(model.error);
      return 0;
    }
    if (!publicAPI.link()) {
      ShaderProgram_vtkErrorMacro(`Links failed: ${model.error}`);
      return 0;
    }
    publicAPI.setCompiled(true);
    return 1;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === 'Unknown' || model.handle === 0) {
      return;
    }
    publicAPI.release();
    if (model.vertexShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.vertexShaderHandle);
      model.vertexShaderHandle = 0;
    }
    if (model.fragmentShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.fragmentShaderHandle);
      model.fragmentShaderHandle = 0;
    }
    model.context.deleteProgram(model.handle);
    model.handle = 0;
    publicAPI.setCompiled(false);
  };
  publicAPI.bind = () => {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }
    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };
  publicAPI.isBound = () => !!model.bound;
  publicAPI.release = () => {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };
  publicAPI.setContext = ctx => {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.link = () => {
    if (model.linked) {
      return true;
    }
    if (model.handle === 0) {
      model.error = 'Program has not been initialized, and/or does not have shaders.';
      return false;
    }

    // clear out the list of uniforms used
    model.uniformLocs = {};
    model.context.linkProgram(model.handle);
    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getProgramInfoLog(model.handle);
      ShaderProgram_vtkErrorMacro(`Error linking shader ${lastError}`);
      model.handle = 0;
      return false;
    }
    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };
  publicAPI.setUniformMatrix = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v);
    model.context.uniformMatrix4fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformMatrix3x3 = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v);
    model.context.uniformMatrix3fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformf = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1f(location, v);
    return true;
  };
  publicAPI.setUniformfv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1fv(location, v);
    return true;
  };
  publicAPI.setUniformi = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1i(location, v);
    return true;
  };
  publicAPI.setUniformiv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1iv(location, v);
    return true;
  };
  publicAPI.setUniform2f = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2fv(location, v);
    return true;
  };
  publicAPI.setUniform2i = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2iv(location, v);
    return true;
  };
  publicAPI.setUniform3f = (name, a1, a2, a3) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (a3 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3f(location, a1, a2, a3);
    return true;
  };
  publicAPI.setUniform3fArray = (name, a) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (!Array.isArray(a) || a.length !== 3) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3f(location, a[0], a[1], a[2]);
    return true;
  };
  publicAPI.setUniform3fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3fv(location, v);
    return true;
  };
  publicAPI.setUniform3i = function (name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 3) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3i(location, array[0], array[1], array[2]);
    return true;
  };
  publicAPI.setUniform3iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3iv(location, v);
    return true;
  };
  publicAPI.setUniform4f = function (name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };
  publicAPI.setUniform4i = function (name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4iv(location, v);
    return true;
  };
  publicAPI.findUniform = name => {
    if (!name || !model.linked) {
      return -1;
    }

    // see if we have cached the result
    let loc = model.uniformLocs[name];
    if (loc !== undefined) {
      return loc;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = `Uniform ${name} not found in current shader program.`;
      model.uniformLocs[name] = -1;
      return -1;
    }
    model.uniformLocs[name] = loc;
    return loc;
  };
  publicAPI.isUniformUsed = name => {
    if (!name) {
      return false;
    }

    // see if we have cached the result
    let loc = model.uniformLocs[name];
    if (loc !== undefined) {
      return loc !== null;
    }
    if (!model.linked) {
      ShaderProgram_vtkErrorMacro('attempt to find uniform when the shader program is not linked');
      return false;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;
    if (loc === null) {
      return false;
    }
    return true;
  };
  publicAPI.isAttributeUsed = name => {
    if (!name) {
      return false;
    }

    // see if we have cached the result
    if (name in model.attributeLocs) {
      return true;
    }
    if (!model.linked) {
      ShaderProgram_vtkErrorMacro('attempt to find uniform when the shader program is not linked');
      return false;
    }
    const loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;
    return true;
  };
  publicAPI.attachShader = shader => {
    if (shader.getHandle() === 0) {
      model.error = 'Shader object was not initialized, cannot attach it.';
      return false;
    }
    if (shader.getShaderType() === 'Unknown') {
      model.error = 'Shader object is of type Unknown and cannot be used.';
      return false;
    }
    if (model.handle === 0) {
      const thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = 'Could not create shader program.';
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }
    if (shader.getShaderType() === 'Vertex') {
      if (model.vertexShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === 'Fragment') {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }
    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };
  publicAPI.detachShader = shader => {
    if (shader.getHandle() === 0) {
      model.error = 'shader object was not initialized, cannot attach it.';
      return false;
    }
    if (shader.getShaderType() === 'Unknown') {
      model.error = 'Shader object is of type Unknown and cannot be used.';
      return false;
    }
    if (model.handle === 0) {
      model.error = 'This shader program has not been initialized yet.';
    }
    switch (shader.getShaderType()) {
      case 'Vertex':
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = 'The supplied shader was not attached to this program.';
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case 'Fragment':
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = 'The supplied shader was not attached to this program.';
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };
  publicAPI.setContext = ctx => {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.setLastCameraMTime = mtime => {
    model.lastCameraMTime = mtime;
  };

  // publicAPI.enableAttributeArray = (name) => {
  //   const location = publicAPI.findAttributeArray(name);
  //   if (location === -1) {
  //     model.error = `Could not enable attribute ${name} No such attribute.`;
  //     return false;
  //   }
  //   model.context.enableVertexAttribArray(location);
  //   return true;
  // };

  // publicAPI.disableAttributeArray = (name) => {
  //   const location = publicAPI.findAttributeArray(name);
  //   if (location === -1) {
  //     model.error = `Could not enable attribute ${name} No such attribute.`;
  //     return false;
  //   }
  //   model.context.disableVertexAttribArray(location);
  //   return true;
  // };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ShaderProgram_DEFAULT_VALUES = {
  vertexShaderHandle: 0,
  fragmentShaderHandle: 0,
  geometryShaderHandle: 0,
  vertexShader: null,
  fragmentShader: null,
  geometryShader: null,
  linked: false,
  bound: false,
  compiled: false,
  error: '',
  handle: 0,
  numberOfOutputs: 0,
  attributesLocs: null,
  uniformLocs: null,
  md5Hash: 0,
  context: null,
  lastCameraMTime: null
};

// ----------------------------------------------------------------------------

function ShaderProgram_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ShaderProgram_DEFAULT_VALUES, initialValues);

  // Instantiate internal objects
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtkShader$1.newInstance();
  model.vertexShader.setShaderType('Vertex');
  model.fragmentShader = vtkShader$1.newInstance();
  model.fragmentShader.setShaderType('Fragment');
  model.geometryShader = vtkShader$1.newInstance();
  model.geometryShader.setShaderType('Geometry');

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['lastCameraMTime']);
  macros2.m.setGet(publicAPI, model, ['error', 'handle', 'compiled', 'bound', 'md5Hash', 'vertexShader', 'fragmentShader', 'geometryShader', 'linked']);

  // Object methods
  vtkShaderProgram(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ShaderProgram_newInstance = macros2.m.newInstance(ShaderProgram_extend, 'vtkShaderProgram');

// ----------------------------------------------------------------------------

var vtkShaderProgram$1 = {
  newInstance: ShaderProgram_newInstance,
  extend: ShaderProgram_extend,
  substitute
};




/***/ }),

/***/ 92530:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkSkybox)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42008);
/* harmony import */ var _Helper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71650);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25196);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1013);
/* harmony import */ var _Core_Property_Constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71995);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(88691);









const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.c;

// ----------------------------------------------------------------------------
// vtkOpenGLSkybox methods
// ----------------------------------------------------------------------------

function vtkOpenGLSkybox(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLSkybox');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOpaqueActorCount();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass && !model._openGLRenderer.getSelector()) {
      publicAPI.updateBufferObjects();
      model.context.depthMask(true);
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());
      model.openGLTexture.render(model._openGLRenderWindow);
      const texUnit = model.openGLTexture.getTextureUnit();
      model.tris.getProgram().setUniformi('sbtexture', texUnit);
      const ren = model._openGLRenderer.getRenderable();
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const imat = new Float64Array(16);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(imat, keyMats.wcpc);
      model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);
      if (model.lastFormat === 'box') {
        const camPos = ren.getActiveCamera().getPosition();
        model.tris.getProgram().setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);
      }
      model.tris.getVAO().bind();

      // draw polygons
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
      model.openGLTexture.deactivate();
    }
  };
  publicAPI.updateBufferObjects = () => {
    // build the VBO if needed, only happens once
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1.0;
        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
        ptsArray[i * 3 + 2] = 1.0;
      }
      const points = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, 'polys', _Core_Property_Constants_js__WEBPACK_IMPORTED_MODULE_6__/* .Representation */ .YL.SURFACE, {
        points,
        cellOffset: 0
      });
    }

    // update the program?
    if (model.renderable.getFormat() !== model.lastFormat) {
      model.lastFormat = model.renderable.getFormat();
      if (model.lastFormat === 'box') {
        // we invert Y below because opengl is messed up!
        // Cube Maps have been specified to follow the RenderMan
        // specification (for whatever reason), and RenderMan
        // assumes the images' origin being in the upper left,
        // contrary to the usual OpenGL behaviour of having the
        // image origin in the lower left. That's why things get
        // swapped in the Y direction. It totally breaks with the usual
        // OpenGL semantics and doesn't make sense at all.
        // But now we're stuck with it.  From
        // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping
        //
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, ''));
      }
      if (model.lastFormat === 'background') {
        // maps the texture to the window
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, ''));
      }
      model.tris.getShaderSourceTime().modified();
      model.tris.getVAO().bind();
      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), 'vertexMC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
        vtkErrorMacro('Error setting vertexMC in shader VAO.');
      }
    }

    // set/update the texture map if needed
    const tmaps = model.renderable.getTextures();
    if (!tmaps.length) {
      vtkErrorMacro('vtkSkybox requires a texture map');
    }
    if (model.openGLTexture.getRenderable() !== tmaps[0]) {
      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.openGLTexture.setRenderable(tmaps[0]);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.openGLTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].newInstance */ .Ay.newInstance();
  model.tris = _Helper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(new Float64Array(9)),
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16))
  };

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.g)(publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLSkybox(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend);

// ----------------------------------------------------------------------------

var vtkSkybox = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_7__/* .registerOverride */ .c9)('vtkSkybox', newInstance);




/***/ }),

/***/ 1013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkOpenGLTexture$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _Texture_Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52271);
/* harmony import */ var _Common_Core_HalfFloat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97888);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42008);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16632);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(88691);








const {
  Wrap,
  Filter
} = _Texture_Constants_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay;
const {
  VtkDataTypes
} = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay;
const {
  vtkDebugMacro,
  vtkErrorMacro,
  vtkWarningMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_2__.c;
const {
  toHalf
} = _Common_Core_HalfFloat_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A;

// ----------------------------------------------------------------------------
// vtkOpenGLTexture methods
// ----------------------------------------------------------------------------

function vtkOpenGLTexture(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLTexture');
  // Renders myself
  publicAPI.render = function () {
    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (renWin) {
      model._openGLRenderWindow = renWin;
    } else {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      // sync renderable properties
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
    }
    model.context = model._openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter.NEAREST);
      publicAPI.setMagnificationFilter(Filter.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap.REPEAT);
      publicAPI.setWrapS(Wrap.REPEAT);
      publicAPI.setWrapT(Wrap.REPEAT);
    }
    // clear image if input data is set
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    // create the texture if it is not done already
    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
      // if we have an Image
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        // Have an Image which may not be complete
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      // if we have a canvas
      if (model.renderable.getCanvas() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        const canvas = model.renderable.getCanvas();
        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      // if we have jsImageData
      if (model.renderable.getJsImageData() !== null) {
        const jsid = model.renderable.getJsImageData();
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      // if we have InputData
      const input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();

        // do we have a cube map? Six inputs
        const data = [];
        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
          const indata = model.renderable.getInputData(i);
          const scalars = indata ? indata.getPointData().getScalars().getData() : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);
        } else {
          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.destroyTexture = () => {
    // deactivate it first
    publicAPI.deactivate();
    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };

  //----------------------------------------------------------------------------
  publicAPI.createTexture = () => {
    // reuse the existing handle if we have one
    if (!model.handle) {
      model.handle = model.context.createTexture();
      if (model.target) {
        model.context.bindTexture(model.target, model.handle);

        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture
        // turn off mip map filter or set the base and max level correctly. here
        // both are done.
        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
        if (model._openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
        }
        model.context.bindTexture(model.target, null);
      }
    }
  };

  //---------------------------------------------------------------------------
  publicAPI.getTextureUnit = () => {
    if (model._openGLRenderWindow) {
      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };

  //---------------------------------------------------------------------------
  publicAPI.activate = () => {
    // activate a free texture unit for this texture
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };

  //---------------------------------------------------------------------------
  publicAPI.deactivate = () => {
    if (model._openGLRenderWindow) {
      model._openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };

  //---------------------------------------------------------------------------
  publicAPI.releaseGraphicsResources = rwin => {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
      model.allocatedGPUMemoryInBytes = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.bind = () => {
    model.context.bindTexture(model.target, model.handle);
    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
      publicAPI.sendParameters();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.isBound = () => {
    let result = false;
    if (model.context && model.handle) {
      let target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro('impossible case');
          break;
      }
      const oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };

  //----------------------------------------------------------------------------
  publicAPI.sendParameters = () => {
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
    }
    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
    }

    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);
    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);

    model.sendParametersTime.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.getInternalFormat = (vtktype, numComps) => {
    if (!model._forceInternalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
    }
    if (!model.internalFormat) {
      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension('OES_texture_float_linear')) {
      vtkWarningMacro('Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.');
    }
    return model.internalFormat;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {
    let result = 0;
    // try default next
    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, model.oglNorm16Ext, publicAPI.useHalfFloat());
    if (result) {
      return result;
    }
    if (!result) {
      vtkDebugMacro('Unsupported internal texture type!');
      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    return result;
  };
  publicAPI.useHalfFloat = () => model.enableHalfFloat && model.canUseHalfFloat;

  //----------------------------------------------------------------------------
  publicAPI.setInternalFormat = iFormat => {
    model._forceInternalFormat = true;
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getFormat = (vtktype, numComps) => {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultFormat = (vtktype, numComps) => {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      // webgl1
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.resetFormatAndType = () => {
    model.format = 0;
    model.internalFormat = 0;
    model._forceInternalFormat = false;
    model.openGLDataType = 0;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultDataType = vtkScalarType => {
    const useHalfFloat = publicAPI.useHalfFloat();
    // DON'T DEAL with VTK_CHAR as this is platform dependent.
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        // case VtkDataTypes.SIGNED_CHAR:
        //   return model.context.BYTE;
        case VtkDataTypes.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        // prefer norm16 since that is accurate compared to
        // half float which is not
        case model.oglNorm16Ext && !useHalfFloat && VtkDataTypes.SHORT:
          return model.context.SHORT;
        case model.oglNorm16Ext && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:
          return model.context.UNSIGNED_SHORT;
        // use half float type
        case useHalfFloat && VtkDataTypes.SHORT:
          return model.context.HALF_FLOAT;
        case useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:
          return model.context.HALF_FLOAT;
        // case VtkDataTypes.INT:
        //   return model.context.INT;
        // case VtkDataTypes.UNSIGNED_INT:
        //   return model.context.UNSIGNED_INT;
        case VtkDataTypes.FLOAT:
        case VtkDataTypes.VOID: // used for depth component textures.
        default:
          return model.context.FLOAT;
      }
    }
    switch (vtkScalarType) {
      // case VtkDataTypes.SIGNED_CHAR:
      //   return model.context.BYTE;
      case VtkDataTypes.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      // case VtkDataTypes.SHORT:
      //   return model.context.SHORT;
      // case VtkDataTypes.UNSIGNED_SHORT:
      //   return model.context.UNSIGNED_SHORT;
      // case VtkDataTypes.INT:
      //   return model.context.INT;
      // case VtkDataTypes.UNSIGNED_INT:
      //   return model.context.UNSIGNED_INT;
      case VtkDataTypes.FLOAT:
      case VtkDataTypes.VOID: // used for depth component textures.
      default:
        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {
          return model.context.FLOAT;
        }
        {
          const halfFloat = model.context.getExtension('OES_texture_half_float');
          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {
            return halfFloat.HALF_FLOAT_OES;
          }
        }
        return model.context.UNSIGNED_BYTE;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLDataType = function (vtkScalarType) {
    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!model.openGLDataType || forceUpdate) {
      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);
    }
    return model.openGLDataType;
  };
  publicAPI.getShiftAndScale = () => {
    let shift = 0.0;
    let scale = 1.0;

    // for all float type internal formats
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale = 127.5;
        shift = scale - 128.0;
        break;
      case model.context.UNSIGNED_BYTE:
        scale = 255.0;
        shift = 0.0;
        break;
      case model.context.SHORT:
        scale = 32767.5;
        shift = scale - 32768.0;
        break;
      case model.context.UNSIGNED_SHORT:
        scale = 65536.0;
        shift = 0.0;
        break;
      case model.context.INT:
        scale = 2147483647.5;
        shift = scale - 2147483648.0;
        break;
      case model.context.UNSIGNED_INT:
        scale = 4294967295.0;
        shift = 0.0;
        break;
      case model.context.FLOAT:
    }
    return {
      shift,
      scale
    };
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLFilterMode = emode => {
    switch (emode) {
      case Filter.NEAREST:
        return model.context.NEAREST;
      case Filter.LINEAR:
        return model.context.LINEAR;
      case Filter.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLWrapMode = vtktype => {
    switch (vtktype) {
      case Wrap.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap.REPEAT:
        return model.context.REPEAT;
      case Wrap.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };

  /**
   * Updates the data array to match the required data type for OpenGL.
   *
   * This function takes the input data and converts it to the appropriate
   * format required by the OpenGL texture, based on the specified data type.
   *
   * @param {string} dataType - The original data type of the input data.
   * @param {Array} data - The input data array that needs to be updated.
   * @param {boolean} [depth=false] - Indicates whether the data is a 3D array.
   * @returns {Array} The updated data array that matches the OpenGL data type.
   */
  publicAPI.updateArrayDataTypeForGL = function (dataType, data) {
    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const pixData = [];
    let pixCount = model.width * model.height * model.components;
    if (depth) {
      pixCount *= model.depth;
    }

    // if the opengl data type is float
    // then the data array must be float
    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
          pixData.push(new Float32Array(dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }

    // if the opengl data type is ubyte
    // then the data array must be u8, we currently simply truncate the data
    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
          pixData.push(new Uint8Array(dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }

    // if the opengl data type is half float
    // then the data array must be u16
    let halfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension('OES_texture_half_float');
      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    if (halfFloat) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          const newArray = new Uint16Array(pixCount);
          const src = data[idx];
          for (let i = 0; i < pixCount; i++) {
            newArray[i] = toHalf(src[i]);
          }
          pixData.push(newArray);
        } else {
          pixData.push(null);
        }
      }
    }

    // The output has to be filled
    if (pixData.length === 0) {
      for (let i = 0; i < data.length; i++) {
        pixData.push(data[i]);
      }
    }
    return pixData;
  };

  //----------------------------------------------------------------------------
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model._openGLRenderWindow.getWebgl2()) {
      // No need if webGL2
      return data;
    }
    const pixData = [];
    const width = model.width;
    const height = model.height;
    const numComps = model.components;
    if (data && (!(0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.T)(width) || !(0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.T)(height))) {
      // Scale up the texture to the next highest power of two dimensions.
      const halfFloat = model.context.getExtension('OES_texture_half_float');
      const newWidth = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.P)(width);
      const newHeight = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.P)(height);
      const pixCount = newWidth * newHeight * model.components;
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx] !== null) {
          let newArray = null;
          const jFactor = height / newHeight;
          const iFactor = width / newWidth;
          let usingHalf = false;
          if (model.openGLDataType === model.context.FLOAT) {
            newArray = new Float32Array(pixCount);
          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
            newArray = new Uint16Array(pixCount);
            usingHalf = true;
          } else {
            newArray = new Uint8Array(pixCount);
          }
          for (let j = 0; j < newHeight; j++) {
            const joff = j * newWidth * numComps;
            const jidx = j * jFactor;
            let jlow = Math.floor(jidx);
            let jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            const jmix = jidx - jlow;
            const jmix1 = 1.0 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (let i = 0; i < newWidth; i++) {
              const ioff = i * numComps;
              const iidx = i * iFactor;
              let ilow = Math.floor(iidx);
              let ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              const imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (let c = 0; c < numComps; c++) {
                if (usingHalf) {
                  newArray[joff + ioff + c] = _Common_Core_HalfFloat_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.toHalf(_Common_Core_HalfFloat_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + _Common_Core_HalfFloat_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + _Common_Core_HalfFloat_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + _Common_Core_HalfFloat_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                } else {
                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                }
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }

    // The output has to be filled
    if (pixData.length === 0) {
      for (let i = 0; i < data.length; i++) {
        pixData.push(data[i]);
      }
    }
    return pixData;
  }

  //----------------------------------------------------------------------------
  function useTexStorage(dataType) {
    if (model._openGLRenderWindow) {
      if (model.resizable || model.renderable?.getResizable()) {
        // Cannot use texStorage if the texture is supposed to be resizable.
        return false;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const webGLInfo = model._openGLRenderWindow.getGLInformations();
        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && model.oglNorm16Ext && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {
          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.
          // No errors reported but the texture is unusable.
          return false;
        }
        // Use texStorage for WebGL2
        return true;
      }
      return false;
    }
    return false;
  }

  //----------------------------------------------------------------------------
  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {
    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType, true);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Create an array of texture with one texture
    const dataArray = [data];
    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

    // Source texture data from the PBO.
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (scaledData[0] != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }

    // always reset the flip
    if (flip) {
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();
    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

    // invert the data because opengl is messed up with cube maps
    // and uses the old renderman standard with Y going down
    // even though it is completely at odds with OpenGL standards
    const invertedData = [];
    let widthLevel = model.width;
    let heightLevel = model.height;
    for (let i = 0; i < scaledData.length; i++) {
      if (i % 6 === 0 && i !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i] = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.a)(dataType, heightLevel * widthLevel * model.components);
      for (let y = 0; y < heightLevel; ++y) {
        const row1 = y * widthLevel * model.components;
        const row2 = (heightLevel - y - 1) * widthLevel * model.components;
        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
      }
    }

    // Source texture data from the PBO.
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);
    }
    // We get the 6 images
    for (let i = 0; i < 6; i++) {
      // For each mipmap level
      let j = 0;
      let w = model.width;
      let h = model.height;
      while (w >= 1 && h >= 1) {
        // In webgl 1, all levels need to be defined. So if the latest level size is
        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)
        // In webgl 2, the attribute maxLevel will be use.
        let tempData = null;
        if (j <= model.maxLevel) {
          tempData = invertedData[6 * j + i];
        }
        if (useTexStorage(dataType)) {
          if (tempData != null) {
            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);
          }
        } else {
          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
        }
        j++;
        w /= 2;
        h /= 2;
      }
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());
    // generateMipmap must not be called here because we manually upload all levels
    // if it is called, all levels will be overwritten

    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (data != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.create2DFromImage = image => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.
    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!(0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.T)(image.width) || !(0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.T)(image.height));
    const canvas = document.createElement('canvas');
    canvas.width = needNearestPowerOfTwo ? (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.P)(image.width) : image.width;
    canvas.height = needNearestPowerOfTwo ? (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.P)(image.height) : image.height;
    model.width = canvas.width;
    model.height = canvas.height;
    const ctx = canvas.getContext('2d');
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
    const safeImage = canvas;
    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (safeImage != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, model.oglNorm16Ext, publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };

  // Compute scale and offset per component from min and max per component
  function computeScaleOffsets(min, max, numComps) {
    const offset = new Array(numComps);
    const scale = new Array(numComps);
    for (let c = 0; c < numComps; ++c) {
      offset[c] = min[c];
      scale[c] = max[c] - min[c] || 1.0;
    }
    return {
      scale,
      offset
    };
  }

  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,
  // for numbers outside of this range there is a precision limitation
  function hasExactHalfFloat(offset, scale) {
    // Per Component
    for (let c = 0; c < offset.length; c++) {
      const min = offset[c];
      const max = scale[c] + min;
      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {
        return false;
      }
    }
    return true;
  }
  function setCanUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {
    publicAPI.getOpenGLDataType(dataType);
    let useHalfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      useHalfFloat = model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension('OES_texture_half_float');
      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }

    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat
    // AND it is not preferable to have a smaller texture than an exact texture.
    const isHalfFloat = useHalfFloat && (hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy);
    model.canUseHalfFloat = isHalfFloat;
  }
  function processDataArray(dataArray, preferSizeOverAccuracy) {
    const numComps = dataArray.getNumberOfComponents();
    const dataType = dataArray.getDataType();
    const data = dataArray.getData();

    // Compute min max from array
    // Using the vtkDataArray.getRange() enables caching
    const minArray = new Array(numComps);
    const maxArray = new Array(numComps);
    for (let c = 0; c < numComps; ++c) {
      const [min, max] = dataArray.getRange(c);
      minArray[c] = min;
      maxArray[c] = max;
    }
    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);

    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247
    setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);

    // since our default is to use half float, in case that we can't use it
    // we need to use another type
    if (!publicAPI.useHalfFloat()) {
      publicAPI.getOpenGLDataType(dataType, true);
    }
    return {
      numComps,
      dataType,
      data,
      scaleOffsets
    };
  }
  publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {
    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    return publicAPI.create2DFilterableFromDataArray(width, height, _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
      numberOfComponents,
      dataType,
      values
    }), preferSizeOverAccuracy);
  };
  publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {
    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const {
      numComps,
      dataType,
      data
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);
  };
  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {
    let isScalingApplied = false;
    const useHalfFloat = publicAPI.useHalfFloat();

    // Initialize volume info if it doesn't exist
    if (!model.volumeInfo?.scale || !model.volumeInfo?.offset) {
      model.volumeInfo = {
        scale: new Array(numComps),
        offset: new Array(numComps)
      };
    }

    // Default scaling and offset
    for (let c = 0; c < numComps; ++c) {
      model.volumeInfo.scale[c] = 1.0;
      model.volumeInfo.offset[c] = 0.0;
    }

    // Handle SHORT data type with EXT_texture_norm16 extension
    if (model.oglNorm16Ext && !useHalfFloat && dataType === VtkDataTypes.SHORT) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 32767.0; // Scale to [-1, 1] range
      }

      isScalingApplied = true;
    }

    // Handle UNSIGNED_SHORT data type with EXT_texture_norm16 extension
    if (model.oglNorm16Ext && !useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 65535.0; // Scale to [0, 1] range
      }

      isScalingApplied = true;
    }

    // Handle UNSIGNED_CHAR data type
    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 255.0; // Scale to [0, 1] range
      }

      isScalingApplied = true;
    }

    // No scaling needed for FLOAT or HalfFloat (SHORT/UNSIGNED_SHORT)
    if (dataType === VtkDataTypes.FLOAT || useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {
      isScalingApplied = true;
    }
    return isScalingApplied;
  };

  //----------------------------------------------------------------------------
  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {
    let dataTypeToUse = dataType;
    let dataToUse = data;
    if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {
      const numPixelsIn = width * height * depth;
      const scaleOffsetsCopy = structuredClone(model.volumeInfo);
      // otherwise convert to float
      const newArray = new Float32Array(numPixelsIn * numComps);
      // use computed scale and offset
      model.volumeInfo.offset = scaleOffsetsCopy.offset;
      model.volumeInfo.scale = scaleOffsetsCopy.scale;
      let count = 0;
      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);
      for (let i = 0; i < numPixelsIn; i++) {
        for (let nc = 0; nc < numComps; nc++) {
          newArray[count] = (dataToUse[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];
          count++;
        }
      }
      dataTypeToUse = VtkDataTypes.FLOAT;
      dataToUse = newArray;
    }

    // Permit OpenGLDataType to be half float, if applicable, for 3D
    publicAPI.getOpenGLDataType(dataTypeToUse);

    // Now determine the texture parameters using the arguments.
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    // Create an array of texture with one texture
    const dataArray = [dataToUse];
    const is3DArray = true;
    const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    // openGLDataType

    if (useTexStorage(dataTypeToUse)) {
      model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);
      if (scaledData[0] != null) {
        model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);
      }
    } else {
      model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, model.oglNorm16Ext, publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  // This method simulates a 3D texture using 2D
  // Prefer create3DFilterableFromDataArray to enable caching of min and max values
  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {
    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    return publicAPI.create3DFilterableFromDataArray(width, height, depth, _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
      numberOfComponents,
      dataType,
      values
    }), preferSizeOverAccuracy);
  };

  //----------------------------------------------------------------------------
  // This method create a 3D texture from dimensions and a DataArray
  publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {
    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    const {
      numComps,
      dataType,
      data,
      scaleOffsets
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    const offset = [];
    const scale = [];
    for (let c = 0; c < numComps; ++c) {
      offset[c] = 0.0;
      scale[c] = 1.0;
    }

    // store the information, we will need it later
    // offset and scale are the offset and scale required to get
    // the texture value back to data values ala
    // data = texture * scale + offset
    // and texture = (data - offset)/scale
    model.volumeInfo = {
      scale,
      offset,
      dataComputedScale: scaleOffsets.scale,
      dataComputedOffset: scaleOffsets.offset,
      width,
      height,
      depth
    };

    // Create a copy of scale and offset to avoid aliasing issues
    // Original is read only, copy is read/write
    // Use the copy as volumeInfo.scale and volumeInfo.offset

    // WebGL2 path, we have 3d textures etc
    if (model._openGLRenderWindow.getWebgl2()) {
      return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
    }
    const numPixelsIn = width * height * depth;
    const scaleOffsetsCopy = structuredClone(scaleOffsets);

    // not webgl2, deal with webgl1, no 3d textures
    // and maybe no float textures

    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {
      outArray[outIdx] = inValue;
    };
    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;
    // unsigned char gets used as is
    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {
      for (let c = 0; c < numComps; ++c) {
        scaleOffsetsCopy.offset[c] = 0.0;
        scaleOffsetsCopy.scale[c] = 255.0;
      }
    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {
      // use float textures scaled to 0.0 to 1.0
      dataTypeToUse = VtkDataTypes.FLOAT;
      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {
        outArray[outIdx] = (inValue - soffset) / sscale;
      };
    } else {
      // worst case, scale data to uchar
      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;
      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {
        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;
      };
    }

    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }

    // have to pack this 3D texture into pot 2D texture
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;

    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,
    // but it doesn't mean it will fit in memory. If we have to use a float data type
    // or 4 components, there are good chances that the texture size will blow up
    // and could not fit in the GPU memory. Use a smaller texture size in that case,
    // which will force a downsampling of the dataset.
    // That problem does not occur when using webGL2 since we can pack the data in
    // denser textures based on our data type.
    // TODO: try to fit in the biggest supported texture, catch the gl error if it
    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture
    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {
      maxTexDim = 4096;
    }

    // compute estimate for XY subsample
    let xstride = 1;
    let ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    let targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.P)(targetWidth);
    // determine X reps
    const xreps = Math.floor(targetWidth * xstride / width);
    const yreps = Math.ceil(depth / xreps);
    const targetHeight = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.P)(height * yreps / ystride);
    model.width = targetWidth;
    model.height = targetHeight;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // store the information, we will need it later
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = scaleOffsetsCopy.offset;
    model.volumeInfo.scale = scaleOffsetsCopy.scale;

    // OK stuff the data into the 2d TEXTURE

    // first allocate the new texture
    let newArray;
    const pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }

    // then stuff the data into it, nothing fancy right now
    // for stride
    let outIdx = 0;
    const tileWidth = Math.floor(width / xstride);
    const tileHeight = Math.floor(height / ystride);
    for (let yRep = 0; yRep < yreps; yRep++) {
      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (let tileY = 0; tileY < tileHeight; tileY++) {
        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {
          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
          for (let tileX = 0; tileX < tileWidth; tileX++) {
            // copy value
            for (let nc = 0; nc < numComps; nc++) {
              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataTypeToUse)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (newArray != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getMaximumTextureSize = ctx => {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }
    return -1;
  };

  // set use half float
  publicAPI.enableUseHalfFloat = use => {
    model.enableUseHalfFloat = use;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  _openGLRenderWindow: null,
  _forceInternalFormat: false,
  context: null,
  handle: 0,
  sendParametersTime: null,
  textureBuildTime: null,
  numberOfDimensions: 0,
  target: 0,
  format: 0,
  openGLDataType: 0,
  components: 0,
  width: 0,
  height: 0,
  depth: 0,
  autoParameters: true,
  wrapS: Wrap.CLAMP_TO_EDGE,
  wrapT: Wrap.CLAMP_TO_EDGE,
  wrapR: Wrap.CLAMP_TO_EDGE,
  minificationFilter: Filter.NEAREST,
  magnificationFilter: Filter.NEAREST,
  minLOD: -1000.0,
  maxLOD: 1000.0,
  baseLevel: 0,
  maxLevel: 1000,
  generateMipmap: false,
  oglNorm16Ext: null,
  allocatedGPUMemoryInBytes: 0,
  // by default it is enabled
  enableUseHalfFloat: true,
  // but by default we don't know if we can use half float base on the data range
  canUseHalfFloat: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.sendParametersTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.o)(model.sendParametersTime, {
    mtime: 0
  });
  model.textureBuildTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.o)(model.textureBuildTime, {
    mtime: 0
  });

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.s)(publicAPI, model, ['format', 'openGLDataType']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.e)(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.g)(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.i)(publicAPI, model, ['openGLRenderWindow']);

  // Object methods
  vtkOpenGLTexture(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.n)(extend, 'vtkOpenGLTexture');

// ----------------------------------------------------------------------------

var vtkOpenGLTexture$1 = {
  newInstance,
  extend,
  ..._Texture_Constants_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_6__/* .registerOverride */ .c9)('vtkTexture', newInstance);




/***/ }),

/***/ 52271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants),
/* harmony export */   B_: () => (/* binding */ Wrap),
/* harmony export */   dJ: () => (/* binding */ Filter)
/* harmony export */ });
const Wrap = {
  CLAMP_TO_EDGE: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};
const Filter = {
  NEAREST: 0,
  LINEAR: 1,
  NEAREST_MIPMAP_NEAREST: 2,
  NEAREST_MIPMAP_LINEAR: 3,
  LINEAR_MIPMAP_NEAREST: 4,
  LINEAR_MIPMAP_LINEAR: 5
};
var Constants = {
  Wrap,
  Filter
};




/***/ }),

/***/ 13926:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkVertexArrayObject)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60003);



// ----------------------------------------------------------------------------
// vtkOpenGLVertexArrayObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLVertexArrayObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVertexArrayObject');

  // Public API methods
  publicAPI.exposedMethod = () => {
    // This is a publicly exposed method of this object
  };
  publicAPI.initialize = () => {
    model.instancingExtension = null;
    if (!model._openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');
    }
    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension('OES_vertex_array_object');
      // Start setting up VAO
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };
  publicAPI.isReady = () =>
  // We either probed and allocated a VAO, or are falling back as the current
  // hardware does not support VAOs.
  model.handleVAO !== 0 || model.supported === false;
  publicAPI.bind = () => {
    // Either simply bind the VAO, or emulate behavior by binding all attributes.
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 1);
              }
            }
          }
        }
      }
    }
  };
  publicAPI.release = () => {
    // Either simply release the VAO, or emulate behavior by releasing all attributes.
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i);
          }
        }
      }
    }
  };
  publicAPI.shaderProgramChanged = () => {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };
  publicAPI.releaseGraphicsResources = () => {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };
  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);
  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) => {
    if (!program) {
      return false;
    }

    // Check the program is bound, and the buffer is valid.
    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== _BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType */ .a.ARRAY_BUFFER) {
      return false;
    }

    // Perform initialization if necessary, ensure program matches VAOs.
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }
    const gl = model.context;
    const attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;
    if (attribs.Index === -1) {
      return false;
    }

    // Always make the call as even the first use wants the attrib pointer setting
    // up when we are emulating.
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }
    attribs.buffer = buffer.getHandle();

    // If vertex array objects are not supported then build up our list.
    if (!model.supported) {
      // find the buffer
      let buffFound = false;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          let found = false;
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({
          buffer: attribs.buffer,
          attributes: [attribs]
        });
      }
    }
    return true;
  };
  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) => {
    // bind the first row of values
    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);
    if (!result) {
      return result;
    }
    const gl = model.context;
    const index = gl.getAttribLocation(model.handleProgram, name);
    for (let i = 1; i < elementTupleSize; i++) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);
        } else {
          gl.vertexAttribDivisor(index + i, 1);
        }
      }
    }
    return true;
  };
  publicAPI.removeAttributeArray = name => {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }

    // If we don't have real VAOs find the entry and remove it too.
    if (!model.supported) {
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }
    return true;
  };
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  forceEmulation: false,
  handleVAO: 0,
  handleProgram: 0,
  supported: true,
  buffers: null,
  context: null
  // _openGLRenderWindow: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Internal objects initialization
  model.buffers = [];

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Create get-only macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['supported']);

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['forceEmulation']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkOpenGLVertexArrayObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkOpenGLVertexArrayObject');

// ----------------------------------------------------------------------------

var vtkVertexArrayObject = {
  newInstance,
  extend
};




/***/ }),

/***/ 88691:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkViewNodeFactory),
/* harmony export */   c9: () => (/* binding */ registerOverride)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84784);



const CLASS_MAPPING = Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}

// ----------------------------------------------------------------------------
// vtkOpenGLViewNodeFactory methods
// ----------------------------------------------------------------------------

function vtkOpenGLViewNodeFactory(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLViewNodeFactory');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Static class mapping shared across instances
  model.overrides = CLASS_MAPPING;

  // Inheritance
  _SceneGraph_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLViewNodeFactory(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkOpenGLViewNodeFactory');

// ----------------------------------------------------------------------------

var vtkViewNodeFactory = {
  newInstance,
  extend
};




/***/ }),

/***/ 8126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkVolume)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88691);





// ----------------------------------------------------------------------------
// vtkOpenGLVolume methods
// ----------------------------------------------------------------------------

function vtkOpenGLVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVolume');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };
  publicAPI.traverseVolumePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  // Renders myself
  publicAPI.volumePass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.MCWCMatrix, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.MCWCMatrix, model.MCWCMatrix);
      if (model.renderable.getIsIdentity()) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(model.normalMatrix);
      } else {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromMat4 */ .w0.fromMat4(model.normalMatrix, model.MCWCMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.invert */ .w0.invert(model.normalMatrix, model.normalMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.transpose */ .w0.transpose(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // context: null,
  // keyMatrixTime: null,
  // normalMatrix: null,
  // MCWCMatrix: null,
  // _openGLRenderWindow: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime, {
    mtime: 0
  });
  // always set by getter
  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16);

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLVolume(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend, 'vtkOpenGLVolume');

// ----------------------------------------------------------------------------

var vtkVolume = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkVolume', newInstance);




/***/ }),

/***/ 95785:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkVolumeMapper)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/fast-deep-equal/index.js
var fast_deep_equal = __webpack_require__(45043);
var fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var Constants = __webpack_require__(28914);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
var Framebuffer = __webpack_require__(32821);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var Texture = __webpack_require__(1013);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
var ReplacementShaderMapper = __webpack_require__(83534);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
var VertexArrayObject = __webpack_require__(13926);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Texture_Constants = __webpack_require__(52271);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js
var VolumeProperty_Constants = __webpack_require__(20433);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js
var VolumeMapper_Constants = __webpack_require__(67737);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
var resourceSharingHelper = __webpack_require__(90919);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js
var vtkVolumeVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n";



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js
var vtkVolumeFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define UseIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define vtkCustomComponentsColorMix\n//VTK::CustomComponentsColorMixOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// possibly define any components that are forced to nearest interpolation\n//VTK::vtkForceNearestComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Possibly define vtkLabelEdgeProjectionOn\n//VTK::LabelEdgeProjectionOn\n\n\n#ifdef vtkImageLabelOutlineOn\n  uniform float outlineOpacity;\n  uniform float vpWidth;\n  uniform float vpHeight;\n  uniform float vpOffsetX;\n  uniform float vpOffsetY;\n  uniform mat4 PCWCMatrix;\n  uniform mat4 vWCtoIDX;\n\n  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];\n  #define MAX_SEGMENTS 256\n  #define UINT_SIZE 32\n  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\n\n  uint bitmask[BITMASK_SIZE];\n\n  // Set the corresponding bit in the bitmask\n  void setBit(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    bitmask[index] |= 1u << bitIndex;\n  }\n\n  // Check if a bit is set in the bitmask\n  bool isBitSet(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    return ((bitmask[index] & (1u << bitIndex)) != 0u);\n  }\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#ifdef UseIndependentComponents\n#if vtkNumComponents > 1\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents > 2\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#if vtkNumComponents > 3\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\nuniform vec3 volumeSpacings; // spacing in the world coorindates\n\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef UseIndependentComponents\n#if vtkNumComponents == 1\nuniform float mix0;\n#define height0 0.5\n#endif\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);\n    vec4 nearestValue = texture(texture1, nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  #ifndef UseIndependentComponents\n    #if vtkNumComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n  #ifdef vtkClippingPlanesOn\n    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n    {\n      vec3 g1VC[3];\n      for (int i = 0; i < 3; ++i)\n      {\n        g1VC[i] = IStoVC(texPos[i]);\n      }\n      vec3 posVC = IStoVC(pos);\n      for (int i = 0; i < clip_numPlanes; ++i)\n      {\n        for (int j = 0; j < 3; ++j)\n        {\n          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n          {\n            g1[j] = 0.0;\n          }\n        }\n      }\n    }\n  #endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {\n      vec3 opacityG1, opacityG2;\n      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;\n      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;\n      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;\n      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;\n      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;\n      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;\n      opacityG1.xyz *= gradientOpacity;\n      opacityG2.xyz *= gradientOpacity;\n\n      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n      // divide by spacing\n      opacityG.xyz /= vSpacing;\n      opacityG.w = length(opacityG.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(opacityG.xyz);\n      if (!all(equal(opacityG.xyz, vec3(0.0)))) {\n        return vec4(normalize(opacityG.xyz),opacityG.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n\n    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)\n    {\n      vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n      vec3 yvec = vec3(0.0, tstep.y, 0.0);\n      vec3 zvec = vec3(0.0, 0.0, tstep.z);\n      vec3 texPosPVec[3];\n      texPosPVec[0] = pos + xvec;\n      texPosPVec[1] = pos + yvec;\n      texPosPVec[2] = pos + zvec;\n      vec3 texPosNVec[3];\n      texPosNVec[0] = pos - xvec;\n      texPosNVec[1] = pos - yvec;\n      texPosNVec[2] = pos - zvec;\n      vec3 g1, g2;\n\n      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];\n      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];\n      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];\n      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];\n      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];\n      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];\n\n      #ifdef vtkClippingPlanesOn\n        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n      #endif\n      vec4 result;\n      result.x = scalarInterp[0].x - scalarInterp[1].x;\n      result.y = scalarInterp[0].y - scalarInterp[1].y;\n      result.z = scalarInterp[0].z - scalarInterp[1].z;\n      // divide by spacing\n      result.xyz /= vSpacing;\n      result.w = length(result.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      if (length(result.xyz) > 0.0) {\n        return vec4(normalize(result.xyz),result.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n  #endif\n\n  // only works with dependent components\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n\n#ifdef vtkImageLabelOutlineOn\n  vec4 fragCoordToPCPos(vec4 fragCoord) {\n    return vec4(\n      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n      (fragCoord.z - 0.5) * 2.0,\n      1.0);\n  }\n\n  vec4 pcPosToWorldCoord(vec4 pcPos) {\n    return PCWCMatrix * pcPos;\n  }\n\n  vec3 fragCoordToIndexSpace(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    vec4 vertex = (worldCoord / worldCoord.w);\n\n    vec3 index = (vWCtoIDX * vertex).xyz;\n\n    // half voxel fix for labelmapOutline\n    return (index + vec3(0.5)) / vec3(volumeDimensions);\n  }\n\n  vec3 fragCoordToWorld(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    return worldCoord.xyz;\n  }\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)\n      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {\n  #if vtkLightComplexity > 0\n    // surface shadows if needed\n    #ifdef SurfaceShadowOn\n      #if vtkLightComplexity < 3\n        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);\n      #else\n        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));\n      #endif\n    #endif\n\n    // volume shadows if needed\n    #ifdef VolumeShadowOn\n      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);\n    #endif\n\n    // merge\n    #ifdef VolumeShadowOn\n      #ifdef SurfaceShadowOn\n        // surface shadows + volumetric shadows\n        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n      #else\n        // volumetric shadows only\n        tColor = tColorVS;\n      #endif\n    #else\n      #ifdef SurfaceShadowOn\n        // surface shadows only\n        tColor = tColorS;\n      #else\n        // no shadows\n        applyLighting(tColor, normal3);\n      #endif\n    #endif\n  #endif\n  return tColor;\n}\n\n  \nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n\n// If labeloutline and not the edge labelmap, since in the edge labelmap blend\n// we need the underlying data to sample through\n#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n\n  // If it is the background (segment index 0), we should quickly bail out. \n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0){\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n        gl_FragCoord.y + float(j),\n        gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = outlineOpacity;\n  }\n\n  return tColor;\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n\n  #ifdef UseIndependentComponents\n\n    // sample textures\n    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n\n    #if vtkNumComponents > 1\n      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n\n      #if vtkNumComponents > 2\n        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n\n        #if vtkNumComponents > 3\n          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #endif\n      #endif\n    #endif\n\n    #if !defined(vtkCustomComponentsColorMix)\n      // default path for component color mix\n\n      // compute the normal vectors as needed\n      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #endif\n\n      // compute gradient opacity factors as needed\n      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);\n      #if defined(vtkGradientOpacityOn)\n        #if !defined(vtkComponent0Proportional)\n          goFactor.x =\n            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n        #endif\n        #if vtkNumComponents > 1\n          #if !defined(vtkComponent1Proportional)\n            goFactor.y =\n              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          #endif\n          #if vtkNumComponents > 2\n            #if !defined(vtkComponent2Proportional)\n              goFactor.z =\n                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);\n            #endif\n            #if vtkNumComponents > 3\n              #if !defined(vtkComponent3Proportional)\n                goFactor.w =\n                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);\n              #endif\n            #endif\n          #endif\n        #endif\n      #endif\n\n      // process color and opacity for each component\n      #if !defined(vtkComponent0Proportional)\n        float alpha = goFactor.x*mix0*pwfValue0;\n        #if vtkLightComplexity > 0\n          applyLighting(tColor0, normalMat[0]);\n        #endif\n      #else\n        tColor0 *= pwfValue0;\n        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));\n      #endif\n\n      #if vtkNumComponents > 1\n        #if !defined(vtkComponent1Proportional)\n          alpha += goFactor.y*mix1*pwfValue1;\n          #if vtkLightComplexity > 0\n            applyLighting(tColor1, normalMat[1]);\n          #endif\n        #else\n          tColor1 *= pwfValue1;\n          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));\n        #endif\n\n        #if vtkNumComponents > 2\n          #if !defined(vtkComponent2Proportional)\n            alpha += goFactor.z*mix2*pwfValue2;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor2, normalMat[2]);\n            #endif\n          #else\n            tColor2 *= pwfValue2;\n            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));\n          #endif\n        #endif\n\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            alpha += goFactor.w*mix3*pwfValue3;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor3, normalMat[3]);\n            #endif\n          #else\n            tColor3 *= pwfValue3;\n            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));\n          #endif\n        #endif\n      #endif\n\n      // perform final independent blend\n      vec3 tColor = mix0 * tColor0;\n      #if vtkNumComponents > 1\n        tColor += mix1 * tColor1;\n        #if vtkNumComponents > 2\n          tColor += mix2 * tColor2;\n          #if vtkNumComponents > 3\n            tColor += mix3 * tColor3;\n          #endif\n        #endif\n      #endif\n\n      return vec4(tColor, alpha);\n    #else\n      /*\n       * Mix the color information from all the independent components to get a single rgba output\n       * Gradient opactity factors and normals are not computed\n       *\n       * You can compute these using:\n       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix\n       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),\n       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper\n       * - computeGradientOpacityFactor: always available, used in a lot of places\n       *\n       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)\n       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight\n       */\n      //VTK::CustomComponentsColorMix::Impl\n    #endif\n  #else\n    // dependent components\n\n    // compute normal if needed\n    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n      #endif\n    #endif\n\n    // compute gradient opacity factor enabled\n    #if defined(vtkGradientOpacityOn)\n      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #else\n      const float gradientOpacity = 1.0;\n    #endif\n\n    // get color and opacity\n    #if vtkNumComponents == 1\n      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      if (alpha < EPSILON){\n        return vec4(0.0);\n      }\n    #endif\n    #if vtkNumComponents == 2\n      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 3\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 4\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n    #endif\n\n    // lighting\n    #if (vtkLightComplexity > 0)\n      #ifdef vtkComputeNormalFromOpacity\n        vec4 normalLight;\n        if (!all(equal(normal0, vec4(0.0)))) {\n          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;\n          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;\n          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);\n          if (all(equal(normalLight, vec4(0.0)))) {\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normalLight = normal0;\n      #endif\n      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);\n    #endif\n\n    return vec4(tColor, alpha);\n  #endif // dependent\n#endif\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #else\n    #ifdef UseIndependentComponents\n      #if vtkNumComponents == 2\n        if (val.r >= min.r && val.r <= max.r &&\n            val.g >= min.g && val.g <= max.g) {\n          withinRange = true;\n        }\n      #else\n        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n            all(lessThanEqual(val, ipScalarRangeMax))) {\n          withinRange = true;\n        }\n      #endif\n    #endif\n  #endif\n  return withinRange;\n}\n\n#if vtkBlendMode == 6 \nbool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    bool justSawIt = false;\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n\n    float stepsTraveled = 0.0;\n\n\n    // float neighborValue;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS += stepIS;\n    }\n\n    if (justSawIt){\n      return false;\n    }\n\n   \n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS -= stepIS;\n    }\n\n\n    if (!justSawIt) {\n        // onedge\n        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;\n        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;\n        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n        return true;\n    }\n\n    // not on edge\n    return false;\n}\n\n#endif\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // Initialize arrays to false\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n  \n  #if vtkBlendMode == 6 \n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    uint bitmask = 0u;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading \n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the segment index\n      // and later check if the bit is set via bit operations\n      setBit(segmentIndex);\n    }\n    \n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value =  tValue; // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue; // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }  \n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);\n      return;\n    }\n\n    // probably we can make this configurable but for now we will use the same\n    // sample distance as the original sample distance\n    float neighborSampleDistanceIS = sampleDistanceIS;\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not \n      // been seen by the center segment\n      if (!isBitSet(s)) {\n       continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have \n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out \n      // faster if we find the edge\n      bool onEdge =\n          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than \n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety \n      // of the all the fragments inside. i.e., this happens when we zoom out, \n      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n      \n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n            for (int j = -actualThickness; j <= actualThickness; j++) {\n                if (i == 0 && j == 0) continue; // Skip the center\n                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners\n                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {\n                    return;\n                }\n          }\n      }\n    }\n\n    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n";



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js






















const {
  vtkWarningMacro,
  vtkErrorMacro
} = macros2.c;

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function getColorCodeFromPreset(colorMixPreset) {
  switch (colorMixPreset) {
    case VolumeProperty_Constants/* ColorMixPreset */.dM.CUSTOM:
      return '//VTK::CustomColorMix';
    case VolumeProperty_Constants/* ColorMixPreset */.dM.ADDITIVE:
      return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);

          vec3 scalarInterp1[2];
          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);
          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;
          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;
          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
          vec4 normalLight1 = normalMat[1];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        float opacity1 = pwfValue1;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          opacity1 *= gof1;
        #endif
        float opacitySum = opacity0 + opacity1;
        if (opacitySum <= 0.0) {
          return vec4(0.0);
        }

        // mix the colors and opacities
        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);
        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);
        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;
        return vec4(mixedColor, min(1.0, opacitySum));
`;
    case VolumeProperty_Constants/* ColorMixPreset */.dM.COLORIZE:
      return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
        #endif

        // mix the colors and opacities
        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);
        color = applyAllLightning(color, opacity0, posIS, normalLight0);
        return vec4(color, opacity0);
`;
    default:
      return null;
  }
}

// ----------------------------------------------------------------------------
// vtkOpenGLVolumeMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLVolumeMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVolumeMapper');
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._scalarOpacityFunc, model._colorTransferFunc, model._labelOutlineThicknessArray].forEach(coreObject => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = () => {
    model.zBufferTexture = null;
  };

  // ohh someone is doing a zbuffer pass, use that for
  // intermixed volume rendering
  publicAPI.zBufferPass = (prepass, renderPass) => {
    if (prepass) {
      const zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.zBufferPass(prepass, renderPass);

  // Renders myself
  publicAPI.volumePass = (prepass, renderPass) => {
    if (prepass) {
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        // Unregister the mapper when the render window changes
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLVolume = publicAPI.getFirstAncestorOfType('vtkOpenGLVolume');
      const actor = model.openGLVolume.getRenderable();
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      publicAPI.renderPiece(ren, actor);
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkVolumeVS;
    shaders.Fragment = vtkVolumeFS;
    shaders.Geometry = '';
  };
  publicAPI.useIndependentComponents = actorProperty => {
    const iComps = actorProperty.getIndependentComponents();
    const image = model.currentInput;
    const numComp = image?.getPointData()?.getScalars()?.getNumberOfComponents();
    const colorMixPreset = actorProperty.getColorMixPreset();
    return iComps && numComp >= 2 || !!colorMixPreset;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    const actorProps = actor.getProperty();
    let FSSource = shaders.Fragment;

    // define some values in the shader
    const iType = actorProps.getInterpolationType();
    if (iType === VolumeProperty_Constants/* InterpolationType */.VO.LINEAR) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TrilinearOn', '#define vtkTrilinearOn').result;
    }
    const vtkImageLabelOutline = publicAPI.isLabelmapOutlineRequired(actor);
    if (vtkImageLabelOutline === true) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;
    }
    const LabelEdgeProjection = model.renderable.getBlendMode() === VolumeMapper_Constants/* BlendMode */.Nx.LABELMAP_EDGE_PROJECTION_BLEND;
    if (LabelEdgeProjection) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::LabelEdgeProjectionOn', '#define vtkLabelEdgeProjectionOn').result;
    }
    const numComp = model.scalarTexture.getComponents();
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::NumComponents', `#define vtkNumComponents ${numComp}`).result;
    const useIndependentComps = publicAPI.useIndependentComponents(actorProps);
    if (useIndependentComps) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::IndependentComponentsOn', '#define UseIndependentComponents').result;
    }

    // Define any proportional components
    const proportionalComponents = [];
    const forceNearestComponents = [];
    for (let nc = 0; nc < numComp; nc++) {
      if (actorProps.getOpacityMode(nc) === VolumeProperty_Constants/* OpacityMode */.tE.PROPORTIONAL) {
        proportionalComponents.push(`#define vtkComponent${nc}Proportional`);
      }
      if (actorProps.getForceNearestInterpolation(nc)) {
        forceNearestComponents.push(`#define vtkComponent${nc}ForceNearest`);
      }
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::vtkProportionalComponents', proportionalComponents.join('\n')).result;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::vtkForceNearestComponents', forceNearestComponents.join('\n')).result;
    const colorMixPreset = actorProps.getColorMixPreset();
    const colorMixCode = getColorCodeFromPreset(colorMixPreset);
    if (colorMixCode) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::CustomComponentsColorMixOn', '#define vtkCustomComponentsColorMix').result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::CustomComponentsColorMix::Impl', colorMixCode).result;
    }

    // WebGL only supports loops over constants
    // and does not support while loops so we
    // have to hard code how many steps/samples to take
    // We do a break so most systems will gracefully
    // early terminate, but it is always possible
    // a system will execute every step regardless
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    esm/* vec3.set */.eR.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    const maxSamples = esm/* vec3.length */.eR.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::MaximumSamplesValue', `${Math.ceil(maxSamples)}`).result;

    // set light complexity
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::LightComplexity', `#define vtkLightComplexity ${model.lightComplexity}`).result;

    // set shadow blending flag
    if (model.lightComplexity > 0) {
      if (model.renderable.getVolumetricScatteringBlending() > 0.0) {
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::VolumeShadowOn', `#define VolumeShadowOn`).result;
      }
      if (model.renderable.getVolumetricScatteringBlending() < 1.0) {
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::SurfaceShadowOn', `#define SurfaceShadowOn`).result;
      }
      if (model.renderable.getLocalAmbientOcclusion() && actorProps.getAmbient() > 0.0) {
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::localAmbientOcclusionOn', `#define localAmbientOcclusionOn`).result;
      }
    }

    // if using gradient opacity define that
    const numIComps = useIndependentComps ? numComp : 1;
    model.gopacity = false;
    for (let nc = 0; !model.gopacity && nc < numIComps; ++nc) {
      model.gopacity ||= actorProps.getUseGradientOpacity(nc);
    }
    if (model.gopacity) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::GradientOpacityOn', '#define vtkGradientOpacityOn').result;
    }

    // set normal from density
    if (model.renderable.getComputeNormalFromOpacity()) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::vtkComputeNormalFromOpacity', `#define vtkComputeNormalFromOpacity`).result;
    }

    // if we have a ztexture then declare it and use it
    if (model.zBufferTexture !== null) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Dec', ['uniform sampler2D zBufferTexture;', 'uniform float vpZWidth;', 'uniform float vpZHeight;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));', 'float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;', 'zdepth = zdepth * 2.0 - 1.0;', 'if (cameraParallel == 0) {', 'zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}', 'else {', 'zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n', 'zdepth = -zdepth/rayDir.z;', 'dists.y = min(zdepth,dists.y);']).result;
    }

    // Set the BlendMode approach
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::BlendMode', `${model.renderable.getBlendMode()}`).result;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    if (model.lightComplexity === 0) {
      return;
    }
    let FSSource = shaders.Fragment;
    // check for shadow maps - not implemented yet, skip
    // const shadowFactor = '';

    // to-do: single out the case when complexity = 1

    // only account for lights that are switched on
    let lightNum = 0;
    ren.getLights().forEach(light => {
      if (light.getSwitch()) {
        lightNum += 1;
      }
    });
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Light::Dec', [`uniform int lightNum;`, `uniform bool twoSidedLighting;`, `uniform vec3 lightColor[${lightNum}];`, `uniform vec3 lightDirectionVC[${lightNum}]; // normalized`, `uniform vec3 lightHalfAngleVC[${lightNum}];`, '//VTK::Light::Dec'], false).result;
    // support any number of lights
    if (model.lightComplexity === 3) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Light::Dec', [`uniform vec3 lightPositionVC[${lightNum}];`, `uniform vec3 lightAttenuation[${lightNum}];`, `uniform float lightConeAngle[${lightNum}];`, `uniform float lightExponent[${lightNum}];`, `uniform int lightPositional[${lightNum}];`], false).result;
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::VolumeShadow::Dec', [`uniform float volumetricScatteringBlending;`, `uniform float giReach;`, `uniform float volumeShadowSamplingDistFactor;`, `uniform float anisotropy;`, `uniform float anisotropy2;`], false).result;
    }
    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::LAO::Dec', [`uniform int kernelRadius;`, `uniform vec2 kernelSample[${model.renderable.getLAOKernelRadius()}];`, `uniform int kernelSize;`], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderClippingPlane = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    if (model.renderable.getClippingPlanes().length > 0) {
      const clipPlaneSize = model.renderable.getClippingPlanes().length;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ClipPlane::Dec', [`uniform vec3 vClipPlaneNormals[6];`, `uniform float vClipPlaneDistances[6];`, `uniform vec3 vClipPlaneOrigins[6];`, `uniform int clip_numPlanes;`, '//VTK::ClipPlane::Dec', '#define vtkClippingPlanesOn'], false).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ClipPlane::Impl', [`for(int i = 0; i < ${clipPlaneSize}; i++) {`, '  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);', '  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];', '  if (rayDirRatio == 0.0)', '  {', '    if (equationResult < 0.0) dists.x = dists.y;', '    continue;', '  }', '  float result = -1.0 * equationResult / rayDirRatio;', '  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);', '  else dists.x = max(dists.x, result);', '}', '//VTK::ClipPlane::Impl'], false).result;
    }
    shaders.Fragment = FSSource;
  };
  const recomputeLightComplexity = (actor, lights) => {
    // do we need lighting?
    let lightComplexity = 0;
    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === VolumeMapper_Constants/* BlendMode */.Nx.COMPOSITE_BLEND) {
      // consider the lighting complexity to determine which case applies
      // simple headlight, Light Kit, the whole feature set of VTK
      lightComplexity = 0;
      model.numberOfLights = 0;
      lights.forEach(light => {
        const status = light.getSwitch();
        if (status > 0) {
          model.numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      });
    }
    if (lightComplexity !== model.lightComplexity) {
      model.lightComplexity = lightComplexity;
      publicAPI.modified();
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    const actorProps = actor.getProperty();
    recomputeLightComplexity(actor, ren.getLights());
    const numComp = model.scalarTexture.getComponents();
    const opacityModes = [];
    const forceNearestInterps = [];
    for (let nc = 0; nc < numComp; nc++) {
      opacityModes.push(actorProps.getOpacityMode(nc));
      forceNearestInterps.push(actorProps.getForceNearestInterpolation(nc));
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    esm/* vec3.set */.eR.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    const maxSamples = esm/* vec3.length */.eR.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    const hasZBufferTexture = !!model.zBufferTexture;
    const state = {
      iComps: actorProps.getIndependentComponents(),
      colorMixPreset: actorProps.getColorMixPreset(),
      interpolationType: actorProps.getInterpolationType(),
      useLabelOutline: publicAPI.isLabelmapOutlineRequired(actor),
      numComp,
      maxSamples,
      useGradientOpacity: actorProps.getUseGradientOpacity(0),
      blendMode: model.renderable.getBlendMode(),
      hasZBufferTexture,
      opacityModes,
      forceNearestInterps
    };

    // We need to rebuild the shader if one of these variables has changed,
    // since they are used in the shader template replacement step.
    // We also need to rebuild if the shader source time is outdated.
    if (cellBO.getProgram()?.getHandle() === 0 || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || !model.previousState || !fast_deep_equal_default()(model.previousState, state)) {
      model.previousState = state;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed('vertexDC')) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexDC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro('Error setting vertexDC in shader VAO.');
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    program.setUniformi('texture1', model.scalarTexture.getTextureUnit());
    program.setUniformf('sampleDistance', publicAPI.getCurrentSampleDistance(ren));
    const volInfo = model.scalarTexture.getVolumeInfo();
    const ipScalarRange = model.renderable.getIpScalarRange();

    // In some situations, we might not have computed the scale and offset
    // for the data range, or it might not be needed.
    if (volInfo?.dataComputedScale?.length) {
      const minVals = [];
      const maxVals = [];
      for (let i = 0; i < 4; i++) {
        // convert iprange from 0-1 into data range values
        minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
        maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
        // convert data ranges into texture values
        minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];
        maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];
      }
      program.setUniform4f('ipScalarRangeMin', minVals[0], minVals[1], minVals[2], minVals[3]);
      program.setUniform4f('ipScalarRangeMax', maxVals[0], maxVals[1], maxVals[2], maxVals[3]);
    }

    // if we have a zbuffer texture then set it
    if (model.zBufferTexture !== null) {
      program.setUniformi('zBufferTexture', model.zBufferTexture.getTextureUnit());
      const size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();
      program.setUniformf('vpZWidth', size[0]);
      program.setUniformf('vpZHeight', size[1]);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    // // [WMVP]C == {world, model, view, projection} coordinates
    // // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLVolume.getKeyMatrices();
    esm/* mat4.multiply */.pB.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);
    const program = cellBO.getProgram();
    const cam = model.openGLCamera.getRenderable();
    const crange = cam.getClippingRange();
    program.setUniformf('camThick', crange[1] - crange[0]);
    program.setUniformf('camNear', crange[0]);
    program.setUniformf('camFar', crange[1]);
    const bounds = model.currentInput.getBounds();
    const dims = model.currentInput.getDimensions();

    // compute the viewport bounds of the volume
    // we will only render those fragments.
    const pos = new Float64Array(3);
    const dir = new Float64Array(3);
    let dcxmin = 1.0;
    let dcxmax = -1.0;
    let dcymin = 1.0;
    let dcymax = -1.0;
    for (let i = 0; i < 8; ++i) {
      esm/* vec3.set */.eR.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);
      esm/* vec3.transformMat4 */.eR.transformMat4(pos, pos, model.modelToView);
      if (!cam.getParallelProjection()) {
        esm/* vec3.normalize */.eR.normalize(dir, pos);

        // now find the projection of this point onto a
        // nearZ distance plane. Since the camera is at 0,0,0
        // in VC the ray is just t*pos and
        // t is -nearZ/dir.z
        // intersection becomes pos.x/pos.z
        const t = -crange[0] / pos[2];
        esm/* vec3.scale */.eR.scale(pos, dir, t);
      }
      // now convert to DC
      esm/* vec3.transformMat4 */.eR.transformMat4(pos, pos, keyMats.vcpc);
      dcxmin = Math.min(pos[0], dcxmin);
      dcxmax = Math.max(pos[0], dcxmax);
      dcymin = Math.min(pos[1], dcymin);
      dcymax = Math.max(pos[1], dcymax);
    }
    program.setUniformf('dcxmin', dcxmin);
    program.setUniformf('dcxmax', dcxmax);
    program.setUniformf('dcymin', dcymin);
    program.setUniformf('dcymax', dcymax);
    if (program.isUniformUsed('cameraParallel')) {
      program.setUniformi('cameraParallel', cam.getParallelProjection());
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    esm/* vec3.set */.eR.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    program.setUniform3f('vSpacing', spc[0], spc[1], spc[2]);
    esm/* vec3.set */.eR.set(pos, ext[0], ext[2], ext[4]);
    model.currentInput.indexToWorldVec3(pos, pos);
    esm/* vec3.transformMat4 */.eR.transformMat4(pos, pos, model.modelToView);
    program.setUniform3f('vOriginVC', pos[0], pos[1], pos[2]);

    // apply the image directions
    const i2wmat4 = model.currentInput.getIndexToWorld();
    esm/* mat4.multiply */.pB.multiply(model.idxToView, model.modelToView, i2wmat4);
    esm/* mat3.multiply */.w0.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    esm/* mat3.multiply */.w0.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirectionByReference());
    const maxSamples = esm/* vec3.length */.eR.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro(`The number of steps required ${Math.ceil(maxSamples)} is larger than the
        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.
        Please either change the
        volumeMapper sampleDistance or its maximum number of samples.`);
    }
    const vctoijk = new Float64Array(3);
    esm/* vec3.set */.eR.set(vctoijk, 1.0, 1.0, 1.0);
    esm/* vec3.divide */.eR.divide(vctoijk, vctoijk, vsize);
    program.setUniform3f('vVCToIJK', vctoijk[0], vctoijk[1], vctoijk[2]);
    program.setUniform3i('volumeDimensions', dims[0], dims[1], dims[2]);
    program.setUniform3f('volumeSpacings', spc[0], spc[1], spc[2]);
    if (!model._openGLRenderWindow.getWebgl2()) {
      const volInfo = model.scalarTexture.getVolumeInfo();
      program.setUniformf('texWidth', model.scalarTexture.getWidth());
      program.setUniformf('texHeight', model.scalarTexture.getHeight());
      program.setUniformi('xreps', volInfo.xreps);
      program.setUniformi('xstride', volInfo.xstride);
      program.setUniformi('ystride', volInfo.ystride);
    }

    // map normals through normal matrix
    // then use a point on the plane to compute the distance
    const normal = new Float64Array(3);
    const pos2 = new Float64Array(3);
    for (let i = 0; i < 6; ++i) {
      switch (i) {
        case 1:
          esm/* vec3.set */.eR.set(normal, -1.0, 0.0, 0.0);
          esm/* vec3.set */.eR.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 2:
          esm/* vec3.set */.eR.set(normal, 0.0, 1.0, 0.0);
          esm/* vec3.set */.eR.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 3:
          esm/* vec3.set */.eR.set(normal, 0.0, -1.0, 0.0);
          esm/* vec3.set */.eR.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 4:
          esm/* vec3.set */.eR.set(normal, 0.0, 0.0, 1.0);
          esm/* vec3.set */.eR.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 5:
          esm/* vec3.set */.eR.set(normal, 0.0, 0.0, -1.0);
          esm/* vec3.set */.eR.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 0:
        default:
          esm/* vec3.set */.eR.set(normal, 1.0, 0.0, 0.0);
          esm/* vec3.set */.eR.set(pos2, ext[1], ext[3], ext[5]);
          break;
      }
      esm/* vec3.transformMat3 */.eR.transformMat3(normal, normal, model.idxNormalMatrix);
      esm/* vec3.transformMat4 */.eR.transformMat4(pos2, pos2, model.idxToView);
      const dist = -1.0 * esm/* vec3.dot */.eR.dot(pos2, normal);

      // we have the plane in view coordinates
      // specify the planes in view coordinates
      program.setUniform3f(`vPlaneNormal${i}`, normal[0], normal[1], normal[2]);
      program.setUniformf(`vPlaneDistance${i}`, dist);
    }
    if (publicAPI.isLabelmapOutlineRequired(actor)) {
      const image = model.currentInput;
      const worldToIndex = image.getWorldToIndex();
      program.setUniformMatrix('vWCtoIDX', worldToIndex);
      const camera = ren.getActiveCamera();
      const [cRange0, cRange1] = camera.getClippingRange();
      const distance = camera.getDistance();

      // set the clipping range to be model.distance and model.distance + 0.1
      // since we use the in the keyMats.wcpc (world to projection) matrix
      // the projection matrix calculation relies on the clipping range to be
      // set correctly. This is done inside the interactorStyleMPRSlice which
      // limits use cases where the interactor style is not used.

      camera.setClippingRange(distance, distance + 0.1);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);

      // Get the projection coordinate to world coordinate transformation matrix.
      esm/* mat4.invert */.pB.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);

      // reset the clipping range since the keyMats are cached
      camera.setClippingRange(cRange0, cRange1);

      // to re compute the matrices for the current camera and cache them
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);
      const size = publicAPI.getRenderTargetSize();
      program.setUniformf('vpWidth', size[0]);
      program.setUniformf('vpHeight', size[1]);
      const offset = publicAPI.getRenderTargetOffset();
      program.setUniformf('vpOffsetX', offset[0] / size[0]);
      program.setUniformf('vpOffsetY', offset[1] / size[1]);
    }
    esm/* mat4.invert */.pB.invert(model.projectionToView, keyMats.vcpc);
    program.setUniformMatrix('PCVCMatrix', model.projectionToView);

    // handle lighting values
    if (model.lightComplexity === 0) {
      return;
    }
    let lightNum = 0;
    const lightColor = [];
    const lightDir = [];
    const halfAngle = [];
    ren.getLights().forEach(light => {
      const status = light.getSwitch();
      if (status > 0) {
        const dColor = light.getColor();
        const intensity = light.getIntensity();
        lightColor[0 + lightNum * 3] = dColor[0] * intensity;
        lightColor[1 + lightNum * 3] = dColor[1] * intensity;
        lightColor[2 + lightNum * 3] = dColor[2] * intensity;
        const ldir = light.getDirection();
        esm/* vec3.set */.eR.set(normal, ldir[0], ldir[1], ldir[2]);
        esm/* vec3.transformMat3 */.eR.transformMat3(normal, normal, keyMats.normalMatrix); // in view coordinat
        esm/* vec3.normalize */.eR.normalize(normal, normal);
        lightDir[0 + lightNum * 3] = normal[0];
        lightDir[1 + lightNum * 3] = normal[1];
        lightDir[2 + lightNum * 3] = normal[2];
        // camera DOP is 0,0,-1.0 in VC
        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];
        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];
        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1.0);
        lightNum++;
      }
    });
    program.setUniformi('twoSidedLighting', ren.getTwoSidedLighting());
    program.setUniformi('lightNum', lightNum);
    program.setUniform3fv('lightColor', lightColor);
    program.setUniform3fv('lightDirectionVC', lightDir);
    program.setUniform3fv('lightHalfAngleVC', halfAngle);
    if (model.lightComplexity === 3) {
      lightNum = 0;
      const lightPositionVC = [];
      const lightAttenuation = [];
      const lightConeAngle = [];
      const lightExponent = [];
      const lightPositional = [];
      ren.getLights().forEach(light => {
        const status = light.getSwitch();
        if (status > 0) {
          const attenuation = light.getAttenuationValues();
          lightAttenuation[0 + lightNum * 3] = attenuation[0];
          lightAttenuation[1 + lightNum * 3] = attenuation[1];
          lightAttenuation[2 + lightNum * 3] = attenuation[2];
          lightExponent[lightNum] = light.getExponent();
          lightConeAngle[lightNum] = light.getConeAngle();
          lightPositional[lightNum] = light.getPositional();
          const lp = light.getTransformedPosition();
          esm/* vec3.transformMat4 */.eR.transformMat4(lp, lp, model.modelToView);
          lightPositionVC[0 + lightNum * 3] = lp[0];
          lightPositionVC[1 + lightNum * 3] = lp[1];
          lightPositionVC[2 + lightNum * 3] = lp[2];
          lightNum += 1;
        }
      });
      program.setUniform3fv('lightPositionVC', lightPositionVC);
      program.setUniform3fv('lightAttenuation', lightAttenuation);
      program.setUniformfv('lightConeAngle', lightConeAngle);
      program.setUniformfv('lightExponent', lightExponent);
      program.setUniformiv('lightPositional', lightPositional);
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {
      program.setUniformf('giReach', model.renderable.getGlobalIlluminationReach());
      program.setUniformf('volumetricScatteringBlending', model.renderable.getVolumetricScatteringBlending());
      program.setUniformf('volumeShadowSamplingDistFactor', model.renderable.getVolumeShadowSamplingDistFactor());
      program.setUniformf('anisotropy', model.renderable.getAnisotropy());
      program.setUniformf('anisotropy2', model.renderable.getAnisotropy() ** 2.0);
    }
    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {
      const ks = model.renderable.getLAOKernelSize();
      program.setUniformi('kernelSize', ks);
      const kernelSample = [];
      for (let i = 0; i < ks; i++) {
        kernelSample[i * 2] = Math.random() * 0.5;
        kernelSample[i * 2 + 1] = Math.random() * 0.5;
      }
      program.setUniform2fv('kernelSample', kernelSample);
      program.setUniformi('kernelRadius', model.renderable.getLAOKernelRadius());
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    program.setUniformi('ctexture', model.colorTexture.getTextureUnit());
    program.setUniformi('otexture', model.opacityTexture.getTextureUnit());
    program.setUniformi('jtexture', model.jitterTexture.getTextureUnit());
    program.setUniformi('ttexture', model.labelOutlineThicknessTexture.getTextureUnit());
    const volInfo = model.scalarTexture.getVolumeInfo();
    const vprop = actor.getProperty();

    // set the component mix when independent
    const numComp = model.scalarTexture.getComponents();
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    if (useIndependentComps) {
      for (let i = 0; i < numComp; i++) {
        program.setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));
      }
    }

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      const target = useIndependentComps ? i : 0;
      const sscale = volInfo.scale[i];
      const ofun = vprop.getScalarOpacity(target);
      const oRange = ofun.getRange();
      const oscale = sscale / (oRange[1] - oRange[0]);
      const oshift = (volInfo.offset[i] - oRange[0]) / (oRange[1] - oRange[0]);
      program.setUniformf(`oshift${i}`, oshift);
      program.setUniformf(`oscale${i}`, oscale);
      const cfun = vprop.getRGBTransferFunction(target);
      const cRange = cfun.getRange();
      const cshift = (volInfo.offset[i] - cRange[0]) / (cRange[1] - cRange[0]);
      const cScale = sscale / (cRange[1] - cRange[0]);
      program.setUniformf(`cshift${i}`, cshift);
      program.setUniformf(`cscale${i}`, cScale);
    }
    if (model.gopacity) {
      if (useIndependentComps) {
        for (let nc = 0; nc < numComp; ++nc) {
          const sscale = volInfo.scale[nc];
          const useGO = vprop.getUseGradientOpacity(nc);
          if (useGO) {
            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);
            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);
            program.setUniformf(`gomin${nc}`, gomin);
            program.setUniformf(`gomax${nc}`, gomax);
            const goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];
            program.setUniformf(`goscale${nc}`, sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
            program.setUniformf(`goshift${nc}`, -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
          } else {
            program.setUniformf(`gomin${nc}`, 1.0);
            program.setUniformf(`gomax${nc}`, 1.0);
            program.setUniformf(`goscale${nc}`, 0.0);
            program.setUniformf(`goshift${nc}`, 1.0);
          }
        }
      } else {
        const sscale = volInfo.scale[numComp - 1];
        const gomin = vprop.getGradientOpacityMinimumOpacity(0);
        const gomax = vprop.getGradientOpacityMaximumOpacity(0);
        program.setUniformf('gomin0', gomin);
        program.setUniformf('gomax0', gomax);
        const goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];
        program.setUniformf('goscale0', sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
        program.setUniformf('goshift0', -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
      }
    }
    const vtkImageLabelOutline = publicAPI.isLabelmapOutlineRequired(actor);
    if (vtkImageLabelOutline === true) {
      const labelOutlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      program.setUniformf('outlineOpacity', labelOutlineOpacity);
    }
    if (model.lightComplexity > 0) {
      program.setUniformf('vAmbient', vprop.getAmbient());
      program.setUniformf('vDiffuse', vprop.getDiffuse());
      program.setUniformf('vSpecular', vprop.getSpecular());
      program.setUniformf('vSpecularPower', vprop.getSpecularPower());
    }
  };
  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {
    if (model.renderable.getClippingPlanes().length > 0) {
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const clipPlaneNormals = [];
      const clipPlaneDistances = [];
      const clipPlaneOrigins = [];
      const clipPlanes = model.renderable.getClippingPlanes();
      const clipPlaneSize = clipPlanes.length;
      for (let i = 0; i < clipPlaneSize; ++i) {
        const clipPlaneNormal = clipPlanes[i].getNormal();
        const clipPlanePos = clipPlanes[i].getOrigin();
        esm/* vec3.transformMat3 */.eR.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);
        esm/* vec3.transformMat4 */.eR.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);
        const clipPlaneDist = -1.0 * esm/* vec3.dot */.eR.dot(clipPlanePos, clipPlaneNormal);
        clipPlaneNormals.push(clipPlaneNormal[0]);
        clipPlaneNormals.push(clipPlaneNormal[1]);
        clipPlaneNormals.push(clipPlaneNormal[2]);
        clipPlaneDistances.push(clipPlaneDist);
        clipPlaneOrigins.push(clipPlanePos[0]);
        clipPlaneOrigins.push(clipPlanePos[1]);
        clipPlaneOrigins.push(clipPlanePos[2]);
      }
      const program = cellBO.getProgram();
      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);
      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);
      program.setUniform3fv(`vClipPlaneOrigins`, clipPlaneOrigins);
      program.setUniformi(`clip_numPlanes`, clipPlaneSize);
    }
  };

  // unsubscribe from our listeners
  publicAPI.delete = (0,macros2.h)(() => {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, () => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.getCurrentSampleDistance = ren => {
    const rwi = ren.getVTKWindow().getInteractor();
    const baseSampleDistance = model.renderable.getSampleDistance();
    if (rwi.isAnimating()) {
      const factor = model.renderable.getInteractionSampleDistanceFactor();
      return baseSampleDistance * factor;
    }
    return baseSampleDistance;
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    const rwi = ren.getVTKWindow().getInteractor();
    if (!model._lastScale) {
      model._lastScale = model.renderable.getInitialInteractionScale();
    }
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    if (!model._animationRateSubscription) {
      // when the animation frame rate changes recompute the scale factor
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
        if (model.renderable.getAutoAdjustSampleDistances()) {
          const frate = rwi.getRecentAnimationFrameRate();
          const adjustment = rwi.getDesiredUpdateRate() / frate;

          // only change if we are off by 15%
          if (adjustment > 1.15 || adjustment < 0.85) {
            model._lastScale *= adjustment;
          }
          // clamp scale to some reasonable values.
          // Below 1.5 we will just be using full resolution as that is close enough
          // Above 400 seems like a lot so we limit to that 1/20th per axis
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        } else {
          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();
        }
      });
    }

    // use/create/resize framebuffer if needed
    if (model._useSmallViewport) {
      const size = model._openGLRenderWindow.getFramebufferSize();
      const scaleFactor = 1 / Math.sqrt(model._lastScale);
      model._smallViewportWidth = Math.ceil(scaleFactor * size[0]);
      model._smallViewportHeight = Math.ceil(scaleFactor * size[1]);

      // adjust viewportSize to always be at most the dest fo size
      if (model._smallViewportHeight > size[1]) {
        model._smallViewportHeight = size[1];
      }
      if (model._smallViewportWidth > size[0]) {
        model._smallViewportWidth = size[0];
      }
      model.framebuffer.saveCurrentBindingsAndBuffers();
      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        const fbSize = model.framebuffer.getSize();
        if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.create(size[0], size[1]);
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      const gl = model.context;
      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);
      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];
    }
    model.context.disable(model.context.DEPTH_TEST);

    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // set interpolation on the texture based on property setting
    const iType = actor.getProperty().getInterpolationType();
    if (iType === VolumeProperty_Constants/* InterpolationType */.VO.NEAREST) {
      model.scalarTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.scalarTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
    } else {
      model.scalarTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.scalarTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
    }

    // if we have a zbuffer texture then activate it
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // render the texture
    model.scalarTexture.activate();
    model.opacityTexture.activate();
    model.labelOutlineThicknessTexture.activate();
    model.colorTexture.activate();
    model.jitterTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);

    // First we do the triangles, update the shader, set uniforms, etc.
    // for (let i = 0; i < 11; ++i) {
    //   gl.drawArrays(gl.TRIANGLES, 66 * i, 66);
    // }
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.scalarTexture.deactivate();
    model.colorTexture.deactivate();
    model.opacityTexture.deactivate();
    model.labelOutlineThicknessTexture.deactivate();
    model.jitterTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    // if we have a zbuffer texture then deactivate it
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }
    if (model._useSmallViewport) {
      // now copy the framebuffer with the volume into the
      // regular buffer
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'uniform vec2 tfactor;', 'varying vec2 tcoord;', 'void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }'].join('\n'), ['//VTK::System::Dec', '//VTK::Output::Dec', 'uniform sampler2D texture1;', 'varying vec2 tcoord;', 'void main() { gl_FragData[0] = texture2D(texture1,tcoord); }'].join('\n'), '');
        const program = model.copyShader;
        model.copyVAO = VertexArrayObject/* default.newInstance */.Ay.newInstance();
        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.tris.getCABO().bind();
        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro('Error setting vertexDC in copy shader VAO.');
        }
      } else {
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);
      }
      const size = model._openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size[0], size[1]);

      // activate texture
      const tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi('texture', tex.getTextureUnit());
      model.copyShader.setUniform2f('tfactor', model.fvp[0], model.fvp[1]);
      const gl = model.context;
      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

      // render quad
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      tex.deactivate();
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: 'StartEvent'
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });
    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      (0,Core_Math.u)(model.Bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || !model.scalarTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.labelOutlineThicknessTexture?.getHandle()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const scalars = image.getPointData() && image.getPointData().getScalars();
    if (!scalars) {
      return;
    }
    const vprop = actor.getProperty();
    if (!model.jitterTexture.getHandle()) {
      const oTable = new Uint8Array(32 * 32);
      for (let i = 0; i < 32 * 32; ++i) {
        oTable[i] = 255.0 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.jitterTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.jitterTexture.create2DFromRaw(32, 32, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, oTable);
    }
    const numComp = scalars.getNumberOfComponents();
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    const numIComps = useIndependentComps ? numComp : 1;
    const scalarOpacityFunc = vprop.getScalarOpacity();
    const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);
    let toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(scalarOpacityFunc, useIndependentComps, numIComps);
    const reBuildOp = !opTex?.oglObject || opTex.hash !== toString;
    if (reBuildOp) {
      model.opacityTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // rebuild opacity tfun?
      const oWidth = 1024;
      const oSize = oWidth * 2 * numIComps;
      const ofTable = new Float32Array(oSize);
      const tmpTable = new Float32Array(oWidth);
      for (let c = 0; c < numIComps; ++c) {
        const ofun = vprop.getScalarOpacity(c);
        const opacityFactor = publicAPI.getCurrentSampleDistance(ren) / vprop.getScalarOpacityUnitDistance(c);
        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        // adjust for sample distance etc
        for (let i = 0; i < oWidth; ++i) {
          ofTable[c * oWidth * 2 + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;
          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];
        }
      }
      model.opacityTexture.resetFormatAndType();
      model.opacityTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.opacityTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);

      // use float texture where possible because we really need the resolution
      // for this table. Errors in low values of opacity accumulate to
      // visible artifacts. High values of opacity quickly terminate without
      // artifacts.
      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, Constants/* VtkDataTypes */.JA.FLOAT, ofTable);
      } else {
        const oTable = new Uint8ClampedArray(oSize);
        for (let i = 0; i < oSize; ++i) {
          oTable[i] = 255.0 * ofTable[i];
        }
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, oTable);
      }
      if (scalarOpacityFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, toString);
        if (scalarOpacityFunc !== model._scalarOpacityFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(scalarOpacityFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalarOpacityFunc, publicAPI);
        }
        model._scalarOpacityFunc = scalarOpacityFunc;
      }
    } else {
      model.opacityTexture = opTex.oglObject;
    }

    // rebuild color tfun?
    const colorTransferFunc = vprop.getRGBTransferFunction();
    toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(colorTransferFunc, useIndependentComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
    if (reBuildC) {
      model.colorTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const cWidth = 1024;
      const cSize = cWidth * 2 * numIComps * 3;
      const cTable = new Uint8ClampedArray(cSize);
      const tmpTable = new Float32Array(cWidth * 3);
      for (let c = 0; c < numIComps; ++c) {
        const cfun = vprop.getRGBTransferFunction(c);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
          cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
        }
      }
      model.colorTexture.resetFormatAndType();
      model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }
    publicAPI.updateLabelOutlineThicknessTexture(actor);
    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    // rebuild the scalarTexture if the data has changed
    toString = (0,resourceSharingHelper/* getImageDataHash */.eS)(image, scalars);
    const reBuildTex = !tex?.oglObject?.getHandle() || tex?.hash !== toString;
    if (reBuildTex) {
      model.scalarTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // Build the textures
      const dims = image.getDimensions();
      // Use norm16 for scalar texture if the extension is available
      model.scalarTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));
      model.scalarTexture.resetFormatAndType();
      model.scalarTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, model.renderable.getPreferSizeOverAccuracy());
      if (scalars) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.scalarTexture, toString);
        if (scalars !== model._scalars) {
          model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
        }
        model._scalars = scalars;
      }
    } else {
      model.scalarTexture = tex.oglObject;
    }
    if (!model.tris.getCABO().getElementCount()) {
      // build the CABO
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1.0;
        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
        ptsArray[i * 3 + 2] = -1.0;
      }
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;

      // const dim = 12.0;
      // const ptsArray = new Float32Array(3 * dim * dim);
      // for (let i = 0; i < dim; i++) {
      //   for (let j = 0; j < dim; j++) {
      //     const offset = ((i * dim) + j) * 3;
      //     ptsArray[offset] = (2.0 * (i / (dim - 1.0))) - 1.0;
      //     ptsArray[offset + 1] = (2.0 * (j / (dim - 1.0))) - 1.0;
      //     ptsArray[offset + 2] = -1.0;
      //   }
      // }

      // const cellArray = new Uint16Array(8 * (dim - 1) * (dim - 1));
      // for (let i = 0; i < dim - 1; i++) {
      //   for (let j = 0; j < dim - 1; j++) {
      //     const offset = 8 * ((i * (dim - 1)) + j);
      //     cellArray[offset] = 3;
      //     cellArray[offset + 1] = (i * dim) + j;
      //     cellArray[offset + 2] = (i * dim) + 1 + j;
      //     cellArray[offset + 3] = ((i + 1) * dim) + 1 + j;
      //     cellArray[offset + 4] = 3;
      //     cellArray[offset + 5] = (i * dim) + j;
      //     cellArray[offset + 6] = ((i + 1) * dim) + 1 + j;
      //     cellArray[offset + 7] = ((i + 1) * dim) + j;
      //   }
      // }

      const points = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');
      const cells = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, 'polys', Property_Constants/* Representation */.YL.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.updateLabelOutlineThicknessTexture = volume => {
    const labelOutlineThicknessArray = volume.getProperty().getLabelOutlineThickness();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);

    // compute the join of the labelOutlineThicknessArray so that
    // we can use it to decide whether to rebuild the labelOutlineThicknessTexture
    // or not
    const toString = `${labelOutlineThicknessArray.join('-')}`;
    const reBuildL = !lTex?.oglObject?.getHandle() || lTex?.hash !== toString;
    if (reBuildL) {
      model.labelOutlineThicknessTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const lWidth = 1024;
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);

      // Assuming labelOutlineThicknessArray contains the thickness for each segment
      for (let i = 0; i < lWidth; ++i) {
        // Retrieve the thickness value for the current segment index.
        // If the value is undefined, use the first element's value as a default, otherwise use the value (even if 0)
        const thickness = typeof labelOutlineThicknessArray[i] !== 'undefined' ? labelOutlineThicknessArray[i] : labelOutlineThicknessArray[0];
        lTable[i] = thickness;
      }
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);

      // Create a 2D texture (acting as 1D) from the raw data
      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, lTable);
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, toString);
        if (labelOutlineThicknessArray !== model._labelOutlineThicknessArray) {
          model._openGLRenderWindow.registerGraphicsResourceUser(labelOutlineThicknessArray, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._labelOutlineThicknessArray, publicAPI);
        }
        model._labelOutlineThicknessArray = labelOutlineThicknessArray;
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.oglObject;
    }
  };
  publicAPI.isLabelmapOutlineRequired = actor => {
    const prop = actor.getProperty();
    const renderable = model.renderable;
    return prop.getUseLabelOutline() || renderable.getBlendMode() === VolumeMapper_Constants/* BlendMode */.Nx.LABELMAP_EDGE_PROJECTION_BLEND;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  VBOBuildTime: null,
  scalarTexture: null,
  opacityTexture: null,
  opacityTextureString: null,
  colorTexture: null,
  colorTextureString: null,
  jitterTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineThicknessTextureString: null,
  tris: null,
  framebuffer: null,
  copyShader: null,
  copyVAO: null,
  lastXYF: 1.0,
  targetXYF: 1.0,
  zBufferTexture: null,
  lastZBufferTexture: null,
  lightComplexity: 0,
  fullViewportTime: 1.0,
  idxToView: null,
  idxNormalMatrix: null,
  modelToView: null,
  projectionToView: null,
  avgWindowArea: 0.0,
  avgFrameTime: 0.0
  // _scalars: null,
  // _scalarOpacityFunc: null,
  // _colorTransferFunc: null,
  // _labelOutlineThicknessArray: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  (0,macros2.o)(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = Helper/* default.newInstance */.Ay.newInstance();
  model.jitterTexture = Texture/* default.newInstance */.Ay.newInstance();
  model.jitterTexture.setWrapS(Texture_Constants/* Wrap */.B_.REPEAT);
  model.jitterTexture.setWrapT(Texture_Constants/* Wrap */.B_.REPEAT);
  model.framebuffer = Framebuffer/* default.newInstance */.Ay.newInstance();
  model.idxToView = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.idxNormalMatrix = esm/* mat3.identity */.w0.identity(new Float64Array(9));
  model.modelToView = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.projectionToView = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.projectionToWorld = esm/* mat4.identity */.pB.identity(new Float64Array(16));

  // Build VTK API
  (0,macros2.e)(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLVolumeMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,macros2.n)(extend, 'vtkOpenGLVolumeMapper');

// ----------------------------------------------------------------------------

var vtkVolumeMapper = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkVolumeMapper', newInstance);




/***/ }),

/***/ 23159:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ vtkPolyDataFS)
/* harmony export */ });
var vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";




/***/ }),

/***/ 84839:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ vtkPolyDataVS)
/* harmony export */ });
var vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";




/***/ }),

/***/ 98455:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
var Camera = __webpack_require__(38475);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var Renderer = __webpack_require__(63819);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
var Actor = __webpack_require__(80639);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
var Actor2D = __webpack_require__(58601);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/d3-scale/src/index.js + 55 modules
var src = __webpack_require__(95583);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var Core_Actor = __webpack_require__(7019);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var BoundingBox = __webpack_require__(21734);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var Mapper = __webpack_require__(82409);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 9 modules
var PolyData = __webpack_require__(79484);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Texture.js
var Texture = __webpack_require__(61433);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js











// ----------------------------------------------------------------------------
// vtkCubeAxesActor
// ----------------------------------------------------------------------------
// faces are -x x -y y -z z
// point 0 is 0,0,0 and then +x fastest changing, +y then +z
const faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
const faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];
const edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];
const edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];
const faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];

//
// Developer note: This class is broken into the main class and a helper
// class. The main class holds view independent properties (those properties
// that do not change as the view's resolution/aspect ratio change). The
// helper class is instantiated one per view and holds properties that can
// depend on view specific values such as resolution. The helper class code
// could have been left to the View specific implementation (such as
// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by
// multiple rendering backends.
//

// some shared temp variables to reduce heap allocs
const ptv3 = new Float64Array(3);
const pt2v3 = new Float64Array(3);
const tmpv3 = new Float64Array(3);
const tmp2v3 = new Float64Array(3);
const xDir = new Float64Array(3);
const yDir = new Float64Array(3);
const invmat = new Float64Array(16);
function applyTextStyle(ctx, style) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
}
function defaultGenerateTicks(dataBounds) {
  const ticks = [];
  const tickStrings = [];
  for (let i = 0; i < 3; i++) {
    const scale = src/* scaleLinear */.m4().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);
    ticks[i] = scale.ticks(5);
    const format = scale.tickFormat(5);
    tickStrings[i] = ticks[i].map(format);
  }
  return {
    ticks,
    tickStrings
  };
}

// many properties of this actor depend on the API specific view The main
// dependency being the resolution as that drives what font sizes to use.
// Bacause of this we need to do some of the calculations in a API specific
// subclass. But... we don't want a lot of duplicated code between WebGL and
// WebGPU for example so we have this helper class, that is designed to be
// fairly API independent so that API specific views can call this to do
// most of the work.
function vtkCubeAxesActorHelper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCubeAxesActorHelper');
  publicAPI.setRenderable = renderable => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.tmActor.addTexture(model.renderable.getTmTexture());
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    publicAPI.modified();
  };

  // called by updateTexturePolyData
  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {
    const value = model.renderable.get_tmAtlas().get(text);
    if (!value) {
      return;
    }
    const coords = model.renderable.getTextPolyData().getPoints().getData();

    // compute pixel to distance factors
    const size = model.lastSize;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    esm/* vec3.transformMat4 */.eR.transformMat4(tmpv3, ptv3, cmat);
    // moving 0.1 in NDC
    tmpv3[0] += 0.1;
    esm/* vec3.transformMat4 */.eR.transformMat4(pt2v3, tmpv3, imat);
    // results in WC move of
    esm/* vec3.subtract */.eR.subtract(xDir, pt2v3, ptv3);
    tmpv3[0] -= 0.1;
    tmpv3[1] += 0.1;
    esm/* vec3.transformMat4 */.eR.transformMat4(pt2v3, tmpv3, imat);
    // results in WC move of
    esm/* vec3.subtract */.eR.subtract(yDir, pt2v3, ptv3);
    for (let i = 0; i < 3; i++) {
      xDir[i] /= 0.5 * 0.1 * size[0];
      yDir[i] /= 0.5 * 0.1 * size[1];
    }

    // have to find the four corners of the texture polygon for this label
    // convert anchor point to View Coords
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    // horizontal left, right, or middle alignment based on dir[0]
    if (dir[0] < -0.5) {
      esm/* vec3.scale */.eR.scale(tmpv3, xDir, dir[0] * offset - value.width);
    } else if (dir[0] > 0.5) {
      esm/* vec3.scale */.eR.scale(tmpv3, xDir, dir[0] * offset);
    } else {
      esm/* vec3.scale */.eR.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);
    }
    esm/* vec3.add */.eR.add(ptv3, ptv3, tmpv3);
    esm/* vec3.scale */.eR.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);
    esm/* vec3.add */.eR.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    esm/* vec3.scale */.eR.scale(tmpv3, xDir, value.width);
    esm/* vec3.add */.eR.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    esm/* vec3.scale */.eR.scale(tmpv3, yDir, value.height);
    esm/* vec3.add */.eR.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    esm/* vec3.scale */.eR.scale(tmpv3, xDir, value.width);
    esm/* vec3.subtract */.eR.subtract(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;

    // add the two triangles to represent the quad
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };

  // update the polydata associated with drawing the text labels
  // specifically the quads used for each label and their associated tcoords
  // etc. This changes every time the camera viewpoint changes
  publicAPI.updateTexturePolyData = () => {
    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);
    esm/* mat4.transpose */.pB.transpose(cmat, cmat);

    // update the polydata
    const numLabels = model.renderable.getTextValues().length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    esm/* mat4.invert */.pB.invert(invmat, cmat);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };
    let ptIdx = 0;
    let textIdx = 0;
    let axisIdx = 0;
    const coords = model.renderable.getTextPolyData().getPoints().getData();
    const textValues = model.renderable.getTextValues();
    while (ptIdx < coords.length / 3) {
      // compute the direction to move out
      ptv3[0] = coords[ptIdx * 3];
      ptv3[1] = coords[ptIdx * 3 + 1];
      ptv3[2] = coords[ptIdx * 3 + 2];
      esm/* vec3.transformMat4 */.eR.transformMat4(tmpv3, ptv3, cmat);
      ptv3[0] = coords[ptIdx * 3 + 3];
      ptv3[1] = coords[ptIdx * 3 + 4];
      ptv3[2] = coords[ptIdx * 3 + 5];
      esm/* vec3.transformMat4 */.eR.transformMat4(tmp2v3, ptv3, cmat);
      esm/* vec3.subtract */.eR.subtract(tmpv3, tmpv3, tmp2v3);
      const dir = [tmpv3[0], tmpv3[1]];
      (0,Core_Math.O)(dir);

      // write the axis label
      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);
      ptIdx += 2;
      textIdx++;

      // write the tick labels
      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {
        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);
        ptIdx++;
        textIdx++;
      }
      axisIdx++;
    }
    const tcoordDA = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: 'TextureCoordinates'
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    // has the size changed?
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    model.camera = camera;

    // compute bounds for label quads whenever the camera changes
    publicAPI.updateTexturePolyData();
  };
}
const newCubeAxesActorHelper = macros2.m.newInstance(function (publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);

  // Inheritance
  macros2.m.obj(publicAPI, model);
  model.tmPolyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.tmMapper = Mapper/* default.newInstance */.Ay.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmActor = Core_Actor/* default.newInstance */.Ay.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  macros2.m.setGet(publicAPI, model, ['renderable']);
  macros2.m.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);
  model.forceUpdate = false;
  model.lastRedrawTime = {};
  macros2.m.obj(model.lastRedrawTime, {
    mtime: 0
  });
  model.lastRebuildTime = {};
  macros2.m.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];

  // internal variables
  model.lastTickBounds = [];
  vtkCubeAxesActorHelper(publicAPI, model);
}, 'vtkCubeAxesActorHelper');
function vtkCubeAxesActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCubeAxesActor');
  publicAPI.setCamera = cam => {
    if (model.camera === cam) {
      return;
    }
    if (model.cameraModifiedSub) {
      model.cameraModifiedSub.unsubscribe();
      model.cameraModifiedSub = null;
    }
    model.camera = cam;
    if (cam) {
      model.cameraModifiedSub = cam.onModified(publicAPI.update);
    }
    publicAPI.update();
    publicAPI.modified();
  };

  // estimate from a camera model what faces to draw
  // return true if the list of faces to draw has changed
  publicAPI.computeFacesToDraw = () => {
    const cmat = model.camera.getViewMatrix();
    esm/* mat4.transpose */.pB.transpose(cmat, cmat);
    let changed = false;
    const length = BoundingBox/* default.getDiagonalLength */.Ay.getDiagonalLength(model.dataBounds);
    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);
    for (let f = 0; f < 6; f++) {
      let drawit = false;
      const faceAxis = Math.floor(f / 2);
      const otherAxis1 = (faceAxis + 1) % 3;
      const otherAxis2 = (faceAxis + 2) % 3;
      // only for non degenerate axes
      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {
        // for each face transform the center and off center to get a direction vector
        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];
        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);
        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);
        esm/* vec3.transformMat4 */.eR.transformMat4(tmpv3, ptv3, cmat);
        ptv3[faceAxis] = model.dataBounds[f];
        esm/* vec3.transformMat4 */.eR.transformMat4(tmp2v3, ptv3, cmat);
        esm/* vec3.subtract */.eR.subtract(tmpv3, tmp2v3, tmpv3);
        esm/* vec3.normalize */.eR.normalize(tmpv3, tmpv3);
        // tmpv3 now holds the face normal vector
        drawit = tmpv3[2] > faceDot;
        // for perspctive we need the view direction to the plane
        if (!model.camera.getParallelProjection()) {
          esm/* vec3.normalize */.eR.normalize(tmp2v3, tmp2v3);
          drawit = esm/* vec3.dot */.eR.dot(tmp2v3, tmpv3) > faceDot;
        }
      }
      if (drawit !== model.lastFacesToDraw[f]) {
        model.lastFacesToDraw[f] = drawit;
        changed = true;
      }
    }
    return changed;
  };

  // update the polydata that represents the boundingd edges and gridlines
  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {
    // compute the number of points and lines required
    let numPts = 0;
    let numLines = 0;
    numPts += 8; // always start with the 8 cube points

    // count edgesToDraw
    let numEdgesToDraw = 0;
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        numEdgesToDraw++;
      }
    }
    numLines += numEdgesToDraw;

    // add values for gridlines
    if (model.gridLines) {
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;
          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;
        }
      }
    }

    // now allocate the memory
    const points = new Float64Array(numPts * 3);
    const lines = new Uint32Array(numLines * 3);
    let ptIdx = 0;
    let lineIdx = 0;

    // add the 8 corner points
    for (let z = 0; z < 2; z++) {
      for (let y = 0; y < 2; y++) {
        for (let x = 0; x < 2; x++) {
          points[ptIdx * 3] = model.dataBounds[x];
          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];
          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];
          ptIdx++;
        }
      }
    }

    // draw the edges
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        lines[lineIdx * 3] = 2;
        lines[lineIdx * 3 + 1] = edgePoints[e][0];
        lines[lineIdx * 3 + 2] = edgePoints[e][1];
        lineIdx++;
      }
    }

    // now handle gridlines
    // grid lines are tick[axis1] + ticks[axes2] lines each having two points
    // for simplicity we don;t worry about duplicating points, this is tiny

    if (model.gridLines) {
      // for each visible face
      // add the points
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          const faceIdx = Math.floor(f / 2);
          let aticks = ticks[faceAxes[f][0]];
          for (let t = 0; t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
          aticks = ticks[faceAxes[f][1]];
          for (let t = 0; t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
        }
      }
    }
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getLines().setData(lines, 1);
    model.polyData.getLines().modified();
    model.polyData.modified();
  };

  // update the data that represents where to put the labels
  // in world coordinates. This only changes when faces to draw changes
  // of dataBounds changes
  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {
    // count outside edgesToDraw
    let textPointCount = 0;
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] === 1) {
        textPointCount += 2;
        textPointCount += ticks[edgeAxes[e]].length;
      }
    }
    const points = model.polyData.getPoints().getData();
    const textPoints = new Float64Array(textPointCount * 3);
    let ptIdx = 0;
    let textIdx = 0;
    let axisCount = 0;
    for (let f = 0; f < 6; f++) {
      if (facesToDraw[f]) {
        for (let e = 0; e < 4; e++) {
          const edgeIdx = faceEdges[f][e];
          if (edgesToDraw[edgeIdx] === 1) {
            const edgeAxis = edgeAxes[edgeIdx];
            // add a middle point on the edge
            const ptIdx1 = edgePoints[edgeIdx][0] * 3;
            const ptIdx2 = edgePoints[edgeIdx][1] * 3;
            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);
            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);
            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);
            ptIdx++;
            // add a middle face point, we use this to
            // move the labels away from the edge in the right direction
            const faceIdx = Math.floor(f / 2);
            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);
            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);
            ptIdx++;
            // set the text
            model.textValues[textIdx] = model.axisLabels[edgeAxis];
            textIdx++;

            // now add the tick marks along the edgeAxis
            const otherAxis1 = (edgeAxis + 1) % 3;
            const otherAxis2 = (edgeAxis + 2) % 3;
            const aticks = ticks[edgeAxis];
            const atickStrings = tickStrings[edgeAxis];
            model.tickCounts[axisCount] = aticks.length;
            for (let t = 0; t < aticks.length; t++) {
              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];
              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];
              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];
              ptIdx++;
              // set the text
              model.textValues[textIdx] = atickStrings[t];
              textIdx++;
            }
            axisCount++;
          }
        }
      }
    }
    model.textPolyData.getPoints().setData(textPoints, 3);
    model.textPolyData.modified();
  };

  // main method to rebuild the cube axes, gets called on camera modify
  // and changes to key members
  publicAPI.update = () => {
    // Can't do anything if we don't have a camera...
    if (!model.camera) {
      return;
    }

    // compute what faces to draw
    const facesChanged = publicAPI.computeFacesToDraw();
    const facesToDraw = model.lastFacesToDraw;

    // have the bounds changed?
    let boundsChanged = false;
    for (let i = 0; i < 6; i++) {
      if (model.dataBounds[i] !== model.lastTickBounds[i]) {
        boundsChanged = true;
        model.lastTickBounds[i] = model.dataBounds[i];
      }
    }

    // did something significant change? If so rebuild a lot of things
    if (facesChanged || boundsChanged || model.forceUpdate) {
      // compute the edges to draw
      // for each drawn face, mark edges, all single mark edges we draw
      const edgesToDraw = new Array(12).fill(0);
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          for (let e = 0; e < 4; e++) {
            edgesToDraw[faceEdges[f][e]]++;
          }
        }
      }

      // compute tick marks for axes
      const t = model.generateTicks(model.dataBounds);

      // update gridlines / edge lines
      publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);

      // compute label world coords and text
      publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);

      // rebuild the texture only when force or changed bounds, face
      // visibility changes do to change the atlas
      if (boundsChanged || model.forceUpdate) {
        publicAPI.updateTextureAtlas(t.tickStrings);
      }
    }
    model.forceUpdate = false;
  };

  // create the texture map atlas that contains the rendering of
  // all the text strings. Only needs to be called when the text strings
  // have changed (labels and ticks)
  publicAPI.updateTextureAtlas = tickStrings => {
    // compute the width and height we need

    // set the text properties
    model.tmContext.textBaseline = 'bottom';
    model.tmContext.textAlign = 'left';

    // first the three labels
    model._tmAtlas.clear();
    let maxWidth = 0;
    let totalHeight = 1; // start one pixel in so we have a border
    for (let i = 0; i < 3; i++) {
      if (!model._tmAtlas.has(model.axisLabels[i])) {
        applyTextStyle(model.tmContext, model.axisTextStyle);
        const metrics = model.tmContext.measureText(model.axisLabels[i]);
        const entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.axisTextStyle
        };
        model._tmAtlas.set(model.axisLabels[i], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
      }
      // and the ticks
      applyTextStyle(model.tmContext, model.tickTextStyle);
      for (let t = 0; t < tickStrings[i].length; t++) {
        if (!model._tmAtlas.has(tickStrings[i][t])) {
          const metrics = model.tmContext.measureText(tickStrings[i][t]);
          const entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.tickTextStyle
          };
          model._tmAtlas.set(tickStrings[i][t], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
        }
      }
    }

    // always use power of two to avoid interpolation
    // in cases where PO2 is required
    maxWidth = (0,Core_Math.P)(maxWidth);
    totalHeight = (0,Core_Math.P)(totalHeight);

    // set the tcoord values
    model._tmAtlas.forEach(value => {
      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];
    });

    // make sure we have power of two dimensions
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = 'bottom';
    model.tmContext.textAlign = 'left';
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);

    // draw the text onto the texture
    model._tmAtlas.forEach((value, key) => {
      applyTextStyle(model.tmContext, value.textStyle);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    model.tmTexture.modified();
  };

  // Make sure the data is correct
  publicAPI.onModified(() => {
    model.forceUpdate = true;
    publicAPI.update();
  });
  publicAPI.setTickTextStyle = tickStyle => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = axisStyle => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.get_tmAtlas = () => model._tmAtlas;

  // try to get the bounds for the annotation. This is complicated
  // as it relies on the pixel size of the window. Every time the camera
  // changes the bounds change. This method simplifies by just expanding
  // the grid bounds by a user specified factor.
  publicAPI.getBounds = () => {
    publicAPI.update();
    BoundingBox/* default.setBounds */.Ay.setBounds(model.bounds, model.gridActor.getBounds());
    BoundingBox/* default.scaleAboutCenter */.Ay.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);
    return model.bounds;
  };

  // Make sure the grid share the actor property
  const _setProp = macros2.m.chain(publicAPI.setProperty, model.gridActor.setProperty);
  publicAPI.setProperty = p => _setProp(p)[0];
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

function defaultValues(publicAPI, model, initialValues) {
  return {
    boundsScaleFactor: 1.3,
    camera: null,
    dataBounds: [...BoundingBox/* default */.Ay.INIT_BOUNDS],
    faceVisibilityAngle: 8,
    gridLines: true,
    axisLabels: null,
    axisTitlePixelOffset: 35.0,
    tickLabelPixelOffset: 12.0,
    generateTicks: defaultGenerateTicks,
    ...initialValues,
    axisTextStyle: {
      fontColor: 'white',
      fontStyle: 'normal',
      fontSize: 18,
      fontFamily: 'serif',
      ...initialValues?.axisTextStyle
    },
    tickTextStyle: {
      fontColor: 'white',
      fontStyle: 'normal',
      fontSize: 14,
      fontFamily: 'serif',
      ...initialValues?.tickTextStyle
    }
  };
}

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Inheritance
  Core_Actor/* default.extend */.Ay.extend(publicAPI, model, defaultValues(publicAPI, model, initialValues));

  // internal variables
  model.lastFacesToDraw = [false, false, false, false, false, false];
  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];
  model.tickCounts = [];
  model.textValues = [];
  model.lastTickBounds = [];
  model.tmCanvas = document.createElement('canvas');
  model.tmContext = model.tmCanvas.getContext('2d');
  model._tmAtlas = new Map();

  // for texture atlas
  model.tmTexture = Texture/* default.newInstance */.Ay.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  publicAPI.getProperty().setDiffuse(0.0);
  publicAPI.getProperty().setAmbient(1.0);
  model.gridMapper = Mapper/* default.newInstance */.Ay.newInstance();
  model.polyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.gridMapper.setInputData(model.polyData);
  model.gridActor = Core_Actor/* default.newInstance */.Ay.newInstance();
  model.gridActor.setMapper(model.gridMapper);
  model.gridActor.setProperty(publicAPI.getProperty());
  model.gridActor.setParentProp(publicAPI);
  model.textPolyData = PolyData/* default.newInstance */.Ay.newInstance();
  macros2.m.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset', 'generateTicks']);
  macros2.m.setGetArray(publicAPI, model, ['dataBounds'], 6);
  macros2.m.setGetArray(publicAPI, model, ['axisLabels'], 3);
  macros2.m.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']);

  // Object methods
  vtkCubeAxesActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkCubeAxesActor');

// ----------------------------------------------------------------------------

var vtkCubeAxesActor$1 = {
  newInstance,
  extend,
  newCubeAxesActorHelper,
  defaultGenerateTicks
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/CubeAxesActor.js





// ----------------------------------------------------------------------------
// vtkOpenGLCubeAxesActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push('vtkOpenGLCubeAxesActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function CubeAxesActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();

  // Object methods
  vtkOpenGLCubeAxesActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const CubeAxesActor_newInstance = (0,macros2.n)(CubeAxesActor_extend, 'vtkOpenGLCubeAxesActor');

// ----------------------------------------------------------------------------

var index = {
  newInstance: CubeAxesActor_newInstance,
  extend: CubeAxesActor_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkCubeAxesActor', CubeAxesActor_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
var PolyDataMapper = __webpack_require__(62939);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js
var AbstractMapper = __webpack_require__(85311);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
var LookupTable = __webpack_require__(72879);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js
var Constants = __webpack_require__(33395);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper2D.js





const {
  ColorMode,
  ScalarMode,
  GetArray
} = Constants/* default */.Ay;

// ---------------------------------------------------------------------------
// vtkMapper2D methods
// ---------------------------------------------------------------------------

function vtkMapper2D(publicAPI, model) {
  // Set out className
  model.classHierarchy.push('vtkMapper2D');
  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = LookupTable/* default.newInstance */.Ay.newInstance();
  };
  publicAPI.getColorModeAsString = () => macros2.m.enumToString(ColorMode, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => macros2.m.enumToString(ScalarMode, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    // make sure we have an input
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFLag: false
      };
    }
    let scalars = null;
    let cellFlag = false;

    // get scalar data and point/cell attribute according to scalar mode
    if (scalarMode === ScalarMode.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.mapScalars = (input, alpha) => {
    const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
    if (!scalars) {
      model.colorMapColors = null;
      return;
    }

    // we want to only recompute when something has changed
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString) return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      // Ensure that the lookup table is built
      lut.build();
      model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Mapper2D_DEFAULT_VALUES = {
  static: false,
  lookupTable: null,
  scalarVisibility: false,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  // By_NAME

  renderTime: 0,
  colorByArrayName: null,
  transformCoordinate: null,
  viewSpecificProperties: null,
  customShaderAttributes: []
};

// ----------------------------------------------------------------------------
function Mapper2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Mapper2D_DEFAULT_VALUES, initialValues);

  // Inheritance
  AbstractMapper/* default.extend */.A.extend(publicAPI, model, initialValues);
  macros2.m.get(publicAPI, model, ['colorMapColors']);
  macros2.m.setGet(publicAPI, model, ['arrayAccessMode', 'colorByArrayName', 'colorMode', 'lookupTable', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'transformCoordinate', 'useLookupTableScalarRange', 'viewSpecificProperties', 'customShaderAttributes' // point data array names that will be transferred to the VBO
  ]);

  macros2.m.setGetArray(publicAPI, model, ['scalarRange'], 2);
  if (!model.viewSpecificProperties) {
    model.viewSpecificProperties = {};
  }

  // Object methods
  vtkMapper2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Mapper2D_newInstance = macros2.m.newInstance(Mapper2D_extend, 'vtkMapper2D');

// ----------------------------------------------------------------------------

var vtkMapper2D$1 = {
  newInstance: Mapper2D_newInstance,
  extend: Mapper2D_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Points.js
var Points = __webpack_require__(74966);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DFS.glsl.js
var vtkPolyData2DFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n";



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DVS.glsl.js
var vtkPolyData2DVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n";



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
var ReplacementShaderMapper = __webpack_require__(83534);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property2D/Constants.js
const DisplayLocation = {
  BACKGROUND: 0,
  FOREGROUND: 1
};
var Constants_Constants = {
  DisplayLocation
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper2D.js














// import { mat3, mat4, vec3 } from 'gl-matrix';
const {
  primTypes
} = Helper/* default */.Ay;
const {
  ScalarMode: PolyDataMapper2D_ScalarMode
} = vtkMapper2D$1;
const {
  vtkErrorMacro
} = macros2.c;
const StartEvent = {
  type: 'StartEvent'
};
const EndEvent = {
  type: 'EndEvent'
};

// ----------------------------------------------------------------------------
// vtkOpenGLPolyDataMapper2D methods
// ----------------------------------------------------------------------------

function vtkOpenGLPolyDataMapper2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLPolyDataMapper2D');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.openGLActor2D = publicAPI.getFirstAncestorOfType('vtkOpenGLActor2D');
      model._openGLRenderer = model.openGLActor2D.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
    }
  };
  publicAPI.overlayPass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyData2DVS;
    shaders.Fragment = vtkPolyData2DFS;
    shaders.Geometry = '';
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor2D.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }

    // if there are no points then we are done
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    if (model._openGLRenderer.getSelector()) {
      switch (model._openGLRenderer.getSelector().getCurrentPass()) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    if (cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model._openGLRenderWindow.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime() || model.renderable.getTransformCoordinate() && vmtime < ren.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, actor.getProperty().getOpacity());
    const c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      // We must figure out how the scalars should be mapped to the polydata.
      if ((scalarMode === PolyDataMapper2D_ScalarMode.USE_CELL_DATA || scalarMode === PolyDataMapper2D_ScalarMode.USE_CELL_FIELD_DATA || scalarMode === PolyDataMapper2D_ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== PolyDataMapper2D_ScalarMode.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }
    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor2D.getActiveTextures()) {
      tcoords = null;
    }
    const transformCoordinate = model.renderable.getTransformCoordinate();
    const view = ren.getRenderWindow().getViews()[0];
    const vsize = view.getViewportSize(ren);
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${c ? c.getMTime() : 1}` + `D${tcoords ? tcoords.getMTime() : 1}` + `E${transformCoordinate ? ren.getMTime() : 1}` + `F${vsize}`;
    if (model.VBOBuildString !== toString) {
      // Build the VBOs
      let points = poly.getPoints();
      if (transformCoordinate) {
        const p = Points/* default.newInstance */.Ay.newInstance();
        const numPts = points.getNumberOfPoints();
        p.setNumberOfPoints(numPts);
        const point = [];
        for (let i = 0; i < numPts; ++i) {
          points.getPoint(i, point);
          transformCoordinate.setValue(point);
          const v = transformCoordinate.getComputedDoubleViewportValue(ren);
          p.setPoint(i, v[0], v[1], 0.0);
        }
        points = p;
      }
      const options = {
        points,
        tcoords,
        colors: c,
        cellOffset: 0,
        haveCellScalars: model.haveCellSCalars,
        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))
      };
      options.cellOffset += model.primitives[primTypes.Points].getCABO().createVBO(poly.getVerts(), 'verts', representation, options);
      options.cellOffset += model.primitives[primTypes.Lines].getCABO().createVBO(poly.getLines(), 'lines', representation, options);
      options.cellOffset += model.primitives[primTypes.Tris].getCABO().createVBO(poly.getPolys(), 'polys', representation, options);
      options.cellOffset += model.primitives[primTypes.TriStrips].getCABO().createVBO(poly.getStrips(), 'strips', representation, options);
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    gl.depthMask(true);

    // for every primitive type
    for (let i = primTypes.Start; i < primTypes.End; i++) {
      // if there are entries
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.lastBoundBO = model.primitives[i];
        model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.lastBoundBO) {
      model.lastBoundBO.getVAO().release();
    }
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    if (model.haveCellScalars) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Dec', ['uniform samplerBuffer texture1;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);']).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0) {
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Dec', ['in vec4 diffuseColor;', 'out vec4 fcolorVSOutput;']).result;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Impl', ['fcolorVSOutput = diffuseColor;']).result;
      GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 fcolorVSOutput[];\n', 'out vec4 fcolorGSOutput;']).result;
      GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::Color::Impl', ['fcolorGSOutput = fcolorVSOutput[i];']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Dec', ['in vec4 fcolorVSOutput;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = fcolorVSOutput;']).result;
    } else {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Dec', ['uniform vec4 diffuseColor;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = diffuseColor;']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const tcdim = model.lastBoundBO.getCABO().getTCoordComponents();
      if (tcdim === 1) {
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Dec', ['in float tcoordMC;', 'out float tcoordVCVSOutput;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Impl', ['tcoordVCVSOutput = tcoordMC;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::TCoord::Dec', ['in float tcoordVCVSOutput[];\n', 'out float tcoordVCGSOutput;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, ['//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];']).result;
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Dec', ['in float tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Impl', ['gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));']).result;
      } else if (tcdim === 2) {
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordMC;', 'out vec2 tcoordVCVSOutput;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Impl', ['tcoordVCVSOutput = tcoordMC;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];\n', 'out vec2 tcoordVCGSOutput;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::TCoord::Impl', ['tcoordVCGSOutput = tcoordVCVSOutput[i];']).result;
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Impl', ['gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);']).result;
      }
      if (model.haveCellScalars) {
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::PrimID::Impl', ['gl_PrimitiveID = gl_PrimitiveIDIn;']).result;
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Picking::Dec', ['uniform vec3 mapperIndex;', 'uniform int picking;']).result;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    // replace common shader code
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach(object => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.
    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {
      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isAttributeUsed('vertexWC')) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
        vtkErrorMacro('Error setting vertexWC in shader VAO.');
      }
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro('Error setting tcoordMC in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('tcoordMC');
      }
      if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {
        cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());
      }
      const tus = model.openGLActor2D.getActiveTextures();
      if (tus) {
        for (let index = 0; index < tus.length; ++index) {
          const tex = tus[index];
          const texUnit = tex.getTextureUnit();
          const tname = `texture${texUnit + 1}`;
          if (cellBO.getProgram().isUniformUsed(tname)) {
            cellBO.getProgram().setUniformi(tname, texUnit);
          }
        }
      }

      // handle wide lines
      cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
      const selector = model._openGLRenderer.getSelector();
      cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);
      cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const c = model.renderable.getColorMapColors();
    if (!c || c.getNumberOfComponents() === 0) {
      const program = cellBO.getProgram();
      const ppty = actor.getProperty();
      const opacity = ppty.getOpacity();
      const dColor = ppty.getColor();
      const diffuseColor = [dColor[0], dColor[1], dColor[2], opacity];
      program.setUniform4f('diffuseColor', diffuseColor);
    }
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    // no-op
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index) => {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;

    // Get the position of the actor
    const view = ren.getRenderWindow().getViews()[0];
    const size = view.getViewportSize(ren);
    const vport = ren.getViewport();
    const actorPos = actor.getActualPositionCoordinate().getComputedDoubleViewportValue(ren);

    // Get the window info
    // Assume tile viewport is 0 1 based on vtkOpenGLRenderer
    const tileViewport = [0.0, 0.0, 1.0, 1.0];
    const visVP = [0.0, 0.0, 1.0, 1.0];
    visVP[0] = vport[0] >= tileViewport[0] ? vport[0] : tileViewport[0];
    visVP[1] = vport[1] >= tileViewport[1] ? vport[1] : tileViewport[1];
    visVP[2] = vport[2] <= tileViewport[2] ? vport[2] : tileViewport[2];
    visVP[3] = vport[3] <= tileViewport[3] ? vport[3] : tileViewport[3];
    if (visVP[0] >= visVP[2]) {
      return;
    }
    if (visVP[1] >= visVP[3]) {
      return;
    }
    size[0] = (0,Core_Math.N)(size[0] * (visVP[2] - visVP[0]) / (vport[2] - vport[0]));
    size[1] = (0,Core_Math.N)(size[1] * (visVP[3] - visVP[1]) / (vport[3] - vport[1]));
    const winSize = model._openGLRenderer.getParent().getSize();
    const xoff = (0,Core_Math.N)(actorPos[0] - (visVP[0] - vport[0]) * winSize[0]);
    const yoff = (0,Core_Math.N)(actorPos[1] - (visVP[1] - vport[1]) * winSize[1]);

    // set ortho projection
    const left = -xoff;
    let right = -xoff + size[0];
    const bottom = -yoff;
    let top = -yoff + size[1];

    // it's an error to call glOrtho with
    // either left==right or top==bottom
    if (left === right) {
      right = left + 1.0;
    }
    if (bottom === top) {
      top = bottom + 1.0;
    }

    // compute the combined ModelView matrix and send it down to save time in the shader
    const tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));
    tmpMat4[0] = 2.0 / (right - left);
    tmpMat4[1 * 4 + 1] = 2.0 / (top - bottom);
    tmpMat4[0 * 4 + 3] = -1.0 * (right + left) / (right - left);
    tmpMat4[1 * 4 + 3] = -1.0 * (top + bottom) / (top - bottom);
    tmpMat4[2 * 4 + 2] = 0.0;
    tmpMat4[2 * 4 + 3] = actor.getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? -1.0 : 1.0;
    tmpMat4[3 * 4 + 3] = 1.0;
    esm/* mat4.transpose */.pB.transpose(tmpMat4, tmpMat4);
    program.setUniformMatrix('WCVCMatrix', safeMatrixMultiply([tmpMat4, inverseShiftScaleMatrix], esm/* mat4 */.pB, model.tmpMat4));
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach(prim => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    // Return in MB
    return memUsed;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const PolyDataMapper2D_DEFAULT_VALUES = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null
};

// ----------------------------------------------------------------------------

function PolyDataMapper2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PolyDataMapper2D_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes;
  model.tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  for (let i = primTypes.Start; i < primTypes.End; i++) {
    model.primitives[i] = Helper/* default.newInstance */.Ay.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }

  // Build VTK API
  (0,macros2.e)(publicAPI, model, ['context']);
  model.VBOBuildTime = {};
  (0,macros2.o)(model.VBOBuildTime, {
    mtime: 0
  });

  // Object methods
  vtkOpenGLPolyDataMapper2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PolyDataMapper2D_newInstance = (0,macros2.n)(PolyDataMapper2D_extend, 'vtkOpenGLPolyDataMapper2D');

// ----------------------------------------------------------------------------

var vtkPolyDataMapper2D = {
  newInstance: PolyDataMapper2D_newInstance,
  extend: PolyDataMapper2D_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkMapper2D', PolyDataMapper2D_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
var ScalarsToColors = __webpack_require__(80993);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ScalarBarActor.js










const {
  VectorMode
} = ScalarsToColors/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkScalarBarActor
//
// Note log scales are currently not supported
//
// Developer note: This class is broken into the main class and a helper
// class. The main class holds view independent properties (those properties
// that do not change as the view's resolution/aspect ratio change). The
// helper class is instantiated one per view and holds properties that can
// depend on view specific values such as resolution. The helper class code
// could have been left to the View specific implementation (such as
// vtkWebGPUScalarBarActor) but is instead placed here to it can be shared by
// multiple rendering backends.
//
// ----------------------------------------------------------------------------

function ScalarBarActor_applyTextStyle(ctx, style) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
}

// ----------------------------------------------------------------------------
// Default autoLayout function
// ----------------------------------------------------------------------------

// compute good values to use based on window size etc a bunch of heuristics
// here with hand tuned constants These values worked for me but really this
// method could be redically changed. The basic gist is
// 1) compute a resonable font size
// 2) render the text atlas using those font sizes
// 3) pick horizontal or vertical bsed on window size
// 4) based on the size of the title and tick labels rendered
//    compute the box size and position such that
//    the text will all fit nicely and the bar will be a resonable size
// 5) compute the bar segments based on the above settings
//
// Note that this function can and should read values from the
// ScalarBarActor but should only write values to the view dependent helper
// instance that is provided as those values are the ones that will be used
// for rendering.
//
function defaultAutoLayout(publicAPI, model) {
  return helper => {
    // we don't do a linear scale, the proportions for
    // a 700 pixel window differ from a 1400
    const lastSize = helper.getLastSize();
    const xAxisAdjust = (lastSize[0] / 700) ** 0.8;
    const yAxisAdjust = (lastSize[1] / 700) ** 0.8;
    const minAdjust = Math.min(xAxisAdjust, yAxisAdjust);
    const axisTextStyle = helper.getAxisTextStyle();
    const tickTextStyle = helper.getTickTextStyle();
    Object.assign(axisTextStyle, model.axisTextStyle);
    Object.assign(tickTextStyle, model.tickTextStyle);

    // compute a reasonable font size first
    axisTextStyle.fontSize = Math.max(24 * minAdjust, 12);
    if (helper.getLastAspectRatio() > 1.0) {
      tickTextStyle.fontSize = Math.max(20 * minAdjust, 10);
    } else {
      tickTextStyle.fontSize = Math.max(16 * minAdjust, 10);
    }

    // rebuild the text atlas
    const textSizes = helper.updateTextureAtlas();

    // now compute the boxSize and pixel offsets, different algorithm
    // for horizonal versus vertical
    helper.setTopTitle(false);
    const boxSize = helper.getBoxSizeByReference();

    // if vertical
    if (helper.getLastAspectRatio() > 1.0) {
      helper.setTickLabelPixelOffset(0.3 * tickTextStyle.fontSize);

      // if the title will fit within the width of the bar then that looks
      // nicer to put it at the top (helper.topTitle), otherwise rotate it
      // and place it sideways
      if (textSizes.titleWidth <= textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) {
        helper.setTopTitle(true);
        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
        boxSize[0] = 2.0 * (textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
        helper.setBoxPosition([0.98 - boxSize[0], -0.92]);
      } else {
        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
        boxSize[0] = 2.0 * (textSizes.titleHeight + helper.getAxisTitlePixelOffset() + textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
        helper.setBoxPosition([0.99 - boxSize[0], -0.92]);
      }
      boxSize[1] = Math.max(1.2, Math.min(1.84 / yAxisAdjust, 1.84));
    } else {
      // horizontal
      helper.setAxisTitlePixelOffset(1.2 * tickTextStyle.fontSize);
      helper.setTickLabelPixelOffset(0.1 * tickTextStyle.fontSize);
      const titleHeight =
      // total offset from top of bar (includes ticks)
      2.0 * (0.8 * tickTextStyle.fontSize + textSizes.titleHeight + helper.getAxisTitlePixelOffset()) / lastSize[1];
      const tickWidth = 2.0 * textSizes.tickWidth / lastSize[0];
      boxSize[0] = Math.min(1.9, Math.max(1.4, 1.4 * tickWidth * (helper.getTicks().length + 3)));
      boxSize[1] = titleHeight;
      helper.setBoxPosition([-0.5 * boxSize[0], -0.97]);
    }

    // recomute bar segments based on positioning
    helper.recomputeBarSegments(textSizes);
  };
}

// ----------------------------------------------------------------------------
// Default generateTicks function
// ----------------------------------------------------------------------------

// This function returns the default function used to generate vtkScalarBarActor ticks.
// The default function makes use of d3.scaleLinear() to generate 5 tick marks between
// the minimum and maximum values of the scalar bar. Customize this behavior by passing
// a function to vtkScalarBarActor.newInstance({ generateTicks: customGenerateTicks })
// or by calling scalarBarActor.setGenerateTicks(customGenerateTicks).
function ScalarBarActor_defaultGenerateTicks(publicApi, model) {
  return helper => {
    const lastTickBounds = helper.getLastTickBounds();
    const scale = src/* scaleLinear */.m4().domain([lastTickBounds[0], lastTickBounds[1]]);
    const ticks = scale.ticks(5);
    const format = scale.tickFormat(5);
    helper.setTicks(ticks);
    helper.setTickStrings(ticks.map(format));
  };
}

// many properties of this actor depend on the API specific view The main
// dependency being the resolution as that drives what font sizes to use.
// Bacause of this we need to do some of the calculations in a API specific
// subclass. But... we don't want a lot of duplicated code between WebGL and
// WebGPU for example so we have this helper class, that is designed to be
// fairly API independent so that API specific views can call this to do
// most of the work.
function vtkScalarBarActorHelper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkScalarBarActorHelper');
  publicAPI.setRenderable = renderable => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.barActor.setProperty(renderable.getProperty());
    model.barActor.setParentProp(renderable);
    model.barActor.setCoordinateSystemToDisplay();
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    model.tmActor.setCoordinateSystemToDisplay();
    model.generateTicks = renderable.generateTicks;
    model.axisTextStyle = {
      ...renderable.getAxisTextStyle()
    };
    model.tickTextStyle = {
      ...renderable.getTickTextStyle()
    };
    publicAPI.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    // has the size changed?
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    const scalarsToColors = model.renderable.getScalarsToColors();
    if (!scalarsToColors || !model.renderable.getVisibility()) {
      return;
    }

    // make sure the lut is assigned to our mapper
    model.barMapper.setLookupTable(scalarsToColors);

    // camera should be the same for all views
    model.camera = camera;
    model.renderWindow = renderWindow;

    // did something significant change? If so rebuild a lot of things
    if (model.forceUpdate || Math.max(scalarsToColors.getMTime(), publicAPI.getMTime(), model.renderable.getMTime()) > model.lastRebuildTime.getMTime()) {
      const range = scalarsToColors.getMappingRange();
      model.lastTickBounds = [...range];

      // compute tick marks for axes (update for log scale)
      model.renderable.getGenerateTicks()(publicAPI);
      if (model.renderable.getAutomated()) {
        model.renderable.getAutoLayout()(publicAPI);
      } else {
        // copy values from renderable
        model.axisTextStyle = {
          ...model.renderable.getAxisTextStyle()
        };
        model.tickTextStyle = {
          ...model.renderable.getTickTextStyle()
        };
        model.barPosition = [...model.renderable.getBarPosition()];
        model.barSize = [...model.renderable.getBarSize()];
        model.boxPosition = [...model.renderable.getBoxPosition()];
        model.boxSize = [...model.renderable.getBoxSize()];
        model.axisTitlePixelOffset = model.renderable.getAxisTitlePixelOffset();
        model.tickLabelPixelOffset = model.renderable.getTickLabelPixelOffset();

        // rebuild the texture only when force or changed bounds, face
        // visibility changes do to change the atlas
        const textSizes = publicAPI.updateTextureAtlas();

        // recompute bar segments based on positioning
        publicAPI.recomputeBarSegments(textSizes);
      }
      publicAPI.updatePolyDataForLabels();
      publicAPI.updatePolyDataForBarSegments();
      model.lastRebuildTime.modified();
      model.forceUpdate = false;
    }
  };

  // create the texture map atlas that contains the rendering of
  // all the text strings. Only needs to be called when the text strings
  // have changed (labels and ticks)
  publicAPI.updateTextureAtlas = () => {
    // set the text properties
    model.tmContext.textBaseline = 'bottom';
    model.tmContext.textAlign = 'left';

    // return some factors about the text atlas
    const results = {};

    // first the axislabel
    const newTmAtlas = new Map();
    let maxWidth = 0;
    let totalHeight = 1; // start one pixel in so we have a border
    ScalarBarActor_applyTextStyle(model.tmContext, model.axisTextStyle);
    let metrics = model.tmContext.measureText(model.renderable.getAxisLabel());
    let entry = {
      height: metrics.actualBoundingBoxAscent + 2,
      startingHeight: totalHeight,
      width: metrics.width + 2,
      textStyle: model.axisTextStyle
    };
    newTmAtlas.set(model.renderable.getAxisLabel(), entry);
    totalHeight += entry.height;
    maxWidth = entry.width;
    results.titleWidth = entry.width;
    results.titleHeight = entry.height;

    // and the ticks, NaN Below and Above
    results.tickWidth = 0;
    results.tickHeight = 0;
    ScalarBarActor_applyTextStyle(model.tmContext, model.tickTextStyle);
    const strings = [...publicAPI.getTickStrings(), 'NaN', 'Below', 'Above'];
    for (let t = 0; t < strings.length; t++) {
      if (!newTmAtlas.has(strings[t])) {
        metrics = model.tmContext.measureText(strings[t]);
        entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.tickTextStyle
        };
        newTmAtlas.set(strings[t], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
        if (results.tickWidth < entry.width) {
          results.tickWidth = entry.width;
        }
        if (results.tickHeight < entry.height) {
          results.tickHeight = entry.height;
        }
      }
    }

    // always use power of two to avoid interpolation
    // in cases where PO2 is required
    maxWidth = (0,Core_Math.P)(maxWidth);
    totalHeight = (0,Core_Math.P)(totalHeight);

    // set the tcoord values
    newTmAtlas.forEach(value => {
      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];
    });

    // make sure we have power of two dimensions
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = 'bottom';
    model.tmContext.textAlign = 'left';
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);

    // draw the text onto the texture
    newTmAtlas.forEach((value, key) => {
      ScalarBarActor_applyTextStyle(model.tmContext, value.textStyle);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    // mark as modified since the canvas typically doesn't change
    model.tmTexture.modified();
    model._tmAtlas = newTmAtlas;
    return results;
  };
  publicAPI.computeBarSize = textSizes => {
    // compute orientation
    model.vertical = model.boxSize[1] > model.boxSize[0];
    const tickHeight = 2.0 * textSizes.tickHeight / model.lastSize[1];
    const segSize = [1, 1];

    // horizontal and vertical have different astetics so adjust based on
    // orientation
    if (model.vertical) {
      const tickWidth = 2.0 * (textSizes.tickWidth + model.tickLabelPixelOffset) / model.lastSize[0];
      if (model.topTitle) {
        const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
        model.barSize[0] = model.boxSize[0] - tickWidth;
        model.barSize[1] = model.boxSize[1] - titleHeight;
      } else {
        // rotated title so width is based off height
        const titleWidth = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[0];
        model.barSize[0] = model.boxSize[0] - titleWidth - tickWidth;
        model.barSize[1] = model.boxSize[1];
      }
      model.barPosition[0] = model.boxPosition[0] + tickWidth;
      model.barPosition[1] = model.boxPosition[1];
      segSize[1] = tickHeight;
    } else {
      const tickWidth = (2.0 * textSizes.tickWidth - 8) / model.lastSize[0];
      const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
      model.barSize[0] = model.boxSize[0];
      model.barPosition[0] = model.boxPosition[0];
      model.barSize[1] = model.boxSize[1] - titleHeight;
      model.barPosition[1] = model.boxPosition[1];
      segSize[0] = tickWidth;
    }
    return segSize;
  };

  // based on all the settins compute a barSegments array
  // containing the segments of the scalar bar
  // each segment contains
  //   corners[4][2]
  //   title - e.g. NaN, Above, ticks
  //   scalars - the normalized scalars values to use for that segment
  //
  // Note that the bar consumes the space in the box that remains after
  // leaving room for the text labels
  publicAPI.recomputeBarSegments = textSizes => {
    // first compute the barSize/Position
    const segSize = publicAPI.computeBarSize(textSizes);
    model.barSegments = [];
    const startPos = [0.0, 0.0];

    // horizontal and vertical have different astetics so adjust based on
    // orientation
    const barAxis = model.vertical ? 1 : 0;
    const segSpace = model.vertical ? 0.01 : 0.02;
    function pushSeg(title, scalars) {
      model.barSegments.push({
        corners: [[...startPos], [startPos[0] + segSize[0], startPos[1]], [startPos[0] + segSize[0], startPos[1] + segSize[1]], [startPos[0], startPos[1] + segSize[1]]],
        scalars,
        title
      });
      startPos[barAxis] += segSize[barAxis] + segSpace;
    }
    if (model.renderable.getDrawNanAnnotation() && model.renderable.getScalarsToColors().getNanColor()) {
      pushSeg('NaN', [NaN, NaN, NaN, NaN]);
    }
    if (model.renderable.getDrawBelowRangeSwatch() && model.renderable.getScalarsToColors().getUseBelowRangeColor?.()) {
      pushSeg('Below', [-0.1, -0.1, -0.1, -0.1]);
    }
    const haveAbove = model.renderable.getScalarsToColors().getUseAboveRangeColor?.();

    // extra space around the ticks section
    startPos[barAxis] += segSpace;
    const oldSegSize = segSize[barAxis];
    segSize[barAxis] = haveAbove ? 1.0 - 2.0 * segSpace - segSize[barAxis] - startPos[barAxis] : 1.0 - segSpace - startPos[barAxis];
    pushSeg('ticks', model.vertical ? [0, 0, 0.995, 0.995] : [0, 0.995, 0.995, 0]);
    if (model.renderable.getDrawAboveRangeSwatch() && haveAbove) {
      segSize[barAxis] = oldSegSize;
      startPos[barAxis] += segSpace;
      pushSeg('Above', [1.1, 1.1, 1.1, 1.1]);
    }
  };

  // called by updatePolyDataForLabels
  // modifies class constants tmp2v3
  const tmp2v3 = new Float64Array(3);

  // anchor point = pos
  // H alignment = left, middle, right
  // V alignment = bottom, middle, top
  // Text Orientation = horizontal, vertical
  // orientation
  publicAPI.createPolyDataForOneLabel = (text, pos, alignment, orientation, offset, results) => {
    const value = model._tmAtlas.get(text);
    if (!value) {
      return;
    }
    // have to find the four corners of the texture polygon for this label
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;

    // get achor point in pixels
    tmp2v3[0] = (0.5 * pos[0] + 0.5) * model.lastSize[0];
    tmp2v3[1] = (0.5 * pos[1] + 0.5) * model.lastSize[1];
    tmp2v3[2] = pos[2];
    tmp2v3[0] += offset[0];
    tmp2v3[1] += offset[1];

    // get text size in display pixels
    const textSize = [];
    const textAxes = orientation === 'vertical' ? [1, 0] : [0, 1];
    if (orientation === 'vertical') {
      textSize[0] = value.width;
      textSize[1] = -value.height;
      // update anchor point based on alignment
      if (alignment[0] === 'middle') {
        tmp2v3[1] -= value.width / 2.0;
      } else if (alignment[0] === 'right') {
        tmp2v3[1] -= value.width;
      }
      if (alignment[1] === 'middle') {
        tmp2v3[0] += value.height / 2.0;
      } else if (alignment[1] === 'top') {
        tmp2v3[0] += value.height;
      }
    } else {
      textSize[0] = value.width;
      textSize[1] = value.height;
      // update anchor point based on alignment
      if (alignment[0] === 'middle') {
        tmp2v3[0] -= value.width / 2.0;
      } else if (alignment[0] === 'right') {
        tmp2v3[0] -= value.width;
      }
      if (alignment[1] === 'middle') {
        tmp2v3[1] -= value.height / 2.0;
      } else if (alignment[1] === 'top') {
        tmp2v3[1] -= value.height;
      }
    }
    results.points[ptIdx * 3] = tmp2v3[0];
    results.points[ptIdx * 3 + 1] = tmp2v3[1];
    results.points[ptIdx * 3 + 2] = tmp2v3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    tmp2v3[textAxes[0]] += textSize[0];
    results.points[ptIdx * 3] = tmp2v3[0];
    results.points[ptIdx * 3 + 1] = tmp2v3[1];
    results.points[ptIdx * 3 + 2] = tmp2v3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    tmp2v3[textAxes[1]] += textSize[1];
    results.points[ptIdx * 3] = tmp2v3[0];
    results.points[ptIdx * 3 + 1] = tmp2v3[1];
    results.points[ptIdx * 3 + 2] = tmp2v3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    tmp2v3[textAxes[0]] -= textSize[0];
    results.points[ptIdx * 3] = tmp2v3[0];
    results.points[ptIdx * 3 + 1] = tmp2v3[1];
    results.points[ptIdx * 3 + 2] = tmp2v3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;

    // add the two triangles to represent the quad
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };

  // update the polydata associated with drawing the text labels
  // specifically the quads used for each label and their associated tcoords
  // etc. This changes every time the camera viewpoint changes
  const tmpv3 = new Float64Array(3);
  publicAPI.updatePolyDataForLabels = () => {
    // update the polydata
    const numLabels = publicAPI.getTickStrings().length + model.barSegments.length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };

    // compute the direction vector
    const offsetAxis = model.vertical ? 0 : 1;
    const spacedAxis = model.vertical ? 1 : 0;
    tmpv3[2] = -0.99; // near plane

    // draw the title
    const alignment = model.vertical ? ['right', 'middle'] : ['middle', 'bottom'];
    let dir = [0, 1];
    const tickOffsets = [0, 0];
    if (model.vertical) {
      tickOffsets[0] = -model.tickLabelPixelOffset;
      if (model.topTitle) {
        tmpv3[0] = model.boxPosition[0] + 0.5 * model.boxSize[0];
        tmpv3[1] = model.barPosition[1] + model.barSize[1];

        // write the axis label
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);
      } else {
        tmpv3[0] = model.barPosition[0] + model.barSize[0];
        tmpv3[1] = model.barPosition[1] + 0.5 * model.barSize[1];

        // write the axis label
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'top'], 'vertical', [model.axisTitlePixelOffset, 0], results);
      }
      dir = [-1, 0];
    } else {
      tickOffsets[1] = model.tickLabelPixelOffset;
      tmpv3[0] = model.barPosition[0] + 0.5 * model.barSize[0];
      tmpv3[1] = model.barPosition[1] + model.barSize[1];
      publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);
    }
    tmpv3[offsetAxis] = model.barPosition[offsetAxis] + (0.5 * dir[offsetAxis] + 0.5) * model.barSize[offsetAxis];
    tmpv3[spacedAxis] = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * 0.5;

    // draw bar segment labels
    let tickSeg = null;
    for (let i = 0; i < model.barSegments.length; i++) {
      const seg = model.barSegments[i];
      if (seg.title === 'ticks') {
        // handle ticks below
        tickSeg = seg;
      } else {
        tmpv3[spacedAxis] = model.barPosition[spacedAxis] + 0.5 * model.barSize[spacedAxis] * (seg.corners[2][spacedAxis] + seg.corners[0][spacedAxis]);
        publicAPI.createPolyDataForOneLabel(seg.title, tmpv3, alignment, 'horizontal', tickOffsets, results);
      }
    }

    // write the tick labels
    const tickSegmentStart = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * tickSeg.corners[0][spacedAxis];
    const tickSegmentSize = model.barSize[spacedAxis] * (tickSeg.corners[2][spacedAxis] - tickSeg.corners[0][spacedAxis]);
    const ticks = publicAPI.getTicks();
    const tickStrings = publicAPI.getTickStrings();
    for (let t = 0; t < ticks.length; t++) {
      const tickPos = (ticks[t] - model.lastTickBounds[0]) / (model.lastTickBounds[1] - model.lastTickBounds[0]);
      tmpv3[spacedAxis] = tickSegmentStart + tickSegmentSize * tickPos;
      publicAPI.createPolyDataForOneLabel(tickStrings[t], tmpv3, alignment, 'horizontal', tickOffsets, results);
    }
    const tcoordDA = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: 'TextureCoordinates'
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updatePolyDataForBarSegments = () => {
    const scalarsToColors = model.renderable.getScalarsToColors();
    let numberOfExtraColors = 0;
    if (model.renderable.getDrawNanAnnotation() && scalarsToColors.getNanColor()) {
      numberOfExtraColors += 1;
    }
    if (model.renderable.getDrawBelowRangeSwatch() && scalarsToColors.getUseBelowRangeColor?.()) {
      numberOfExtraColors += 1;
    }
    if (model.renderable.getDrawAboveRangeSwatch() && scalarsToColors.getUseAboveRangeColor?.()) {
      numberOfExtraColors += 1;
    }
    const numPts = 4 * (1 + numberOfExtraColors);
    const numQuads = numPts;

    // handle vector component mode
    let numComps = 1;
    if (scalarsToColors.getVectorMode() === VectorMode.COMPONENT) {
      numComps = scalarsToColors.getVectorComponent() + 1;
    }

    // create the colored bars
    const points = new Float64Array(numPts * 3);
    const cells = new Uint16Array(numQuads * 5);
    const scalars = new Float32Array(numPts * numComps);
    let ptIdx = 0;
    let cellIdx = 0;
    for (let i = 0; i < model.barSegments.length; i++) {
      const seg = model.barSegments[i];
      for (let e = 0; e < 4; e++) {
        tmpv3[0] = model.barPosition[0] + seg.corners[e][0] * model.barSize[0];
        tmpv3[1] = model.barPosition[1] + seg.corners[e][1] * model.barSize[1];
        points[ptIdx * 3] = (0.5 * tmpv3[0] + 0.5) * model.lastSize[0];
        points[ptIdx * 3 + 1] = (0.5 * tmpv3[1] + 0.5) * model.lastSize[1];
        points[ptIdx * 3 + 2] = tmpv3[2];
        for (let nc = 0; nc < numComps; nc++) {
          scalars[ptIdx * numComps + nc] = model.lastTickBounds[0] + seg.scalars[e] * (model.lastTickBounds[1] - model.lastTickBounds[0]);
        }
        ptIdx++;
      }
      cells[cellIdx * 5] = 4;
      cells[cellIdx * 5 + 1] = ptIdx - 4;
      cells[cellIdx * 5 + 2] = ptIdx - 3;
      cells[cellIdx * 5 + 3] = ptIdx - 2;
      cells[cellIdx * 5 + 4] = ptIdx - 1;
      cellIdx++;
    }
    const scalarsDA = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: numComps,
      values: scalars,
      name: 'Scalars'
    });
    model.polyData.getPointData().setScalars(scalarsDA);
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getPolys().setData(cells, 1);
    model.polyData.getPolys().modified();
    model.polyData.modified();
  };
}
const newScalarBarActorHelper = macros2.m.newInstance(function (publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);

  // Inheritance
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['axisTitlePixelOffset', 'tickLabelPixelOffset', 'renderable', 'topTitle', 'ticks', 'tickStrings']);
  macros2.m.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'lastTickBounds', 'axisTextStyle', 'tickTextStyle', 'barActor', 'tmActor']);
  macros2.m.getArray(publicAPI, model, ['boxPosition', 'boxSize']);
  macros2.m.setArray(publicAPI, model, ['boxPosition', 'boxSize'], 2);
  model.forceUpdate = false;
  model.lastRebuildTime = {};
  macros2.m.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];
  model.tmCanvas = document.createElement('canvas');
  model.tmContext = model.tmCanvas.getContext('2d');
  model._tmAtlas = new Map();
  model.barMapper = Mapper/* default.newInstance */.Ay.newInstance();
  model.barMapper.setInterpolateScalarsBeforeMapping(true);
  model.barMapper.setUseLookupTableScalarRange(true);
  model.polyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.barMapper.setInputData(model.polyData);
  model.barActor = Core_Actor/* default.newInstance */.Ay.newInstance();
  model.barActor.setMapper(model.barMapper);

  // for texture atlas
  model.tmPolyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.tmMapper = Mapper/* default.newInstance */.Ay.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmTexture = Texture/* default.newInstance */.Ay.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  model.tmActor = Core_Actor/* default.newInstance */.Ay.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  model.tmActor.addTexture(model.tmTexture);
  model.barPosition = [0, 0];
  model.barSize = [0, 0];
  model.boxPosition = [0.88, -0.92];
  model.boxSize = [0.1, 1.1];

  // internal variables
  model.lastTickBounds = [];
  vtkScalarBarActorHelper(publicAPI, model);
}, 'vtkScalarBarActorHelper');

//
// Now we define the public class that the application sets view independent
// properties on. This class is fairly small as it mainly just holds
// properties setter and getters leaving all calculations to the helper
// class.
//
function vtkScalarBarActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkScalarBarActor');
  publicAPI.setTickTextStyle = tickStyle => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = axisStyle => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.resetAutoLayoutToDefault = () => {
    publicAPI.setAutoLayout(defaultAutoLayout(publicAPI, model));
  };
  publicAPI.resetGenerateTicksToDefault = () => {
    publicAPI.setGenerateTicks(ScalarBarActor_defaultGenerateTicks());
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

function ScalarBarActor_defaultValues(initialValues) {
  return {
    automated: true,
    autoLayout: null,
    axisLabel: 'Scalar Value',
    barPosition: [0, 0],
    barSize: [0, 0],
    boxPosition: [0.88, -0.92],
    boxSize: [0.1, 1.1],
    scalarToColors: null,
    axisTitlePixelOffset: 36.0,
    axisTextStyle: {
      fontColor: 'white',
      fontStyle: 'normal',
      fontSize: 18,
      fontFamily: 'serif'
    },
    tickLabelPixelOffset: 14.0,
    tickTextStyle: {
      fontColor: 'white',
      fontStyle: 'normal',
      fontSize: 14,
      fontFamily: 'serif'
    },
    generateTicks: null,
    drawNanAnnotation: true,
    drawBelowRangeSwatch: true,
    drawAboveRangeSwatch: true,
    ...initialValues
  };
}

// ----------------------------------------------------------------------------

function ScalarBarActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ScalarBarActor_defaultValues(initialValues));
  if (!model.autoLayout) model.autoLayout = defaultAutoLayout(publicAPI, model);
  if (!model.generateTicks) model.generateTicks = ScalarBarActor_defaultGenerateTicks();

  // Inheritance
  Core_Actor/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  publicAPI.getProperty().setDiffuse(0.0);
  publicAPI.getProperty().setAmbient(1.0);
  macros2.m.setGet(publicAPI, model, ['automated', 'autoLayout', 'axisTitlePixelOffset', 'axisLabel', 'scalarsToColors', 'tickLabelPixelOffset', 'generateTicks', 'drawNanAnnotation', 'drawBelowRangeSwatch', 'drawAboveRangeSwatch']);
  macros2.m.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle']);
  macros2.m.getArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize']);
  macros2.m.setArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize'], 2);

  // Object methods
  vtkScalarBarActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ScalarBarActor_newInstance = macros2.m.newInstance(ScalarBarActor_extend, 'vtkScalarBarActor');

// ----------------------------------------------------------------------------

var vtkScalarBarActor$1 = {
  newInstance: ScalarBarActor_newInstance,
  extend: ScalarBarActor_extend,
  newScalarBarActorHelper
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ScalarBarActor.js





// ----------------------------------------------------------------------------
// vtkOpenGLScalarBarActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLScalarBarActor(publicAPI, model) {
  model.classHierarchy.push('vtkOpenGLScalarBarActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ScalarBarActor_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function OpenGL_ScalarBarActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ScalarBarActor_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();

  // Object methods
  vtkOpenGLScalarBarActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const OpenGL_ScalarBarActor_newInstance = (0,macros2.n)(OpenGL_ScalarBarActor_extend, 'vtkOpenGLScalarBarActor');

// ----------------------------------------------------------------------------

var ScalarBarActor_index = {
  newInstance: OpenGL_ScalarBarActor_newInstance,
  extend: OpenGL_ScalarBarActor_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkScalarBarActor', OpenGL_ScalarBarActor_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
var Skybox = __webpack_require__(92530);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var OpenGL_Texture = __webpack_require__(1013);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var PixelSpaceCallbackMapper = __webpack_require__(68464);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
var WebGPU_Camera = __webpack_require__(26910);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js + 1 modules
var WebGPU_Renderer = __webpack_require__(24210);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop.js + 1 modules
var Prop = __webpack_require__(46985);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var WebGPU_ViewNodeFactory = __webpack_require__(50440);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor.js






const {
  CoordinateSystem
} = Prop/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkWebGPUActor methods
// ----------------------------------------------------------------------------

function vtkWebGPUActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = wgpuRen => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = wgpuRen => {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();

      // compute the net shift, only apply stabilized coords with world coordinates
      model.bufferShift[0] = mcwc[3];
      model.bufferShift[1] = mcwc[7];
      model.bufferShift[2] = mcwc[11];
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === CoordinateSystem.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      esm/* mat4.transpose */.pB.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        esm/* mat4.identity */.pB.identity(model.keyMatrices.normalMatrix);
      } else {
        // we use bcwc BEFORE the translate below (just to get transposed mcvc)
        esm/* mat4.copy */.pB.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        // zero out translation
        model.keyMatrices.normalMatrix[3] = 0.0;
        model.keyMatrices.normalMatrix[7] = 0.0;
        model.keyMatrices.normalMatrix[11] = 0.0;
        esm/* mat4.invert */.pB.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        esm/* mat4.transpose */.pB.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }

      // only need the buffer shift to get to world
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);

      // to get to stabilized we also need the center
      if (model.renderable.getCoordinateSystem() === CoordinateSystem.WORLD) {
        esm/* mat4.translate */.pB.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        esm/* mat4.copy */.pB.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Actor_DEFAULT_VALUES = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: undefined,
  bufferShift: undefined
};

// ----------------------------------------------------------------------------

function Actor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Actor_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macros2.m.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macros2.m.get(publicAPI, model, ['propID', 'keyMatricesTime']);
  model.bufferShift = [0, 0, 0, 0];

  // Object methods
  vtkWebGPUActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Actor_newInstance = macros2.m.newInstance(Actor_extend);

// ----------------------------------------------------------------------------

var Actor_index = {
  newInstance: Actor_newInstance,
  extend: Actor_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkActor', Actor_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor2D.js






const {
  CoordinateSystem: Actor2D_CoordinateSystem
} = Prop/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkWebGPUActor methods
// ----------------------------------------------------------------------------

function vtkWebGPUActor2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUActor2D');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = wgpuRen => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = wgpuRen => {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      // compute the net shift, only apply stabilized coords with world coordinates
      model.bufferShift[0] = 0.0;
      model.bufferShift[1] = 0.0;
      model.bufferShift[2] = 0.0;
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === Actor2D_CoordinateSystem.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      esm/* mat4.identity */.pB.identity(model.keyMatrices.bcwc);
      esm/* mat4.identity */.pB.identity(model.keyMatrices.normalMatrix);

      // only meed the buffer shift to get to world
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);

      // to get to stabilized we also need the center
      if (model.renderable.getCoordinateSystem() === Actor2D_CoordinateSystem.WORLD) {
        esm/* mat4.translate */.pB.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        esm/* mat4.copy */.pB.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Actor2D_DEFAULT_VALUES = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: undefined,
  bufferShift: undefined
};

// ----------------------------------------------------------------------------

function Actor2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Actor2D_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macros2.m.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macros2.m.get(publicAPI, model, ['propID', 'keyMatricesTime']);
  model.bufferShift = [0, 0, 0, 0];

  // Object methods
  vtkWebGPUActor2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Actor2D_newInstance = macros2.m.newInstance(Actor2D_extend);

// ----------------------------------------------------------------------------

var Actor2D_index = {
  newInstance: Actor2D_newInstance,
  extend: Actor2D_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkActor2D', Actor2D_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/CubeAxesActor.js





// ----------------------------------------------------------------------------
// vtkWebGPUCubeAxesActor methods
// ----------------------------------------------------------------------------

function vtkWebGPUCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push('vtkWebGPUCubeAxesActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const CubeAxesActor_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function WebGPU_CubeAxesActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, CubeAxesActor_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();

  // Object methods
  vtkWebGPUCubeAxesActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const WebGPU_CubeAxesActor_newInstance = (0,macros2.n)(WebGPU_CubeAxesActor_extend, 'vtkWebGPUCubeAxesActor');

// ----------------------------------------------------------------------------

var CubeAxesActor_index = {
  newInstance: WebGPU_CubeAxesActor_newInstance,
  extend: WebGPU_CubeAxesActor_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkCubeAxesActor', WebGPU_CubeAxesActor_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js + 3 modules
var BufferManager = __webpack_require__(49767);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var Property = __webpack_require__(89585);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property2D.js




const {
  DisplayLocation: Property2D_DisplayLocation
} = Constants_Constants;

// ----------------------------------------------------------------------------
// vtkProperty2D methods
// ----------------------------------------------------------------------------

function vtkProperty2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProperty2D');
  publicAPI.setDisplayLocationToBackground = () => publicAPI.setDisplayLocation(Property2D_DisplayLocation.BACKGROUND);
  publicAPI.setDisplayLocationToForeground = () => publicAPI.setDisplayLocation(Property2D_DisplayLocation.FOREGROUND);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Property_Constants/* Representation */.YL.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Property_Constants/* Representation */.YL.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Property_Constants/* Representation */.YL.POINTS);
  publicAPI.getRepresentationAsString = () => macros2.m.enumToString(Property_Constants/* Representation */.YL, model.representation);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const Property2D_DEFAULT_VALUES = {
  color: [1, 1, 1],
  opacity: 1,
  pointSize: 1,
  lineWidth: 1,
  representation: Property_Constants/* Representation */.YL.SURFACE,
  displayLocation: Property2D_DisplayLocation.FOREGROUND
};

// ----------------------------------------------------------------------------

function Property2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Property2D_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['opacity', 'lineWidth', 'pointSize', 'displayLocation', 'representation']);
  macros2.m.setGetArray(publicAPI, model, ['color'], 3);

  // Object methods
  vtkProperty2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Property2D_newInstance = macros2.m.newInstance(Property2D_extend, 'vtkProperty2D');

// ----------------------------------------------------------------------------

var vtkProperty2D$1 = {
  newInstance: Property2D_newInstance,
  extend: Property2D_extend,
  ...Constants_Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js + 1 modules
var ShaderCache = __webpack_require__(9806);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var UniformBuffer = __webpack_require__(83259);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js + 3 modules
var SimpleMapper = __webpack_require__(32603);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var Types = __webpack_require__(57372);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js













const {
  BufferUsage,
  PrimitiveTypes
} = BufferManager/* default */.Ay;
const {
  Representation
} = Property/* default */.Ay;
const {
  ScalarMode: CellArrayMapper_ScalarMode
} = Mapper/* default */.Ay;
const {
  CoordinateSystem: CellArrayMapper_CoordinateSystem
} = Prop/* default */.Ay;
const {
  DisplayLocation: CellArrayMapper_DisplayLocation
} = vtkProperty2D$1;
const vtkWebGPUPolyDataVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
const vtkWebGPUPolyDataFS = `
struct PBRData {
  diffuse: vec3<f32>,
  specular: vec3<f32>,
}

// Dot product with the max already in it
fn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  return max(0.0, dot(a, b));
}
// Dot product with a max in it that does not allow for negative values
// Physically based rendering is accurate as long as normals are accurate,
// however this is pretty often not the case. In order to prevent negative
// values from ruining light calculations and creating zones of zero light,
// this remapping is used, which smoothly clamps the dot product between
// zero and one while still maintaining a good amount of accuracy.
fn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  var d: f32 = max(0.0, dot(a, b));
  d = pow((d + 1.0) / 2.0, 2.6);
  return d;
}

// Lambertian diffuse model
fn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {
  var pi: f32 = 3.14159265359; 
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5);
  return (base/pi)*NdotL;
}

// Yasuhiro Fujii improvement on the Oren-Nayar model
// https://mimosa-pudica.net/improved-oren-nayar.html
// p is surface color, o is roughness
fn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {
  var invpi: f32 = 0.31830988618; // 1/pi

  var o2 = o*o;
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the "seams" between lights better

  var NdotV: f32 = mdot(N, V);
  var LdotV: f32 = mdot(L, V);

  var s: f32 = LdotV - NdotL*NdotV;
  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement
  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));
  A = invpi*(1 - A);
  var B: f32 = 0.45*(o2 / (o2 + 0.09));
  B = invpi*B;

  return p*NdotL*(A + B*(s/t));
}

// Fresnel portion of BRDF (IOR only, simplified)
fn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {
  var NdotV: f32 = mdot(V, N);
  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not
  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);
}

// Fresnel portion of BRDF (Color ior, better)
fn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {
  var NdotV: f32 = mdot(V, N);
  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);
}

// Normal portion of BRDF
// https://learnopengl.com/PBR/Theory
// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2
fn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {
  var pi: f32 = 3.14159265359; 

  var a2: f32 = a*a;
  var NdotH = mdot(N, H);
  var NdotH2 = NdotH*NdotH;
  
  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;

  return a2 / max((pi*denom*denom), 0.000001);
}

// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent
fn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {
  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;

  var ggx1: f32 = trGGX(N + Op*s, H, a);
  var ggx2: f32 = trGGX(N - Op*s, H, a);
  return (0.5 * ggx1 + 0.5 * ggx2);
}

// Geometry portion of BRDF
fn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {
  var NdotX = cdot(N, X);
  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));
}

fn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {
  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));
  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));
  return ggx1*ggx2;
}

// BRDF Combination
fn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {
  var num: f32 = D*F*G;
  var denom: f32 = 4*cdot(V, N)*cdot(L, N);

  return num / max(denom, 0.000001);
}

// Different lighting calculations for different light sources
fn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  
  var L: vec3<f32> = normalize(direction); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later
  var incoming: vec3<f32> = color;
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5);

  var specular: vec3<f32> = brdf*incoming*angle;
  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate
  // control property for the diffuse vs specular roughness
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); 
  // Stores the specular and diffuse separately to allow for finer post processing
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// TODO: find some way to reduce the number of arguments going in here
fn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  var incoming: vec3<f32> = color * (1.0 / (dist*dist));
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights
fn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos);
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  
  // Cones.x is the inner phi and cones.y is the outer phi
  var theta: f32 = mdot(normalize(direction), L);
  var epsilon: f32 = cones.x - cones.y;
  var intensity: f32 = (theta - cones.y) / epsilon;
  intensity = clamp(intensity, 0.0, 1.0);
  intensity /= dist*dist;

  var incoming: vec3<f32> = color * intensity;

  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// Environment mapping stuff
// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::TCoord::Dec

// optional surface normal declaration
//VTK::Normal::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  // Temporary ambient, diffuse, and opacity
  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;
  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;
  var opacity: f32 = mapperUBO.Opacity;

  // This should be declared somewhere else
  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);
  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);
  var _metallicMap: vec4<f32> = vec4<f32>(1.0);
  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment
  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);
  var _emissionMap: vec4<f32> = vec4<f32>(0.);

  //VTK::Color::Impl

  //VTK::TCoord::Impl

  //VTK::Normal::Impl

  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);

  //VTK::Light::Impl

  //VTK::Select::Impl

  if (computedColor.a == 0.0) { discard; };

  //VTK::Position::Impl

  //VTK::RenderEncoder::Impl

  return output;
}
`;
function isEdges(hash) {
  // edge pipelines have "edge" in them
  return hash.indexOf('edge') >= 0;
}

// ----------------------------------------------------------------------------
// vtkWebGPUCellArrayMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUCellArrayMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUCellArrayMapper');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (model.is2D) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');
        model.forceZValue = true;
      } else {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');
        model.forceZValue = false;
      }
      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();
      model.useRendererMatrix = model.coordinateSystem !== CellArrayMapper_CoordinateSystem.DISPLAY;
      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
    }
  };

  // Renders myself
  publicAPI.translucentPass = prepass => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.updateUBO = () => {
    // make sure the data is up to date
    const actor = model.WebGPUActor.getRenderable();
    const ppty = actor.getProperty();
    const utime = model.UBO.getSendTime();
    if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {
      // Matricies
      const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);
      model.UBO.setArray('BCWCMatrix', keyMats.bcwc);
      model.UBO.setArray('BCSCMatrix', keyMats.bcsc);
      model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);
      if (model.is2D) {
        model.UBO.setValue('ZValue', model.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === CellArrayMapper_DisplayLocation.FOREGROUND ? 1.0 : 0.0);
        const aColor = ppty.getColorByReference();
        model.UBO.setValue('AmbientIntensity', 1.0);
        model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);
        model.UBO.setValue('DiffuseIntensity', 0.0);
        model.UBO.setValue('SpecularIntensity', 0.0);
      } else {
        // Base Colors
        let aColor = ppty.getAmbientColorByReference();
        model.UBO.setValue('AmbientIntensity', ppty.getAmbient());
        model.UBO.setArray('AmbientColor', [aColor[0], aColor[1], aColor[2], 1.0]);
        model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());
        aColor = ppty.getDiffuseColorByReference();
        model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);
        // Roughness
        model.UBO.setValue('Roughness', ppty.getRoughness());
        model.UBO.setValue('BaseIOR', ppty.getBaseIOR());
        // Metallic
        model.UBO.setValue('Metallic', ppty.getMetallic());
        // Normal
        model.UBO.setValue('NormalStrength', ppty.getNormalStrength());
        // Emission
        model.UBO.setValue('Emission', ppty.getEmission());
        // Specular
        model.UBO.setValue('SpecularIntensity', ppty.getSpecular());
        aColor = ppty.getSpecularColorByReference();
        model.UBO.setArray('SpecularColor', [aColor[0], aColor[1], aColor[2], 1.0]);
      }
      // Edge and line rendering
      const aColor = ppty.getEdgeColorByReference?.();
      if (aColor) {
        model.UBO.setArray('EdgeColor', [aColor[0], aColor[1], aColor[2], 1.0]);
      }
      model.UBO.setValue('LineWidth', ppty.getLineWidth());
      model.UBO.setValue('Opacity', ppty.getOpacity());
      model.UBO.setValue('PropID', model.WebGPUActor.getPropID());
      const device = model.WebGPURenderWindow.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.haveWideLines = () => {
    const actor = model.WebGPUActor.getRenderable();
    const representation = actor.getProperty().getRepresentation();
    if (actor.getProperty().getLineWidth() <= 1.0) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes.Verts) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {
      return representation === Representation.WIREFRAME;
    }
    return true;
  };
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');
    let code = vDesc.getCode();
    if (model.useRendererMatrix) {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);', '//VTK::Position::Impl']).result;
      if (model.forceZValue) {
        code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);', 'pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;
      }
    } else {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;', '    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;', '    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;', '    pCoord.z = 0.5 - 0.5 * pCoord.z;', '//VTK::Position::Impl']).result;
      if (model.forceZValue) {
        code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;
      }
    }
    if (publicAPI.haveWideLines()) {
      vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex');
      // widen the edge
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = pCoord;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);',
      // could become a setting
      '    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '//VTK::Position::Impl']).result;
    }
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    output.Position = pCoord;']).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
    const normalBuffer = vertexInput.getBuffer('normalMC');
    const actor = model.WebGPUActor.getRenderable();
    if (normalBuffer) {
      const vDesc = pipeline.getShaderDescription('vertex');
      if (!vDesc.hasOutput('normalVC')) {
        vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput('tangentVC')) {
        vDesc.addOutput('vec3<f32>', 'tangentVC', normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput('bitangentVC')) {
        vDesc.addOutput('vec3<f32>', 'bitangentVC', normalBuffer.getArrayInformation()[0].interpolation);
      }
      let code = vDesc.getCode();
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);',
      // This is just an approximation, but it happens to work extremely well
      // It only works well for normals that are head on and not super angled though
      // Definitely needs to be replaced
      '  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));', '  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));', '  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));', '  output.tangentVC = normalize(tangent);', '  output.bitangentVC = normalize(cross(output.normalVC, tangent));']).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription('fragment');
      code = fDesc.getCode();
      if (actor.getProperty().getNormalTexture()) {
        code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  var tangent: vec3<f32> = input.tangentVC;', '  var bitangent: vec3<f32> = input.bitangentVC;', '  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(', '    tangent.x, bitangent.x, normal.x,', '    tangent.y, bitangent.y, normal.y,', '    tangent.z, bitangent.z, normal.z,', '  );', '  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);', '  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);', '  normal = normalize(normal);']).result;
      } else {
        code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  normal = normalize(normal);']).result;
      }
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal);

  // we only apply lighting when there is a "var normal" declaration in the
  // fragment shader code. That is the lighting trigger.
  publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {
    if (hash.includes('sel')) return;
    const vDesc = pipeline.getShaderDescription('vertex');
    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');
    const renderer = model.WebGPURenderer.getRenderable();
    const fDesc = pipeline.getShaderDescription('fragment');
    let code = fDesc.getCode();

    // Code that runs if the fragment shader includes normals
    if (code.includes('var normal:') && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes('sel')) {
      const lightingCode = [
      // Constants
      '  var pi: f32 = 3.14159265359;',
      // Vectors needed for light calculations
      '  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);', '  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector',
      // Values needed for light calculations
      '  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;', '  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);',
      // Need to have a different way of sampling greyscale values aside from .r
      '  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;', '  var alpha: f32 = roughness*roughness;', '  var ior: f32 = mapperUBO.BaseIOR;', '  var k: f32 = alpha*alpha / 2;',
      // Split diffuse and specular components
      '  var diffuse: vec3<f32> = vec3<f32>(0.);', '  var specular: vec3<f32> = vec3<f32>(0.);', '  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;',
      // Summing diffuse and specular components of directional lights
      '  {', '    var i: i32 = 0;', '    loop {', '      if !(i < rendererUBO.LightCount) { break; }', '      switch (i32(rendererLightSSBO.values[i].LightData.x)) {', '         // Point Light', '         case 0 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '          }', '         // Directional light', '         case 1 {', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         // Spot Light', '         case 2 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);', '           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         default { continue; }', '       }', '      continuing { i++; }', '    }', '  }',
      // Final variables for combining specular and diffuse
      '  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel', '  fresnel = min(1.0, fresnel);', '  // This could be controlled with its own variable (that isnt base color) for better artistic control', '  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account', '  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);', '  kS = min(vec3<f32>(1.0), kS);', '  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);', '  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;', '  PBR += emission;', '  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);'];
      if (renderer.getEnvironmentTexture()?.getImageLoaded()) {
        lightingCode.push('  // To get diffuse IBL, the texture is sampled with normals in worldspace', '  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;', '  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);', '  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors', '  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment', '  var VreflN: vec3<f32> = normalize(reflect(-V, normal));', '  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;', '  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);', '  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);',
        // Level multiplier should be set by UBO
        '  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;', '  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);',
        // Manual mip smoothing since not all formats support smooth level sampling
        '  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;', '  computedColor += vec4<f32>(specularIBLContribution*kS, 0);', '  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;', '  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;',
        // Multipy by baseColor may be changed
        '  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);');
      }
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Light::Impl', lightingCode).result;
      fDesc.setCode(code);
      // If theres no normals, just set the specular color to be flat
    } else {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Light::Impl', ['  var diffuse: vec3<f32> = diffuseColor.rgb;', '  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;', '  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);']).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);
  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {
    // By default, set the colors to be flat
    if (isEdges(hash)) {
      const fDesc = pipeline.getShaderDescription('fragment');
      let code = fDesc.getCode();
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;
      fDesc.setCode(code);
      return;
    }

    // If there's no vertex color buffer return the shader as is
    const colorBuffer = vertexInput.getBuffer('colorVI');
    if (!colorBuffer) return;

    // Modifies the vertex shader to include the vertex colors and interpolation in the outputs
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);
    let code = vDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;
    vDesc.setCode(code);

    // Sets the fragment shader to accept the color inputs from the vertex shader
    const fDesc = pipeline.getShaderDescription('fragment');
    code = fDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    if (!vertexInput.hasAttribute('tcoord')) return;
    const vDesc = pipeline.getShaderDescription('vertex');
    const tcoords = vertexInput.getBuffer('tcoord');
    const numComp = Types/* default */.A.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
    let code = vDesc.getCode();
    vDesc.addOutput(`vec${numComp}<f32>`, 'tcoordVS');
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription('fragment');
    code = fDesc.getCode();
    const actor = model.WebGPUActor.getRenderable();
    const checkDims = texture => {
      if (!texture) return false;
      const dims = texture.getDimensionality();
      return dims === numComp;
    };
    const usedTextures = [];
    if (actor.getProperty().getDiffuseTexture?.()?.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {
      if (
      // Chained or statements here are questionable
      checkDims(actor.getProperty().getDiffuseTexture?.()) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {
        usedTextures.push('_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getRoughnessTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getRoughnessTexture())) {
        usedTextures.push('_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getMetallicTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getMetallicTexture())) {
        usedTextures.push('_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getNormalTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getNormalTexture())) {
        usedTextures.push('_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getAmbientOcclusionTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getAmbientOcclusionTexture())) {
        usedTextures.push('_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getEmissionTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getEmissionTexture())) {
        usedTextures.push('_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);');
      }
    }
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::TCoord::Impl', usedTextures).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {
    if (hash.includes('sel')) {
      const fDesc = pipeline.getShaderDescription('fragment');
      let code = fDesc.getCode();
      // by default there are no composites, so just 0
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);
  publicAPI.getUsage = (rep, i) => {
    if (rep === Representation.POINTS || i === PrimitiveTypes.Points) {
      return BufferUsage.Verts;
    }
    if (i === PrimitiveTypes.Lines) {
      return BufferUsage.Lines;
    }
    if (rep === Representation.WIREFRAME) {
      if (i === PrimitiveTypes.Triangles) {
        return BufferUsage.LinesFromTriangles;
      }
      return BufferUsage.LinesFromStrips;
    }
    if (i === PrimitiveTypes.Triangles) {
      return BufferUsage.Triangles;
    }
    if (i === PrimitiveTypes.TriangleStrips) {
      return BufferUsage.Strips;
    }
    if (i === PrimitiveTypes.TriangleEdges) {
      return BufferUsage.LinesFromTriangles;
    }

    // only strip edges left which are lines
    return BufferUsage.LinesFromStrips;
  };
  publicAPI.getHashFromUsage = usage => `pt${usage}`;
  publicAPI.getTopologyFromUsage = usage => {
    switch (usage) {
      case BufferUsage.Triangles:
        return 'triangle-list';
      case BufferUsage.Verts:
        return 'point-list';
      case BufferUsage.Lines:
      default:
        return 'line-list';
    }
  };

  // TODO: calculate tangents
  publicAPI.buildVertexInput = () => {
    const pd = model.currentInput;
    const cells = model.cellArray;
    const primType = model.primitiveType;
    const actor = model.WebGPUActor.getRenderable();
    let representation = actor.getProperty().getRepresentation();
    const device = model.WebGPURenderWindow.getDevice();
    let edges = false;
    if (primType === PrimitiveTypes.TriangleEdges) {
      edges = true;
      representation = Representation.WIREFRAME;
    }
    const vertexInput = model.vertexInput;
    const points = pd.getPoints();
    let indexBuffer;

    // get the flat mapping indexBuffer for the cells
    if (cells) {
      const buffRequest = {
        hash: `R${representation}P${primType}${cells.getMTime()}`,
        usage: BufferUsage.Index,
        cells,
        numberOfPoints: points.getNumberOfPoints(),
        primitiveType: primType,
        representation
      };
      indexBuffer = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.setIndexBuffer(indexBuffer);
    } else {
      vertexInput.setIndexBuffer(null);
    }

    // hash = all things that can change the values on the buffer
    // since mtimes are unique we can use
    // - indexBuffer mtime - because cells drive how we pack
    // - relevant dataArray mtime - the source data
    // - shift - not currently captured
    // - scale - not currently captured
    // - format
    // - usage
    // - packExtra - covered by format

    // points
    if (points) {
      const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);
      const buffRequest = {
        hash: `${points.getMTime()}I${indexBuffer.getMTime()}${shift.join()}float32x4`,
        usage: BufferUsage.PointArray,
        format: 'float32x4',
        dataArray: points,
        indexBuffer,
        shift,
        packExtra: true
      };
      const buff = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.addBuffer(buff, ['vertexBC']);
    } else {
      vertexInput.removeBufferIfPresent('vertexBC');
    }

    // normals, only used for surface rendering
    const usage = publicAPI.getUsage(representation, primType);
    model._usesCellNormals = false;
    if (!model.is2D && (
    // no lighting on Property2D
    usage === BufferUsage.Triangles || usage === BufferUsage.Strips)) {
      const normals = pd.getPointData().getNormals();
      // https://vtk.org/doc/nightly/html/classvtkPolyDataTangents.html
      // Need to find some way of using precomputed tangents (or computing new ones)
      const buffRequest = {
        format: 'snorm8x4',
        indexBuffer,
        packExtra: true,
        shift: 0,
        scale: 127
      };
      if (normals) {
        buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = normals;
        buffRequest.usage = BufferUsage.PointArray;
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ['normalMC']);
      } else if (primType === PrimitiveTypes.Triangles) {
        model._usesCellNormals = true;
        buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = points;
        buffRequest.cells = cells;
        buffRequest.usage = BufferUsage.NormalsFromPoints;
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ['normalMC']);
      } else {
        vertexInput.removeBufferIfPresent('normalMC');
      }
    } else {
      vertexInput.removeBufferIfPresent('normalMC');
    }

    // deal with colors but only if modified
    let haveColors = false;
    if (model.renderable.getScalarVisibility()) {
      const c = model.renderable.getColorMapColors();
      if (c && !edges) {
        const scalarMode = model.renderable.getScalarMode();
        let haveCellScalars = false;
        // We must figure out how the scalars should be mapped to the polydata.
        if ((scalarMode === CellArrayMapper_ScalarMode.USE_CELL_DATA || scalarMode === CellArrayMapper_ScalarMode.USE_CELL_FIELD_DATA || scalarMode === CellArrayMapper_ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== CellArrayMapper_ScalarMode.USE_POINT_FIELD_DATA && c) {
          haveCellScalars = true;
        }
        const buffRequest = {
          usage: BufferUsage.PointArray,
          format: 'unorm8x4',
          hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,
          dataArray: c,
          indexBuffer,
          cellData: haveCellScalars,
          cellOffset: 0
        };
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ['colorVI']);
        haveColors = true;
      }
    }
    if (!haveColors) {
      vertexInput.removeBufferIfPresent('colorVI');
    }
    let tcoords = null;
    if (model.renderable.getInterpolateScalarsBeforeMapping?.() && model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
    } else {
      tcoords = pd.getPointData().getTCoords();
    }
    if (tcoords && !edges) {
      const buff = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());
      vertexInput.addBuffer(buff, ['tcoord']);
    } else {
      vertexInput.removeBufferIfPresent('tcoord');
    }
  };
  publicAPI.updateTextures = () => {
    // we keep track of new and used textures so
    // that we can clean up any unused textures so we don't hold onto them
    const usedTextures = [];
    const newTextures = [];

    // do we have a scalar color texture
    const idata = model.renderable.getColorTextureMap?.();
    if (idata) {
      if (!model.colorTexture) {
        model.colorTexture = Texture/* default.newInstance */.Ay.newInstance({
          label: 'polyDataColor'
        });
      }
      model.colorTexture.setInputData(idata);
      newTextures.push(['Diffuse', model.colorTexture]);
    }

    // actor textures?
    const actor = model.WebGPUActor.getRenderable();
    const renderer = model.WebGPURenderer.getRenderable();

    // Reusing the old code for new and old textures, just loading in from properties instead of actor.getTextures()
    const textures = [];

    // Feels like there should be a better way than individually adding all
    if (actor.getProperty().getDiffuseTexture?.()) {
      const pair = ['Diffuse', actor.getProperty().getDiffuseTexture()];
      textures.push(pair);
    }
    if (actor.getTextures()[0]) {
      const pair = ['Diffuse', actor.getTextures()[0]];
      textures.push(pair);
    }
    if (model.colorTexture) {
      const pair = ['Diffuse', model.colorTexture];
      textures.push(pair);
    }
    if (actor.getProperty().getRoughnessTexture?.()) {
      const pair = ['Roughness', actor.getProperty().getRoughnessTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getMetallicTexture?.()) {
      const pair = ['Metallic', actor.getProperty().getMetallicTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getNormalTexture?.()) {
      const pair = ['Normal', actor.getProperty().getNormalTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getAmbientOcclusionTexture?.()) {
      const pair = ['AmbientOcclusion', actor.getProperty().getAmbientOcclusionTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getEmissionTexture?.()) {
      const pair = ['Emission', actor.getProperty().getEmissionTexture()];
      textures.push(pair);
    }
    if (renderer.getEnvironmentTexture?.()) {
      const pair = ['Environment', renderer.getEnvironmentTexture()];
      textures.push(pair);
    }
    for (let i = 0; i < textures.length; i++) {
      if (textures[i][1].getInputData() || textures[i][1].getJsImageData() || textures[i][1].getCanvas()) {
        newTextures.push(textures[i]);
      }
      if (textures[i][1].getImage() && textures[i][1].getImageLoaded()) {
        newTextures.push(textures[i]);
      }
    }
    for (let i = 0; i < newTextures.length; i++) {
      const srcTexture = newTextures[i][1];
      const textureName = newTextures[i][0];
      const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture); // Generates hash
      if (newTex.getReady()) {
        // is this a new texture
        let found = false;
        for (let t = 0; t < model.textures.length; t++) {
          if (model.textures[t] === newTex) {
            found = true;
            usedTextures[t] = true;
          }
        }
        if (!found) {
          usedTextures[model.textures.length] = true;
          const tview = newTex.createView(`${textureName}Texture`);
          model.textures.push(newTex);
          model.textureViews.push(tview);
          const interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';
          let addressMode = null;
          if (!addressMode && srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = 'mirror-repeat';
          if (!addressMode && srcTexture.getEdgeClamp()) addressMode = 'clamp-to-edge';
          if (!addressMode && srcTexture.getRepeat()) addressMode = 'repeat';
          if (textureName !== 'Environment') {
            tview.addSampler(model.device, {
              addressModeU: addressMode,
              addressModeV: addressMode,
              addressModeW: addressMode,
              minFilter: interpolate,
              magFilter: interpolate
            });
          } else {
            tview.addSampler(model.device, {
              addressModeU: 'repeat',
              addressModeV: 'clamp-to-edge',
              addressModeW: 'repeat',
              minFilter: interpolate,
              magFilter: interpolate,
              mipmapFilter: 'linear'
            });
          }
        }
      }
    }

    // remove unused textures
    for (let i = model.textures.length - 1; i >= 0; i--) {
      if (!usedTextures[i]) {
        model.textures.splice(i, 1);
        model.textureViews.splice(i, 1);
      }
    }
  };

  // compute a unique hash for a pipeline, this needs to be unique enough to
  // capture any pipeline code changes (which includes shader changes)
  // or vertex input changes/ bind groups/ etc
  publicAPI.computePipelineHash = () => {
    let pipelineHash = `pd${model.useRendererMatrix ? 'r' : ''}${model.forceZValue ? 'z' : ''}`;
    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {
      pipelineHash += 'edge';
    } else {
      if (model.vertexInput.hasAttribute(`normalMC`)) {
        pipelineHash += `n`;
      }
      if (model.vertexInput.hasAttribute(`colorVI`)) {
        pipelineHash += `c`;
      }
      if (model.vertexInput.hasAttribute(`tcoord`)) {
        const tcoords = model.vertexInput.getBuffer('tcoord');
        const numComp = Types/* default */.A.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
        pipelineHash += `t${numComp}`;
      }
      if (model.textures.length) {
        pipelineHash += `tx${model.textures.length}`;
      }
    }
    if (model._usesCellNormals) {
      pipelineHash += `cn`;
    }
    if (model.SSBO) {
      pipelineHash += `ssbo`;
    }
    const uhash = publicAPI.getHashFromUsage(model.usage);
    pipelineHash += uhash;
    pipelineHash += model.renderEncoder.getPipelineHash();
    model.pipelineHash = pipelineHash;
  };
  publicAPI.updateBuffers = () => {
    // handle textures if not edges
    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {
      publicAPI.updateTextures();
    }
    const actor = model.WebGPUActor.getRenderable();
    const rep = actor.getProperty().getRepresentation();

    // handle per primitive type
    model.usage = publicAPI.getUsage(rep, model.primitiveType);
    publicAPI.buildVertexInput();
    const vbo = model.vertexInput.getBuffer('vertexBC');
    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());
    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));
    publicAPI.updateUBO();
    if (publicAPI.haveWideLines()) {
      const ppty = actor.getProperty();
      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));
    } else {
      publicAPI.setNumberOfInstances(1);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const CellArrayMapper_DEFAULT_VALUES = {
  is2D: false,
  cellArray: null,
  currentInput: null,
  cellOffset: 0,
  primitiveType: 0,
  colorTexture: null,
  renderEncoder: null,
  textures: null
};

// ----------------------------------------------------------------------------

function CellArrayMapper_extend(publicAPI, model) {
  let initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, CellArrayMapper_DEFAULT_VALUES, initiaLalues);

  // Inheritance
  SimpleMapper/* default.extend */.Ay.extend(publicAPI, model, initiaLalues);
  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;
  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;
  model._tmpMat3 = esm/* mat3.identity */.w0.identity(new Float64Array(9));
  model._tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));

  // UBO
  model.UBO = UniformBuffer/* default.newInstance */.Ay.newInstance({
    label: 'mapperUBO'
  });
  model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');
  model.UBO.addEntry('AmbientColor', 'vec4<f32>');
  model.UBO.addEntry('DiffuseColor', 'vec4<f32>');
  model.UBO.addEntry('EdgeColor', 'vec4<f32>');
  model.UBO.addEntry('SpecularColor', 'vec4<f32>');
  model.UBO.addEntry('AmbientIntensity', 'f32');
  model.UBO.addEntry('DiffuseIntensity', 'f32');
  model.UBO.addEntry('Roughness', 'f32');
  model.UBO.addEntry('Metallic', 'f32');
  model.UBO.addEntry('Ambient', 'f32');
  model.UBO.addEntry('Normal', 'f32');
  model.UBO.addEntry('Emission', 'f32');
  model.UBO.addEntry('NormalStrength', 'f32');
  model.UBO.addEntry('BaseIOR', 'f32');
  model.UBO.addEntry('SpecularIntensity', 'f32');
  model.UBO.addEntry('LineWidth', 'f32');
  model.UBO.addEntry('Opacity', 'f32');
  model.UBO.addEntry('ZValue', 'f32');
  model.UBO.addEntry('PropID', 'u32');
  model.UBO.addEntry('ClipNear', 'f32');
  model.UBO.addEntry('ClipFar', 'f32');
  model.UBO.addEntry('Time', 'u32');

  // Build VTK API
  (0,macros2.e)(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'is2D', 'primitiveType', 'renderEncoder']);
  model.textures = [];

  // Object methods
  vtkWebGPUCellArrayMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const CellArrayMapper_newInstance = (0,macros2.n)(CellArrayMapper_extend, 'vtkWebGPUCellArrayMapper');

// ----------------------------------------------------------------------------

var vtkWebGPUCellArrayMapper$1 = {
  newInstance: CellArrayMapper_newInstance,
  extend: CellArrayMapper_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper.js






const {
  PrimitiveTypes: PolyDataMapper_PrimitiveTypes
} = BufferManager/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkWebGPUPolyDataMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUPolyDataMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUPolyDataMapper');
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1.0);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = poly => {
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];

    // we instantiate a cell array mapper for each cellArray that has cells
    // and they handle the rendering of that cell array
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PolyDataMapper_PrimitiveTypes.Points; i <= PolyDataMapper_PrimitiveTypes.Triangles; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    if (model.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) {
      for (let i = PolyDataMapper_PrimitiveTypes.TriangleEdges; i <= PolyDataMapper_PrimitiveTypes.TriangleStripEdges; i++) {
        if (prims[i - 2].getNumberOfValues() > 0) {
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[i - 2]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(model.primitives[i - 2].getCellOffset());
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellMappers.push(cellMapper);
        } else {
          model.primitives[i] = null;
        }
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const PolyDataMapper_DEFAULT_VALUES = {
  primitives: null
};

// ----------------------------------------------------------------------------

function PolyDataMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PolyDataMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.primitives = [];

  // Object methods
  vtkWebGPUPolyDataMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PolyDataMapper_newInstance = (0,macros2.n)(PolyDataMapper_extend, 'vtkWebGPUPolyDataMapper');

// ----------------------------------------------------------------------------

var vtkWebGPUPolyDataMapper$1 = {
  newInstance: PolyDataMapper_newInstance,
  extend: PolyDataMapper_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkMapper', PolyDataMapper_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper2D.js






const {
  PrimitiveTypes: PolyDataMapper2D_PrimitiveTypes
} = BufferManager/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkWebGPUPolyDataMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUPolyDataMapper2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUPolyDataMapper2D');
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1.0);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = poly => {
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];

    // we instantiate a cell array mapper for each cellArray that has cells
    // and they handle the rendering of that cell array
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PolyDataMapper2D_PrimitiveTypes.Points; i <= PolyDataMapper2D_PrimitiveTypes.Triangles; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMapper.setIs2D(true);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

function PolyDataMapper2D_defaultValues(initialValues) {
  return {
    primitives: [],
    ...initialValues
  };
}

// ----------------------------------------------------------------------------
function WebGPU_PolyDataMapper2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PolyDataMapper2D_defaultValues(initialValues));

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.primitives = [];

  // Object methods
  vtkWebGPUPolyDataMapper2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const WebGPU_PolyDataMapper2D_newInstance = (0,macros2.n)(WebGPU_PolyDataMapper2D_extend, 'vtkWebGPUPolyDataMapper2D');

// ----------------------------------------------------------------------------

var PolyDataMapper2D_index = {
  newInstance: WebGPU_PolyDataMapper2D_newInstance,
  extend: WebGPU_PolyDataMapper2D_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkMapper2D', WebGPU_PolyDataMapper2D_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ScalarBarActor.js





// ----------------------------------------------------------------------------
// vtkWebGPUScalarBarActor methods
// ----------------------------------------------------------------------------

function vtkWebGPUScalarBarActor(publicAPI, model) {
  model.classHierarchy.push('vtkWebGPUScalarBarActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const WebGPU_ScalarBarActor_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function WebGPU_ScalarBarActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, WebGPU_ScalarBarActor_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();

  // Object methods
  vtkWebGPUScalarBarActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const WebGPU_ScalarBarActor_newInstance = (0,macros2.n)(WebGPU_ScalarBarActor_extend, 'vtkWebGPUScalarBarActor');

// ----------------------------------------------------------------------------

var WebGPU_ScalarBarActor_index = {
  newInstance: WebGPU_ScalarBarActor_newInstance,
  extend: WebGPU_ScalarBarActor_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkScalarBarActor', WebGPU_ScalarBarActor_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
var HalfFloat = __webpack_require__(97888);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
var Sampler = __webpack_require__(20461);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureView.js




// ----------------------------------------------------------------------------
// vtkWebGPUTextureView methods
// ----------------------------------------------------------------------------

/* eslint-disable no-bitwise */

function vtkWebGPUTextureView(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUTextureView');
  publicAPI.create = (texture, options) => {
    model.texture = texture;
    model.options = options;
    model.options.dimension = model.options.dimension || '2d';
    model.options.label = model.label;
    model.textureHandle = texture.getHandle();
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(model.texture.getFormat());
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
  };
  publicAPI.createFromTextureHandle = (textureHandle, options) => {
    model.texture = null;
    model.options = options;
    model.options.dimension = model.options.dimension || '2d';
    model.options.label = model.label;
    model.textureHandle = textureHandle;
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(options.format);
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
    model.bindGroupTime.modified();
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: publicAPI.getHandle()
    };
    return foo;
  };
  publicAPI.getShaderCode = (binding, group) => {
    let ttype = 'f32';
    if (model.bindGroupLayoutEntry.texture.sampleType === 'sint') {
      ttype = 'i32';
    } else if (model.bindGroupLayoutEntry.texture.sampleType === 'uint') {
      ttype = 'u32';
    }
    let result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_${model.options.dimension}<${ttype}>;`;
    if (model.bindGroupLayoutEntry.texture.sampleType === 'depth') {
      result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_depth_${model.options.dimension};`;
    }
    return result;
  };
  publicAPI.addSampler = (device, options) => {
    const newSamp = Sampler/* default.newInstance */.Ay.newInstance({
      label: `${model.label}Sampler`
    });
    newSamp.create(device, options);
    publicAPI.setSampler(newSamp);
  };
  publicAPI.getBindGroupTime = () => {
    // check if the handle changed
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.bindGroupTime;
  };

  // if the texture has changed then get a new view
  publicAPI.getHandle = () => {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.handle;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const TextureView_DEFAULT_VALUES = {
  texture: null,
  handle: null,
  sampler: null,
  label: null
};

// ----------------------------------------------------------------------------

function TextureView_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, TextureView_DEFAULT_VALUES, initialValues);

  // Object methods
  macros2.m.obj(publicAPI, model);
  model.bindGroupLayoutEntry = {
    /* eslint-disable no-undef */
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    /* eslint-enable no-undef */
    texture: {
      sampleType: 'float',
      viewDimension: '2d'
      // multisampled: false,
    }
  };

  model.bindGroupTime = {};
  macros2.m.obj(model.bindGroupTime, {
    mtime: 0
  });
  macros2.m.get(publicAPI, model, ['bindGroupTime', 'texture']);
  macros2.m.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'label', 'sampler']);
  vtkWebGPUTextureView(publicAPI, model);
}

// ----------------------------------------------------------------------------

const TextureView_newInstance = macros2.m.newInstance(TextureView_extend);

// ----------------------------------------------------------------------------

var vtkWebGPUTextureView$1 = {
  newInstance: TextureView_newInstance,
  extend: TextureView_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Texture.js







const {
  BufferUsage: Texture_BufferUsage
} = BufferManager/* default */.Ay;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkWebGPUTexture methods
// ----------------------------------------------------------------------------

function vtkWebGPUTexture(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUTexture');
  publicAPI.create = (device, options) => {
    model.device = device;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    const dimension = model.depth === 1 ? '2d' : '3d';
    model.format = options.format ? options.format : 'rgba8unorm';
    model.mipLevel = options.mipLevel ? options.mipLevel : 0;
    /* eslint-disable no-undef */
    /* eslint-disable no-bitwise */
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    /* eslint-enable no-undef */
    /* eslint-enable no-bitwise */
    model.handle = model.device.getHandle().createTexture({
      size: [model.width, model.height, model.depth],
      format: model.format,
      // 'rgba8unorm',
      usage: model.usage,
      label: model.label,
      dimension,
      mipLevelCount: model.mipLevel + 1
    });
  };
  publicAPI.assignFromHandle = (device, handle, options) => {
    model.device = device;
    model.handle = handle;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    model.format = options.format ? options.format : 'rgba8unorm';
    /* eslint-disable no-undef */
    /* eslint-disable no-bitwise */
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    /* eslint-enable no-undef */
    /* eslint-enable no-bitwise */
  };

  publicAPI.writeImageData = req => {
    let nativeArray = [];
    if (req.canvas) {
      model.device.getHandle().queue.copyExternalImageToTexture({
        source: req.canvas,
        flipY: req.flip
      }, {
        texture: model.handle,
        premultipliedAlpha: true
      }, [model.width, model.height, model.depth]);
      model.ready = true;
      return;
    }
    if (req.jsImageData && !req.nativeArray) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = 'rgba8unorm';
      req.flip = true;
      req.nativeArray = req.jsImageData.data;
    }
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(model.format);
    let bufferBytesPerRow = model.width * tDetails.stride;
    const fixAll = (arr, height, depth) => {
      // bytesPerRow must be a multiple of 256 so we might need to rebuild
      // the data here before passing to the buffer. e.g. if it is unorm8x4 then
      // we need to have width be a multiple of 64
      const inWidthInBytes = arr.length / (height * depth) * arr.BYTES_PER_ELEMENT;

      // is this a half float texture?
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';

      // if we need to copy the data
      if (halfFloat || inWidthInBytes % 256) {
        const inArray = arr;
        const inWidth = inWidthInBytes / inArray.BYTES_PER_ELEMENT;
        const outBytesPerElement = tDetails.elementSize;
        const outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);
        const outWidth = outWidthInBytes / outBytesPerElement;
        const outArray = macros2.m.newTypedArray(halfFloat ? 'Uint16Array' : inArray.constructor.name, outWidth * height * depth);
        for (let v = 0; v < height * depth; v++) {
          if (halfFloat) {
            for (let i = 0; i < inWidth; i++) {
              outArray[v * outWidth + i] = HalfFloat/* default */.A.toHalf(inArray[v * inWidth + i]);
            }
          } else {
            outArray.set(inArray.subarray(v * inWidth, (v + 1) * inWidth), v * outWidth);
          }
        }
        return [outArray, outWidthInBytes];
      }
      return [arr, inWidthInBytes];
    };
    if (req.nativeArray) {
      nativeArray = req.nativeArray;
    }
    if (req.image) {
      const canvas = document.createElement('canvas');
      canvas.width = req.image.width;
      canvas.height = req.image.height;
      const ctx = canvas.getContext('2d');
      ctx.translate(0, canvas.height);
      ctx.scale(1, -1);
      ctx.drawImage(req.image, 0, 0, req.image.width, req.image.height, 0, 0, canvas.width, canvas.height);
      const imageData = ctx.getImageData(0, 0, req.image.width, req.image.height);
      nativeArray = imageData.data;
    }
    const cmdEnc = model.device.createCommandEncoder();
    if (publicAPI.getDimensionality() !== 3) {
      // Non-3D, supports mipmaps
      const mips = Texture/* default */.Ay.generateMipmaps(nativeArray, model.width, model.height, model.mipLevel);
      let currentWidth = model.width;
      let currentHeight = model.height;
      for (let m = 0; m <= model.mipLevel; m++) {
        const fix = fixAll(mips[m], currentHeight, 1);
        bufferBytesPerRow = fix[1];
        const buffRequest = {
          dataArray: req.dataArray ? req.dataArray : null,
          nativeArray: fix[0],
          /* eslint-disable no-undef */
          usage: Texture_BufferUsage.Texture
          /* eslint-enable no-undef */
        };

        const buff = model.device.getBufferManager().getBuffer(buffRequest);
        cmdEnc.copyBufferToTexture({
          buffer: buff.getHandle(),
          offset: 0,
          bytesPerRow: bufferBytesPerRow,
          rowsPerImage: currentHeight
        }, {
          texture: model.handle,
          mipLevel: m
        }, [currentWidth, currentHeight, 1]);
        currentWidth /= 2;
        currentHeight /= 2;
      }
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    } else {
      // 3D, no mipmaps
      const fix = fixAll(nativeArray, model.height, model.depth);
      bufferBytesPerRow = fix[1];
      const buffRequest = {
        dataArray: req.dataArray ? req.dataArray : null,
        /* eslint-disable no-undef */
        usage: Texture_BufferUsage.Texture
        /* eslint-enable no-undef */
      };

      buffRequest.nativeArray = fix[0];
      const buff = model.device.getBufferManager().getBuffer(buffRequest);
      cmdEnc.copyBufferToTexture({
        buffer: buff.getHandle(),
        offset: 0,
        bytesPerRow: bufferBytesPerRow,
        rowsPerImage: model.height
      }, {
        texture: model.handle
      }, [model.width, model.height, model.depth]);
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    }
  };

  // when data is pulled out of this texture what scale must be applied to
  // get back to the original source data. For formats such as r8unorm we
  // have to multiply by 255.0, for formats such as r16float it is 1.0
  publicAPI.getScale = () => {
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(model.format);
    const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';
    return halfFloat ? 1.0 : 255.0;
  };
  publicAPI.getNumberOfComponents = () => {
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(model.format);
    return tDetails.numComponents;
  };
  publicAPI.getDimensionality = () => {
    let dims = 0;
    if (model.width > 1) dims++;
    if (model.height > 1) dims++;
    if (model.depth > 1) dims++;
    return dims;
  };
  publicAPI.resizeToMatch = tex => {
    if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {
      model.width = tex.getWidth();
      model.height = tex.getHeight();
      model.depth = tex.getDepth();
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.resize = function (width, height) {
    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    if (width !== model.width || height !== model.height || depth !== model.depth) {
      model.width = width;
      model.height = height;
      model.depth = depth;
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.createView = function (label) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // if options is missing values try to add them in
    if (!options.dimension) {
      options.dimension = model.depth === 1 ? '2d' : '3d';
    }
    const view = vtkWebGPUTextureView$1.newInstance({
      label
    });
    view.create(publicAPI, options);
    return view;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Texture_DEFAULT_VALUES = {
  device: null,
  handle: null,
  buffer: null,
  ready: false,
  label: null
};

// ----------------------------------------------------------------------------

function Texture_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Texture_DEFAULT_VALUES, initialValues);

  // Object methods
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['handle', 'ready', 'width', 'height', 'depth', 'format', 'usage']);
  macros2.m.setGet(publicAPI, model, ['device', 'label']);
  vtkWebGPUTexture(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Texture_newInstance = macros2.m.newInstance(Texture_extend);

// ----------------------------------------------------------------------------

var vtkWebGPUTexture$1 = {
  newInstance: Texture_newInstance,
  extend: Texture_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
var WebGPU_PixelSpaceCallbackMapper = __webpack_require__(77489);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Profiles/Geometry.js























/***/ }),

/***/ 7742:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
var Camera = __webpack_require__(38475);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var Renderer = __webpack_require__(63819);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js
var CellArray = __webpack_require__(35056);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 9 modules
var PolyData = __webpack_require__(79484);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Filters/General/ClosedPolyLineToSurfaceFilter.js




const {
  vtkErrorMacro
} = macros2.m;
class SegmentAgregator {
  constructor() {
    this.segmentMapping = {};
    this.segments = [null]; // to force first id to be 1
    this.faces = [];
  }
  addSegment(segment) {
    const first = segment[0];
    const last = segment[segment.length - 1];
    if (first === last || segment.length < 2) {
      return;
    }
    const mappingFirst = this.segmentMapping[first];
    const mappingLast = this.segmentMapping[last];
    if (mappingFirst !== undefined && mappingLast !== undefined) {
      if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {
        // This make a closing loop
        const idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;
        const seg = this.segments[idx];
        if (mappingFirst > 0) {
          for (let i = 1; i < segment.length - 1; i++) {
            seg.push(segment[i]);
          }
        } else {
          for (let i = 1; i < segment.length - 1; i++) {
            seg.unshift(segment[segment.length - 1 - i]);
          }
        }
        this.faces.push(seg);
        this.segments[idx] = null;
        this.segmentMapping[first] = undefined;
        this.segmentMapping[last] = undefined;
      } else {
        // we need to merge segments
        // strategie:
        // => remove and add them again in special order to induce merge
        const idxHead = Math.abs(mappingFirst);
        const idxTail = Math.abs(mappingLast);
        const segHead = this.segments[idxHead];
        const segTail = this.segments[idxTail];
        this.segments[idxHead] = null;
        this.segments[idxTail] = null;
        this.segmentMapping[segHead[0]] = undefined;
        this.segmentMapping[segTail[0]] = undefined;
        this.segmentMapping[segHead[segHead.length - 1]] = undefined;
        this.segmentMapping[segTail[segTail.length - 1]] = undefined;

        // This will lead to a single segment
        this.addSegment(segment);
        this.addSegment(segHead);
        this.addSegment(segTail);
      }
    } else if (mappingFirst !== undefined) {
      if (mappingFirst > 0) {
        // The head of our segment match the tail of the existing one
        const seg = this.segments[mappingFirst];
        for (let i = 1; i < segment.length; i++) {
          seg.push(segment[i]);
        }
        // record new tail
        this.segmentMapping[last] = mappingFirst;
      } else {
        // our segment should be reverted and put on the front of the existing one
        const seg = this.segments[-mappingFirst];
        // record new head
        this.segmentMapping[last] = mappingFirst;
        for (let i = 1; i < segment.length; i++) {
          seg.unshift(segment[i]);
        }
      }
      // Erase used connection
      this.segmentMapping[first] = undefined;
    } else if (mappingLast !== undefined) {
      if (mappingLast > 0) {
        // The tail of our segment match the tail of the existing one
        const seg = this.segments[mappingLast];
        for (let i = 1; i < segment.length; i++) {
          seg.push(segment[segment.length - 1 - i]);
        }
        // record new tail
        this.segmentMapping[first] = mappingLast;
      } else {
        // our segment should be reverted and put on the front of the existing one
        const seg = this.segments[-mappingLast];

        // record new head
        this.segmentMapping[first] = mappingLast;
        for (let i = 1; i < segment.length; i++) {
          seg.unshift(segment[segment.length - i - 1]);
        }
      }
      // Erase used connection
      this.segmentMapping[last] = undefined;
    } else {
      // store segment for now
      const id = this.segments.length;
      this.segments.push(segment);
      this.segmentMapping[first] = -id;
      this.segmentMapping[last] = id;
    }
  }
}

// ----------------------------------------------------------------------------
// vtkClosedPolyLineToSurfaceFilter methods
// ----------------------------------------------------------------------------

function vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkClosedPolyLineToSurfaceFilter');

  // --------------------------------------------------------------------------

  publicAPI.requestData = (inData, outData) => {
    // implement requestData
    const input = inData[0];
    if (!input) {
      vtkErrorMacro('Invalid or missing input');
      return;
    }
    const output = PolyData/* default.newInstance */.Ay.newInstance();
    output.shallowCopy(input);

    // Extract faces
    const agregator = new SegmentAgregator();
    const lines = input.getLines().getData();
    let offset = 0;
    while (offset < lines.length) {
      const lineSize = lines[offset++];
      const lineSegment = [];
      for (let i = 0; i < lineSize; i++) {
        lineSegment.push(lines[offset + i]);
      }
      agregator.addSegment(lineSegment);
      offset += lineSize;
    }

    // Create CellArray for polys
    const {
      faces
    } = agregator;
    let cellArraySize = faces.length;
    for (let i = 0; i < faces.length; i++) {
      cellArraySize += faces[i].length;
    }
    const cellArray = new Uint16Array(cellArraySize);
    offset = 0;
    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      cellArray[offset++] = face.length;
      for (let j = 0; j < face.length; j++) {
        cellArray[offset++] = face[j];
      }
    }
    output.setPolys(CellArray/* default.newInstance */.Ay.newInstance({
      values: cellArray,
      name: 'faces'
    }));
    outData[0] = output;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Make this a VTK object
  macros2.m.obj(publicAPI, model);

  // Also make it an algorithm with one input and one output
  macros2.m.algo(publicAPI, model, 1, 1);

  // Object specific methods
  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkClosedPolyLineToSurfaceFilter');

// ----------------------------------------------------------------------------

var vtkClosedPolyLineToSurfaceFilter$1 = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Filters/Core/Cutter.js
var Cutter = __webpack_require__(61088);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Filters/Sources/CubeSource.js
var CubeSource = __webpack_require__(56748);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Filters/General/ImageDataOutlineFilter.js



const {
  vtkErrorMacro: ImageDataOutlineFilter_vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkImageDataOutlineFilter methods
// ----------------------------------------------------------------------------

function vtkImageDataOutlineFilter(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageDataOutlineFilter');

  // Capture "parentClass" api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.requestData = (inData, outData) => {
    // implement requestData
    const input = inData[0];
    if (!input || !input.isA('vtkImageData')) {
      ImageDataOutlineFilter_vtkErrorMacro('Invalid or missing input');
      return;
    }

    // First create a cube polydata in the index-space of the image.
    // The benefit of using `getSpatialExtent` call is that it automatically
    // takes care of 0.5 voxel padding as required by an vtkImageData representation.
    const spatialExt = input.getSpatialExtent();
    if (!spatialExt) {
      ImageDataOutlineFilter_vtkErrorMacro('Unable to fetch spatial extents of input image.');
      return;
    }
    model._cubeSource.setBounds(spatialExt);

    // Then apply index-to-world transform to the cube to create the outline.
    model._cubeSource.setMatrix(input.getIndexToWorld());
    outData[0] = model._cubeSource.getOutputData();
  };
  publicAPI.getMTime = () => Math.max(superClass.getMTime(), model._cubeSource.getMTime());

  // Forward calls for [set/get]Generate[Faces/Lines] functions to cubeSource:
  publicAPI.setGenerateFaces = model._cubeSource.setGenerateFaces;
  publicAPI.setGenerateLines = model._cubeSource.setGenerateLines;
  publicAPI.getGenerateFaces = model._cubeSource.getGenerateFaces;
  publicAPI.getGenerateLines = model._cubeSource.getGenerateLines;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageDataOutlineFilter_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function ImageDataOutlineFilter_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageDataOutlineFilter_DEFAULT_VALUES, initialValues);

  // Make this a VTK object
  macros2.m.obj(publicAPI, model);

  // Also make it an algorithm with one input and one output
  macros2.m.algo(publicAPI, model, 1, 1);

  // Internal persistent objects
  model._cubeSource = CubeSource/* default.newInstance */.Ay.newInstance();
  macros2.m.moveToProtected(publicAPI, model, ['cubeSource', 'tmpOut']);

  // Object specific methods
  vtkImageDataOutlineFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageDataOutlineFilter_newInstance = macros2.m.newInstance(ImageDataOutlineFilter_extend, 'vtkImageDataOutlineFilter');

// ----------------------------------------------------------------------------

var vtkImageDataOutlineFilter$1 = {
  newInstance: ImageDataOutlineFilter_newInstance,
  extend: ImageDataOutlineFilter_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var Texture = __webpack_require__(1013);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js + 1 modules
var Plane = __webpack_require__(75127);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
var ReplacementShaderMapper = __webpack_require__(83534);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js
var Constants = __webpack_require__(35341);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/Transform/Transform.js





// ----------------------------------------------------------------------------
// vtkTransform methods
// ----------------------------------------------------------------------------
// eslint-disable-next-line import/no-mutable-exports
let Transform_newInstance;
function vtkTransform(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkAbstractTransform', 'vtkHomogeneousTransform', 'vtkTransform');
  publicAPI.transformPoint = (point, out) => {
    esm/* vec3.transformMat4 */.eR.transformMat4(out, point, model.matrix);
    return out;
  };
  publicAPI.transformPoints = (points, out) => {
    const inPoint = new Float64Array(3);
    const outPoint = new Float64Array(3);
    for (let i = 0; i < points.length; i += 3) {
      inPoint[0] = points[i];
      inPoint[1] = points[i + 1];
      inPoint[2] = points[i + 2];
      esm/* vec3.transformMat4 */.eR.transformMat4(outPoint, inPoint, model.matrix);
      out[i] = outPoint[0];
      out[i + 1] = outPoint[1];
      out[i + 2] = outPoint[2];
    }
    return out;
  };

  /**
   * Sets the internal state of the transform to PreMultiply.
   * All subsequent operations will occur before those already represented in the current transformation.
   * In homogeneous matrix notation, M = M*A where M is the current transformation matrix and A is the applied matrix.
   * The default is PreMultiply.
   */
  publicAPI.preMultiply = () => {
    publicAPI.setPreMultiplyFlag(true);
  };

  /**
   * Sets the internal state of the transform to PostMultiply.
   * All subsequent operations will occur after those already represented in the current transformation.
   * In homogeneous matrix notation, M = A*M where M is the current transformation matrix and A is the applied matrix.
   * The default is PreMultiply.
   */
  publicAPI.postMultiply = () => {
    publicAPI.setPreMultiplyFlag(false);
  };
  publicAPI.transformMatrix = (matrix, out) => {
    if (model.preMultiplyFlag) {
      esm/* mat4.multiply */.pB.multiply(out, model.matrix, matrix);
    } else {
      esm/* mat4.multiply */.pB.multiply(out, matrix, model.matrix);
    }
    return out;
  };

  // Apply the transform to each matrix in the same way as transformMatrix
  // `matrices` can be a contiguous array of float or an array of array
  publicAPI.transformMatrices = (matrices, out) => {
    const inMat = new Float64Array(16);
    const outMat = new Float64Array(16);
    const transform = model.preMultiplyFlag ? () => esm/* mat4.multiply */.pB.multiply(outMat, model.matrix, inMat) : () => esm/* mat4.multiply */.pB.multiply(outMat, inMat, model.matrix);
    for (let i = 0; i < matrices.length; i += 16) {
      for (let j = 0; j < 16; ++j) {
        inMat[j] = matrices[i + j];
      }
      transform();
      for (let j = 0; j < 16; ++j) {
        out[i + j] = outMat[j];
      }
    }
    return out;
  };
  publicAPI.getInverse = () => Transform_newInstance({
    matrix: Core_Math.f.invertMatrix(Array.from(model.matrix), [], 4),
    preMultiplyFlag: model.preMultiplyFlag
  });
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Transform_DEFAULT_VALUES = {
  preMultiplyFlag: false,
  matrix: [...Constants/* IDENTITY */.zK]
};

// ----------------------------------------------------------------------------

function Transform_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Transform_DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['preMultiplyFlag']);
  macros2.m.setGetArray(publicAPI, model, ['matrix'], 16);
  vtkTransform(publicAPI, model);
}

// ----------------------------------------------------------------------------
Transform_newInstance = macros2.m.newInstance(Transform_extend, 'vtkTransform');

// ----------------------------------------------------------------------------

var vtkTransform$1 = {
  newInstance: Transform_newInstance,
  extend: Transform_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
var resourceSharingHelper = __webpack_require__(90919);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperVS.glsl.js
var vtkImageResliceMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n";



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperFS.glsl.js
var vtkImageResliceMapperFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Texture_Constants = __webpack_require__(52271);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var ImageProperty_Constants = __webpack_require__(91732);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var DataArray_Constants = __webpack_require__(28914);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
var CoincidentTopologyHelper = __webpack_require__(57285);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
var Static = __webpack_require__(7698);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageResliceMapper.js


























const {
  vtkErrorMacro: ImageResliceMapper_vtkErrorMacro
} = macros2.c;

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
  matrixType.identity(tmpMat);
  return matrixArray.reduce((res, matrix, index) => {
    if (index === 0) {
      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
    }
    return matrix ? matrixType.multiply(res, res, matrix) : res;
  }, tmpMat);
}

// ----------------------------------------------------------------------------
// vtkOpenGLImageResliceMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageResliceMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageResliceMapper');
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._colorTransferFunc, model._pwFunc].forEach(coreObject => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.currentRenderPass = null;
      model._openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      const ren = model._openGLRenderer.getRenderable();
      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        // Unregister the mapper when the render window changes
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = prepass => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (
    // backwards compat with code that (errorneously) set this to boolean
    // eslint-disable-next-line eqeqeq
    model.renderable.getResolveCoincidentTopology() == Static/* Resolve */.XK.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };

  // Renders myself
  publicAPI.render = () => {
    const actor = model._openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: 'StartEvent'
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    if (!model.currentInput) {
      ImageResliceMapper_vtkErrorMacro('No input!');
      return;
    }
    publicAPI.updateResliceGeometry();
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);
    const iType = actor.getProperty().getInterpolationType();
    if (iType === ImageProperty_Constants/* InterpolationType */.V.NEAREST) {
      model.openGLTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.openGLTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.pwfTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.pwfTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
    } else {
      model.openGLTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.openGLTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.pwfTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.pwfTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
    }

    // No buffer objects bound.
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // render the texture
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();

    // update shaders if required
    publicAPI.updateShaders(model.tris, ren, actor);

    // Finally draw
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {};
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffer objects if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime() || !model.openGLTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.pwfTexture?.getHandle();
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const scalars = image.getPointData()?.getScalars();
    if (!scalars) {
      return;
    }
    const numComp = scalars.getNumberOfComponents();
    let toString = (0,resourceSharingHelper/* getImageDataHash */.eS)(image, scalars);
    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    const reBuildTex = !tex?.oglObject?.getHandle() || tex?.hash !== toString;
    if (reBuildTex) {
      model.openGLTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // Build the image scalar texture
      const dims = image.getDimensions();
      // Use norm16 for the 3D texture if the extension is available
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));
      model.openGLTexture.resetFormatAndType();
      model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars);
      model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, toString);
      if (scalars !== model._scalars) {
        model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
        model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
      }
      model._scalars = scalars;
    } else {
      model.openGLTexture = tex.oglObject;
    }
    const ppty = actor.getProperty();
    const iComps = ppty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = ppty.getRGBTransferFunction();
    toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(colorTransferFunc, iComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
    if (reBuildC) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      model.colorTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0; c < numIComps; c++) {
          const cfun = ppty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }

    // Build piecewise function buffer.  This buffer is used either
    // for component weighting or opacity, depending on whether we're
    // rendering components independently or not.
    const pwFunc = ppty.getPiecewiseFunction();
    toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(pwFunc, iComps, numIComps);
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    // rebuild opacity tfun?
    const reBuildPwf = !pwfTex?.oglObject?.getHandle() || pwfTex?.hash !== toString;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0; c < numIComps; ++c) {
          const pwfun = ppty.getPiecewiseFunction(c);
          if (pwfun === null) {
            // Piecewise constant max if no function supplied for this component
            pwfFloatTable.fill(1.0);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            // adjust for sample distance etc
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, DataArray_Constants/* VtkDataTypes */.JA.FLOAT, pwfFloatTable);
      } else {
        // default is opaque
        pwfTable.fill(255.0);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, toString);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = pwfTex.oglObject;
    }
    const vboString = `${model.resliceGeom.getMTime()}A${model.renderable.getSlabThickness()}`;
    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {
      const points = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: model.resliceGeom.getPoints().getData()
      });
      points.setName('points');
      const cells = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 1,
        values: model.resliceGeom.getPolys().getData()
      });
      const options = {
        points,
        cellOffset: 0
      };
      if (model.renderable.getSlabThickness() > 0.0) {
        const n = model.resliceGeom.getPointData().getNormals();
        if (!n) {
          ImageResliceMapper_vtkErrorMacro('Slab mode requested without normals');
        } else {
          options.normals = n;
        }
      }
      model.tris.getCABO().createVBO(cells, 'polys', Property_Constants/* Representation */.YL.SURFACE, options);
    }
    model.VBOBuildString = vboString;
    model.VBOBuildTime.modified();
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;

    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      // Set the 3D texture
      if (program.isUniformUsed('texture1')) {
        program.setUniformi('texture1', model.openGLTexture.getTextureUnit());
      }

      // Set the plane vertex attributes
      if (program.isAttributeUsed('vertexWC')) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          ImageResliceMapper_vtkErrorMacro('Error setting vertexWC in shader VAO.');
        }
      }

      // If we are doing slab mode, we need normals
      if (program.isAttributeUsed('normalWC')) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'normalWC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          ImageResliceMapper_vtkErrorMacro('Error setting normalWC in shader VAO.');
        }
      }
      if (program.isUniformUsed('slabThickness')) {
        program.setUniformf('slabThickness', model.renderable.getSlabThickness());
      }
      if (program.isUniformUsed('spacing')) {
        program.setUniform3fv('spacing', model.currentInput.getSpacing());
      }
      if (program.isUniformUsed('slabType')) {
        program.setUniformi('slabType', model.renderable.getSlabType());
      }
      if (program.isUniformUsed('slabType')) {
        program.setUniformi('slabType', model.renderable.getSlabType());
      }
      if (program.isUniformUsed('slabTrapezoid')) {
        program.setUniformi('slabTrapezoid', model.renderable.getSlabTrapezoidIntegration());
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;

      // Set the world->texture matrix
      if (program.isUniformUsed('WCTCMatrix')) {
        const image = model.currentInput;
        const dim = image.getDimensions();
        esm/* mat4.copy */.pB.copy(model.tmpMat4, image.getIndexToWorld());
        esm/* mat4.translate */.pB.translate(model.tmpMat4, model.tmpMat4, [-0.5, -0.5, -0.5]);
        esm/* mat4.scale */.pB.scale(model.tmpMat4, model.tmpMat4, dim);
        esm/* mat4.invert */.pB.invert(model.tmpMat4, model.tmpMat4);
        if (inverseShiftScaleMatrix) {
          esm/* mat4.multiply */.pB.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
        }
        program.setUniformMatrix('WCTCMatrix', model.tmpMat4);
      }
      if (program.isUniformUsed('vboScaling')) {
        program.setUniform3fv('vboScaling', cellBO.getCABO().getCoordScale() ?? [1, 1, 1]);
      }
      cellBO.getAttributeUpdateTime().modified();
    }

    // Depth request
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }

    // handle coincident
    if (cellBO.getProgram().isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (cellBO.getProgram().isUniformUsed('cfactor')) {
        cellBO.getProgram().setUniformf('cfactor', cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    // [WMVP]C == {world, model, view, projection} coordinates
    // e.g. WCPC == world to projection coordinate transformation
    const keyMats = model._openGLCamera.getKeyMatrices(ren);
    const actMats = model._openGLImageSlice.getKeyMatrices();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const program = cellBO.getProgram();
    if (program.isUniformUsed('MCPCMatrix')) {
      esm/* mat4.identity */.pB.identity(model.tmpMat4);
      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], esm/* mat4 */.pB, model.tmpMat4));
    }
    if (program.isUniformUsed('MCVCMatrix')) {
      esm/* mat4.identity */.pB.identity(model.tmpMat4);
      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], esm/* mat4 */.pB, model.tmpMat4));
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf('opacity', opacity);

    // Component mix
    // Independent components: Mixed according to component weights
    // Dependent components: Mixed using the following logic:
    //    - 2 comps => LA
    //    - 3 comps => RGB + opacity from pwf
    //    - 4 comps => RGBA
    const numComp = model.openGLTexture.getComponents();
    const iComps = ppty.getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; ++i) {
        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));
      }
    }

    // Color opacity map
    const volInfo = model.openGLTexture.getVolumeInfo();

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      let cw = ppty.getColorWindow();
      let cl = ppty.getColorLevel();
      const target = iComps ? i : 0;
      const cfun = ppty.getRGBTransferFunction(target);
      if (cfun && ppty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale = volInfo.scale[i] / cw;
      const shift = (volInfo.offset[i] - cl) / cw + 0.5;
      program.setUniformf(`cshift${i}`, shift);
      program.setUniformf(`cscale${i}`, scale);
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    program.setUniformi('colorTexture1', texColorUnit);

    // pwf shift/scale
    for (let i = 0; i < numComp; i++) {
      let pwfScale = 1.0;
      let pwfShift = 0.0;
      const target = iComps ? i : 0;
      const pwfun = ppty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volInfo.scale[i] / length;
        pwfShift = (volInfo.offset[i] - mid) / length + 0.5;
      }
      program.setUniformf(`pwfshift${i}`, pwfShift);
      program.setUniformf(`pwfscale${i}`, pwfScale);
    }
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    program.setUniformi('pwfTexture1', texOpacityUnit);

    // Background color
    program.setUniform4fv('backgroundColor', model.renderable.getBackgroundColor());
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    // render pass shader replacement changed
    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    const slabTh = model.renderable.getSlabThickness();
    const slabType = model.renderable.getSlabType();
    const slabTrap = model.renderable.getSlabTrapezoidIntegration();

    // has the render pass shader replacement changed? Two options
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      model.lastSlabThickness = slabTh;
      model.lastSlabType = slabType;
      model.lastSlabTrapezoidIntegration = slabTrap;
      return true;
    }
    return false;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkImageResliceMapperVS;
    shaders.Fragment = vtkImageResliceMapperFS;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
      shaders.Fragment = FSSource;
    }
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const tcoordVSDec = ['uniform mat4 WCTCMatrix;', 'out vec3 fragTexCoord;'];
    const slabThickness = model.renderable.getSlabThickness();
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Dec', tcoordVSDec).result;
    const tcoordVSImpl = ['fragTexCoord = (WCTCMatrix * vertexWC).xyz;'];
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Impl', tcoordVSImpl).result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordFSDec = ['in vec3 fragTexCoord;', 'uniform highp sampler3D texture1;', 'uniform mat4 WCTCMatrix;',
    // color shift and scale
    'uniform float cshift0;', 'uniform float cscale0;',
    // pwf shift and scale
    'uniform float pwfshift0;', 'uniform float pwfscale0;',
    // color and pwf textures
    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',
    // opacity
    'uniform float opacity;',
    // background color
    'uniform vec4 backgroundColor;'];
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
        // color shift and scale
        `uniform float cshift${comp};`, `uniform float cscale${comp};`,
        // weighting shift and scale
        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);
      }
      // the heights defined below are the locations
      // for the up to four components of the tfuns
      // the tfuns have a height of 2XnumComps pixels so the
      // values are computed to hit the middle of the two rows
      // for that component
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);
          break;
        default:
          ImageResliceMapper_vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    }
    if (slabThickness > 0.0) {
      tcoordFSDec = tcoordFSDec.concat(['uniform vec3 spacing;', 'uniform float slabThickness;', 'uniform int slabType;', 'uniform int slabTrapezoid;', 'uniform vec3 vboScaling;']);
      tcoordFSDec = tcoordFSDec.concat(['vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)', '{', '  vec4 retVal = vec4(1.0);', '  if (slabType == 0) // min', '  {', '    retVal = min(currVal, valToComp);', '  }', '  else if (slabType == 1) // max', '  {', '    retVal = max(currVal, valToComp);', '  }', '  else if (slabType == 3) // sum', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  else // mean', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  return retVal;', '}']);
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;
    let tcoordFSImpl = ['if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}', 'vec4 tvalue = texture(texture1, fragTexCoord);'];
    if (slabThickness > 0.0) {
      tcoordFSImpl = tcoordFSImpl.concat(['// Get the first and last samples', 'int numSlices = 1;', 'float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;', 'vec3 normalxspacing = scaling * normalWCVSOutput;', 'float distTraveled = length(normalxspacing);', 'int trapezoid = 0;', 'while (distTraveled < slabThickness * 0.5)', '{', '  distTraveled += length(normalxspacing);', '  float fnumSlices = float(numSlices);', '  if (distTraveled > slabThickness * 0.5)', '  {', '    // Before stepping outside the slab, sample at the boundaries', '    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;', '    trapezoid = slabTrapezoid;', '  }', '  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordNeg);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordPos);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '}', '// Finally, if slab type is *mean*, divide the sum by the numSlices', 'if (slabType == 2)', '{', '  tvalue = tvalue / float(numSlices);', '}']);
    }
    if (iComps) {
      const rgba = ['r', 'g', 'b', 'a'];
      for (let comp = 0; comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);
          break;
        default:
          ImageResliceMapper_vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    } else {
      // dependent components
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);
      }
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    shaders.Geometry = GSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const slabThickness = model.renderable.getSlabThickness();
    let posVCVSDec = ['attribute vec4 vertexWC;'];
    // Add a unique hash to the shader to ensure that the shader program is unique to this mapper.
    posVCVSDec = posVCVSDec.concat([`//${publicAPI.getMTime()}${model.resliceGeomUpdateString}`]);
    if (slabThickness > 0.0) {
      posVCVSDec = posVCVSDec.concat(['attribute vec3 normalWC;', 'varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);
    }
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Dec', posVCVSDec).result;
    let posVCVSImpl = ['gl_Position = MCPCMatrix * vertexWC;'];
    if (slabThickness > 0.0) {
      posVCVSImpl = posVCVSImpl.concat(['normalWCVSOutput = normalWC;', 'vertexWCVSOutput = vertexWC;']);
    }
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', posVCVSImpl).result;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;
    let posVCFSDec = [];
    if (slabThickness > 0.0) {
      posVCFSDec = posVCFSDec.concat(['varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Dec', posVCFSDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  function isVectorAxisAligned(n) {
    Core_Math.f.normalize(n);
    const tmpN = [0, 0, 0];
    for (let i = 0; i < 3; ++i) {
      esm/* vec3.zero */.eR.zero(tmpN);
      tmpN[i] = 1.0;
      const dotP = Core_Math.f.dot(n, tmpN);
      if (dotP < -0.999 || dotP > 0.999) {
        return [true, i];
      }
    }
    return [false, 2];
  }
  publicAPI.updateResliceGeometry = () => {
    let resGeomString = '';
    const image = model.currentInput;
    const imageBounds = image?.getBounds();
    // Orthogonal slicing by default
    let orthoSlicing = true;
    let orthoAxis = 2;
    const slicePD = model.renderable.getSlicePolyData();
    const slicePlane = model.renderable.getSlicePlane();
    if (slicePD) {
      resGeomString = resGeomString.concat(`PolyData${slicePD.getMTime()}`);
    } else if (slicePlane) {
      resGeomString = resGeomString.concat(`Plane${slicePlane.getMTime()}`);
      // Compute a world-to-image-orientation matrix.
      const w2io = esm/* mat3.create */.w0.create();
      if (image) {
        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);
        // Ignore the translation component since we are
        // using it on vectors rather than positions.
        esm/* mat3.set */.w0.set(w2io, ...image.getDirection());
        esm/* mat3.invert */.w0.invert(w2io, w2io);
      }
      // Check to see if we can bypass oblique slicing related bounds computation
      // transform the cutting plane normal to image local coords
      const imageLocalNormal = [...slicePlane.getNormal()];
      esm/* vec3.transformMat3 */.eR.transformMat3(imageLocalNormal, imageLocalNormal, w2io);
      [orthoSlicing, orthoAxis] = isVectorAxisAligned(imageLocalNormal);
    } else {
      // Create a default slice plane here
      const plane = Plane/* default.newInstance */.Ay.newInstance();
      plane.setNormal(0, 0, 1);
      let bds = [0, 1, 0, 1, 0, 1];
      if (image) {
        bds = imageBounds;
      }
      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));
      model.renderable.setSlicePlane(plane);
      resGeomString = resGeomString.concat(`Plane${slicePlane?.getMTime()}`);
      if (image) {
        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);
      }
    }
    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {
      if (slicePD) {
        if (!model.resliceGeom) {
          model.resliceGeom = PolyData/* default.newInstance */.Ay.newInstance();
        }
        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);
        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);
        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());
      } else if (slicePlane) {
        if (!orthoSlicing) {
          model.outlineFilter.setInputData(image);
          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());
          model.cutter.setCutFunction(slicePlane);
          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());
          model.lineToSurfaceFilter.update();
          if (!model.resliceGeom) {
            model.resliceGeom = PolyData/* default.newInstance */.Ay.newInstance();
          }
          const planePD = model.lineToSurfaceFilter.getOutputData();
          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);
          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);
          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals());
          // The above method does not generate point normals
          // Set it manually here.
          const n = slicePlane.getNormal();
          const npts = model.resliceGeom.getNumberOfPoints();
          Core_Math.f.normalize(n);
          const normalsData = new Float32Array(npts * 3);
          for (let i = 0; i < npts; ++i) {
            normalsData[3 * i] = n[0];
            normalsData[3 * i + 1] = n[1];
            normalsData[3 * i + 2] = n[2];
          }
          const normals = DataArray/* default.newInstance */.Ay.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: 'Normals'
          });
          model.resliceGeom.getPointData().setNormals(normals);
        } else {
          // Since the image-local normal is axis-aligned, we
          // can quickly construct the cutting plane using indexToWorld transforms.
          const ptsArray = new Float32Array(12);
          const indexSpacePlaneOrigin = image.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);
          const otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();
          const ext = image.getSpatialExtent();
          let ptIdx = 0;
          for (let i = 0; i < 2; ++i) {
            for (let j = 0; j < 2; ++j) {
              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];
              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j];
              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + i];
              ptIdx += 3;
            }
          }
          model.transform.setMatrix(image.getIndexToWorld());
          model.transform.transformPoints(ptsArray, ptsArray);
          const cellArray = new Uint16Array(8);
          cellArray[0] = 3;
          cellArray[1] = 0;
          cellArray[2] = 1;
          cellArray[3] = 3;
          cellArray[4] = 3;
          cellArray[5] = 0;
          cellArray[6] = 3;
          cellArray[7] = 2;
          const n = slicePlane.getNormal();
          Core_Math.f.normalize(n);
          const normalsData = new Float32Array(12);
          for (let i = 0; i < 4; ++i) {
            normalsData[3 * i] = n[0];
            normalsData[3 * i + 1] = n[1];
            normalsData[3 * i + 2] = n[2];
          }
          if (!model.resliceGeom) {
            model.resliceGeom = PolyData/* default.newInstance */.Ay.newInstance();
          }
          model.resliceGeom.getPoints().setData(ptsArray, 3);
          model.resliceGeom.getPolys().setData(cellArray, 1);
          const normals = DataArray/* default.newInstance */.Ay.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: 'Normals'
          });
          model.resliceGeom.getPointData().setNormals(normals);
        }
      } else {
        ImageResliceMapper_vtkErrorMacro('Something went wrong.', 'A default slice plane should have been created in the beginning of', 'updateResliceGeometry.');
      }
      model.resliceGeomUpdateString = resGeomString;
      model.resliceGeom?.modified();
    }
  };
  publicAPI.setOpenGLTexture = oglTex => {
    if (oglTex) {
      model.openGLTexture = oglTex;
      model._externalOpenGLTexture = true;
    }
  };
  publicAPI.delete = (0,macros2.h)(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageResliceMapper_DEFAULT_VALUES = {
  VBOBuildTime: {},
  VBOBuildString: null,
  haveSeenDepthRequest: false,
  lastHaveSeenDepthRequest: false,
  lastIndependentComponents: false,
  lastTextureComponents: 0,
  lastSlabThickness: 0,
  lastSlabTrapezoidIntegration: 0,
  lastSlabType: -1,
  openGLTexture: null,
  colorTextureString: null,
  pwfTextureString: null,
  resliceGeom: null,
  resliceGeomUpdateString: null,
  tris: null,
  colorTexture: null,
  pwfTexture: null,
  _externalOpenGLTexture: false
  // _scalars: null,
  // _colorTransferFunc: null,
  // _pwFunc: null,
};

// ----------------------------------------------------------------------------

function ImageResliceMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageResliceMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = Helper/* default.newInstance */.Ay.newInstance();
  model.openGLTexture = null;
  model.colorTexture = null;
  model.pwfTexture = null;
  model.VBOBuildTime = {};
  (0,macros2.o)(model.VBOBuildTime);
  model.tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));

  // Implicit plane to polydata related cache:
  model.outlineFilter = vtkImageDataOutlineFilter$1.newInstance();
  model.outlineFilter.setGenerateFaces(true);
  model.outlineFilter.setGenerateLines(false);
  model.cubePolyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.cutter = Cutter/* default.newInstance */.Ay.newInstance();
  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter$1.newInstance();
  model.transform = vtkTransform$1.newInstance();
  (0,macros2.g)(publicAPI, model, ['openGLTexture']);

  // Object methods
  vtkOpenGLImageResliceMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageResliceMapper_newInstance = (0,macros2.n)(ImageResliceMapper_extend, 'vtkOpenGLImageResliceMapper');

// ----------------------------------------------------------------------------

var vtkImageResliceMapper = {
  newInstance: ImageResliceMapper_newInstance,
  extend: ImageResliceMapper_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkImageResliceMapper', ImageResliceMapper_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var ImageMapper = __webpack_require__(6814);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageCPRMapper/Constants.js
const ProjectionMode = {
  MAX: 0,
  MIN: 1,
  AVERAGE: 2
};
var Constants_Constants = {
  ProjectionMode
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js
var vtkPolyDataVS_glsl = __webpack_require__(84839);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS_glsl = __webpack_require__(23159);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageCPRMapper.js




















const {
  vtkErrorMacro: ImageCPRMapper_vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkOpenGLImageCPRMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageCPRMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageCPRMapper');
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._colorTransferFunc, model._pwFunc].forEach(coreObject => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.opaqueZBufferPass = prepass => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology() === Static/* Resolve */.XK.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const prop = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, prop);
  };
  publicAPI.renderPiece = (ren, prop) => {
    publicAPI.invokeEvent({
      type: 'StartEvent'
    });
    model.renderable.update();
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });

    // Check if the ImageCPRMapper has everything it needs to render
    if (!model.renderable.preRenderCheck()) {
      return;
    }
    model.currentImageDataInput = model.renderable.getInputData(0);
    model.currentCenterlineInput = model.renderable.getOrientedCenterline();
    publicAPI.renderPieceStart(ren, prop);
    publicAPI.renderPieceDraw(ren, prop);
    publicAPI.renderPieceFinish(ren, prop);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // activate the texture
    model.volumeTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();

    // draw polygons
    if (model.tris.getCABO().getElementCount()) {
      // First we do the triangles, update the shader, set uniforms, etc.
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.volumeTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {};
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
    // Set interpolation on the texture based on property setting
    const actorProperty = actor.getProperty();
    if (actorProperty.getInterpolationType() === ImageProperty_Constants/* InterpolationType */.V.NEAREST) {
      model.volumeTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.volumeTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.pwfTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.pwfTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
    } else {
      model.volumeTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.volumeTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.pwfTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.pwfTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    return vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentImageDataInput.getMTime() || vmtime < model.currentCenterlineInput.getMTime() || !model.volumeTexture?.getHandle();
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentImageDataInput;
    const centerline = model.currentCenterlineInput;

    // Rebuild the volumeTexture if the data has changed
    const scalars = image?.getPointData()?.getScalars();
    if (!scalars) {
      return;
    }
    const cachedScalarsEntry = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    const volumeTextureHash = (0,resourceSharingHelper/* getImageDataHash */.eS)(image, scalars);
    const reBuildTex = !cachedScalarsEntry?.oglObject?.getHandle() || cachedScalarsEntry?.hash !== volumeTextureHash;
    if (reBuildTex) {
      model.volumeTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.volumeTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // Build the textures
      const dims = image.getDimensions();
      // Use norm16 for scalar texture if the extension is available
      model.volumeTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));
      model.volumeTexture.resetFormatAndType();
      model.volumeTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, model.renderable.getPreferSizeOverAccuracy());
      model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.volumeTexture, volumeTextureHash);
      if (scalars !== model._scalars) {
        model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
        model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
      }
      model._scalars = scalars;
    } else {
      model.volumeTexture = cachedScalarsEntry.oglObject;
    }

    // Rebuild the color texture if needed
    const numComp = scalars.getNumberOfComponents();
    const ppty = actor.getProperty();
    const iComps = ppty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = ppty.getRGBTransferFunction();
    const colorTextureHash = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(colorTransferFunc, iComps, numIComps);
    const cachedColorEntry = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildColorTexture = !cachedColorEntry?.oglObject?.getHandle() || cachedColorEntry?.hash !== colorTextureHash;
    if (reBuildColorTexture) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      model.colorTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0; c < numIComps; c++) {
          const cfun = ppty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, colorTextureHash);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cachedColorEntry.oglObject;
    }

    // Build piecewise function buffer.  This buffer is used either
    // for component weighting or opacity, depending on whether we're
    // rendering components independently or not.
    const pwFunc = ppty.getPiecewiseFunction();
    const pwfTextureHash = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(pwFunc, iComps, numIComps);
    const cachedPwfEntry = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    const reBuildPwf = !cachedPwfEntry?.oglObject?.getHandle() || cachedPwfEntry?.hash !== pwfTextureHash;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0; c < numIComps; ++c) {
          const pwfun = ppty.getPiecewiseFunction(c);
          if (pwfun === null) {
            // Piecewise constant max if no function supplied for this component
            pwfFloatTable.fill(1.0);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            // adjust for sample distance etc
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, DataArray_Constants/* VtkDataTypes */.JA.FLOAT, pwfFloatTable);
      } else {
        // default is opaque
        pwfTable.fill(255.0);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, pwfTextureHash);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = cachedPwfEntry.oglObject;
    }

    // Rebuild the image vertices if needed
    if (model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < centerline.getMTime()) {
      const nPoints = centerline.getNumberOfPoints();
      const nLines = nPoints <= 1 ? 0 : nPoints - 1;
      const distances = centerline.getDistancesToFirstPoint();
      const totalHeight = model.renderable.getHeight();
      const nPts = 4 * nLines;

      // Create the array of point: 4 points per segment
      const ptsArray = new Float32Array(3 * nPts);
      const widthMC = model.renderable.getWidth();
      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {
        // Use model coordinates
        // See "setCameraShaderParameters" to see how MCPCMatrix is built

        // Top left
        ptsArray.set([0, totalHeight - distances[lineIdx], 0], offset);
        offset += 3;
        // Top right
        ptsArray.set([widthMC, totalHeight - distances[lineIdx], 0], offset);
        offset += 3;
        // Bottom right
        ptsArray.set([widthMC, totalHeight - distances[lineIdx + 1], 0], offset);
        offset += 3;
        // Bottom left
        ptsArray.set([0, totalHeight - distances[lineIdx + 1], 0], offset);
        offset += 3;
      }
      const points = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');

      // Create the array of cells: a quad per segment
      const cellArray = new Uint16Array(5 * nLines);
      for (let lineIdx = 0, offset = 0, ptIdx = 0; lineIdx < nLines; ++lineIdx) {
        cellArray.set([4, ptIdx + 3, ptIdx + 2, ptIdx + 1, ptIdx], offset);
        offset += 5;
        ptIdx += 4;
      }
      const cells = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });

      // Create the array of centerline positions (VBO custom attribute)
      const pointsDataArray = centerline.getPoints();
      const centerlinePositionArray = new Float32Array(3 * nPts);
      const pa = new Array(3);
      const pb = new Array(3);
      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {
        pointsDataArray.getPoint(lineIdx, pa);
        pointsDataArray.getPoint(lineIdx + 1, pb);

        // Top left
        centerlinePositionArray.set(pa, offset);
        offset += 3;
        // Top right
        centerlinePositionArray.set(pa, offset);
        offset += 3;
        // Bottom right
        centerlinePositionArray.set(pb, offset);
        offset += 3;
        // Bottom left
        centerlinePositionArray.set(pb, offset);
        offset += 3;
      }
      const centerlinePosition = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: centerlinePositionArray,
        name: 'centerlinePosition'
      });

      // Create the array of quad index:
      //   0 ____ 1
      //    |    |
      //    |____|
      //   2      3
      const quadIndexArray = new Float32Array(nPts);
      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {
        quadIndexArray.set([0,
        // Top left
        1,
        // Top right
        3,
        // Bottom right
        2 // Bottom left
        ], offset);
        offset += 4;
      }
      const quadIndex = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 1,
        values: quadIndexArray,
        name: 'quadIndex'
      });
      const customAttributes = [centerlinePosition, quadIndex];
      if (!model.renderable.getUseUniformOrientation()) {
        // For each quad (i.e. centerline segment), a top and bottom quaternion give the orientation
        // Send both quaternions to each vertex and use flat interpolation to get them "as is" in the fragment shader
        // The interpolation of the quaternions will occur in the fragment shader (slerp)
        const orientationQuats = model.renderable.getOrientedCenterline().getOrientations() ?? [];
        const centerlineTopOrientationArray = new Float32Array(4 * nPts);
        const centerlineBotOrientationArray = new Float32Array(4 * nPts);
        for (let quadIdx = 0; quadIdx < nLines; ++quadIdx) {
          // All vertices of a given quad have the same topDir and botDir
          // Polyline goes from top to bottom
          const topQuat = orientationQuats[quadIdx];
          const botQuat = orientationQuats[quadIdx + 1];
          for (let pointInQuadIdx = 0; pointInQuadIdx < 4; ++pointInQuadIdx) {
            const pointIdx = pointInQuadIdx + 4 * quadIdx;
            const quaternionArrayOffset = 4 * pointIdx;
            centerlineTopOrientationArray.set(topQuat, quaternionArrayOffset);
            centerlineBotOrientationArray.set(botQuat, quaternionArrayOffset);
          }
        }
        const centerlineTopOrientation = DataArray/* default.newInstance */.Ay.newInstance({
          numberOfComponents: 4,
          values: centerlineTopOrientationArray,
          name: 'centerlineTopOrientation'
        });
        const centerlineBotOrientation = DataArray/* default.newInstance */.Ay.newInstance({
          numberOfComponents: 4,
          values: centerlineBotOrientationArray,
          name: 'centerlineBotOrientation'
        });
        customAttributes.push(centerlineTopOrientation, centerlineBotOrientation);
      }
      model.tris.getCABO().createVBO(cells, 'polys', Property_Constants/* Representation */.YL.SURFACE, {
        points,
        customAttributes
      });
      model.VBOBuildTime.modified();
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // presence of centerPoint
    // value of useUniformOrientation
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    // render pass shader replacement changed

    const tNumComp = model.volumeTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    const useCenterPoint = !!model.renderable.getCenterPoint();
    const useUniformOrientation = model.renderable.getUseUniformOrientation();
    const projectionMode = model.renderable.isProjectionEnabled() && model.renderable.getProjectionMode();
    if (cellBO.getProgram() === 0 || model.lastUseCenterPoint !== useCenterPoint || model.lastUseUniformOrientation !== useUniformOrientation || model.lastProjectionMode !== projectionMode || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastUseCenterPoint = useCenterPoint;
      model.lastUseUniformOrientation = useUniformOrientation;
      model.lastProjectionMode = projectionMode;
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;

    // https://glmatrix.net/docs/vec3.js.html#line522
    const applyQuaternionToVecShaderFunction = ['vec3 applyQuaternionToVec(vec4 q, vec3 v) {', '  float uvx = q.y * v.z - q.z * v.y;', '  float uvy = q.z * v.x - q.x * v.z;', '  float uvz = q.x * v.y - q.y * v.x;', '  float uuvx = q.y * uvz - q.z * uvy;', '  float uuvy = q.z * uvx - q.x * uvz;', '  float uuvz = q.x * uvy - q.y * uvx;', '  float w2 = q.w * 2.0;', '  uvx *= w2;', '  uvy *= w2;', '  uvz *= w2;', '  uuvx *= 2.0;', '  uuvy *= 2.0;', '  uuvz *= 2.0;', '  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);', '}'];

    // Vertex shader main replacements
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;
    const vsColorDec = ['attribute vec3 centerlinePosition;', 'attribute float quadIndex;', 'uniform float width;', 'out vec2 quadOffsetVSOutput;', 'out vec3 centerlinePosVSOutput;'];
    const useProjection = model.renderable.isProjectionEnabled();
    const isDirectionUniform = model.renderable.getUseUniformOrientation();
    if (isDirectionUniform) {
      vsColorDec.push('out vec3 samplingDirVSOutput;', 'uniform vec4 centerlineOrientation;', 'uniform vec3 tangentDirection;', ...applyQuaternionToVecShaderFunction);
      if (useProjection) {
        vsColorDec.push('out vec3 projectionDirVSOutput;', 'uniform vec3 bitangentDirection;');
      }
    } else {
      vsColorDec.push('out vec4 centerlineTopOrientationVSOutput;', 'out vec4 centerlineBotOrientationVSOutput;', 'attribute vec4 centerlineTopOrientation;', 'attribute vec4 centerlineBotOrientation;');
    }
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Dec', vsColorDec).result;
    const vsColorImpl = [
    // quadOffsetVSOutput.x: left = -0.5* width; right = 0.5 * width
    // quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;
    'quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);', 'centerlinePosVSOutput = centerlinePosition;'];
    if (isDirectionUniform) {
      vsColorImpl.push('samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);');
      if (useProjection) {
        vsColorImpl.push('projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);');
      }
    } else {
      vsColorImpl.push('centerlineTopOrientationVSOutput = centerlineTopOrientation;', 'centerlineBotOrientationVSOutput = centerlineBotOrientation;');
    }
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Impl', vsColorImpl).result;

    // Fragment shader main replacements
    const tNumComp = model.volumeTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordFSDec = [
    // used to compute texture coordinates of the sample
    'uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates', 'in vec2 quadOffsetVSOutput;', 'in vec3 centerlinePosVSOutput;',
    // volume texture
    'uniform highp sampler3D volumeTexture;',
    // color and pwf textures
    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',
    // opacity
    'uniform float opacity;',
    // background color (out of volume samples)
    'uniform vec4 backgroundColor;',
    // color shift and scale
    `uniform float cshift0;`, `uniform float cscale0;`,
    // weighting shift and scale
    `uniform float pwfshift0;`, `uniform float pwfscale0;`];
    if (useProjection) {
      tcoordFSDec.push('uniform vec3 volumeSizeMC;', 'uniform int projectionSlabNumberOfSamples;', 'uniform float projectionConstantOffset;', 'uniform float projectionStepLength;');
    }
    if (isDirectionUniform) {
      tcoordFSDec.push('in vec3 samplingDirVSOutput;');
      if (useProjection) {
        tcoordFSDec.push('in vec3 projectionDirVSOutput;');
      }
    } else {
      tcoordFSDec.push('uniform vec3 tangentDirection;', 'in vec4 centerlineTopOrientationVSOutput;', 'in vec4 centerlineBotOrientationVSOutput;', ...applyQuaternionToVecShaderFunction);
      if (useProjection) {
        tcoordFSDec.push('uniform vec3 bitangentDirection;');
      }
    }
    const centerPoint = model.renderable.getCenterPoint();
    if (centerPoint) {
      tcoordFSDec.push('uniform vec3 globalCenterPoint;');
    }
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
        // color shift and scale
        `uniform float cshift${comp};`, `uniform float cscale${comp};`,
        // weighting shift and scale
        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);
      }
      // the heights defined below are the locations
      // for the up to four components of the tfuns
      // the tfuns have a height of 2XnumComps pixels so the
      // values are computed to hit the middle of the two rows
      // for that component
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);
          break;
        default:
          ImageCPRMapper_vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;
    let tcoordFSImpl = [];
    if (isDirectionUniform) {
      tcoordFSImpl.push('vec3 samplingDirection = samplingDirVSOutput;');
      if (useProjection) {
        tcoordFSImpl.push('vec3 projectionDirection = projectionDirVSOutput;');
      }
    } else {
      // Slerp or lerp between centerlineTopDirVSOutput and centerlineBotDirVSOutput
      // We use quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;
      tcoordFSImpl.push(
      // Slerp / Lerp
      'vec4 q0 = centerlineBotOrientationVSOutput;', 'vec4 q1 = centerlineTopOrientationVSOutput;', 'float qCosAngle = dot(q0, q1);', 'vec4 interpolatedOrientation;', 'if (qCosAngle > 0.999 || qCosAngle < -0.999) {', '  // Use LERP instead of SLERP when the two quaternions are close or opposite', '  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));', '} else {', '  float omega = acos(qCosAngle);', '  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);', '}', 'vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);');
      if (useProjection) {
        tcoordFSImpl.push('vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);');
      }
    }
    if (centerPoint) {
      tcoordFSImpl.push('float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);', 'float horizontalOffset = quadOffsetVSOutput.x + baseOffset;');
    } else {
      tcoordFSImpl.push('float horizontalOffset = quadOffsetVSOutput.x;');
    }
    tcoordFSImpl.push('vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;', 'vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;', 'if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}');
    if (useProjection) {
      const projectionMode = model.renderable.getProjectionMode();
      switch (projectionMode) {
        case ProjectionMode.MIN:
          tcoordFSImpl.push('const vec4 initialProjectionTextureValue = vec4(1.0);');
          break;
        case ProjectionMode.MAX:
        case ProjectionMode.AVERAGE:
        default:
          tcoordFSImpl.push('const vec4 initialProjectionTextureValue = vec4(0.0);');
          break;
      }

      // Loop on all the samples of the projection
      tcoordFSImpl.push('vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;', 'vec3 projectionStep = projectionStepLength * projectionScaledDirection;', 'vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;', 'vec4 tvalue = initialProjectionTextureValue;', 'for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {', '  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;', '  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);');
      switch (projectionMode) {
        case ProjectionMode.MAX:
          tcoordFSImpl.push('  tvalue = max(tvalue, sampledTextureValue);');
          break;
        case ProjectionMode.MIN:
          tcoordFSImpl.push('  tvalue = min(tvalue, sampledTextureValue);');
          break;
        case ProjectionMode.AVERAGE:
        default:
          tcoordFSImpl.push('  tvalue = tvalue + sampledTextureValue;');
          break;
      }
      tcoordFSImpl.push('}');

      // Process the total if needed
      if (projectionMode === ProjectionMode.AVERAGE) {
        tcoordFSImpl.push('tvalue = tvalue / float(projectionSlabNumberOfSamples);');
      }
    } else {
      tcoordFSImpl.push('vec4 tvalue = texture(volumeTexture, volumePosTC);');
    }
    if (iComps) {
      const rgba = ['r', 'g', 'b', 'a'];
      for (let comp = 0; comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);
          break;
        default:
          ImageCPRMapper_vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    } else {
      // dependent components
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);
      }
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;

    // Picking shader replacements
    if (model.haveSeenDepthRequest) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        macros2.m.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS_glsl.v;
    shaders.Fragment = vtkPolyDataFS_glsl.v;
    shaders.Geometry = '';
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cellArrayBufferObject = cellBO.getCABO();
    if (cellArrayBufferObject.getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed('vertexMC')) {
        if (!cellBO.getVAO().addAttributeArray(program, cellArrayBufferObject, 'vertexMC', cellArrayBufferObject.getVertexOffset(), cellArrayBufferObject.getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          ImageCPRMapper_vtkErrorMacro('Error setting vertexMC in shader VAO.');
        }
      }
      // Custom data of the CABO (centerlinePosition, centerlineTopDirection,
      // centerlineBotDirection, quadIndex and user defined custom data)
      cellBO.getCABO().getCustomData().forEach(data => {
        if (data && program.isAttributeUsed(data.name) && !cellBO.getVAO().addAttributeArray(program, cellArrayBufferObject, data.name, data.offset, cellArrayBufferObject.getStride(), model.context.FLOAT, data.components, model.context.FALSE)) {
          ImageCPRMapper_vtkErrorMacro(`Error setting ${data.name} in shader VAO.`);
        }
      });
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.volumeTexture.getTextureUnit();
    program.setUniformi('volumeTexture', texUnit);
    program.setUniformf('width', model.renderable.getWidth());
    cellBO.getProgram().setUniform4fv('backgroundColor', model.renderable.getBackgroundColor());
    if (program.isUniformUsed('tangentDirection')) {
      const tangentDirection = model.renderable.getTangentDirection();
      cellBO.getProgram().setUniform3fArray('tangentDirection', tangentDirection);
    }
    if (program.isUniformUsed('bitangentDirection')) {
      const bitangentDirection = model.renderable.getBitangentDirection();
      cellBO.getProgram().setUniform3fArray('bitangentDirection', bitangentDirection);
    }
    if (program.isUniformUsed('centerlineOrientation')) {
      const uniformOrientation = model.renderable.getUniformOrientation();
      cellBO.getProgram().setUniform4fv('centerlineOrientation', uniformOrientation);
    }
    if (program.isUniformUsed('globalCenterPoint')) {
      const centerPoint = model.renderable.getCenterPoint();
      program.setUniform3fArray('globalCenterPoint', centerPoint);
    }
    // Projection uniforms
    if (model.renderable.isProjectionEnabled()) {
      const image = model.currentImageDataInput;
      const spacing = image.getSpacing();
      const dimensions = image.getDimensions();
      const projectionSlabThickness = model.renderable.getProjectionSlabThickness();
      const projectionSlabNumberOfSamples = model.renderable.getProjectionSlabNumberOfSamples();
      const volumeSize = esm/* vec3.mul */.eR.mul([], spacing, dimensions);
      program.setUniform3fArray('volumeSizeMC', volumeSize);
      program.setUniformi('projectionSlabNumberOfSamples', projectionSlabNumberOfSamples);
      const constantOffset = -0.5 * projectionSlabThickness;
      program.setUniformf('projectionConstantOffset', constantOffset);
      const stepLength = projectionSlabThickness / (projectionSlabNumberOfSamples - 1);
      program.setUniformf('projectionStepLength', stepLength);
    }

    // Model coordinates to image space
    // getWorldToIndex is badly named and is in fact modelToIndex
    // MCIC -> Model coordinates to index coordinates
    // MCTC -> Model coordinates to texture coordinates
    const image = model.currentImageDataInput;
    const MCICMatrix = image.getWorldToIndex();
    const ICTCMatrix = esm/* mat4.fromScaling */.pB.fromScaling(new Float32Array(16), esm/* vec3.inverse */.eR.inverse([], image.getDimensions()));
    const MCTCMatrix = esm/* mat4.mul */.pB.mul(ICTCMatrix, ICTCMatrix, MCICMatrix);
    program.setUniformMatrix('MCTCMatrix', MCTCMatrix);
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      // add all the clipping planes
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        macros2.m.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellArrayBufferObject.getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellArrayBufferObject.getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? esm/* mat4.copy */.pB.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        esm/* mat4.transpose */.pB.transpose(mat, mat);
        esm/* mat4.multiply */.pB.multiply(mat, mat, inverseShiftScaleMatrix);
        esm/* mat4.transpose */.pB.transpose(mat, mat);
      }

      // transform crop plane normal with transpose(inverse(worldToIndex))
      esm/* mat4.transpose */.pB.transpose(model.imagemat, model.currentImageDataInput.getIndexToWorld());
      esm/* mat4.multiply */.pB.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      program.setUniformi('numClipPlanes', numClipPlanes);
      program.setUniform4fv('clipPlanes', planeEquations);
    }

    // handle coincident
    if (program.isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      program.setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (program.isUniformUsed('cfactor')) {
        program.setUniformf('cfactor', cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const MCWCMatrix = model.openGLImageSlice.getKeyMatrices().mcwc;
    const WCPCMatrix = model.openGLCamera.getKeyMatrices(ren).wcpc;
    esm/* mat4.multiply */.pB.multiply(model.imagemat, WCPCMatrix, MCWCMatrix);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      esm/* mat4.multiply */.pB.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    cellBO.getProgram().setUniformMatrix('MCPCMatrix', model.imagemat);
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf('opacity', opacity);

    // Component mix
    // Independent components: Mixed according to component weights
    // Dependent components: Mixed using the following logic:
    //    - 2 comps => LA
    //    - 3 comps => RGB + opacity from pwf
    //    - 4 comps => RGBA
    const numComp = model.volumeTexture.getComponents();
    const iComps = ppty.getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; ++i) {
        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));
      }
    }

    // Color opacity map
    const volInfo = model.volumeTexture.getVolumeInfo();

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      let cw = ppty.getColorWindow();
      let cl = ppty.getColorLevel();
      const target = iComps ? i : 0;
      const cfun = ppty.getRGBTransferFunction(target);
      if (cfun && ppty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale = volInfo.scale[i] / cw;
      const shift = (volInfo.offset[i] - cl) / cw + 0.5;
      program.setUniformf(`cshift${i}`, shift);
      program.setUniformf(`cscale${i}`, scale);
    }
    const texColorUnit = model.colorTexture.getTextureUnit(); // TODO
    program.setUniformi('colorTexture1', texColorUnit);

    // pwf shift/scale
    for (let i = 0; i < numComp; i++) {
      let pwfScale = 1.0;
      let pwfShift = 0.0;
      const target = iComps ? i : 0;
      const pwfun = ppty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volInfo.scale[i] / length;
        pwfShift = (volInfo.offset[i] - mid) / length + 0.5;
      }
      program.setUniformf(`pwfshift${i}`, pwfShift);
      program.setUniformf(`pwfscale${i}`, pwfScale);
    }
    const texOpacityUnit = model.pwfTexture.getTextureUnit(); // TODO
    program.setUniformi('pwfTexture1', texOpacityUnit);
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.delete = macros2.m.chain(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageCPRMapper_DEFAULT_VALUES = {
  currentRenderPass: null,
  volumeTexture: null,
  colorTexture: null,
  pwfTexture: null,
  tris: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0,
  lastIndependentComponents: 0,
  imagemat: null,
  imagematinv: null
  // _scalars: null,
  // _colorTransferFunc: null,
  // _pwFunc: null,
};

// ----------------------------------------------------------------------------

function ImageCPRMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageCPRMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);

  // Two inputs: one for the ImageData/Texture and one for the PolyData (centerline)
  macros2.m.algo(publicAPI, model, 2, 0);
  model.tris = Helper/* default.newInstance */.Ay.newInstance();
  model.volumeTexture = null;
  model.colorTexture = null;
  model.pwfTexture = null;
  model.imagemat = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.imagematinv = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  macros2.m.obj(model.VBOBuildTime, {
    mtime: 0
  });

  // Object methods
  vtkOpenGLImageCPRMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageCPRMapper_newInstance = macros2.m.newInstance(ImageCPRMapper_extend, 'vtkOpenGLImageCPRMapper');
const STATIC = {};

// ----------------------------------------------------------------------------

var index = {
  newInstance: ImageCPRMapper_newInstance,
  extend: ImageCPRMapper_extend,
  ...STATIC
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkImageCPRMapper', ImageCPRMapper_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
var ImageSlice = __webpack_require__(64501);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
var Volume = __webpack_require__(8126);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js + 2 modules
var VolumeMapper = __webpack_require__(95785);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var PixelSpaceCallbackMapper = __webpack_require__(68464);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
var WebGPU_Camera = __webpack_require__(26910);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js + 1 modules
var WebGPU_Renderer = __webpack_require__(24210);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var ImageMapper_Constants = __webpack_require__(94520);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js + 1 modules
var ShaderCache = __webpack_require__(9806);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
var FullScreenQuad = __webpack_require__(94363);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var UniformBuffer = __webpack_require__(83259);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
var Sampler = __webpack_require__(20461);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var WebGPU_ViewNodeFactory = __webpack_require__(50440);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js










// const { vtkErrorMacro } = macro;
const {
  SlicingMode
} = ImageMapper_Constants/* default */.A;
const imgFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Image::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  //VTK::Image::Sample

  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);

//VTK::RenderEncoder::Impl

  return output;
}
`;

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function computeFnToString(property, fn, numberOfComponents) {
  const pwfun = fn.apply(property);
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return '0';
}

// ----------------------------------------------------------------------------
// vtkWebGPUImageMapper methods
// ----------------------------------------------------------------------------

const tmpMat4 = new Float64Array(16);
const tmp2Mat4 = new Float64Array(16);
const tmp3Mat4 = new Float64Array(16);
const ptsArray1 = new Float64Array(4);
const ptsArray2 = new Float64Array(4);
function vtkWebGPUImageMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUImageMapper');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType('vtkWebGPUImageSlice');
      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
      const ren = model.WebGPURenderer.getRenderable();
      // is slice set by the camera
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };

  // Renders myself
  publicAPI.translucentPass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.computePipelineHash = () => {
    const ext = model.currentInput.getExtent();
    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {
      model.dimensions = 2;
      model.pipelineHash = 'img2';
    } else {
      model.dimensions = 3;
      model.pipelineHash = 'img3';
    }
  };
  publicAPI.updateUBO = () => {
    const utime = model.UBO.getSendTime();
    const actor = model.WebGPUImageSlice.getRenderable();
    const volMapr = actor.getMapper();
    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {
      // compute the SCTCMatrix
      const image = volMapr.getInputData();
      const center = model.WebGPURenderer.getStabilizedCenterByReference();
      esm/* mat4.identity */.pB.identity(tmpMat4);
      esm/* mat4.translate */.pB.translate(tmpMat4, tmpMat4, center);
      // tmpMat4 is now SC->World

      const mcwcmat = actor.getMatrix();
      esm/* mat4.transpose */.pB.transpose(tmp2Mat4, mcwcmat);
      esm/* mat4.invert */.pB.invert(tmp2Mat4, tmp2Mat4);
      // tmp2Mat4 is now world to model

      esm/* mat4.multiply */.pB.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      // tmp4Mat is now SC->Model

      // the method on the data is world to index but the volume is in
      // model coordinates so really in this context it is model to index
      const modelToIndex = image.getWorldToIndex();
      esm/* mat4.multiply */.pB.multiply(tmpMat4, modelToIndex, tmpMat4);
      // tmpMat4 is now SC -> Index, save this as we need it later
      esm/* mat4.invert */.pB.invert(tmp3Mat4, tmpMat4);

      // need translation and scale
      esm/* mat4.fromTranslation */.pB.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);
      esm/* mat4.multiply */.pB.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const dims = image.getDimensions();
      esm/* mat4.identity */.pB.identity(tmp2Mat4);
      esm/* mat4.scale */.pB.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);
      esm/* mat4.multiply */.pB.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      // tmpMat4 is now SC -> Tcoord

      model.UBO.setArray('SCTCMatrix', tmpMat4);

      // need to compute the plane here in world coordinates
      // then pass that down in the UBO
      const ext = model.currentInput.getExtent();

      // Find what IJK axis and what direction to slice along
      const {
        ijkMode
      } = model.renderable.getClosestIJKAxis();

      // Find the IJK slice
      let nSlice = model.renderable.getSlice();
      if (ijkMode !== model.renderable.getSlicingMode()) {
        // If not IJK slicing, get the IJK slice from the XYZ position/slice
        nSlice = model.renderable.getSliceAtPosition(nSlice);
      }
      let axis0 = 2;
      let axis1 = 0;
      let axis2 = 1;
      if (ijkMode === SlicingMode.I) {
        axis0 = 0;
        axis1 = 1;
        axis2 = 2;
      } else if (ijkMode === SlicingMode.J) {
        axis0 = 1;
        axis1 = 2;
        axis2 = 0;
      }
      ptsArray1[axis0] = nSlice;
      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray1[3] = 1.0;
      esm/* vec4.transformMat4 */.ln.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);
      model.UBO.setArray('Origin', ptsArray1);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;
      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray2[3] = 1.0;
      esm/* vec4.transformMat4 */.ln.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      esm/* vec4.subtract */.ln.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1.0;
      model.UBO.setArray('Axis1', ptsArray2);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;
      ptsArray2[3] = 1.0;
      esm/* vec4.transformMat4 */.ln.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      esm/* vec4.subtract */.ln.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1.0;
      model.UBO.setArray('Axis2', ptsArray2);

      // three levels of shift scale combined into one
      // for performance in the fragment shader
      const cScale = [1, 1, 1, 1];
      const cShift = [0, 0, 0, 0];
      const tView = model.textureViews[0];
      const tScale = tView.getTexture().getScale();
      const numComp = tView.getTexture().getNumberOfComponents();
      for (let i = 0; i < numComp; i++) {
        let cw = actor.getProperty().getColorWindow();
        let cl = actor.getProperty().getColorLevel();
        const target = 0;
        const cfun = actor.getProperty().getRGBTransferFunction(target);
        if (cfun) {
          const cRange = cfun.getRange();
          cw = cRange[1] - cRange[0];
          cl = 0.5 * (cRange[1] + cRange[0]);
        }
        cScale[i] = tScale / cw;
        cShift[i] = -cl / cw + 0.5;
      }
      model.UBO.setArray('cScale', cScale);
      model.UBO.setArray('cShift', cShift);
      model.UBO.sendIfNeeded(model.device);
    }
  };
  publicAPI.updateLUTImage = () => {
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const tView = publicAPI.getTextureViews()[0];
    tView.getTexture().getNumberOfComponents();
    const numIComps = 1;
    const cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      model.numRows = numIComps;
      const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
      let cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        const tmpTable = new Float32Array(model.rowLength * 3);
        for (let c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);
          {
            for (let i = 0; i < model.rowLength; i++) {
              const idx = c * model.rowLength * 8 + i * 4;
              colorArray[idx] = 255.0 * tmpTable[i * 3];
              colorArray[idx + 1] = 255.0 * tmpTable[i * 3 + 1];
              colorArray[idx + 2] = 255.0 * tmpTable[i * 3 + 2];
              colorArray[idx + 3] = 255.0;
              for (let j = 0; j < 4; j++) {
                colorArray[idx + model.rowLength * 4 + j] = colorArray[idx + j];
              }
            }
          }
        }
      } else {
        for (let i = 0; i < model.rowLength; ++i) {
          const grey = 255.0 * i / (model.rowLength - 1);
          colorArray[i * 4] = grey;
          colorArray[i * 4 + 1] = grey;
          colorArray[i * 4 + 2] = grey;
          colorArray[i * 4 + 3] = 255.0;
          for (let j = 0; j < 4; j++) {
            colorArray[i * 4 + model.rowLength * 4 + j] = colorArray[i * 4 + j];
          }
        }
      }
      {
        const treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: 'rgba8unorm'
        };
        const newTex = model.device.getTextureManager().getTexture(treq);
        const tview = newTex.createView('tfunTexture');
        model.textureViews[1] = tview;
      }
      model.colorTextureString = cfunToString;
    }
  };
  const superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = () => {
    superClassUpdateBuffers();
    const newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);
    const tViews = model.textureViews;
    if (!tViews[0] || tViews[0].getTexture() !== newTex) {
      const tview = newTex.createView('imgTexture');
      tViews[0] = tview;
    }
    publicAPI.updateLUTImage();
    publicAPI.updateUBO();

    // set interpolation on the texture based on property setting
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const iType = actorProperty.getInterpolationType() === ImageProperty_Constants/* InterpolationType */.V.NEAREST ? 'nearest' : 'linear';
    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {
      model.clampSampler = Sampler/* default.newInstance */.Ay.newInstance({
        label: 'clampSampler'
      });
      model.clampSampler.create(model.device, {
        minFilter: iType,
        magFilter: iType
      });
      model.additionalBindables = [model.clampSampler];
    }
  };
  const sr = publicAPI.getShaderReplacements();
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    let code = vDesc.getCode();
    const lines = ['var pos: vec4<f32> = mapperUBO.Origin +', '   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;', 'pos.w = 1.0;'];
    if (model.dimensions === 2) {
      lines.push('var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;');
    } else {
      lines.push('var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;');
    }
    lines.push('output.tcoordVS = tcoord;', 'output.Position = rendererUBO.SCPCMatrix * pos;');
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', lines).result;
    vDesc.setCode(code);
  };
  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    if (model.dimensions === 2) {
      vDesc.addOutput('vec2<f32>', 'tcoordVS');
    } else {
      vDesc.addOutput('vec3<f32>', 'tcoordVS');
    }
  };
  sr.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderImage = (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription('fragment');
    let code = fDesc.getCode();
    if (model.dimensions === 3) {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Image::Sample', [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    } else {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Image::Sample', [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    }
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Image::Sample', [`    var coord: vec2<f32> =`, `      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);`, `    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);`]).result;
    fDesc.setCode(code);
  };
  sr.set('replaceShaderImage', publicAPI.replaceShaderImage);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageMapper_DEFAULT_VALUES = {
  rowLength: 1024
};

// ----------------------------------------------------------------------------

function ImageMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  FullScreenQuad/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  publicAPI.setFragmentShaderTemplate(imgFragTemplate);
  model.UBO = UniformBuffer/* default.newInstance */.Ay.newInstance({
    label: 'mapperUBO'
  });
  model.UBO.addEntry('SCTCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('Origin', 'vec4<f32>');
  model.UBO.addEntry('Axis2', 'vec4<f32>');
  model.UBO.addEntry('Axis1', 'vec4<f32>');
  model.UBO.addEntry('cScale', 'vec4<f32>');
  model.UBO.addEntry('cShift', 'vec4<f32>');
  model.lutBuildTime = {};
  (0,macros2.o)(model.lutBuildTime, {
    mtime: 0
  });
  model.imagemat = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.imagematinv = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  (0,macros2.o)(model.VBOBuildTime);

  // Object methods
  vtkWebGPUImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageMapper_newInstance = (0,macros2.n)(ImageMapper_extend, 'vtkWebGPUImageMapper');

// ----------------------------------------------------------------------------

var ImageMapper_index = {
  newInstance: ImageMapper_newInstance,
  extend: ImageMapper_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkImageMapper', ImageMapper_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js





// ----------------------------------------------------------------------------
// vtkWebGPUImageSlice methods
// ----------------------------------------------------------------------------

function vtkWebGPUImageSlice(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUImageSlice');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = wgpuRen => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = wgpuRen => {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();

      // compute the net shift
      const center = wgpuRen.getStabilizedCenterByReference();
      model.bufferShift[0] = mcwc[3] - center[0];
      model.bufferShift[1] = mcwc[7] - center[1];
      model.bufferShift[2] = mcwc[11] - center[2];
      esm/* mat4.transpose */.pB.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        esm/* mat4.identity */.pB.identity(model.keyMatrices.normalMatrix);
      } else {
        // we use bcwc BEFORE the translate below (just to get transposed mcvc)
        esm/* mat4.copy */.pB.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        // zero out translation
        model.keyMatrices.normalMatrix[3] = 0.0;
        model.keyMatrices.normalMatrix[7] = 0.0;
        model.keyMatrices.normalMatrix[11] = 0.0;
        esm/* mat4.invert */.pB.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        esm/* mat4.transpose */.pB.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }

      // only meed the buffer shift to get to world
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);

      // to get to stabilized we also need the center
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageSlice_DEFAULT_VALUES = {
  bufferShift: undefined,
  keyMatrixTime: null,
  keyMatrices: null,
  propID: undefined
};

// ----------------------------------------------------------------------------

function ImageSlice_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageSlice_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  (0,macros2.o)(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  model.keyMatrixTime = {};
  (0,macros2.o)(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: esm/* mat4.identity */.pB.identity(new Float64Array(16))
  };
  model.bufferShift = [0, 0, 0, 0];
  (0,macros2.g)(publicAPI, model, ['propID', 'keyMatricesTime']);

  // Object methods
  vtkWebGPUImageSlice(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageSlice_newInstance = (0,macros2.n)(ImageSlice_extend, 'vtkWebGPUImageSlice');

// ----------------------------------------------------------------------------

var ImageSlice_index = {
  newInstance: ImageSlice_newInstance,
  extend: ImageSlice_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkImageSlice', ImageSlice_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Volume.js





// ----------------------------------------------------------------------------
// vtkWebGPUVolume methods
// ----------------------------------------------------------------------------

function vtkWebGPUVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUVolume');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
      // for the future if we support hardware selection of volumes
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      model.renderable.getMapper().update();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }

      // Check for the special case when the mapper's bounds are unknown
      const bds = model.renderable.getMapper().getBounds();
      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }
      renderPass.addVolume(publicAPI);
    }
  };

  // used in the method below
  const idx = new Float64Array(3);
  const vout = new Float64Array(3);
  publicAPI.getBoundingCubePoints = (result, offset) => {
    const input = model.renderable.getMapper().getInputData();
    if (!input) {
      return;
    }
    const extent = input.getExtent();
    const m = model.renderable.getMatrix();
    let count = 0;
    for (let iz = 4; iz < 6; iz++) {
      idx[2] = extent[iz];
      for (let iy = 2; iy < 4; iy++) {
        idx[1] = extent[iy];
        for (let ix = 0; ix < 2; ix++) {
          idx[0] = extent[ix];
          input.indexToWorld(idx, vout);
          let poffset = offset + count * 3;
          result[poffset++] = m[0] * vout[0] + m[1] * vout[1] + m[2] * vout[2] + m[3];
          result[poffset++] = m[4] * vout[0] + m[5] * vout[1] + m[6] * vout[2] + m[7];
          result[poffset++] = m[8] * vout[0] + m[9] * vout[1] + m[10] * vout[2] + m[11];
          count++;
        }
      }
    }
  };
  publicAPI.getKeyMatrices = wgpuRen => {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();

      // compute the net shift
      const center = wgpuRen.getStabilizedCenterByReference();
      esm/* mat4.transpose */.pB.transpose(model.keyMatrices.bcwc, mcwc);

      // to get to stabilized we also need the center
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Volume_DEFAULT_VALUES = {
  propID: undefined,
  keyMatricesTime: null
};

// ----------------------------------------------------------------------------

function Volume_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Volume_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macros2.m.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macros2.m.get(publicAPI, model, ['propID', 'keyMatricesTime']);

  // Object methods
  vtkWebGPUVolume(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Volume_newInstance = macros2.m.newInstance(Volume_extend, 'vtkWebGPUVolume');

// ----------------------------------------------------------------------------

var Volume_index = {
  newInstance: Volume_newInstance,
  extend: Volume_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkVolume', Volume_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
var WebGPU_PixelSpaceCallbackMapper = __webpack_require__(77489);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Profiles/Volume.js

















/***/ }),

/***/ 25196:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkViewNode$1)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;
const PASS_TYPES = ['Build', 'Render'];

// ----------------------------------------------------------------------------
// vtkViewNode methods
// ----------------------------------------------------------------------------

function vtkViewNode(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkViewNode');

  // Builds myself.
  publicAPI.build = prepass => {};

  // Renders myself
  publicAPI.render = prepass => {};
  publicAPI.traverse = renderPass => {
    // we can choose to do special
    // traversal here based on pass
    const passTraversal = renderPass.getTraverseOperation();
    const fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }

    // default traversal
    publicAPI.apply(renderPass, true);
    for (let index = 0; index < model.children.length; index++) {
      model.children[index].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.apply = (renderPass, prepass) => {
    const customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };
  publicAPI.getViewNodeFor = dataObject => {
    if (model.renderable === dataObject) {
      return publicAPI;
    }
    for (let index = 0; index < model.children.length; ++index) {
      const child = model.children[index];
      const vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return undefined;
  };
  publicAPI.getFirstAncestorOfType = type => {
    if (!model._parent) {
      return null;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return model._parent.getFirstAncestorOfType(type);
  };
  publicAPI.getLastAncestorOfType = type => {
    if (!model._parent) {
      return null;
    }
    const lastAncestor = model._parent.getLastAncestorOfType(type);
    if (lastAncestor) {
      return lastAncestor;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return null;
  };

  // add a missing node/child for the passed in renderables. This should
  // be called only in between prepareNodes and removeUnusedNodes
  publicAPI.addMissingNode = dobj => {
    if (!dobj) {
      return undefined;
    }

    // if found just mark as visited
    const result = model._renderableChildMap.get(dobj);
    if (result !== undefined) {
      result.setVisited(true);
      return result;
    }

    // otherwise create a node
    const newNode = publicAPI.createViewNode(dobj);
    if (newNode) {
      newNode.setParent(publicAPI);
      newNode.setVisited(true);
      model._renderableChildMap.set(dobj, newNode);
      model.children.push(newNode);
      return newNode;
    }
    return undefined;
  };

  // add missing nodes/children for the passed in renderables. This should
  // be called only in between prepareNodes and removeUnusedNodes
  publicAPI.addMissingNodes = dataObjs => {
    if (!dataObjs || !dataObjs.length) {
      return;
    }
    for (let index = 0; index < dataObjs.length; ++index) {
      const dobj = dataObjs[index];
      publicAPI.addMissingNode(dobj);
    }
  };

  // ability to add children that have no renderable use in the same manner
  // as addMissingNodes This case is when a normal viewnode wants to
  // delegate passes to a helper or child that doeasn't map to a clear
  // renderable or any renderable
  publicAPI.addMissingChildren = children => {
    if (!children || !children.length) {
      return;
    }
    for (let index = 0; index < children.length; ++index) {
      const child = children[index];
      const cindex = model.children.indexOf(child);
      if (cindex === -1) {
        child.setParent(publicAPI);
        model.children.push(child);
        const childRenderable = child.getRenderable();
        if (childRenderable) {
          model._renderableChildMap.set(childRenderable, child);
        }
      }
      child.setVisited(true);
    }
  };
  publicAPI.removeNode = child => {
    const childIdx = model.children.findIndex(x => x === child);
    if (childIdx < 0) {
      return false;
    }
    const renderable = child.getRenderable();
    if (renderable) {
      model._renderableChildMap.delete(renderable);
    }
    child.delete();
    model.children.splice(childIdx, 1);
    return true;
  };
  publicAPI.prepareNodes = () => {
    for (let index = 0; index < model.children.length; ++index) {
      model.children[index].setVisited(false);
    }
  };
  publicAPI.setVisited = val => {
    model.visited = val;
  };
  publicAPI.removeUnusedNodes = () => {
    let visitedCount = 0;
    for (let index = 0; index < model.children.length; ++index) {
      const child = model.children[index];
      const visited = child.getVisited();
      if (visited) {
        model.children[visitedCount++] = child;
        child.setVisited(false);
      } else {
        const renderable = child.getRenderable();
        if (renderable) {
          model._renderableChildMap.delete(renderable);
        }
        child.delete();
      }
    }
    model.children.length = visitedCount;
  };
  publicAPI.createViewNode = dataObj => {
    if (!model.myFactory) {
      vtkErrorMacro('Cannot create view nodes without my own factory');
      return null;
    }
    const ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
  const parentDelete = publicAPI.delete;
  publicAPI.delete = () => {
    for (let i = 0; i < model.children.length; i++) {
      model.children[i].delete();
    }
    parentDelete();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // _parent: null,
  renderable: null,
  myFactory: null,
  children: [],
  visited: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.event(publicAPI, model, 'event');
  model._renderableChildMap = new Map();
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['visited']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['_parent', 'renderable', 'myFactory']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['children']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.moveToProtected(publicAPI, model, ['parent']);

  // Object methods
  vtkViewNode(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkViewNode');

// ----------------------------------------------------------------------------

var vtkViewNode$1 = {
  newInstance,
  extend,
  PASS_TYPES
};




/***/ }),

/***/ 84784:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkViewNodeFactory$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkViewNodeFactory methods
// ----------------------------------------------------------------------------

function vtkViewNodeFactory(publicAPI, model) {
  // Make sure our overrides is just for our instance not shared with everyone...
  if (!model.overrides) {
    model.overrides = {};
  }

  // Set our className
  model.classHierarchy.push('vtkViewNodeFactory');
  publicAPI.createNode = dataObject => {
    if (dataObject.isDeleted()) {
      return null;
    }
    let cpt = 0;
    let className = dataObject.getClassName(cpt++);
    let isObject = false;
    const keys = Object.keys(model.overrides);
    while (className && !isObject) {
      if (keys.indexOf(className) !== -1) {
        isObject = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject) {
      return null;
    }
    const vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // overrides: {},
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Object methods
  vtkViewNodeFactory(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkViewNodeFactory');

// ----------------------------------------------------------------------------

var vtkViewNodeFactory$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 10299:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkWebGPUBindGroup$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkWebGPUBindGroup methods
// ----------------------------------------------------------------------------

function vtkWebGPUBindGroup(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUBindGroup');
  publicAPI.setBindables = bindables => {
    // is there a difference between the old and new list?
    if (model.bindables.length === bindables.length) {
      let allMatch = true;
      for (let i = 0; i < model.bindables.length; i++) {
        if (model.bindables[i] !== bindables[i]) {
          allMatch = false;
        }
      }
      if (allMatch) {
        return;
      }
    }

    // there is a difference
    model.bindables = bindables;
    publicAPI.modified();
  };
  publicAPI.getBindGroupLayout = device => {
    const entries = [];
    for (let i = 0; i < model.bindables.length; i++) {
      const entry = model.bindables[i].getBindGroupLayoutEntry();
      entry.binding = i;
      entries.push(entry);
    }
    return device.getBindGroupLayout({
      entries
    });
  };
  publicAPI.getBindGroup = device => {
    // check mtime
    let mtime = publicAPI.getMTime();
    for (let i = 0; i < model.bindables.length; i++) {
      const tm = model.bindables[i].getBindGroupTime().getMTime();
      mtime = tm > mtime ? tm : mtime;
    }
    if (mtime < model.bindGroupTime.getMTime()) {
      return model.bindGroup;
    }
    const entries = [];
    for (let i = 0; i < model.bindables.length; i++) {
      const entry = model.bindables[i].getBindGroupEntry();
      entry.binding = i;
      entries.push(entry);
    }
    model.bindGroup = device.getHandle().createBindGroup({
      layout: publicAPI.getBindGroupLayout(device),
      entries,
      label: model.label
    });
    model.bindGroupTime.modified();
    return model.bindGroup;
  };
  publicAPI.getShaderCode = pipeline => {
    const lines = [];
    const bgroup = pipeline.getBindGroupLayoutCount(model.label);
    for (let i = 0; i < model.bindables.length; i++) {
      lines.push(model.bindables[i].getShaderCode(i, bgroup));
    }
    return lines.join('\n');
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  device: null,
  handle: null,
  label: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  model.bindables = [];
  model.bindGroupTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.bindGroupTime, {
    mtime: 0
  });
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['bindGroupTime', 'handle', 'sizeInBytes', 'usage']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['label', 'device', 'arrayInformation']);
  vtkWebGPUBindGroup(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkWebGPUBindGroup$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 49767:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkWebGPUBufferManager$1)
});

// UNUSED EXPORTS: STATIC, extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js
const BufferUsage = {
  Verts: 0,
  Lines: 1,
  Triangles: 2,
  Strips: 3,
  LinesFromStrips: 4,
  LinesFromTriangles: 5,
  Points: 6,
  UniformArray: 7,
  PointArray: 8,
  NormalsFromPoints: 9,
  Texture: 10,
  RawVertex: 11,
  Storage: 12,
  Index: 13
};
const PrimitiveTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Triangles: 2,
  TriangleStrips: 3,
  TriangleEdges: 4,
  TriangleStripEdges: 5,
  End: 6
};
var Constants = {
  BufferUsage,
  PrimitiveTypes
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js



// methods we forward to the handle
const forwarded = ['getMappedRange', 'mapAsync', 'unmap'];
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
  const byteCount = srcArrayBuffer.byteLength;
  const srcBuffer = device.createBuffer({
    size: byteCount,
    /* eslint-disable no-undef */
    usage: GPUBufferUsage.COPY_SRC,
    /* eslint-enable no-undef */
    mappedAtCreation: true
  });
  const arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer)); // memcpy
  srcBuffer.unmap();
  const encoder = device.createCommandEncoder();
  encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
  const commandBuffer = encoder.finish();
  const queue = device.queue;
  queue.submit([commandBuffer]);
  srcBuffer.destroy();
}
// ----------------------------------------------------------------------------
// vtkWebGPUBufferManager methods
// ----------------------------------------------------------------------------

function vtkWebGPUBuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUBuffer');
  publicAPI.create = (sizeInBytes, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: sizeInBytes,
      usage,
      label: model.label
    });
    model.sizeInBytes = sizeInBytes;
    model.usage = usage;
  };
  publicAPI.write = data => {
    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
  };
  publicAPI.createAndWrite = (data, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
      label: model.label
    });
    model.sizeInBytes = data.byteLength;
    model.usage = usage;
    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer)); // memcpy
    model.handle.unmap();
  };

  // simple forwarders
  for (let i = 0; i < forwarded.length; i++) {
    publicAPI[forwarded[i]] = function () {
      return model.handle[forwarded[i]](...arguments);
    };
  }
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  device: null,
  handle: null,
  sizeInBytes: 0,
  strideInBytes: 0,
  arrayInformation: null,
  usage: null,
  label: null,
  sourceTime: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['handle', 'sizeInBytes', 'usage']);
  macros2.m.setGet(publicAPI, model, ['strideInBytes', 'device', 'arrayInformation', 'label', 'sourceTime']);
  vtkWebGPUBuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkWebGPUBuffer$1 = {
  newInstance,
  extend,
  ...Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var Property = __webpack_require__(89585);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js





const {
  Representation
} = Property/* default */.Ay;
const {
  PrimitiveTypes: IndexBuffer_PrimitiveTypes
} = Constants;

// Simulate a small map of pointId to flatId for a cell. The original code
// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed
// length arrays with a count is so much faster even with the required for
// loops and if statements. This only works as we know the usage is
// restricted to clear(), set() get() and has() so the count is always
// incrmenting except for clear where it goes back to 0. Performance
// improvement is probably due to this appoach not hitting the heap but wow
// it is so much faster. Code that adds to these vectors checks against 9 to
// make sure there is room. Switching to test against vec.length -1 results
// in a small performance hit, so if you change 10, search for 9 in this
// small class and change those as well.
class _LimitedMap {
  constructor() {
    this.keys = new Uint32Array(10);
    this.values = new Uint32Array(10);
    this.count = 0;
  }
  clear() {
    this.count = 0;
  }
  has(key) {
    for (let i = 0; i < this.count; i++) {
      if (this.keys[i] === key) {
        return true;
      }
    }
    return undefined;
  }
  get(key) {
    for (let i = 0; i < this.count; i++) {
      if (this.keys[i] === key) {
        return this.values[i];
      }
    }
    return undefined;
  }
  set(key, value) {
    if (this.count < 9) {
      this.keys[this.count] = key;
      this.values[this.count++] = value;
    }
  }
}
function getPrimitiveName(primType) {
  switch (primType) {
    case IndexBuffer_PrimitiveTypes.Points:
      return 'points';
    case IndexBuffer_PrimitiveTypes.Lines:
      return 'lines';
    case IndexBuffer_PrimitiveTypes.Triangles:
    case IndexBuffer_PrimitiveTypes.TriangleEdges:
      return 'polys';
    case IndexBuffer_PrimitiveTypes.TriangleStripEdges:
    case IndexBuffer_PrimitiveTypes.TriangleStrips:
      return 'strips';
    default:
      return '';
  }
}
function _getOrAddFlatId(state, ptId, cellId) {
  let flatId = state.pointIdToFlatId[ptId];
  if (flatId < 0) {
    flatId = state.flatId;
    state.pointIdToFlatId[ptId] = flatId;
    state.flatIdToPointId[state.flatId] = ptId;
    state.flatIdToCellId[state.flatId] = cellId;
    state.flatId++;
  }
  return flatId;
}
function fillCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  // are any points already marked for this cell? If so use that as the provoking point
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    let ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId)) {
      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId);

      // insert remaining ptIds (they do not need to provoke)
      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId = ptIds[ptIdx2 % numPtIds];
        const flatId = _getOrAddFlatId(state, ptId, cellId);
        // add to ibo
        state.ibo[state.iboId++] = flatId;
      }
      // all done now
      return;
    }
  }

  // else have any of the points not been used yet? (not in provokedPointIds)
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    let ptId = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId]) {
      let flatId = _getOrAddFlatId(state, ptId, cellId);
      // mark provoking and add to ibo
      state.provokedPointIds[ptId] = 1;
      state.cellProvokedMap.set(ptId, flatId);
      // when provoking always set the cellId as an original non-provoking value
      // will have been stored and we need to overwrite that
      state.flatIdToCellId[flatId] = cellId;
      state.ibo[state.iboId++] = flatId;

      // insert remaining ptIds (they do not need to provoke)
      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId = ptIds[ptIdx2 % numPtIds];
        flatId = _getOrAddFlatId(state, ptId, cellId);
        // add to ibo
        state.ibo[state.iboId++] = flatId;
      }
      // all done now
      return;
    }
  }

  // if we got here then none of the ptIds could be used to provoke
  // so just duplicate the first one
  let ptId = ptIds[0];
  let flatId = state.flatId;
  state.cellProvokedMap.set(ptId, flatId);
  state.flatIdToPointId[state.flatId] = ptId;
  state.flatIdToCellId[state.flatId] = cellId;
  state.flatId++;

  // add to ibo
  state.ibo[state.iboId++] = flatId;

  // insert remaining ptIds (they do not need to provoke)
  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {
    ptId = ptIds[ptIdx2];
    flatId = _getOrAddFlatId(state, ptId, cellId);
    // add to ibo
    state.ibo[state.iboId++] = flatId;
  }
}
function countCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  state.iboSize += numPtIds;

  // are any points already marked for this cell? If so use that as the provoking point
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId)) {
      return;
    }
  }

  // else have any of the points not been used yet? (not in provokedPointIds)
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId]) {
      state.provokedPointIds[ptId] = 1;
      state.cellProvokedMap.set(ptId, 1);
      return;
    }
  }
  // if we got here then none of the ptIds could be used to provoke
  state.cellProvokedMap.set(ptIds[0], 1);
  state.extraPoints++;
}
let processCell;
const _single = new Uint32Array(1);
const _double = new Uint32Array(2);
const _triple = new Uint32Array(3);
const _indexCellBuilders = {
  // easy, every input point becomes an output point
  anythingToPoints(numPoints, cellPts, offset, cellId, state) {
    for (let i = 0; i < numPoints; ++i) {
      _single[0] = cellPts[offset + i];
      processCell(_single, cellId, state);
    }
  },
  linesToWireframe(numPoints, cellPts, offset, cellId, state) {
    // for lines we add a bunch of segments
    for (let i = 0; i < numPoints - 1; ++i) {
      _double[0] = cellPts[offset + i];
      _double[1] = cellPts[offset + i + 1];
      processCell(_double, cellId, state);
    }
  },
  polysToWireframe(numPoints, cellPts, offset, cellId, state) {
    // for polys we add a bunch of segments and close it
    if (numPoints > 2) {
      for (let i = 0; i < numPoints; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + (i + 1) % numPoints];
        processCell(_double, cellId, state);
      }
    }
  },
  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {
    if (numPoints > 2) {
      // for strips we add a bunch of segments and close it
      for (let i = 0; i < numPoints - 1; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 1];
        processCell(_double, cellId, state);
      }
      for (let i = 0; i < numPoints - 2; i++) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 2];
        processCell(_double, cellId, state);
      }
    }
  },
  polysToSurface(npts, cellPts, offset, cellId, state) {
    for (let i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset];
      _triple[1] = cellPts[offset + i + 1];
      _triple[2] = cellPts[offset + i + 2];
      processCell(_triple, cellId, state);
    }
  },
  stripsToSurface(npts, cellPts, offset, cellId, state) {
    for (let i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset + i];
      _triple[1] = cellPts[offset + i + 1 + i % 2];
      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];
      processCell(_triple, cellId, state);
    }
  }
};

// ----------------------------------------------------------------------------
// vtkWebGPUIndexBufferManager methods
// ----------------------------------------------------------------------------

function vtkWebGPUIndexBuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUIndexBuffer');
  publicAPI.buildIndexBuffer = req => {
    const cellArray = req.cells;
    const primitiveType = req.primitiveType;
    const representation = req.representation;
    const cellOffset = req.cellOffset;
    const array = cellArray.getData();
    const cellArraySize = array.length;
    const inRepName = getPrimitiveName(primitiveType);
    const numPts = req.numberOfPoints;
    const state = {
      provokedPointIds: new Uint8Array(numPts),
      // size is good
      extraPoints: 0,
      iboSize: 0,
      flatId: 0,
      iboId: 0,
      cellProvokedMap: new _LimitedMap()
    };
    let func = null;
    if (representation === Representation.POINTS || primitiveType === IndexBuffer_PrimitiveTypes.Points) {
      func = _indexCellBuilders.anythingToPoints;
    } else if (representation === Representation.WIREFRAME || primitiveType === IndexBuffer_PrimitiveTypes.Lines) {
      func = _indexCellBuilders[`${inRepName}ToWireframe`];
    } else {
      func = _indexCellBuilders[`${inRepName}ToSurface`];
    }

    // first we count how many extra provoking points we need
    processCell = countCell;
    let cellId = cellOffset || 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }

    // then we allocate the remaining structures
    // (we pick the best size to save space and transfer costs)
    if (numPts <= 0xffff) {
      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);
    }
    if (numPts + state.extraPoints < 0x8fff) {
      state.pointIdToFlatId = new Int16Array(numPts);
    } else {
      state.pointIdToFlatId = new Int32Array(numPts);
    }
    if (numPts + state.extraPoints <= 0xffff) {
      state.ibo = new Uint16Array(state.iboSize);
      req.format = 'uint16';
    } else {
      state.ibo = new Uint32Array(state.iboSize);
      req.format = 'uint32';
    }
    if (cellId <= 0xffff) {
      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);
    }
    state.pointIdToFlatId.fill(-1);
    state.provokedPointIds.fill(0);

    // and fill them in
    processCell = fillCell;
    cellId = cellOffset || 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }
    delete state.provokedPointIds;
    delete state.pointIdToFlatId;

    // store the results we need
    req.nativeArray = state.ibo;
    model.flatIdToPointId = state.flatIdToPointId;
    model.flatIdToCellId = state.flatIdToCellId;
    model.flatSize = state.flatId;
    model.indexCount = state.iboId;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const IndexBuffer_DEFAULT_VALUES = {
  flatIdToPointId: null,
  flatIdToCellId: null,
  flatSize: 0,
  indexCount: 0
};

// ----------------------------------------------------------------------------

function IndexBuffer_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, IndexBuffer_DEFAULT_VALUES, initialValues);

  // Inheritance
  vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);
  vtkWebGPUIndexBuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const IndexBuffer_newInstance = macros2.m.newInstance(IndexBuffer_extend);

// ----------------------------------------------------------------------------

var vtkWebGPUIndexBuffer$1 = {
  newInstance: IndexBuffer_newInstance,
  extend: IndexBuffer_extend,
  ...Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var Types = __webpack_require__(57372);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js








const {
  BufferUsage: BufferManager_BufferUsage
} = Constants;
const {
  vtkErrorMacro
} = macros2.c;
const {
  VtkDataTypes
} = DataArray/* default */.Ay;

// the webgpu constants all show up as undefined
/* eslint-disable no-undef */

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {};
function _getFormatForDataArray(dataArray) {
  let format;
  switch (dataArray.getDataType()) {
    case VtkDataTypes.UNSIGNED_CHAR:
      format = 'uint8';
      break;
    case VtkDataTypes.FLOAT:
      format = 'float32';
      break;
    case VtkDataTypes.UNSIGNED_INT:
      format = 'uint32';
      break;
    case VtkDataTypes.INT:
      format = 'sint32';
      break;
    case VtkDataTypes.DOUBLE:
      format = 'float32';
      break;
    case VtkDataTypes.UNSIGNED_SHORT:
      format = 'uint16';
      break;
    case VtkDataTypes.SHORT:
      format = 'sin16';
      break;
    default:
      format = 'float32';
      break;
  }
  switch (dataArray.getNumberOfComponents()) {
    case 2:
      format += 'x2';
      break;
    case 3:
      // only 32bit types support x3
      if (!format.includes('32')) {
        vtkErrorMacro(`unsupported x3 type for ${format}`);
      }
      format += 'x3';
      break;
    case 4:
      format += 'x4';
      break;
  }
  return format;
}
function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
  const result = {};
  const flatSize = indexBuffer.getFlatSize();
  if (!flatSize) {
    return result;
  }

  // setup shift and scale
  let shift = [0.0, 0.0, 0.0, 0.0];
  if (options.shift) {
    if (options.shift.length) {
      shift = options.shift;
    } else {
      shift.fill(options.shift);
    }
  }
  let scale = [1.0, 1.0, 1.0, 1.0];
  if (options.scale) {
    if (options.scale.length) {
      scale = options.scale;
    } else {
      scale.fill(options.scale);
    }
  }
  const packExtra = Object.prototype.hasOwnProperty.call(options, 'packExtra') ? options.packExtra : false;
  let addAPoint;
  let vboidx = 0;
  const stride = numComp + (packExtra ? 1 : 0);
  const packedVBO = (0,macros2.a)(outputType, flatSize * stride);

  // pick the right function based on point versus cell data
  let flatIdMap = indexBuffer.getFlatIdToPointId();
  if (options.cellData) {
    flatIdMap = indexBuffer.getFlatIdToCellId();
  }

  // add data based on number of components
  if (numComp === 1) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
    };
  } else if (numComp === 2) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
    };
  } else if (numComp === 3 && !packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
    };
  } else if (numComp === 3 && packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale[3] * 1.0 + shift[3];
    };
  } else if (numComp === 4) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale[3] * inArrayData[i + 3] + shift[3];
    };
  }

  // for each entry in the flat array process it
  for (let index = 0; index < flatSize; index++) {
    const inArrayId = numComp * flatIdMap[index];
    addAPoint(inArrayId);
  }
  result.nativeArray = packedVBO;
  return result;
}
function getNormal(pointData, i0, i1, i2) {
  const v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];
  const v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
  const result = [];
  (0,Core_Math.j)(v1, v2, result);
  (0,Core_Math.l)(result);
  return result;
}
function generateNormals(cellArray, pointArray) {
  const pointData = pointArray.getData();
  const cellArrayData = cellArray.getData();
  if (!cellArrayData || !pointData) {
    return null;
  }

  // return a cellArray of normals
  const packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
  const size = cellArrayData.length;
  let vboidx = 0;
  for (let index = 0; index < size;) {
    const normal = getNormal(pointData, cellArrayData[index + 1], cellArrayData[index + 2], cellArrayData[index + 3]);
    packedVBO[vboidx++] = 127 * normal[0];
    packedVBO[vboidx++] = 127 * normal[1];
    packedVBO[vboidx++] = 127 * normal[2];
    packedVBO[vboidx++] = 127;
    index += cellArrayData[index] + 1;
  }
  return packedVBO;
}

// ----------------------------------------------------------------------------
// vtkWebGPUBufferManager methods
// ----------------------------------------------------------------------------
function vtkWebGPUBufferManager(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUBufferManager');
  function _createBuffer(req) {
    // if a dataArray is provided set the nativeArray
    if (req.dataArray && !req.nativeArray) {
      req.nativeArray = req.dataArray.getData();
    }
    let buffer;
    let gpuUsage;

    // handle index buffers
    if (req.usage === BufferManager_BufferUsage.Index) {
      // todo change to FlattenedIndex to be more clear
      buffer = vtkWebGPUIndexBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
      /* eslint-disable no-bitwise */
      gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
      /* eslint-enable no-bitwise */
      buffer.buildIndexBuffer(req);
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setArrayInformation([{
        format: req.format
      }]);
    }

    // create one if not done already
    if (!buffer) {
      buffer = vtkWebGPUBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
    }

    // handle uniform buffers
    if (req.usage === BufferManager_BufferUsage.UniformArray) {
      /* eslint-disable no-bitwise */
      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
      /* eslint-enable no-bitwise */
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }

    // handle storage buffers
    if (req.usage === BufferManager_BufferUsage.Storage) {
      /* eslint-disable no-bitwise */
      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
      /* eslint-enable no-bitwise */
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }

    // handle textures
    if (req.usage === BufferManager_BufferUsage.Texture) {
      /* eslint-disable no-bitwise */
      gpuUsage = GPUBufferUsage.COPY_SRC;
      /* eslint-enable no-bitwise */
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }

    // all of the below types that have gpuUsage = VERTEX require format
    // to be provided.

    // handle point data
    if (req.usage === BufferManager_BufferUsage.PointArray) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType = Types/* default */.A.getNativeTypeFromBufferFormat(req.format);
      const result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {
        packExtra: req.packExtra,
        shift: req.shift,
        scale: req.scale,
        cellData: req.cellData,
        cellOffset: req.cellOffset
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(Types/* default */.A.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: req.cellData ? 'flat' : 'perspective'
      }]);
    }

    // handle normals from points, snorm8x4
    if (req.usage === BufferManager_BufferUsage.NormalsFromPoints) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType = Types/* default */.A.getNativeTypeFromBufferFormat(req.format);
      const normals = generateNormals(req.cells, req.dataArray);
      const result = packArray(req.indexBuffer, normals, 4, arrayType, {
        cellData: true
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(Types/* default */.A.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: 'flat'
      }]);
    }
    if (req.usage === BufferManager_BufferUsage.RawVertex) {
      gpuUsage = GPUBufferUsage.VERTEX;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setStrideInBytes(Types/* default */.A.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    buffer.setSourceTime(req.time);
    return buffer;
  }

  // is the buffer already present?
  publicAPI.hasBuffer = hash => model.device.hasCachedObject(hash);
  publicAPI.getBuffer = req => {
    // if we have a source the get/create/cache the buffer
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createBuffer, req);
    }
    return _createBuffer(req);
  };
  publicAPI.getBufferForPointArray = (dataArray, indexBuffer) => {
    const format = _getFormatForDataArray(dataArray);
    const buffRequest = {
      hash: `${dataArray.getMTime()}I${indexBuffer.getMTime()}${format}`,
      usage: BufferManager_BufferUsage.PointArray,
      format,
      dataArray,
      indexBuffer
    };
    return publicAPI.getBuffer(buffRequest);
  };
  publicAPI.getFullScreenQuadBuffer = () => {
    if (model.fullScreenQuadBuffer) {
      return model.fullScreenQuadBuffer;
    }
    model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
    model.fullScreenQuadBuffer.setDevice(model.device);

    // prettier-ignore
    const array = new Float32Array([-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0]);
    model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
    model.fullScreenQuadBuffer.setStrideInBytes(12);
    model.fullScreenQuadBuffer.setArrayInformation([{
      offset: 0,
      format: 'float32x3'
    }]);
    return model.fullScreenQuadBuffer;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const BufferManager_DEFAULT_VALUES = {
  device: null,
  fullScreenQuadBuffer: null
};

// ----------------------------------------------------------------------------

function BufferManager_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, BufferManager_DEFAULT_VALUES, initialValues);

  // Object methods
  (0,macros2.o)(publicAPI, model);
  (0,macros2.e)(publicAPI, model, ['device']);
  vtkWebGPUBufferManager(publicAPI, model);
}

// ----------------------------------------------------------------------------

const BufferManager_newInstance = (0,macros2.n)(BufferManager_extend);

// ----------------------------------------------------------------------------

var vtkWebGPUBufferManager$1 = {
  newInstance: BufferManager_newInstance,
  extend: BufferManager_extend,
  ...STATIC,
  ...Constants
};




/***/ }),

/***/ 26910:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50440);





// ----------------------------------------------------------------------------
// vtkWebGPUCamera methods
// ----------------------------------------------------------------------------

function vtkWebGPUCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUCamera');
  publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(outMat);
    if (model.renderable.getParallelProjection()) {
      // set up a rectangular parallelipiped
      const parallelScale = model.renderable.getParallelScale();
      const width = parallelScale * aspect;
      const height = parallelScale;
      const xmin = (windowCenter[0] - 1.0) * width;
      const xmax = (windowCenter[0] + 1.0) * width;
      const ymin = (windowCenter[1] - 1.0) * height;
      const ymax = (windowCenter[1] + 1.0) * height;
      const xr = 1.0 / (xmax - xmin);
      const yr = 1.0 / (ymax - ymin);
      outMat[0] = 2.0 * xr;
      outMat[5] = 2.0 * yr;
      outMat[10] = 1.0 / (cRange[1] - cRange[0]);
      outMat[12] = (xmax + xmin) * xr;
      outMat[13] = (ymax + ymin) * yr;
      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
    } else {
      const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360.0);
      let width;
      let height;
      if (model.renderable.getUseHorizontalViewAngle() === true) {
        width = cRange[0] * tmp;
        height = cRange[0] * tmp / aspect;
      } else {
        width = cRange[0] * tmp * aspect;
        height = cRange[0] * tmp;
      }
      const xmin = (windowCenter[0] - 1.0) * width;
      const xmax = (windowCenter[0] + 1.0) * width;
      const ymin = (windowCenter[1] - 1.0) * height;
      const ymax = (windowCenter[1] + 1.0) * height;
      outMat[0] = 2.0 * cRange[0] / (xmax - xmin);
      outMat[5] = 2.0 * cRange[0] / (ymax - ymin);
      outMat[12] = (xmin + xmax) / (xmax - xmin);
      outMat[13] = (ymin + ymax) / (ymax - ymin);
      outMat[10] = 0.0;
      outMat[14] = cRange[0];
      outMat[11] = -1.0;
      outMat[15] = 0.0;
    }
  };
  publicAPI.convertToOpenGLDepth = val => {
    if (model.renderable.getParallelProjection()) {
      return 1.0 - val;
    }
    const cRange = model.renderable.getClippingRangeByReference();
    let zval = -cRange[0] / val;
    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2.0 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
    return 0.5 * zval + 0.5;
  };
  publicAPI.getKeyMatrices = webGPURenderer => {
    // has the camera changed?
    const ren = webGPURenderer.getRenderable();
    const webGPURenderWindow = webGPURenderer.getParent();
    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      const wcvc = model.renderable.getViewMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.normalMatrix, wcvc);
      // zero out translation
      model.keyMatrices.normalMatrix[3] = 0.0;
      model.keyMatrices.normalMatrix[7] = 0.0;
      model.keyMatrices.normalMatrix[11] = 0.0;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.wcvc, wcvc);
      const center = webGPURenderer.getStabilizedCenterByReference();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      const aspectRatio = webGPURenderer.getAspectRatio();
      const cRange = model.renderable.getClippingRangeByReference();
      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  keyMatrixTime: null,
  keyMatrices: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.obj(model.keyMatrixTime);

  // values always get set by the get method
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  };

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGet(publicAPI, model, ['keyMatrixTime']);

  // Object methods
  vtkWebGPUCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.newInstance(extend);

// ----------------------------------------------------------------------------

var index = {
  newInstance,
  extend
};

// Register ourself to WebGPU backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkCamera', newInstance);




/***/ }),

/***/ 94363:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkWebGPUFullScreenQuad$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _ShaderCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9806);
/* harmony import */ var _SimpleMapper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32603);




// ----------------------------------------------------------------------------
// vtkWebGPUFullScreenQuad methods
// ----------------------------------------------------------------------------

function vtkWebGPUFullScreenQuad(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUFullScreenQuad');
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    vDesc.addOutput('vec4<f32>', 'vertexVC');
    let code = vDesc.getCode();
    code = _ShaderCache_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);', 'output.vertexVC = vec4<f32>(vertexBC, 1);']).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
  publicAPI.updateBuffers = () => {
    const buff = model.device.getBufferManager().getFullScreenQuadBuffer();
    model.vertexInput.addBuffer(buff, ['vertexBC']);
    model.numberOfVertices = 6;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SimpleMapper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkWebGPUFullScreenQuad(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkWebGPUFullScreenQuad');

// ----------------------------------------------------------------------------

var vtkWebGPUFullScreenQuad$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 77489:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50440);




// ----------------------------------------------------------------------------
// vtkWebGPUPixelSpaceCallbackMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push('vtkWebGPUPixelSpaceCallbackMapper');
  publicAPI.opaquePass = (prepass, renderPass) => {
    model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
    model.WebGPURenderWindow = model.WebGPURenderer.getParent();
    const aspectRatio = model.WebGPURenderer.getAspectRatio();
    const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
    const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
    const texels = null;
    if (model.renderable.getUseZValues()) ;
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.extend(publicAPI, model, initialValues);

  // Object methods
  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkWebGPUPixelSpaceCallbackMapper');

// ----------------------------------------------------------------------------

var index = {
  newInstance,
  extend
};

// Register ourself to WebGPU backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__/* .registerOverride */ .c9)('vtkPixelSpaceCallbackMapper', newInstance);




/***/ }),

/***/ 24210:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: default, extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
var BindGroup = __webpack_require__(10299);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
var FullScreenQuad = __webpack_require__(94363);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js + 3 modules
var BufferManager = __webpack_require__(49767);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var Types = __webpack_require__(57372);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js




const {
  BufferUsage
} = BufferManager/* default */.Ay;
const {
  vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkWebGPUStorageBuffer - similar to the UniformBuffer class
// but YOU are responsible for layout issues and alignment.
// The order you add entries is the order they will be layed out
// in memory. But you must follow layout rules.
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkWebGPUStorageBuffer methods
// ----------------------------------------------------------------------------

function vtkWebGPUStorageBuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUStorageBuffer');
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro(`entry named ${name} already exists`);
      return;
    }
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    const sizeInBytes = Types/* default */.A.getByteStrideFromShaderFormat(type);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes,
      offset: model.sizeInBytes,
      nativeType: Types/* default */.A.getNativeTypeFromShaderFormat(type)
    });
    model.sizeInBytes += sizeInBytes;
  };
  publicAPI.send = device => {
    if (!model._buffer) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage.Storage,
        label: model.label
      };
      model._buffer = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model._sendTime.modified();
      return;
    }
    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
    model._sendTime.modified();
  };
  publicAPI.createView = type => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
      }
      model[type] = macros2.m.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, instance, val) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
  };
  publicAPI.setArray = (name, instance, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
    for (let i = 0; i < arr.length; i++) {
      view[ioffset + i] = arr[i];
    }
  };
  publicAPI.setAllInstancesFromArray = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i];
      }
    }
  };
  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i] / 255.0;
      }
    }
  };
  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = 9;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let j = 0; j < 3; j++) {
        for (let i = 0; i < 3; i++) {
          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
        }
      }
    }
  };
  publicAPI.getSendTime = () => model._sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group) => {
    const lines = [`struct ${model.label}StructEntry\n{`];
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`
};
struct ${model.label}Struct
{
  values: array<${model.label}StructEntry>,
};
@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;
`);
    return lines.join('\n');
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model._buffer.getHandle()
      }
    };
    return foo;
  };
  publicAPI.clearData = () => {
    model.numberOfInstances = 0;
    model.sizeInBytes = 0;
    model.bufferEntries = [];
    model._bufferEntryNames = new Map();
    model._buffer = null;
    delete model.arrayBuffer;
    delete model.Float32Array;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  numberOfInstances: 1
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);

  // Internal objects
  model._bufferEntryNames = new Map();
  model.bufferEntries = [];
  model._sendTime = {};
  macros2.m.obj(model._sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macros2.m.obj(model.bindGroupTime, {
    mtime: 0
  });

  // default SSBO desc
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: 'read-only-storage'
    }
  };
  macros2.m.get(publicAPI, model, ['bindGroupTime']);
  macros2.m.setGet(publicAPI, model, ['device', 'bindGroupLayoutEntry', 'label', 'numberOfInstances', 'sizeInBytes']);

  // Object methods
  vtkWebGPUStorageBuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkWebGPUStorageBuffer');

// ----------------------------------------------------------------------------

var vtkWebGPUStorageBuffer$1 = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var UniformBuffer = __webpack_require__(83259);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(50440);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js










const {
  vtkDebugMacro
} = macros2.c;
const clearFragColorTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`;
const clearFragTextureTemplate = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
const _fsqClearMat4 = new Float64Array(16);
const _tNormalMat4 = new Float64Array(16);

// Light type index gives either 0, 1, or 2 which indicates what type of light there is.
// While technically, there are only spot and directional lights, within the CellArrayMapper
// there is a third, positional light. It is technically just a variant of a spot light with
// a cone angle of 90 or above, however certain calculations can be skipped if it is treated
// separately.
// The mappings are shown below:
// 0 -> positional light
// 1 -> directional light
// 2 -> spot light
function getLightTypeIndex(light) {
  if (light.getPositional()) {
    if (light.getConeAngle() >= 90) {
      return 0;
    }
    return 2;
  }
  return 1;
}

// ----------------------------------------------------------------------------
// vtkWebGPURenderer methods
// ----------------------------------------------------------------------------
/* eslint-disable no-bitwise */

function vtkWebGPURenderer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPURenderer');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.camera = model.renderable.getActiveCamera();
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.camera);
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);
      publicAPI.updateStabilizedMatrix();
    }
  };
  publicAPI.updateStabilizedMatrix = () => {
    // This method is designed to help with floating point
    // issues when rendering datasets that push the limits of
    // resolutions on float.
    //
    // One of the most common cases is when the dataset is located far
    // away from the origin relative to the clipping range we are looking
    // at. For that case we want to perform the floating point sensitive
    // multiplications on the CPU in double. To this end we want the
    // vertex rendering ops to look something like
    //
    // Compute shifted points and load those into the VBO
    // pointCoordsSC = WorldToStabilizedMatrix * pointCoords;
    //
    // In the vertex shader do the following
    // positionVC = StabilizedToDeviceMatrix * ModelToStabilizedMatrix*vertexIn;
    //
    // We use two matrices because it is expensive to change the
    // WorldToStabilized matrix as we have to reupload all pointCoords
    // So that matrix (MCSCMatrix) is fairly static, the Stabilized to
    // Device matrix is the one that gets updated every time the camera
    // changes.
    //
    // The basic idea is that we should translate the data so that
    // when the center of the view frustum moves a lot
    // we recenter it. The center of the view frustum is roughly
    // camPos + dirOfProj*(far + near)*0.5
    const clipRange = model.camera.getClippingRange();
    const pos = model.camera.getPositionByReference();
    const dop = model.camera.getDirectionOfProjectionByReference();
    const center = [];
    const offset = [];
    esm/* vec3.scale */.eR.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
    esm/* vec3.add */.eR.add(center, pos, offset);
    esm/* vec3.sub */.eR.sub(offset, center, model.stabilizedCenter);
    const length = esm/* vec3.len */.eR.len(offset);
    if (length / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
      model.stabilizedCenter = center;
      model.stabilizedTime.modified();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0.0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro('No lights are on, creating one.');
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.updateUBO = () => {
    // make sure the data is up to date
    // has the camera changed?
    const utime = model.UBO.getSendTime();
    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      model.UBO.setArray('WCVCMatrix', keyMats.wcvc);
      model.UBO.setArray('SCPCMatrix', keyMats.scpc);
      model.UBO.setArray('PCSCMatrix', keyMats.pcsc);
      model.UBO.setArray('SCVCMatrix', keyMats.scvc);
      model.UBO.setArray('VCPCMatrix', keyMats.vcpc);
      model.UBO.setArray('WCVCNormals', keyMats.normalMatrix);
      model.UBO.setValue('LightCount', model.renderable.getLights().length);
      model.UBO.setValue('MaxEnvironmentMipLevel', model.renderable.getEnvironmentTexture()?.getMipLevel());
      model.UBO.setValue('BackgroundDiffuseStrength', model.renderable.getEnvironmentTextureDiffuseStrength());
      model.UBO.setValue('BackgroundSpecularStrength', model.renderable.getEnvironmentTextureSpecularStrength());
      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      model.UBO.setArray('viewportSize', [tsize.usize, tsize.vsize]);
      model.UBO.setValue('cameraParallel', model.camera.getParallelProjection());
      const device = model._parent.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.updateSSBO = () => {
    const lights = model.renderable.getLights();
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    let lightTimeString = `${model.renderable.getMTime()}`;
    for (let i = 0; i < lights.length; i++) {
      lightTimeString += lights[i].getMTime();
    }
    if (lightTimeString !== model.lightTimeString) {
      const lightPosArray = new Float32Array(lights.length * 4);
      const lightDirArray = new Float32Array(lights.length * 4);
      const lightColorArray = new Float32Array(lights.length * 4);
      const lightTypeArray = new Float32Array(lights.length * 4);
      for (let i = 0; i < lights.length; i++) {
        const offset = i * 4;

        // Position
        const viewCoordinatePosition = lights[i].getPosition();
        esm/* vec3.transformMat4 */.eR.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
        // viewCoordinatePosition
        lightPosArray[offset] = viewCoordinatePosition[0];
        lightPosArray[offset + 1] = viewCoordinatePosition[1];
        lightPosArray[offset + 2] = viewCoordinatePosition[2];
        lightPosArray[offset + 3] = 0;

        // Rotation (All are negative to correct for -Z being forward)
        lightDirArray[offset] = -lights[i].getDirection()[0];
        lightDirArray[offset + 1] = -lights[i].getDirection()[1];
        lightDirArray[offset + 2] = -lights[i].getDirection()[2];
        lightDirArray[offset + 3] = 0;

        // Color
        lightColorArray[offset] = lights[i].getColor()[0];
        lightColorArray[offset + 1] = lights[i].getColor()[1];
        lightColorArray[offset + 2] = lights[i].getColor()[2];
        lightColorArray[offset + 3] = lights[i].getIntensity() * 5; // arbitrary multiplication to fix the dullness of low value PBR lights

        // Type
        lightTypeArray[offset] = getLightTypeIndex(lights[i]); // Type
        lightTypeArray[offset + 1] = Math.cos((0,Core_Math.r)(lights[i].getConeAngle())); // Inner Phi, should probably do some check on these to make sure they dont excede limits
        lightTypeArray[offset + 2] = Math.cos((0,Core_Math.r)(lights[i].getConeAngle() + lights[i].getConeFalloff())); // Outer Phi
        lightTypeArray[offset + 3] = 0;
      }

      // Im not sure how correct this is, but this is what the example does
      // https://kitware.github.io/vtk-js/api/Rendering_WebGPU_VolumePassFSQ.html
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(lights.length);
      model.SSBO.addEntry('LightPos', 'vec4<f32>'); // Position
      model.SSBO.addEntry('LightDir', 'vec4<f32>'); // Direction
      model.SSBO.addEntry('LightColor', 'vec4<f32>'); // Color (r, g, b, intensity)
      model.SSBO.addEntry('LightData', 'vec4<f32>'); // Other data (type, etc, etc, etc)

      model.SSBO.setAllInstancesFromArray('LightPos', lightPosArray);
      model.SSBO.setAllInstancesFromArray('LightDir', lightDirArray);
      model.SSBO.setAllInstancesFromArray('LightColor', lightColorArray);
      model.SSBO.setAllInstancesFromArray('LightData', lightTypeArray);
      const device = model._parent.getDevice();
      model.SSBO.send(device);
    }
    model.lightTimeString = lightTimeString;
  };
  publicAPI.scissorAndViewport = encoder => {
    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0.0, 1.0);
    // set scissor
    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
  };
  publicAPI.bindUBO = renderEncoder => {
    renderEncoder.activateBindGroup(model.bindGroup);
  };

  // Renders myself
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
      publicAPI.updateUBO();
      publicAPI.updateSSBO();
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      publicAPI.clear();
      model.renderEncoder.end();
    }
  };
  publicAPI.clear = () => {
    if (model.renderable.getTransparent() || model.suppressClear) {
      return;
    }
    const device = model._parent.getDevice();
    // Normal Solid Color
    if (!model.clearFSQ) {
      model.clearFSQ = FullScreenQuad/* default.newInstance */.Ay.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash('clearfsq');
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = UniformBuffer/* default.newInstance */.Ay.newInstance({
        label: 'mapperUBO'
      });
      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
      ubo.addEntry('BackgroundColor', 'vec4<f32>');
      model.clearFSQ.setUBO(ubo);
      model.backgroundTex = model.renderable.getEnvironmentTexture();
    }
    // Textured Background
    if (model.clearFSQ.getPipelineHash() !== 'clearfsqwithtexture' && model.renderable.getUseEnvironmentTextureAsBackground() && model.backgroundTex?.getImageLoaded()) {
      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
      const ubo = UniformBuffer/* default.newInstance */.Ay.newInstance({
        label: 'mapperUBO'
      });
      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
      ubo.addEntry('BackgroundColor', 'vec4<f32>');
      model.clearFSQ.setUBO(ubo);
      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex);
      if (environmentTextureHash.getReady()) {
        const tview = environmentTextureHash.createView(`EnvironmentTexture`);
        model.clearFSQ.setTextureViews([tview]);
        model.backgroundTexLoaded = true;
        const interpolate = model.backgroundTex.getInterpolate() ? 'linear' : 'nearest';
        tview.addSampler(device, {
          addressModeU: 'repeat',
          addressModeV: 'clamp-to-edge',
          addressModeW: 'repeat',
          minFilter: interpolate,
          magFilter: interpolate,
          mipmapFilter: 'linear'
        });
      }
      model.clearFSQ.setPipelineHash('clearfsqwithtexture');
    } else if (model.clearFSQ.getPipelineHash() === 'clearfsqwithtexture' && !model.renderable.getUseEnvironmentTextureAsBackground()) {
      // In case the mode is changed at runtime
      model.clearFSQ = FullScreenQuad/* default.newInstance */.Ay.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash('clearfsq');
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = UniformBuffer/* default.newInstance */.Ay.newInstance({
        label: 'mapperUBO'
      });
      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
      ubo.addEntry('BackgroundColor', 'vec4<f32>');
      model.clearFSQ.setUBO(ubo);
    }
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    const background = model.renderable.getBackgroundByReference();
    model.clearFSQ.getUBO().setArray('BackgroundColor', background);
    esm/* mat4.transpose */.pB.transpose(_tNormalMat4, keyMats.normalMatrix);
    esm/* mat4.mul */.pB.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
    esm/* mat4.mul */.pB.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
    model.clearFSQ.getUBO().setArray('FSQMatrix', _fsqClearMat4);
    model.clearFSQ.getUBO().sendIfNeeded(device);
    model.clearFSQ.prepareAndDraw(model.renderEncoder);
  };
  publicAPI.translucentPass = prepass => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.volumeDepthRangePass = prepass => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.convertToOpenGLDepth = val => model.webgpuCamera.convertToOpenGLDepth(val);
  publicAPI.getYInvertedTiledSizeAndOrigin = () => {
    const res = publicAPI.getTiledSizeAndOrigin();
    const size = model._parent.getSizeByReference();
    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;
    return res;
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();

    // if there is no window assume 0 1
    const tileViewPort = [0.0, 0.0, 1.0, 1.0];

    // find the lower left corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];

    // store the result as a pixel value
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);

    // find the upper right corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);

    // now compute the size of the intersection of the viewport with the
    // current tile
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.getPropFromID = id => {
    for (let i = 0; i < model.children.length; i++) {
      const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
      if (res === id) {
        return model.children[i];
      }
    }
    return null;
  };
  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Renderer_DEFAULT_VALUES = {
  bindGroup: null,
  selector: null,
  renderEncoder: null,
  recenterThreshold: 20.0,
  suppressClear: false,
  stabilizedCenter: [0.0, 0.0, 0.0]
};

// ----------------------------------------------------------------------------

function Renderer_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Renderer_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);

  // UBO
  model.UBO = UniformBuffer/* default.newInstance */.Ay.newInstance({
    label: 'rendererUBO'
  });
  model.UBO.addEntry('WCVCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('SCPCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('PCSCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('SCVCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('VCPCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('WCVCNormals', 'mat4x4<f32>');
  model.UBO.addEntry('viewportSize', 'vec2<f32>');
  model.UBO.addEntry('LightCount', 'i32');
  model.UBO.addEntry('MaxEnvironmentMipLevel', 'f32');
  model.UBO.addEntry('BackgroundDiffuseStrength', 'f32');
  model.UBO.addEntry('BackgroundSpecularStrength', 'f32');
  model.UBO.addEntry('cameraParallel', 'u32');

  // SSBO (Light data)
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: 'rendererLightSSBO'
  });
  model.lightTimeString = '';
  model.bindGroup = BindGroup/* default.newInstance */.Ay.newInstance({
    label: 'rendererBG'
  });
  model.bindGroup.setBindables([model.UBO, model.SSBO]);
  model.tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.stabilizedTime = {};
  (0,macros2.o)(model.stabilizedTime, {
    mtime: 0
  });

  // Build VTK API
  (0,macros2.g)(publicAPI, model, ['bindGroup', 'stabilizedTime']);
  (0,macros2.k)(publicAPI, model, ['stabilizedCenter']);
  (0,macros2.e)(publicAPI, model, ['renderEncoder', 'selector', 'suppressClear', 'UBO']);

  // Object methods
  vtkWebGPURenderer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Renderer_newInstance = (0,macros2.n)(Renderer_extend, 'vtkWebGPURenderer');

// ----------------------------------------------------------------------------

var index = {
  newInstance: Renderer_newInstance,
  extend: Renderer_extend
};

// Register ourself to WebGPU backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkRenderer', Renderer_newInstance);




/***/ }),

/***/ 20461:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkWebGPUSampler$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


/* eslint-disable no-bitwise */

// ----------------------------------------------------------------------------
// vtkWebGPUSampler methods
// ----------------------------------------------------------------------------

function vtkWebGPUSampler(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUSampler');
  publicAPI.create = function (device) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    model.device = device;
    model.options.addressModeU = options.addressModeU ? options.addressModeU : 'clamp-to-edge';
    model.options.addressModeV = options.addressModeV ? options.addressModeV : 'clamp-to-edge';
    model.options.addressModeW = options.addressModeW ? options.addressModeW : 'clamp-to-edge';
    model.options.magFilter = options.magFilter ? options.magFilter : 'nearest';
    model.options.minFilter = options.minFilter ? options.minFilter : 'nearest';
    model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : 'nearest';
    model.options.label = model.label;
    model.handle = model.device.getHandle().createSampler(model.options);
    model.bindGroupTime.modified();
  };
  publicAPI.getShaderCode = (binding, group) => {
    const result = `@binding(${binding}) @group(${group}) var ${model.label}: sampler;`;
    return result;
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: model.handle
    };
    return foo;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  device: null,
  handle: null,
  label: null,
  options: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  model.options = {};
  model.bindGroupLayoutEntry = {
    /* eslint-disable no-undef */
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    /* eslint-enable no-undef */
    sampler: {
      // type: 'filtering',
    }
  };
  model.bindGroupTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.bindGroupTime, {
    mtime: 0
  });
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['bindGroupTime', 'handle', 'options']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label']);
  vtkWebGPUSampler(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkWebGPUSampler$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 9806:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkWebGPUShaderCache$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js


// ----------------------------------------------------------------------------
// vtkWebGPUShaderModule methods
// ----------------------------------------------------------------------------

function vtkWebGPUShaderModule(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUShaderModule');
  publicAPI.initialize = (device, shaderDesc) => {
    model.device = device;
    // console.log(shaderDesc.getCode());
    model.handle = model.device.getHandle().createShaderModule({
      code: shaderDesc.getCode()
    });
  };

  // publicAPI.setLastCameraMTime = (mtime) => {
  //   model.lastCameraMTime = mtime;
  // };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  device: null,
  handle: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['lastCameraMTime']);
  macros2.m.setGet(publicAPI, model, ['device', 'handle']);

  // Object methods
  vtkWebGPUShaderModule(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkWebGPUShaderModule');

// ----------------------------------------------------------------------------

var vtkWebGPUShaderModule$1 = {
  newInstance,
  extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js



// perform in place string substitutions, indicate if a substitution was done
// this is useful for building up shader strings which typically involve
// lots of string substitutions. Return true if a substitution was done.
function substitute(source, search, replace) {
  let all = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  const replaceStr = Array.isArray(replace) ? replace.join('\n') : replace;
  let replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  let gflag = '';
  if (all) {
    gflag = 'g';
  }
  const regex = new RegExp(search, gflag);
  const resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}

// ----------------------------------------------------------------------------
// vtkWebGPUShaderCache methods
// ----------------------------------------------------------------------------

function vtkWebGPUShaderCache(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUShaderCache');
  publicAPI.getShaderModule = shaderDesc => {
    // has it already been created?
    const sType = shaderDesc.getType();
    const sHash = shaderDesc.getHash();
    const keys = model._shaderModules.keys();
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key.getHash() === sHash && key.getType() === sType) {
        return model._shaderModules.get(key);
      }
    }

    // console.log(JSON.stringify(shaderDesc));

    const sm = vtkWebGPUShaderModule$1.newInstance();
    sm.initialize(model.device, shaderDesc);
    model._shaderModules.set(shaderDesc, sm);
    return sm;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ShaderCache_DEFAULT_VALUES = {
  shaderModules: null,
  device: null,
  window: null
};

// ----------------------------------------------------------------------------

function ShaderCache_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ShaderCache_DEFAULT_VALUES, initialValues);

  // Internal objects
  model._shaderModules = new Map();

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['device', 'window']);

  // Object methods
  vtkWebGPUShaderCache(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ShaderCache_newInstance = macros2.m.newInstance(ShaderCache_extend, 'vtkWebGPUShaderCache');

// ----------------------------------------------------------------------------

var vtkWebGPUShaderCache$1 = {
  newInstance: ShaderCache_newInstance,
  extend: ShaderCache_extend,
  substitute
};




/***/ }),

/***/ 32603:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkWebGPUSimpleMapper$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
var BindGroup = __webpack_require__(10299);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js


// ----------------------------------------------------------------------------
// vtkWebGPUPipeline methods
// ----------------------------------------------------------------------------
function vtkWebGPUPipeline(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUPipeline');
  publicAPI.getShaderDescriptions = () => model.shaderDescriptions;
  publicAPI.initialize = (device, hash) => {
    // start with the renderencoder settings
    model.pipelineDescription = model.renderEncoder.getPipelineSettings();
    model.pipelineDescription.primitive.topology = model.topology;
    model.pipelineDescription.vertex = model.vertexState;
    model.pipelineDescription.label = hash;

    // add in bind group layouts
    const bindGroupLayouts = [];
    for (let i = 0; i < model.layouts.length; i++) {
      bindGroupLayouts.push(model.layouts[i].layout);
    }
    model.pipelineLayout = device.getHandle().createPipelineLayout({
      bindGroupLayouts
    });
    model.pipelineDescription.layout = model.pipelineLayout;
    for (let i = 0; i < model.shaderDescriptions.length; i++) {
      const sd = model.shaderDescriptions[i];
      const sm = device.getShaderModule(sd);
      if (sd.getType() === 'vertex') {
        model.pipelineDescription.vertex.module = sm.getHandle();
        model.pipelineDescription.vertex.entryPoint = 'main';
      }
      if (sd.getType() === 'fragment') {
        model.pipelineDescription.fragment.module = sm.getHandle();
        model.pipelineDescription.fragment.entryPoint = 'main';
      }
    }
    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
  };
  publicAPI.getShaderDescription = stype => {
    for (let i = 0; i < model.shaderDescriptions.length; i++) {
      if (model.shaderDescriptions[i].getType() === stype) return model.shaderDescriptions[i];
    }
    return null;
  };
  publicAPI.addBindGroupLayout = bindGroup => {
    if (!bindGroup) {
      return;
    }
    model.layouts.push({
      layout: bindGroup.getBindGroupLayout(model.device),
      label: bindGroup.getLabel()
    });
  };
  publicAPI.getBindGroupLayout = idx => model.layouts[idx].layout;
  publicAPI.getBindGroupLayoutCount = llabel => {
    for (let i = 0; i < model.layouts.length; i++) {
      if (model.layouts[i].label === llabel) {
        return i;
      }
    }
    return 0;
  };
  publicAPI.bindVertexInput = (renderEncoder, vInput) => {
    vInput.bindBuffers(renderEncoder);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const DEFAULT_VALUES = {
  handle: null,
  layouts: null,
  renderEncoder: null,
  shaderDescriptions: null,
  vertexState: null,
  topology: null,
  pipelineDescription: null
};

// ----------------------------------------------------------------------------
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  (0,macros2.o)(publicAPI, model);
  model.layouts = [];
  model.shaderDescriptions = [];
  (0,macros2.g)(publicAPI, model, ['handle', 'pipelineDescription']);
  (0,macros2.e)(publicAPI, model, ['device', 'renderEncoder', 'topology', 'vertexState']);

  // For more macro methods, see "Sources/macros.js"
  // Object specific methods
  vtkWebGPUPipeline(publicAPI, model);
}

// ----------------------------------------------------------------------------
const newInstance = (0,macros2.n)(extend, 'vtkWebGPUPipeline');

// ----------------------------------------------------------------------------
var vtkWebGPUPipeline$1 = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js + 1 modules
var ShaderCache = __webpack_require__(9806);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js



// ----------------------------------------------------------------------------
// vtkWebGPUShaderDescription methods
// ----------------------------------------------------------------------------

// shader description

function vtkWebGPUShaderDescription(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUShaderDescription');
  publicAPI.hasOutput = name => model.outputNames.includes(name);
  publicAPI.addOutput = function (type, name) {
    let interpolation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    model.outputTypes.push(type);
    model.outputNames.push(name);
    model.outputInterpolations.push(interpolation);
  };
  publicAPI.addBuiltinOutput = (type, name) => {
    model.builtinOutputTypes.push(type);
    model.builtinOutputNames.push(name);
  };
  publicAPI.addBuiltinInput = (type, name) => {
    model.builtinInputTypes.push(type);
    model.builtinInputNames.push(name);
  };

  // perform shader replacements for the input and outputs
  // of this shader. That includes vertex inputs if specified
  publicAPI.replaceShaderCode = (priorStage, vertexInput) => {
    const inputImpl = [];
    let iodec = [];
    if (vertexInput) {
      inputImpl.push(vertexInput.getShaderCode());
    }
    if (priorStage || model.builtinInputNames.length) {
      const inputStruct = [];
      inputStruct.push(`struct ${model.type}Input\n{`);
      if (priorStage) {
        const inputNames = priorStage.getOutputNamesByReference();
        const inputTypes = priorStage.getOutputTypesByReference();
        const inputInterpolations = priorStage.getOutputInterpolationsByReference();
        for (let i = 0; i < inputNames.length; i++) {
          if (inputInterpolations[i] !== undefined) {
            inputStruct.push(`  @location(${i}) @interpolate(${inputInterpolations[i]}) ${inputNames[i]} : ${inputTypes[i]},`);
          } else {
            inputStruct.push(`  @location(${i}) ${inputNames[i]} : ${inputTypes[i]},`);
          }
        }
      }
      for (let i = 0; i < model.builtinInputNames.length; i++) {
        inputStruct.push(`  ${model.builtinInputNames[i]} : ${model.builtinInputTypes[i]},`);
      }
      if (inputStruct.length > 1) {
        inputStruct.push('};');
        iodec = inputStruct;
        inputImpl[inputImpl.length - 1] += ',';
        inputImpl.push(`input: ${model.type}Input`);
      }
    }
    if (inputImpl.length) {
      model.code = ShaderCache/* default */.Ay.substitute(model.code, '//VTK::IOStructs::Input', inputImpl).result;
    }
    if (model.outputNames.length + model.builtinOutputNames.length) {
      const outputStruct = [`struct ${model.type}Output\n{`];
      for (let i = 0; i < model.outputNames.length; i++) {
        if (model.outputInterpolations[i] !== undefined) {
          outputStruct.push(`  @location(${i}) @interpolate(${model.outputInterpolations[i]}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
        } else {
          outputStruct.push(`  @location(${i}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
        }
      }
      for (let i = 0; i < model.builtinOutputNames.length; i++) {
        outputStruct.push(`  ${model.builtinOutputNames[i]} : ${model.builtinOutputTypes[i]},`);
      }
      outputStruct.push('};');
      iodec = iodec.concat(outputStruct);
      model.code = ShaderCache/* default */.Ay.substitute(model.code, '//VTK::IOStructs::Output', [`-> ${model.type}Output`]).result;
    }
    model.code = ShaderCache/* default */.Ay.substitute(model.code, '//VTK::IOStructs::Dec', iodec).result;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ShaderDescription_DEFAULT_VALUES = {
  type: null,
  // 'vertex' or 'fragment'
  hash: null,
  code: null,
  outputNames: null,
  outputTypes: null
};

// ----------------------------------------------------------------------------

function ShaderDescription_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ShaderDescription_DEFAULT_VALUES, initialValues);
  model.outputNames = [];
  model.outputTypes = [];
  model.outputInterpolations = [];
  model.builtinOutputNames = [];
  model.builtinOutputTypes = [];
  model.builtinInputNames = [];
  model.builtinInputTypes = [];

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['type', 'hash', 'code']);
  macros2.m.getArray(publicAPI, model, ['outputTypes', 'outputNames', 'outputInterpolations']);

  // Object methods
  vtkWebGPUShaderDescription(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ShaderDescription_newInstance = macros2.m.newInstance(ShaderDescription_extend, 'vtkWebGPUShaderDescription');

// ----------------------------------------------------------------------------

var vtkWebGPUShaderDescription$1 = {
  newInstance: ShaderDescription_newInstance,
  extend: ShaderDescription_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var Types = __webpack_require__(57372);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js



function arraysEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (!b.includes(a[i])) return false;
  }
  return true;
}

// ----------------------------------------------------------------------------
// vtkWebGPUVertexInput methods
// ----------------------------------------------------------------------------
function vtkWebGPUVertexInput(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUVertexInput');
  publicAPI.addBuffer = function (buffer, inames) {
    let stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';
    let names = inames;
    if (!Array.isArray(names)) {
      names = [names];
    }
    // only add if it is a new setting
    for (let i = 0; i < model.inputs.length; i++) {
      if (arraysEqual(model.inputs[i].names, names)) {
        if (model.inputs[i].buffer === buffer) {
          return;
        }
        model.inputs[i].buffer = buffer;
        return;
      }
    }

    // when adding a new entry, make sure we sort the array
    // as the order is important to the shader and must always
    // be the same, so alphabetical is an easy option
    model.inputs.push({
      buffer,
      stepMode,
      names
    });
    model.inputs = model.inputs.sort((v1, v2) => {
      if (v1.names[0] < v2.names[0]) {
        return -1;
      }
      if (v1.names[0] > v2.names[0]) {
        return 1;
      }
      return 0;
    });
  };
  publicAPI.removeBufferIfPresent = name => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        model.inputs.splice(i, 1);
      }
    }
  };
  publicAPI.getBuffer = name => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer;
      }
    }
    return null;
  };
  publicAPI.hasAttribute = name => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getAttributeTime = name => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer.getSourceTime();
      }
    }
    return 0;
  };
  publicAPI.getShaderCode = () => {
    let result = '';
    let nameCount = 0;
    for (let i = 0; i < model.inputs.length; i++) {
      for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];
        const type = Types/* default */.A.getShaderTypeFromBufferFormat(arrayInfo.format);
        if (nameCount > 0) {
          result += ',\n';
        }
        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;
        nameCount++;
      }
    }
    return result;
  };
  publicAPI.getVertexInputInformation = () => {
    const info = {};
    if (model.inputs.length) {
      const vertexBuffers = [];
      let nameCount = 0;
      for (let i = 0; i < model.inputs.length; i++) {
        const buf = model.inputs[i].buffer;
        const buffer = {
          arrayStride: buf.getStrideInBytes(),
          stepMode: model.inputs[i].stepMode,
          attributes: []
        };
        const arrayInfo = buf.getArrayInformation();
        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
          buffer.attributes.push({
            shaderLocation: nameCount,
            offset: arrayInfo[nm].offset,
            format: arrayInfo[nm].format
          });
          nameCount++;
        }
        vertexBuffers.push(buffer);
      }
      info.buffers = vertexBuffers;
    }
    return info;
  };
  publicAPI.bindBuffers = renderEncoder => {
    for (let i = 0; i < model.inputs.length; i++) {
      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
    }
    if (model.indexBuffer) {
      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
    }
  };
  publicAPI.getReady = () => {};
  publicAPI.releaseGraphicsResources = () => {
    if (model.created) {
      model.inputs = [];
      model.bindingDescriptions = [];
      model.attributeDescriptions = [];
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const VertexInput_DEFAULT_VALUES = {
  inputs: null,
  bindingDescriptions: false,
  attributeDescriptions: null,
  indexBuffer: null
};

// ----------------------------------------------------------------------------
function VertexInput_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, VertexInput_DEFAULT_VALUES, initialValues);

  // Build VTK API
  (0,macros2.o)(publicAPI, model);
  model.bindingDescriptions = [];
  model.attributeDescriptions = [];
  model.inputs = [];
  (0,macros2.e)(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']);

  // For more macro methods, see "Sources/macros.js"
  // Object specific methods
  vtkWebGPUVertexInput(publicAPI, model);
}

// ----------------------------------------------------------------------------
const VertexInput_newInstance = (0,macros2.n)(VertexInput_extend, 'vtkWebGPUVertexInput');

// ----------------------------------------------------------------------------
var vtkWebGPUVertexInput$1 = {
  newInstance: VertexInput_newInstance,
  extend: VertexInput_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js








const vtkWebGPUSimpleMapperVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
const vtkWebGPUSimpleMapperFS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;

// ----------------------------------------------------------------------------
// vtkWebGPUSimpleMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUSimpleMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUSimpleMapper');
  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {
    // create the shader descriptions
    const vDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: 'vertex',
      hash,
      code: model.vertexShaderTemplate
    });
    const fDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: 'fragment',
      hash,
      code: model.fragmentShaderTemplate
    });

    // add them to the pipeline
    const sdrs = pipeline.getShaderDescriptions();
    sdrs.push(vDesc);
    sdrs.push(fDesc);

    // look for replacements to invoke
    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
    // eslint-disable-next-line prefer-regex-literals
    const re = new RegExp('//VTK::[^:]*::', 'g');
    const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);
    const fnames = unique.map(v => `replaceShader${v.substring(7, v.length - 2)}`);

    // now invoke shader replacement functions
    for (let i = 0; i < fnames.length; i++) {
      const fname = fnames[i];
      if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {
        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
      }
    }

    // always replace the IOStructs last as other replacement funcs may
    // add inputs or outputs
    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);

    // console.log(vDesc.getCode());
    // console.log(fDesc.getCode());
  };

  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.replaceShaderCode(null, vertexInput);
    const fDesc = pipeline.getShaderDescription('fragment');
    fDesc.replaceShaderCode(vDesc);
  };
  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {
    model.renderEncoder.replaceShaderCode(pipeline);
  };
  model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);
  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {
    if (!model.WebGPURenderer) {
      return;
    }
    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription('vertex');
    let code = vDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription('fragment');
    code = fDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);
  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {
    const ubocode = model.bindGroup.getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription('vertex');
    let code = vDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription('fragment');
    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');
    code = fDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    let code = vDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addOutput('vec2<f32>', 'tcoordVS');
  };
  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);
  publicAPI.addTextureView = view => {
    // is it already there?
    if (model.textureViews.includes(view)) {
      return;
    }
    model.textureViews.push(view);
  };

  // do everything required for this mapper to be rerady to draw
  // but do not bind or do the actual draw commands as the pipeline
  // is not neccessarily bound yet
  publicAPI.prepareToDraw = renderEncoder => {
    model.renderEncoder = renderEncoder;

    // do anything needed to get our input data up to date
    publicAPI.updateInput();

    // make sure buffers are created and up to date
    publicAPI.updateBuffers();

    // update bindings and bind groups/layouts
    // does not acutally bind them, that is done in draw(...)
    publicAPI.updateBindings();

    // update the pipeline, includes computing the hash, and if needed
    // creating the pipeline, shader code etc
    publicAPI.updatePipeline();
  };
  publicAPI.updateInput = () => {};
  publicAPI.updateBuffers = () => {};
  publicAPI.updateBindings = () => {
    // bindings can change without a pipeline change
    // as long as their layout remains the same.
    // That is why this is done even when the pipeline
    // hash doesn't change.
    model.bindGroup.setBindables(publicAPI.getBindables());
  };
  publicAPI.computePipelineHash = () => {};
  publicAPI.registerDrawCallback = encoder => {
    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.prepareAndDraw = encoder => {
    publicAPI.prepareToDraw(encoder);
    encoder.setPipeline(model.pipeline);
    publicAPI.draw(encoder);
  };

  // do the rest of the calls required to draw this mapper
  // at this point the command encouder and pipeline are
  // created and bound
  publicAPI.draw = renderEncoder => {
    const pipeline = renderEncoder.getBoundPipeline();

    // bind the mapper bind group
    renderEncoder.activateBindGroup(model.bindGroup);
    if (model.WebGPURenderer) {
      model.WebGPURenderer.bindUBO(renderEncoder);
    }

    // bind the vertex input
    pipeline.bindVertexInput(renderEncoder, model.vertexInput);
    const indexBuffer = model.vertexInput.getIndexBuffer();
    if (indexBuffer) {
      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
    } else {
      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
    }
  };
  publicAPI.getBindables = () => {
    const bindables = [...model.additionalBindables];
    if (model.UBO) {
      bindables.push(model.UBO);
    }
    if (model.SSBO) {
      bindables.push(model.SSBO);
    }

    // add texture BindGroupLayouts
    for (let t = 0; t < model.textureViews.length; t++) {
      bindables.push(model.textureViews[t]);
      const samp = model.textureViews[t].getSampler();
      if (samp) {
        bindables.push(samp);
      }
    }
    return bindables;
  };
  publicAPI.updatePipeline = () => {
    publicAPI.computePipelineHash();
    model.pipeline = model.device.getPipeline(model.pipelineHash);

    // build the pipeline if needed
    if (!model.pipeline) {
      model.pipeline = vtkWebGPUPipeline$1.newInstance();
      model.pipeline.setDevice(model.device);
      if (model.WebGPURenderer) {
        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
      }
      model.pipeline.addBindGroupLayout(model.bindGroup);
      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
      model.pipeline.setTopology(model.topology);
      model.pipeline.setRenderEncoder(model.renderEncoder);
      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
      model.device.createPipeline(model.pipelineHash, model.pipeline);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const SimpleMapper_DEFAULT_VALUES = {
  additionalBindables: undefined,
  bindGroup: null,
  device: null,
  fragmentShaderTemplate: null,
  numberOfInstances: 1,
  numberOfVertices: 0,
  pipelineHash: null,
  shaderReplacements: null,
  SSBO: null,
  textureViews: null,
  topology: 'triangle-list',
  UBO: null,
  vertexShaderTemplate: null,
  WebGPURenderer: null
};

// ----------------------------------------------------------------------------

function SimpleMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, SimpleMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.textureViews = [];
  model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
  model.bindGroup = BindGroup/* default.newInstance */.Ay.newInstance({
    label: 'mapperBG'
  });
  model.additionalBindables = [];
  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
  model.shaderReplacements = new Map();

  // Build VTK API
  macros2.m.get(publicAPI, model, ['pipeline', 'vertexInput']);
  macros2.m.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']);

  // Object methods
  vtkWebGPUSimpleMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const SimpleMapper_newInstance = macros2.m.newInstance(SimpleMapper_extend, 'vtkWebGPUSimpleMapper');

// ----------------------------------------------------------------------------

var vtkWebGPUSimpleMapper$1 = {
  newInstance: SimpleMapper_newInstance,
  extend: SimpleMapper_extend
};




/***/ }),

/***/ 57372:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkWebGPUTypes)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkWebGPUDevice static functions
//
// WebGPU uses types in a many places and calls, and often those types
// need to be associated with byte sizes, alignments, native arrays etc.
// The folowing methods are designed to help vtk.js introspect those types.
// WebGPU currently tends to use multiple type formats:
//  - buffer types such as float32x4
//  - shader types suchs as vec4<f32>
//  - texture types such as rgba32float
// ----------------------------------------------------------------------------

// see https://gpuweb.github.io/gpuweb/#texture-formats
// for possible formats, there are a lot of them
const textureDetails = {
  // 8-bit formats
  r8unorm: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'float'
  },
  r8snorm: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'float'
  },
  r8uint: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'uint'
  },
  r8sint: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'sint'
  },
  // 16-bit formats
  r16uint: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: 'uint'
  },
  r16sint: {
    numComponents: 1,
    nativeType: Int16Array,
    stride: 2,
    elementSize: 2,
    sampleType: 'sint'
  },
  r16float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 2,
    elementSize: 2,
    sampleType: 'float'
  },
  rg8unorm: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: 'float'
  },
  rg8snorm: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: 'float'
  },
  rg8uint: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: 'uint'
  },
  rg8sint: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: 'sint'
  },
  // 32-bit formats
  r32uint: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 4,
    sampleType: 'uint'
  },
  r32sint: {
    numComponents: 1,
    nativeType: Int32Array,
    stride: 4,
    elementSize: 4,
    sampleType: 'sint'
  },
  r32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: 'unfilterable-float'
  },
  rg16uint: {
    numComponents: 2,
    nativeType: Uint16Array,
    stride: 4,
    elementSize: 2,
    sampleType: 'uint'
  },
  rg16sint: {
    numComponents: 2,
    nativeType: Int16Array,
    stride: 4,
    elementSize: 2,
    sampleType: 'sint'
  },
  rg16float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 2,
    sampleType: 'float'
  },
  rgba8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  'rgba8unorm-srgb': {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  rgba8snorm: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  rgba8uint: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'uint'
  },
  rgba8sint: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'sint'
  },
  bgra8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  'bgra8unorm-srgb': {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  // Packed 32-bit formats
  rgb9e5ufloat: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: 'float'
  },
  rgb10a2unorm: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: 'float'
  },
  rg11b10ufloat: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 4,
    sampleType: 'float'
  },
  // 64-bit formats
  rg32uint: {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 8,
    elementSize: 4,
    sampleType: 'uint'
  },
  rg32sint: {
    numComponents: 2,
    nativeType: Int32Array,
    stride: 8,
    elementSize: 4,
    sampleType: 'sint'
  },
  rg32float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 4,
    sampleType: 'unfilterable-float'
  },
  rgba16uint: {
    numComponents: 4,
    nativeType: Uint16Array,
    stride: 8,
    elementSize: 2,
    sampleType: 'uint'
  },
  rgba16sint: {
    numComponents: 4,
    nativeType: Int16Array,
    stride: 8,
    elementSize: 2,
    sampleType: 'sint'
  },
  rgba16float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 2,
    sampleType: 'float'
  },
  // 128-bit formats
  rgba32uint: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 16,
    elementSize: 4,
    sampleType: 'uint'
  },
  rgba32sint: {
    numComponents: 4,
    nativeType: Int32Array,
    stride: 16,
    elementSize: 4,
    sampleType: 'sint'
  },
  rgba32float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 16,
    elementSize: 4,
    sampleType: 'unfilterable-float'
  },
  // Depth and stencil formats
  stencil8: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'uint'
  },
  depth16unorm: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: 'depth'
  },
  depth24plus: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 3,
    sampleType: 'depth'
  },
  'depth24plus-stencil8': {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: 'mixed'
  },
  depth32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: 'depth'
  }
};
function getDetailsFromTextureFormat(format) {
  if (!format || format.length < 6) return 0;
  if (format in textureDetails === true) {
    return textureDetails[format];
  }
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
  return null;
}

// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
// for possible formats
function getByteStrideFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;

  // options are x2, x3, x4 or nothing
  let numComp = 1;
  if (format[format.length - 2] === 'x') {
    numComp = Number(format[format.length - 1]);
  }
  const sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;
  // options are 8, 16, 32 resulting in 8, 6, 2 as the last char
  // plugged into the formula below gives 1, 2, 4 respectively
  const num = Number(format[sizeStart]);
  if (Number.isNaN(num)) {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
    return 0;
  }
  const typeSize = 5 - num / 2;
  return numComp * typeSize;
}

// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
// for possible formats
function getNumberOfComponentsFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;

  // options are x2, x3, x4 or nothing
  let numComp = 1;
  if (format[format.length - 2] === 'x') {
    numComp = Number(format[format.length - 1]);
  }
  return numComp;
}

// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
// for possible formats
function getNativeTypeFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;

  // raw types are Uint Int or Float as follows
  let result;
  if (format[0] === 'f') {
    result = 'Float';
  } else if (format[0] === 's') {
    result = 'Int';
  } else if (format[0] === 'u') {
    result = 'Uint';
  } else {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
    return undefined;
  }

  // options are 8, 16, 32 resulting in 8, 6, 2 as the last char
  // plugged into the formula below gives 1, 2, 4 respectively
  const base = format.split('x')[0];
  const num = Number(base[base.length - 1]);
  if (Number.isNaN(num)) {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
    return undefined;
  }
  result += 8 * (5 - num / 2);
  result += 'Array';
  return result;
}
function getShaderTypeFromBufferFormat(format) {
  let dataType;
  if (format[0] === 'f' || format[1] === 'n') {
    dataType = 'f32';
  } else if (format[0] === 's' && format[1] === 'i') {
    dataType = 'i32';
  } else if (format[0] === 'u' && format[1] === 'i') {
    dataType = 'u32';
  } else {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
    return undefined;
  }

  // options are x2, x3, x4 or nothing
  let numComp = 1;
  if (format[format.length - 2] === 'x') {
    numComp = Number(format[format.length - 1]);
  }
  if (numComp === 4) return `vec4<${dataType}>`;
  if (numComp === 3) return `vec3<${dataType}>`;
  if (numComp === 2) return `vec2<${dataType}>`;
  return dataType;
}
function getByteStrideFromShaderFormat(format) {
  if (!format) return 0;
  let numComp = 1;
  if (format.substring(0, 3) === 'vec') {
    numComp = Number(format[3]);
  } else if (format.substring(0, 3) === 'mat') {
    numComp = format[3] * format[5];
  }
  const typeSize = 4;
  return numComp * typeSize;
}
function getNativeTypeFromShaderFormat(format) {
  if (!format) return undefined;
  if (format.includes('f32')) return 'Float32Array';
  if (format.includes('i32')) return 'Int32Array';
  if (format.includes('u32')) return 'Uint32Array';
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
  return undefined;
}
var vtkWebGPUTypes = {
  getDetailsFromTextureFormat,
  getByteStrideFromBufferFormat,
  getNumberOfComponentsFromBufferFormat,
  getNativeTypeFromBufferFormat,
  getShaderTypeFromBufferFormat,
  getByteStrideFromShaderFormat,
  getNativeTypeFromShaderFormat
};




/***/ }),

/***/ 83259:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkWebGPUUniformBuffer$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _BufferManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49767);
/* harmony import */ var _Types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57372);




const {
  BufferUsage
} = _BufferManager_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay;
const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// vtkWebGPUUniformBuffer methods
// ----------------------------------------------------------------------------

function vtkWebGPUUniformBuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUUniformBuffer');
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro(`entry named ${name} already exists`);
      return;
    }
    model.sortDirty = true;
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes: _Types_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.getByteStrideFromShaderFormat(type),
      offset: -1,
      nativeType: _Types_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.getNativeTypeFromShaderFormat(type),
      packed: false
    });
  };

  // UBOs have layout rules in terms of how memory is aligned so we
  // have to be careful how we order the entries. For example a vec4<f32>
  // must be aligned on a 16 byte offset, etc. See
  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts
  // for more details. Right now you can create a situation that would fail
  // in the future we could add dummy spacer entries where needed to
  // handle alignment issues
  publicAPI.sortBufferEntries = () => {
    if (!model.sortDirty) {
      return;
    }
    let currOffset = 0;
    const newEntries = [];

    // compute the max alignment, this is required as WebGPU defines a UBO to have
    // a size that is a multiple of the maxAlignment
    let maxAlignment = 4;
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.sizeInBytes % 16 === 0) {
        maxAlignment = Math.max(16, maxAlignment);
      }
      if (entry.sizeInBytes % 8 === 0) {
        maxAlignment = Math.max(8, maxAlignment);
      }
    }

    // pack anything whose size is a multiple of 16 bytes first
    // this includes a couple types that don't require 16 byte alignment
    // such as mat2x2<f32> but that is OK
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }

    // now it gets tough, we have the following common types (f32, i32, u32)
    // - vec2<f32> 8 byte size, 8 byte alignment
    // - vec3<f32> 12 byte size, 16 byte alignment
    // - f32 4 byte size, 4 byte alignment

    // try adding 12 byte, 4 byte pairs
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.packed === false && entry.sizeInBytes === 12) {
        for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (entry2.packed === false && entry2.sizeInBytes === 4) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }

    // try adding 8 byte, 8 byte pairs
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }

    // try adding 8 byte, 4 byte 4 byte triplets
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        let found = false;
        for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (!entry2.packed && entry2.sizeInBytes === 4) {
            for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {
              const entry3 = model.bufferEntries[i3];
              if (!entry3.packed && entry3.sizeInBytes === 4) {
                entry.packed = true;
                entry.offset = currOffset;
                newEntries.push(entry);
                currOffset += entry.sizeInBytes;
                entry2.packed = true;
                entry2.offset = currOffset;
                newEntries.push(entry2);
                currOffset += entry2.sizeInBytes;
                entry3.packed = true;
                entry3.offset = currOffset;
                newEntries.push(entry3);
                currOffset += entry3.sizeInBytes;
                found = true;
                break;
              }
            }
          }
        }
      }
    }

    // Add anything remaining that is larger than 4 bytes and hope we get lucky.
    // Likely if there is more than one item added here it will result
    // in a failed UBO
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes > 4) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }

    // finally add remaining 4 byte items
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }

    // update entries and entryNames
    model.bufferEntries = newEntries;
    model._bufferEntryNames.clear();
    for (let i = 0; i < model.bufferEntries.length; i++) {
      model._bufferEntryNames.set(model.bufferEntries[i].name, i);
    }
    model.sizeInBytes = currOffset;
    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
    model.sortDirty = false;
  };
  publicAPI.sendIfNeeded = device => {
    if (!model.UBO) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage.UniformArray,
        label: model.label
      };
      model.UBO = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model.sendDirty = false;
    }

    // send data down if needed
    if (model.sendDirty) {
      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
      model.sendDirty = false;
    }

    // always updated as mappers depend on this time
    // it is more of a sentIfNeededTime
    model.sendTime.modified();
  };
  publicAPI.createView = type => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
      }
      model[type] = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, val) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    if (entry.lastValue !== val) {
      view[entry.offset / view.BYTES_PER_ELEMENT] = val;
      model.sendDirty = true;
    }
    entry.lastValue = val;
  };
  publicAPI.setArray = (name, arr) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    let changed = false;
    for (let i = 0; i < arr.length; i++) {
      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
        changed = true;
      }
    }
    if (changed) {
      model.sendDirty = true;
      entry.lastValue = [...arr];
    }
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model.UBO.getHandle()
      }
    };
    return foo;
  };
  publicAPI.getSendTime = () => model.sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group) => {
    // sort the entries
    publicAPI.sortBufferEntries();
    const lines = [`struct ${model.label}Struct\n{`];
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`};\n@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);
    return lines.join('\n');
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  bindGroupLayoutEntry: null,
  bindGroupEntry: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Internal objects
  model._bufferEntryNames = new Map();
  model.bufferEntries = [];

  // default UBO desc
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: 'uniform'
    }
  };
  model.sendTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.sendDirty = true;
  model.sortDirty = true;
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['binding', 'bindGroupTime']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']);

  // Object methods
  vtkWebGPUUniformBuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkWebGPUUniformBuffer');

// ----------------------------------------------------------------------------

var vtkWebGPUUniformBuffer$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 50440:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c9: () => (/* binding */ registerOverride)
/* harmony export */ });
/* unused harmony exports default, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84784);



const CLASS_MAPPING = Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}

// ----------------------------------------------------------------------------
// vtkWebGPUViewNodeFactory methods
// ----------------------------------------------------------------------------

function vtkWebGPUViewNodeFactory(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUViewNodeFactory');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Static class mapping shared across instances
  model.overrides = CLASS_MAPPING;

  // Inheritance
  _SceneGraph_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkWebGPUViewNodeFactory(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkWebGPUViewNodeFactory');

// ----------------------------------------------------------------------------

var vtkWebGPUViewNodeFactory$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 37290:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* reexport safe */ _macros2_js__WEBPACK_IMPORTED_MODULE_3__.m)
/* harmony export */ });
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45043);
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vtk_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42852);
/* harmony import */ var _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44302);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28906);






/***/ }),

/***/ 28906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ newTypedArray),
/* harmony export */   b: () => (/* binding */ newTypedArrayFrom),
/* harmony export */   c: () => (/* binding */ macro$1),
/* harmony export */   d: () => (/* binding */ algo),
/* harmony export */   e: () => (/* binding */ setGet),
/* harmony export */   g: () => (/* binding */ get),
/* harmony export */   h: () => (/* binding */ chain),
/* harmony export */   i: () => (/* binding */ moveToProtected),
/* harmony export */   k: () => (/* binding */ getArray),
/* harmony export */   l: () => (/* binding */ setGetArray),
/* harmony export */   m: () => (/* binding */ macro),
/* harmony export */   n: () => (/* binding */ newInstance),
/* harmony export */   o: () => (/* binding */ obj),
/* harmony export */   r: () => (/* binding */ vtkErrorMacro),
/* harmony export */   s: () => (/* binding */ set)
/* harmony export */ });
/* unused harmony exports A, B, C, D, E, F, G, H, I, J, K, L, M, T, V, _, f, j, p, q, t, u, v, w, x, y, z */
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45043);
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vtk_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42852);
/* harmony import */ var _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44302);




/**
 * macros.js is the old macro.js.
 * The name change is so we do not get eaten by babel-plugin-macros.
 */
let globalMTime = 0;
const VOID = Symbol('void');
function getCurrentGlobalMTime() {
  return globalMTime;
}

// ----------------------------------------------------------------------------
// Logging function calls
// ----------------------------------------------------------------------------
/* eslint-disable no-prototype-builtins                                      */

const fakeConsole = {};
function noOp() {}
const consoleMethods = ['log', 'debug', 'info', 'warn', 'error', 'time', 'timeEnd', 'group', 'groupEnd'];
consoleMethods.forEach(methodName => {
  fakeConsole[methodName] = noOp;
});
_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console = console.hasOwnProperty('log') ? console : fakeConsole;
const loggerFunctions = {
  debug: noOp,
  // Don't print debug by default
  error: _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console.error || noOp,
  info: _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console.info || noOp,
  log: _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console.log || noOp,
  warn: _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console.warn || noOp
};
function setLoggerFunction(name, fn) {
  if (loggerFunctions[name]) {
    loggerFunctions[name] = fn || noOp;
  }
}
function vtkLogMacro() {
  loggerFunctions.log(...arguments);
}
function vtkInfoMacro() {
  loggerFunctions.info(...arguments);
}
function vtkDebugMacro() {
  loggerFunctions.debug(...arguments);
}
function vtkErrorMacro() {
  loggerFunctions.error(...arguments);
}
function vtkWarningMacro() {
  loggerFunctions.warn(...arguments);
}
const ERROR_ONCE_MAP = {};
function vtkOnceErrorMacro(str) {
  if (!ERROR_ONCE_MAP[str]) {
    loggerFunctions.error(str);
    ERROR_ONCE_MAP[str] = true;
  }
}

// ----------------------------------------------------------------------------
// TypedArray
// ----------------------------------------------------------------------------

const TYPED_ARRAYS = Object.create(null);
TYPED_ARRAYS.Float32Array = Float32Array;
TYPED_ARRAYS.Float64Array = Float64Array;
TYPED_ARRAYS.Uint8Array = Uint8Array;
TYPED_ARRAYS.Int8Array = Int8Array;
TYPED_ARRAYS.Uint16Array = Uint16Array;
TYPED_ARRAYS.Int16Array = Int16Array;
TYPED_ARRAYS.Uint32Array = Uint32Array;
TYPED_ARRAYS.Int32Array = Int32Array;
TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;
try {
  TYPED_ARRAYS.BigInt64Array = BigInt64Array;
  TYPED_ARRAYS.BigUint64Array = BigUint64Array;
} catch {
  // ignore
}
function newTypedArray(type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return new (TYPED_ARRAYS[type] || Float64Array)(...args);
}
function newTypedArrayFrom(type) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return (TYPED_ARRAYS[type] || Float64Array).from(...args);
}

// ----------------------------------------------------------------------------
// capitilize provided string
// ----------------------------------------------------------------------------

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function _capitalize(str) {
  return capitalize(str[0] === '_' ? str.slice(1) : str);
}
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

// ----------------------------------------------------------------------------
// Convert byte size into a well formatted string
// ----------------------------------------------------------------------------

function formatBytesToProperUnit(size) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  let chunkSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
  const units = ['TB', 'GB', 'MB', 'KB'];
  let value = Number(size);
  let currentUnit = 'B';
  while (value > chunkSize) {
    value /= chunkSize;
    currentUnit = units.pop();
  }
  return `${value.toFixed(precision)} ${currentUnit}`;
}

// ----------------------------------------------------------------------------
// Convert thousand number with proper separator
// ----------------------------------------------------------------------------

function formatNumbersWithThousandSeparator(n) {
  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
  const sections = [];
  let size = n;
  while (size > 1000) {
    sections.push(`000${size % 1000}`.slice(-3));
    size = Math.floor(size / 1000);
  }
  if (size > 0) {
    sections.push(size);
  }
  sections.reverse();
  return sections.join(separator);
}

// ----------------------------------------------------------------------------
// Array helper
// ----------------------------------------------------------------------------

function safeArrays(model) {
  Object.keys(model).forEach(key => {
    if (Array.isArray(model[key])) {
      model[key] = [].concat(model[key]);
    }
  });
}
function isTypedArray(value) {
  return Object.values(TYPED_ARRAYS).some(ctor => value instanceof ctor);
}

// ----------------------------------------------------------------------------
// shallow equals
// ----------------------------------------------------------------------------

function shallowEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// ----------------------------------------------------------------------------

function enumToString(e, value) {
  return Object.keys(e).find(key => e[key] === value);
}
function getStateArrayMapFunc(item) {
  if (item && item.isA) {
    return item.getState();
  }
  return item;
}

// ----------------------------------------------------------------------------
// setImmediate
// ----------------------------------------------------------------------------

function setImmediateVTK(fn) {
  setTimeout(fn, 0);
}

// ----------------------------------------------------------------------------
// measurePromiseExecution
//
// Measures the time it takes for a promise to finish from
//   the time this function is invoked.
// The callback receives the time it took for the promise to resolve or reject.
// ----------------------------------------------------------------------------

function measurePromiseExecution(promise, callback) {
  const start = performance.now();
  promise.finally(() => {
    const delta = performance.now() - start;
    callback(delta);
  });
}

// ----------------------------------------------------------------------------
// vtkObject: modified(), onModified(callback), delete()
// ----------------------------------------------------------------------------

function obj() {
  let publicAPI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // Ensure each instance as a unique ref of array
  safeArrays(model);
  const callbacks = [];
  if (!Number.isInteger(model.mtime)) {
    model.mtime = ++globalMTime;
  }
  if (!('classHierarchy' in model)) {
    model.classHierarchy = new _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A('vtkObject');
  } else if (!(model.classHierarchy instanceof _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)) {
    const hierarchy = new _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A();
    for (let i = 0; i < model.classHierarchy.length; i++) {
      hierarchy.push(model.classHierarchy[i]);
    }
    model.classHierarchy = hierarchy;
  }
  function off(index) {
    callbacks[index] = null;
  }
  function on(index) {
    function unsubscribe() {
      off(index);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  publicAPI.isDeleted = () => !!model.deleted;
  publicAPI.modified = otherMTime => {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (otherMTime && otherMTime < publicAPI.getMTime()) {
      return;
    }
    model.mtime = ++globalMTime;
    callbacks.forEach(callback => callback && callback(publicAPI));
  };
  publicAPI.onModified = callback => {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }
    const index = callbacks.length;
    callbacks.push(callback);
    return on(index);
  };
  publicAPI.getMTime = () => model.mtime;
  publicAPI.isA = className => {
    let count = model.classHierarchy.length;
    // we go backwards as that is more likely for
    // early termination
    while (count--) {
      if (model.classHierarchy[count] === className) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getClassName = function () {
    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.classHierarchy[model.classHierarchy.length - 1 - depth];
  };
  publicAPI.set = function () {
    let map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let noWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let noFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let ret = false;
    Object.keys(map).forEach(name => {
      const fn = noFunction ? null : publicAPI[`set${capitalize(name)}`];
      if (fn && Array.isArray(map[name]) && fn.length > 1) {
        ret = fn(...map[name]) || ret;
      } else if (fn) {
        ret = fn(map[name]) || ret;
      } else {
        // Set data on model directly
        if (['mtime'].indexOf(name) === -1 && !noWarning) {
          vtkWarningMacro(`Warning: Set value to model directly ${name}, ${map[name]}`);
        }
        ret = model[name] !== map[name] || ret;
        model[name] = map[name];
      }
    });
    return ret;
  };
  publicAPI.get = function () {
    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      list[_key3] = arguments[_key3];
    }
    if (!list.length) {
      return model;
    }
    const subset = {};
    list.forEach(name => {
      subset[name] = model[name];
    });
    return subset;
  };
  publicAPI.getReferenceByName = val => model[val];
  publicAPI.delete = () => {
    Object.keys(model).forEach(field => delete model[field]);
    callbacks.forEach((el, index) => off(index));

    // Flag the instance being deleted
    model.deleted = true;
  };

  // Add serialization support
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = {
      ...model,
      vtkClass: publicAPI.getClassName()
    };

    // Convert every vtkObject to its serializable form
    Object.keys(jsonArchive).forEach(keyName => {
      if (jsonArchive[keyName] === null || jsonArchive[keyName] === undefined || keyName[0] === '_' // protected members start with _
      ) {
        delete jsonArchive[keyName];
      } else if (jsonArchive[keyName].isA) {
        jsonArchive[keyName] = jsonArchive[keyName].getState();
      } else if (Array.isArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
      } else if (isTypedArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = Array.from(jsonArchive[keyName]);
      }
    });

    // Sort resulting object by key name
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(name => {
      sortedObj[name] = jsonArchive[name];
    });

    // Remove mtime
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };

  // Add shallowCopy(otherInstance) support
  publicAPI.shallowCopy = function (other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (other.getClassName() !== publicAPI.getClassName()) {
      throw new Error(`Cannot ShallowCopy ${other.getClassName()} into ${publicAPI.getClassName()}`);
    }
    const otherModel = other.get();
    const keyList = Object.keys(model).sort();
    const otherKeyList = Object.keys(otherModel).sort();
    otherKeyList.forEach(key => {
      const keyIdx = keyList.indexOf(key);
      if (keyIdx === -1) {
        if (debug) {
          vtkDebugMacro(`add ${key} in shallowCopy`);
        }
      } else {
        keyList.splice(keyIdx, 1);
      }
      model[key] = otherModel[key];
    });
    if (keyList.length && debug) {
      vtkDebugMacro(`Untouched keys: ${keyList.join(', ')}`);
    }
    publicAPI.modified();
  };

  // This function will get called when one invoke JSON.stringify(vtkObject)
  // JSON.stringify will only stringify the return value of this function
  publicAPI.toJSON = function vtkObjToJSON() {
    return publicAPI.getState();
  };

  // Allow usage as decorator
  return publicAPI;
}

// ----------------------------------------------------------------------------
// getXXX: add getters
// ----------------------------------------------------------------------------

const objectGetterMap = {
  object(publicAPI, model, field) {
    return function getter() {
      return {
        ...model[field.name]
      };
    };
  }
};
function get(publicAPI, model, fieldNames) {
  fieldNames.forEach(field => {
    if (typeof field === 'object') {
      const getter = objectGetterMap[field.type];
      if (getter) {
        publicAPI[`get${_capitalize(field.name)}`] = getter(publicAPI, model, field);
      } else {
        publicAPI[`get${_capitalize(field.name)}`] = () => model[field.name];
      }
    } else {
      publicAPI[`get${_capitalize(field)}`] = () => model[field];
    }
  });
}

// ----------------------------------------------------------------------------
// setXXX: add setters
// ----------------------------------------------------------------------------

const objectSetterMap = {
  enum(publicAPI, model, field) {
    const onChanged = `_on${_capitalize(field.name)}Changed`;
    return value => {
      if (typeof value === 'string') {
        if (field.enum[value] !== undefined) {
          if (model[field.name] !== field.enum[value]) {
            model[field.name] = field.enum[value];
            publicAPI.modified();
            return true;
          }
          return false;
        }
        vtkErrorMacro(`Set Enum with invalid argument ${field}, ${value}`);
        throw new RangeError('Set Enum with invalid string argument');
      }
      if (typeof value === 'number') {
        if (model[field.name] !== value) {
          if (Object.keys(field.enum).map(key => field.enum[key]).indexOf(value) !== -1) {
            const previousValue = model[field.name];
            model[field.name] = value;
            model[onChanged]?.(publicAPI, model, value, previousValue);
            publicAPI.modified();
            return true;
          }
          vtkErrorMacro(`Set Enum outside numeric range ${field}, ${value}`);
          throw new RangeError('Set Enum outside numeric range');
        }
        return false;
      }
      vtkErrorMacro(`Set Enum with invalid argument (String/Number) ${field}, ${value}`);
      throw new TypeError('Set Enum with invalid argument (String/Number)');
    };
  },
  object(publicAPI, model, field) {
    if (field.params?.length === 1) {
      vtkWarningMacro('Setter of type "object" with a single "param" field is not supported');
    }
    const onChanged = `_on${_capitalize(field.name)}Changed`;
    return function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      let value;
      if (args.length > 1 && field.params?.length) {
        value = field.params.reduce((acc, prop, idx) => Object.assign(acc, {
          [prop]: args[idx]
        }), {});
      } else {
        value = args[0];
      }
      if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_0___default()(model[field.name], value)) {
        const previousValue = model[field.name];
        model[field.name] = value;
        model[onChanged]?.(publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }
      return false;
    };
  }
};
function findSetter(field) {
  if (typeof field === 'object') {
    const fn = objectSetterMap[field.type];
    if (fn) {
      return (publicAPI, model) => fn(publicAPI, model, field);
    }
    vtkErrorMacro(`No setter for field ${field}`);
    throw new TypeError('No setter for field');
  }
  return function getSetter(publicAPI, model) {
    const onChanged = `_on${_capitalize(field)}Changed`;
    return function setter(value) {
      if (model.deleted) {
        vtkErrorMacro('instance deleted - cannot call any method');
        return false;
      }
      if (model[field] !== value) {
        const previousValue = model[field.name];
        model[field] = value;
        model[onChanged]?.(publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }
      return false;
    };
  };
}
function set(publicAPI, model, fields) {
  fields.forEach(field => {
    if (typeof field === 'object') {
      publicAPI[`set${_capitalize(field.name)}`] = findSetter(field)(publicAPI, model);
    } else {
      publicAPI[`set${_capitalize(field)}`] = findSetter(field)(publicAPI, model);
    }
  });
}

// ----------------------------------------------------------------------------
// set/get XXX: add both setters and getters
// ----------------------------------------------------------------------------

function setGet(publicAPI, model, fieldNames) {
  get(publicAPI, model, fieldNames);
  set(publicAPI, model, fieldNames);
}

// ----------------------------------------------------------------------------
// getXXX: add getters for object of type array with copy to be safe
// getXXXByReference: add getters for object of type array without copy
// ----------------------------------------------------------------------------

function getArray(publicAPI, model, fieldNames) {
  fieldNames.forEach(field => {
    publicAPI[`get${_capitalize(field)}`] = () => model[field] ? Array.from(model[field]) : model[field];
    publicAPI[`get${_capitalize(field)}ByReference`] = () => model[field];
  });
}

// ----------------------------------------------------------------------------
// setXXX: add setter for object of type array
// if 'defaultVal' is supplied, shorter arrays will be padded to 'size' with 'defaultVal'
// set...From: fast path to copy the content of an array to the current one without call to modified.
// ----------------------------------------------------------------------------

function setArray(publicAPI, model, fieldNames, size) {
  let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  fieldNames.forEach(field => {
    if (model[field] && size && model[field].length !== size) {
      throw new RangeError(`Invalid initial number of values for array (${field})`);
    }
    const onChanged = `_on${_capitalize(field)}Changed`;
    publicAPI[`set${_capitalize(field)}`] = function () {
      if (model.deleted) {
        vtkErrorMacro('instance deleted - cannot call any method');
        return false;
      }
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      let array = args;
      let changeDetected;
      let needCopy = false;
      // allow null or an array to be passed as a single arg.
      if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
        /* eslint-disable prefer-destructuring */
        array = array[0];
        /* eslint-enable prefer-destructuring */
        needCopy = true;
      }
      if (array == null) {
        changeDetected = model[field] !== array;
      } else {
        if (size && array.length !== size) {
          if (array.length < size && defaultVal !== undefined) {
            array = Array.from(array);
            needCopy = false;
            while (array.length < size) array.push(defaultVal);
          } else {
            throw new RangeError(`Invalid number of values for array setter (${field})`);
          }
        }
        changeDetected = model[field] == null || model[field].length !== array.length;
        for (let i = 0; !changeDetected && i < array.length; ++i) {
          changeDetected = model[field][i] !== array[i];
        }
        if (changeDetected && needCopy) {
          array = Array.from(array);
        }
      }
      if (changeDetected) {
        const previousValue = model[field.name];
        model[field] = array;
        model[onChanged]?.(publicAPI, model, array, previousValue);
        publicAPI.modified();
      }
      return changeDetected;
    };
    publicAPI[`set${_capitalize(field)}From`] = otherArray => {
      const target = model[field];
      otherArray.forEach((v, i) => {
        target[i] = v;
      });
    };
  });
}

// ----------------------------------------------------------------------------
// set/get XXX: add setter and getter for object of type array
// ----------------------------------------------------------------------------

function setGetArray(publicAPI, model, fieldNames, size) {
  let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  getArray(publicAPI, model, fieldNames);
  setArray(publicAPI, model, fieldNames, size, defaultVal);
}
function moveToProtected(publicAPI, model, fieldNames) {
  for (let i = 0; i < fieldNames.length; i++) {
    const fieldName = fieldNames[i];
    if (model[fieldName] !== undefined) {
      model[`_${fieldName}`] = model[fieldName];
      delete model[fieldName];
    }
  }
}
// ----------------------------------------------------------------------------
// vtkAlgorithm: setInputData(), setInputConnection(), getOutputData(), getOutputPort()
// ----------------------------------------------------------------------------

function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
  if (model.inputData) {
    model.inputData = model.inputData.map(_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
  } else {
    model.inputData = [];
  }
  if (model.inputConnection) {
    model.inputConnection = model.inputConnection.map(_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
  } else {
    model.inputConnection = [];
  }
  if (model.output) {
    model.output = model.output.map(_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
  } else {
    model.output = [];
  }
  if (model.inputArrayToProcess) {
    model.inputArrayToProcess = model.inputArrayToProcess.map(_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
  } else {
    model.inputArrayToProcess = [];
  }

  // Cache the argument for later manipulation
  model.numberOfInputs = numberOfInputs;

  // Methods
  function setInputData(dataset) {
    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (port >= model.numberOfInputs) {
      vtkErrorMacro(`algorithm ${publicAPI.getClassName()} only has ${model.numberOfInputs} input ports. To add more input ports, use addInputData()`);
      return;
    }
    if (model.inputData[port] !== dataset || model.inputConnection[port]) {
      model.inputData[port] = dataset;
      model.inputConnection[port] = null;
      if (publicAPI.modified) {
        publicAPI.modified();
      }
    }
  }
  function getInputData() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.inputConnection[port]) {
      model.inputData[port] = model.inputConnection[port]();
    }
    return model.inputData[port];
  }
  function setInputConnection(outputPort) {
    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (port >= model.numberOfInputs) {
      let msg = `algorithm ${publicAPI.getClassName()} only has `;
      msg += `${model.numberOfInputs}`;
      msg += ' input ports. To add more input ports, use addInputConnection()';
      vtkErrorMacro(msg);
      return;
    }
    model.inputData[port] = null;
    model.inputConnection[port] = outputPort;
  }
  function getInputConnection() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.inputConnection[port];
  }
  function getPortToFill() {
    let portToFill = model.numberOfInputs;
    while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
      portToFill--;
    }
    if (portToFill === model.numberOfInputs) {
      model.numberOfInputs++;
    }
    return portToFill;
  }
  function addInputConnection(outputPort) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    setInputConnection(outputPort, getPortToFill());
  }
  function addInputData(dataset) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    setInputData(dataset, getPortToFill());
  }
  function getOutputData() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }
    if (publicAPI.shouldUpdate()) {
      publicAPI.update();
    }
    return model.output[port];
  }
  publicAPI.shouldUpdate = () => {
    const localMTime = publicAPI.getMTime();
    let minOutputMTime = Infinity;
    let count = numberOfOutputs;
    while (count--) {
      if (!model.output[count] || model.output[count].isDeleted()) {
        return true;
      }
      const mt = model.output[count].getMTime();
      if (mt < localMTime) {
        return true;
      }
      if (mt < minOutputMTime) {
        minOutputMTime = mt;
      }
    }
    count = model.numberOfInputs;
    while (count--) {
      if (model.inputConnection[count]?.filter.shouldUpdate() || publicAPI.getInputData(count)?.getMTime() > minOutputMTime) {
        return true;
      }
    }
    return false;
  };
  function getOutputPort() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const outputPortAccess = () => getOutputData(port);
    // Add reference to filter
    outputPortAccess.filter = publicAPI;
    return outputPortAccess;
  }

  // Handle input if needed
  if (model.numberOfInputs) {
    // Reserve inputs
    let count = model.numberOfInputs;
    while (count--) {
      model.inputData.push(null);
      model.inputConnection.push(null);
    }

    // Expose public methods
    publicAPI.setInputData = setInputData;
    publicAPI.setInputConnection = setInputConnection;
    publicAPI.addInputData = addInputData;
    publicAPI.addInputConnection = addInputConnection;
    publicAPI.getInputData = getInputData;
    publicAPI.getInputConnection = getInputConnection;
  }
  if (numberOfOutputs) {
    publicAPI.getOutputData = getOutputData;
    publicAPI.getOutputPort = getOutputPort;
  }
  publicAPI.update = () => {
    const ins = [];
    if (model.numberOfInputs) {
      let count = 0;
      while (count < model.numberOfInputs) {
        ins[count] = publicAPI.getInputData(count);
        count++;
      }
    }
    if (publicAPI.shouldUpdate() && publicAPI.requestData) {
      publicAPI.requestData(ins, model.output);
    }
  };
  publicAPI.getNumberOfInputPorts = () => model.numberOfInputs;
  publicAPI.getNumberOfOutputPorts = () => numberOfOutputs || model.output.length;
  publicAPI.getInputArrayToProcess = inputPort => {
    const arrayDesc = model.inputArrayToProcess[inputPort];
    const ds = model.inputData[inputPort];
    if (arrayDesc && ds) {
      return ds[`get${arrayDesc.fieldAssociation}`]().getArray(arrayDesc.arrayName);
    }
    return null;
  };
  publicAPI.setInputArrayToProcess = function (inputPort, arrayName, fieldAssociation) {
    let attributeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Scalars';
    while (model.inputArrayToProcess.length < inputPort) {
      model.inputArrayToProcess.push(null);
    }
    model.inputArrayToProcess[inputPort] = {
      arrayName,
      fieldAssociation,
      attributeType
    };
  };
}

// ----------------------------------------------------------------------------
// Event handling: onXXX(callback), invokeXXX(args...)
// ----------------------------------------------------------------------------

const EVENT_ABORT = Symbol('Event abort');
function event(publicAPI, model, eventName) {
  const callbacks = [];
  const previousDelete = publicAPI.delete;
  let curCallbackID = 1;
  function off(callbackID) {
    for (let i = 0; i < callbacks.length; ++i) {
      const [cbID] = callbacks[i];
      if (cbID === callbackID) {
        callbacks.splice(i, 1);
        return;
      }
    }
  }
  function on(callbackID) {
    function unsubscribe() {
      off(callbackID);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  function invoke() {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    /* eslint-disable prefer-rest-params */
    // Go through a copy of the callbacks array in case new callbacks
    // get prepended within previous callbacks
    const currentCallbacks = callbacks.slice();
    for (let index = 0; index < currentCallbacks.length; ++index) {
      const [, cb, priority] = currentCallbacks[index];
      if (!cb) {
        continue; // eslint-disable-line
      }

      if (priority < 0) {
        setTimeout(() => cb.apply(publicAPI, arguments), 1 - priority);
      } else {
        // Abort only if the callback explicitly returns false
        const continueNext = cb.apply(publicAPI, arguments);
        if (continueNext === EVENT_ABORT) {
          break;
        }
      }
    }
    /* eslint-enable prefer-rest-params */
  }

  publicAPI[`invoke${_capitalize(eventName)}`] = invoke;
  publicAPI[`on${_capitalize(eventName)}`] = function (callback) {
    let priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
    if (!callback.apply) {
      console.error(`Invalid callback for event ${eventName}`);
      return null;
    }
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }
    const callbackID = curCallbackID++;
    callbacks.push([callbackID, callback, priority]);
    callbacks.sort((cb1, cb2) => cb2[2] - cb1[2]);
    return on(callbackID);
  };
  publicAPI.delete = () => {
    previousDelete();
    callbacks.forEach(_ref => {
      let [cbID] = _ref;
      return off(cbID);
    });
  };
}

// ----------------------------------------------------------------------------
// newInstance
// ----------------------------------------------------------------------------

function newInstance(extend, className) {
  const constructor = function () {
    let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const model = {};
    const publicAPI = {};
    extend(publicAPI, model, initialValues);
    return Object.freeze(publicAPI);
  };

  // Register constructor to factory
  if (className) {
    _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.register(className, constructor);
  }
  return constructor;
}

// ----------------------------------------------------------------------------
// Chain function calls
// ----------------------------------------------------------------------------

function chain() {
  for (var _len6 = arguments.length, fn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    fn[_key6] = arguments[_key6];
  }
  return function () {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return fn.filter(i => !!i).map(i => i(...args));
  };
}

// ----------------------------------------------------------------------------
// Some utility methods for vtk objects
// ----------------------------------------------------------------------------

function isVtkObject(instance) {
  return instance && instance.isA && instance.isA('vtkObject');
}
function traverseInstanceTree(instance, extractFunction) {
  let accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  let visitedInstances = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  if (isVtkObject(instance)) {
    if (visitedInstances.indexOf(instance) >= 0) {
      // avoid cycles
      return accumulator;
    }
    visitedInstances.push(instance);
    const result = extractFunction(instance);
    if (result !== undefined) {
      accumulator.push(result);
    }

    // Now go through this instance's model
    const model = instance.get();
    Object.keys(model).forEach(key => {
      const modelObj = model[key];
      if (Array.isArray(modelObj)) {
        modelObj.forEach(subObj => {
          traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
        });
      } else {
        traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
      }
    });
  }
  return accumulator;
}

// ----------------------------------------------------------------------------
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.

function debounce(func, wait, immediate) {
  var _this = this;
  let timeout;
  const debounced = function () {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    const context = _this;
    const later = () => {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
  debounced.cancel = () => clearTimeout(timeout);
  return debounced;
}

// ----------------------------------------------------------------------------
// Creates a throttled function that only invokes `func` at most once per
// every `wait` milliseconds.

function throttle(callback, delay) {
  let isThrottled = false;
  let argsToUse = null;
  function next() {
    isThrottled = false;
    if (argsToUse !== null) {
      wrapper(...argsToUse); // eslint-disable-line
      argsToUse = null;
    }
  }
  function wrapper() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    if (isThrottled) {
      argsToUse = args;
      return;
    }
    isThrottled = true;
    callback(...args);
    setTimeout(next, delay);
  }
  return wrapper;
}

// ----------------------------------------------------------------------------
// keystore(publicAPI, model, initialKeystore)
//
//    - initialKeystore: Initial keystore. This can be either a Map or an
//      object.
//
// Generated API
//  setKey(key, value) : mixed (returns value)
//  getKey(key) : mixed
//  getAllKeys() : [mixed]
//  deleteKey(key) : Boolean
// ----------------------------------------------------------------------------

function keystore(publicAPI, model) {
  let initialKeystore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  model.keystore = Object.assign(model.keystore || {}, initialKeystore);
  publicAPI.setKey = (key, value) => {
    model.keystore[key] = value;
  };
  publicAPI.getKey = key => model.keystore[key];
  publicAPI.getAllKeys = () => Object.keys(model.keystore);
  publicAPI.deleteKey = key => delete model.keystore[key];
  publicAPI.clearKeystore = () => publicAPI.getAllKeys().forEach(key => delete model.keystore[key]);
}

// ----------------------------------------------------------------------------
// proxy(publicAPI, model, sectionName, propertyUI)
//
//    - sectionName: Name of the section for UI
//    - propertyUI: List of props with their UI description
//
// Generated API
//  getProxyId() : String
//  listProxyProperties() : [string]
//  updateProxyProperty(name, prop)
//  getProxySection() => List of properties for UI generation
// ----------------------------------------------------------------------------
let nextProxyId = 1;
const ROOT_GROUP_NAME = '__root__';
function proxy(publicAPI, model) {
  // Proxies are keystores
  keystore(publicAPI, model);
  const parentDelete = publicAPI.delete;

  // getProxyId
  model.proxyId = `${nextProxyId++}`;

  // ui handling
  model.ui = JSON.parse(JSON.stringify(model.ui || [])); // deep copy
  get(publicAPI, model, ['proxyId', 'proxyGroup', 'proxyName']);
  setGet(publicAPI, model, ['proxyManager']);

  // group properties
  const propertyMap = {};
  const groupChildrenNames = {};
  function registerProperties(descriptionList, currentGroupName) {
    if (!groupChildrenNames[currentGroupName]) {
      groupChildrenNames[currentGroupName] = [];
    }
    const childrenNames = groupChildrenNames[currentGroupName];
    for (let i = 0; i < descriptionList.length; i++) {
      childrenNames.push(descriptionList[i].name);
      propertyMap[descriptionList[i].name] = descriptionList[i];
      if (descriptionList[i].children && descriptionList[i].children.length) {
        registerProperties(descriptionList[i].children, descriptionList[i].name);
      }
    }
  }
  registerProperties(model.ui, ROOT_GROUP_NAME);
  publicAPI.updateUI = ui => {
    model.ui = JSON.parse(JSON.stringify(ui || [])); // deep copy
    Object.keys(propertyMap).forEach(k => delete propertyMap[k]);
    Object.keys(groupChildrenNames).forEach(k => delete groupChildrenNames[k]);
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.modified();
  };
  function listProxyProperties() {
    let gName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
    return groupChildrenNames[gName];
  }
  publicAPI.updateProxyProperty = (propertyName, propUI) => {
    const prop = propertyMap[propertyName];
    if (prop) {
      Object.assign(prop, propUI);
    } else {
      propertyMap[propertyName] = {
        ...propUI
      };
    }
  };
  publicAPI.activate = () => {
    if (model.proxyManager) {
      const setActiveMethod = `setActive${_capitalize(publicAPI.getProxyGroup().slice(0, -1))}`;
      if (model.proxyManager[setActiveMethod]) {
        model.proxyManager[setActiveMethod](publicAPI);
      }
    }
  };

  // property link
  model.propertyLinkSubscribers = {};
  publicAPI.registerPropertyLinkForGC = (otherLink, type) => {
    if (!(type in model.propertyLinkSubscribers)) {
      model.propertyLinkSubscribers[type] = [];
    }
    model.propertyLinkSubscribers[type].push(otherLink);
  };
  publicAPI.gcPropertyLinks = type => {
    const subscribers = model.propertyLinkSubscribers[type] || [];
    while (subscribers.length) {
      subscribers.pop().unbind(publicAPI);
    }
  };
  model.propertyLinkMap = {};
  publicAPI.getPropertyLink = function (id) {
    let persistent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (model.propertyLinkMap[id]) {
      return model.propertyLinkMap[id];
    }
    let value = null;
    const links = [];
    let count = 0;
    let updateInProgress = false;
    function update(source) {
      let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (updateInProgress) {
        return null;
      }
      const needUpdate = [];
      let sourceLink = null;
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === source) {
          sourceLink = link;
        } else {
          needUpdate.push(link);
        }
      }
      if (!sourceLink) {
        return null;
      }
      const newValue = sourceLink.instance[`get${_capitalize(sourceLink.propertyName)}`]();
      if (!shallowEquals(newValue, value) || force) {
        value = newValue;
        updateInProgress = true;
        while (needUpdate.length) {
          const linkToUpdate = needUpdate.pop();
          linkToUpdate.instance.set({
            [linkToUpdate.propertyName]: value
          });
        }
        updateInProgress = false;
      }
      if (model.propertyLinkMap[id].persistent) {
        model.propertyLinkMap[id].value = newValue;
      }
      return newValue;
    }
    function unbind(instance, propertyName) {
      const indexToDelete = [];
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === instance && (link.propertyName === propertyName || propertyName === undefined)) {
          link.subscription.unsubscribe();
          indexToDelete.push(count);
        }
      }
      while (indexToDelete.length) {
        links.splice(indexToDelete.pop(), 1);
      }
    }
    function bind(instance, propertyName) {
      let updateMe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const subscription = instance.onModified(update);
      const other = links[0];
      links.push({
        instance,
        propertyName,
        subscription
      });
      if (updateMe) {
        if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== undefined) {
          instance.set({
            [propertyName]: model.propertyLinkMap[id].value
          });
        } else if (other) {
          update(other.instance, true);
        }
      }
      return {
        unsubscribe: () => unbind(instance, propertyName)
      };
    }
    function unsubscribe() {
      while (links.length) {
        links.pop().subscription.unsubscribe();
      }
    }
    const linkHandler = {
      bind,
      unbind,
      unsubscribe,
      persistent
    };
    model.propertyLinkMap[id] = linkHandler;
    return linkHandler;
  };

  // extract values
  function getProperties() {
    let groupName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
    const values = [];
    const id = model.proxyId;
    const propertyNames = listProxyProperties(groupName) || [];
    for (let i = 0; i < propertyNames.length; i++) {
      const name = propertyNames[i];
      const method = publicAPI[`get${_capitalize(name)}`];
      const value = method ? method() : undefined;
      const prop = {
        id,
        name,
        value
      };
      const children = getProperties(name);
      if (children.length) {
        prop.children = children;
      }
      values.push(prop);
    }
    return values;
  }
  publicAPI.listPropertyNames = () => getProperties().map(p => p.name);
  publicAPI.getPropertyByName = name => getProperties().find(p => p.name === name);
  publicAPI.getPropertyDomainByName = name => (propertyMap[name] || {}).domain;

  // ui section
  publicAPI.getProxySection = () => ({
    id: model.proxyId,
    name: model.proxyGroup,
    ui: model.ui,
    properties: getProperties()
  });

  // free resources
  publicAPI.delete = () => {
    const list = Object.keys(model.propertyLinkMap);
    let count = list.length;
    while (count--) {
      model.propertyLinkMap[list[count]].unsubscribe();
    }
    Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
    parentDelete();
  };

  // @todo fix infinite recursion due to active source
  publicAPI.getState = () => null;
  function registerLinks() {
    // Allow dynamic registration of links at the application level
    if (model.links) {
      for (let i = 0; i < model.links.length; i++) {
        const {
          link,
          property,
          persistent,
          updateOnBind,
          type
        } = model.links[i];
        if (type === 'application') {
          const sLink = model.proxyManager.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, 'application');
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  }
  setImmediateVTK(registerLinks);
}

// ----------------------------------------------------------------------------
// proxyPropertyMapping(publicAPI, model, map)
//
//   map = {
//      opacity: { modelKey: 'property', property: 'opacity' },
//   }
//
// Generated API:
//  Elevate set/get methods from internal object stored in the model to current one
// ----------------------------------------------------------------------------

function proxyPropertyMapping(publicAPI, model, map) {
  const parentDelete = publicAPI.delete;
  const subscriptions = [];
  const propertyNames = Object.keys(map);
  let count = propertyNames.length;
  while (count--) {
    const propertyName = propertyNames[count];
    const {
      modelKey,
      property,
      modified = true
    } = map[propertyName];
    const methodSrc = _capitalize(property);
    const methodDst = _capitalize(propertyName);
    publicAPI[`get${methodDst}`] = model[modelKey][`get${methodSrc}`];
    publicAPI[`set${methodDst}`] = model[modelKey][`set${methodSrc}`];
    if (modified) {
      subscriptions.push(model[modelKey].onModified(publicAPI.modified));
    }
  }
  publicAPI.delete = () => {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    parentDelete();
  };
}

// ----------------------------------------------------------------------------
// proxyPropertyState(publicAPI, model, state, defaults)
//
//   state = {
//     representation: {
//       'Surface with edges': { property: { edgeVisibility: true, representation: 2 } },
//       Surface: { property: { edgeVisibility: false, representation: 2 } },
//       Wireframe: { property: { edgeVisibility: false, representation: 1 } },
//       Points: { property: { edgeVisibility: false, representation: 0 } },
//     },
//   }
//
//   defaults = {
//      representation: 'Surface',
//   }
//
// Generated API
//   get / set Representation ( string ) => push state to various internal objects
// ----------------------------------------------------------------------------

function proxyPropertyState(publicAPI, model) {
  let state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let defaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  model.this = publicAPI;
  function applyState(map) {
    const modelKeys = Object.keys(map);
    let count = modelKeys.length;
    while (count--) {
      const modelKey = modelKeys[count];
      model[modelKey].set(map[modelKey]);
    }
  }
  const modelKeys = Object.keys(defaults);
  let count = modelKeys.length;
  while (count--) {
    // Add default
    const key = modelKeys[count];
    model[key] = defaults[key];

    // Add set method
    const mapping = state[key];
    publicAPI[`set${_capitalize(key)}`] = value => {
      if (value !== model[key]) {
        model[key] = value;
        const propValues = mapping[value];
        applyState(propValues);
        publicAPI.modified();
      }
    };
  }

  // Add getter
  if (modelKeys.length) {
    get(publicAPI, model, modelKeys);
  }
}

// ----------------------------------------------------------------------------
// From : https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
//
//
// Copyright (c) 2015, Facebook, Inc.
// All rights reserved.
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree. An additional grant
// of patent rights can be found in the PATENTS file in the same directory.
//
//
// Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
// complicated, thus this doc is long and (hopefully) detailed enough to answer
// your questions.
//
// If you need to react to the mouse wheel in a predictable way, this code is
// like your bestest friend.// hugs//
//
// As of today, there are 4 DOM event types you can listen to:
//
//   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
//   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
//   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
//   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
//
// So what to do?  The is the best:
//
//   normalizeWheel.getEventType();
//
// In your event callback, use this code to get sane interpretation of the
// deltas.  This code will return an object with properties:
//
//   spinX   -- normalized spin speed (use for zoom) - x plane
//   spinY   -- " - y plane
//   pixelX  -- normalized distance (to pixels) - x plane
//   pixelY  -- " - y plane
//
// Wheel values are provided by the browser assuming you are using the wheel to
// scroll a web page by a number of lines or pixels (or pages).  Values can vary
// significantly on different platforms and browsers, forgetting that you can
// scroll at different speeds.  Some devices (like trackpads) emit more events
// at smaller increments with fine granularity, and some emit massive jumps with
// linear speed or acceleration.
//
// This code does its best to normalize the deltas for you:
//
//   - spin is trying to normalize how far the wheel was spun (or trackpad
//     dragged).  This is super useful for zoom support where you want to
//     throw away the chunky scroll steps on the PC and make those equal to
//     the slow and smooth tiny steps on the Mac. Key data: This code tries to
//     resolve a single slow step on a wheel to 1.
//
//   - pixel is normalizing the desired scroll delta in pixel units.  You'll
//     get the crazy differences between browsers, but at least it'll be in
//     pixels!
//
//   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
//     should translate to positive value zooming IN, negative zooming OUT.
//     This matches the newer 'wheel' event.
//
// Why are there spinX, spinY (or pixels)?
//
//   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
//     with a mouse.  It results in side-scrolling in the browser by default.
//
//   - spinY is what you expect -- it's the classic axis of a mouse wheel.
//
//   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
//     probably is by browsers in conjunction with fancy 3D controllers .. but
//     you know.
//
// Implementation info:
//
// Examples of 'wheel' event if you scroll slowly (down) by one step with an
// average mouse:
//
//   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
//   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
//   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
//   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
//   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
//
// On the trackpad:
//
//   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
//   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
//
// On other/older browsers.. it's more complicated as there can be multiple and
// also missing delta values.
//
// The 'wheel' event is more standard:
//
// http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
//
// The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
// deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
// backward compatibility with older events.  Those other values help us
// better normalize spin speed.  Example of what the browsers provide:
//
//                          | event.wheelDelta | event.detail
//        ------------------+------------------+--------------
//          Safari v5/OS X  |       -120       |       0
//          Safari v5/Win7  |       -120       |       0
//         Chrome v17/OS X  |       -120       |       0
//         Chrome v17/Win7  |       -120       |       0
//                IE9/Win7  |       -120       |   undefined
//         Firefox v4/OS X  |     undefined    |       1
//         Firefox v4/Win7  |     undefined    |       3
//
// ----------------------------------------------------------------------------

// Reasonable defaults
const PIXEL_STEP = 10;
const LINE_HEIGHT = 40;
const PAGE_HEIGHT = 800;
function normalizeWheel(wheelEvent) {
  let sX = 0; // spinX
  let sY = 0; // spinY
  let pX = 0; // pixelX
  let pY = 0; // pixelY

  // Legacy
  if ('detail' in wheelEvent) {
    sY = wheelEvent.detail;
  }
  if ('wheelDelta' in wheelEvent) {
    sY = -wheelEvent.wheelDelta / 120;
  }
  if ('wheelDeltaY' in wheelEvent) {
    sY = -wheelEvent.wheelDeltaY / 120;
  }
  if ('wheelDeltaX' in wheelEvent) {
    sX = -wheelEvent.wheelDeltaX / 120;
  }

  // side scrolling on FF with DOMMouseScroll
  if ('axis' in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ('deltaY' in wheelEvent) {
    pY = wheelEvent.deltaY;
  }
  if ('deltaX' in wheelEvent) {
    pX = wheelEvent.deltaX;
  }
  if ((pX || pY) && wheelEvent.deltaMode) {
    if (wheelEvent.deltaMode === 1) {
      // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY || sX,
    pixelX: pX,
    pixelY: pY || pX
  };
}

// ----------------------------------------------------------------------------
// Default export
// ----------------------------------------------------------------------------

var macro = {
  algo,
  capitalize,
  chain,
  debounce,
  enumToString,
  event,
  EVENT_ABORT,
  formatBytesToProperUnit,
  formatNumbersWithThousandSeparator,
  get,
  getArray,
  getCurrentGlobalMTime,
  getStateArrayMapFunc,
  isVtkObject,
  keystore,
  measurePromiseExecution,
  moveToProtected,
  newInstance,
  newTypedArray,
  newTypedArrayFrom,
  normalizeWheel,
  obj,
  proxy,
  proxyPropertyMapping,
  proxyPropertyState,
  safeArrays,
  set,
  setArray,
  setGet,
  setGetArray,
  setImmediate: setImmediateVTK,
  setLoggerFunction,
  throttle,
  traverseInstanceTree,
  TYPED_ARRAYS,
  // deprecated todo remove on breaking API revision
  uncapitalize,
  VOID,
  vtkDebugMacro,
  vtkErrorMacro,
  vtkInfoMacro,
  vtkLogMacro,
  vtkOnceErrorMacro,
  vtkWarningMacro,
  // vtk.js internal use
  objectSetterMap
};

var macro$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  VOID: VOID,
  setLoggerFunction: setLoggerFunction,
  vtkLogMacro: vtkLogMacro,
  vtkInfoMacro: vtkInfoMacro,
  vtkDebugMacro: vtkDebugMacro,
  vtkErrorMacro: vtkErrorMacro,
  vtkWarningMacro: vtkWarningMacro,
  vtkOnceErrorMacro: vtkOnceErrorMacro,
  TYPED_ARRAYS: TYPED_ARRAYS,
  newTypedArray: newTypedArray,
  newTypedArrayFrom: newTypedArrayFrom,
  capitalize: capitalize,
  _capitalize: _capitalize,
  uncapitalize: uncapitalize,
  formatBytesToProperUnit: formatBytesToProperUnit,
  formatNumbersWithThousandSeparator: formatNumbersWithThousandSeparator,
  setImmediateVTK: setImmediateVTK,
  measurePromiseExecution: measurePromiseExecution,
  obj: obj,
  get: get,
  set: set,
  setGet: setGet,
  getArray: getArray,
  setArray: setArray,
  setGetArray: setGetArray,
  moveToProtected: moveToProtected,
  algo: algo,
  EVENT_ABORT: EVENT_ABORT,
  event: event,
  newInstance: newInstance,
  chain: chain,
  isVtkObject: isVtkObject,
  traverseInstanceTree: traverseInstanceTree,
  debounce: debounce,
  throttle: throttle,
  keystore: keystore,
  proxy: proxy,
  proxyPropertyMapping: proxyPropertyMapping,
  proxyPropertyState: proxyPropertyState,
  normalizeWheel: normalizeWheel,
  'default': macro
});




/***/ }),

/***/ 42852:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtk),
/* harmony export */   n: () => (/* binding */ vtkGlobal)
/* harmony export */ });
/* harmony import */ var globalthis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5744);
/* harmony import */ var globalthis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(globalthis__WEBPACK_IMPORTED_MODULE_0__);


const vtkGlobal = globalthis__WEBPACK_IMPORTED_MODULE_0___default()(); // returns native globalThis if compliant

const factoryMapping = {
  vtkObject: () => null
};
function vtk(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }
  if (obj.isA) {
    return obj;
  }
  if (!obj.vtkClass) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error('Invalid VTK object');
    }
    return null;
  }
  const constructor = factoryMapping[obj.vtkClass];
  if (!constructor) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error(`No vtk class found for Object of type ${obj.vtkClass}`);
    }
    return null;
  }

  // Shallow copy object
  const model = {
    ...obj
  };

  // Convert into vtkObject any nested key
  Object.keys(model).forEach(keyName => {
    if (model[keyName] && typeof model[keyName] === 'object' && model[keyName].vtkClass) {
      model[keyName] = vtk(model[keyName]);
    }
  });

  // Return the root
  const newInst = constructor(model);
  if (newInst && newInst.modified) {
    newInst.modified();
  }
  return newInst;
}
function register(vtkClassName, constructor) {
  factoryMapping[vtkClassName] = constructor;
}

// Nest register method under the vtk function
vtk.register = register;




/***/ }),

/***/ 45043:
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 24457:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARRAY_TYPE: () => (/* binding */ ARRAY_TYPE),
/* harmony export */   EPSILON: () => (/* binding */ EPSILON),
/* harmony export */   RANDOM: () => (/* binding */ RANDOM),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   setMatrixArrayType: () => (/* binding */ setMatrixArrayType),
/* harmony export */   toRadian: () => (/* binding */ toRadian)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ 3823:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Fd: () => (/* reexport */ common),
  w0: () => (/* reexport */ mat3),
  pB: () => (/* reexport */ mat4),
  Yu: () => (/* reexport */ quat),
  Zc: () => (/* reexport */ vec2_namespaceObject),
  eR: () => (/* reexport */ vec3),
  ln: () => (/* reexport */ vec4)
});

// UNUSED EXPORTS: mat2, mat2d, quat2

// NAMESPACE OBJECT: ../../../node_modules/gl-matrix/esm/vec2.js
var vec2_namespaceObject = {};
__webpack_require__.r(vec2_namespaceObject);
__webpack_require__.d(vec2_namespaceObject, {
  add: () => (add),
  angle: () => (angle),
  ceil: () => (ceil),
  clone: () => (clone),
  copy: () => (copy),
  create: () => (create),
  cross: () => (cross),
  dist: () => (dist),
  distance: () => (distance),
  div: () => (div),
  divide: () => (divide),
  dot: () => (dot),
  equals: () => (equals),
  exactEquals: () => (exactEquals),
  floor: () => (floor),
  forEach: () => (forEach),
  fromValues: () => (fromValues),
  inverse: () => (inverse),
  len: () => (len),
  length: () => (vec2_length),
  lerp: () => (lerp),
  max: () => (max),
  min: () => (min),
  mul: () => (mul),
  multiply: () => (multiply),
  negate: () => (negate),
  normalize: () => (normalize),
  random: () => (random),
  rotate: () => (rotate),
  round: () => (round),
  scale: () => (scale),
  scaleAndAdd: () => (scaleAndAdd),
  set: () => (set),
  sqrDist: () => (sqrDist),
  sqrLen: () => (sqrLen),
  squaredDistance: () => (squaredDistance),
  squaredLength: () => (squaredLength),
  str: () => (str),
  sub: () => (sub),
  subtract: () => (subtract),
  transformMat2: () => (transformMat2),
  transformMat2d: () => (transformMat2d),
  transformMat3: () => (transformMat3),
  transformMat4: () => (transformMat4),
  zero: () => (zero)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/common.js
var common = __webpack_require__(24457);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/mat2.js
var mat2 = __webpack_require__(98232);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/mat2d.js
var mat2d = __webpack_require__(72918);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/mat3.js
var mat3 = __webpack_require__(32591);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/mat4.js
var mat4 = __webpack_require__(28910);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/quat.js
var quat = __webpack_require__(50095);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/quat2.js
var quat2 = __webpack_require__(16953);
;// CONCATENATED MODULE: ../../../node_modules/gl-matrix/esm/vec2.js

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new common.ARRAY_TYPE(2);

  if (common.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new common.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new common.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function vec2_length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = common.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= common.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= common.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = vec2_length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/vec3.js
var vec3 = __webpack_require__(9175);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/vec4.js
var vec4 = __webpack_require__(15958);
;// CONCATENATED MODULE: ../../../node_modules/gl-matrix/esm/index.js












/***/ }),

/***/ 32591:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromMat2d: () => (/* binding */ fromMat2d),
/* harmony export */   fromMat4: () => (/* binding */ fromMat4),
/* harmony export */   fromQuat: () => (/* binding */ fromQuat),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   normalFromMat4: () => (/* binding */ normalFromMat4),
/* harmony export */   projection: () => (/* binding */ projection),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24457);

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ 50095:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   calculateW: () => (/* binding */ calculateW),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   conjugate: () => (/* binding */ conjugate),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   fromEuler: () => (/* binding */ fromEuler),
/* harmony export */   fromMat3: () => (/* binding */ fromMat3),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   getAngle: () => (/* binding */ getAngle),
/* harmony export */   getAxisAngle: () => (/* binding */ getAxisAngle),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   ln: () => (/* binding */ ln),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   rotationTo: () => (/* binding */ rotationTo),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setAxes: () => (/* binding */ setAxes),
/* harmony export */   setAxisAngle: () => (/* binding */ setAxisAngle),
/* harmony export */   slerp: () => (/* binding */ slerp),
/* harmony export */   sqlerp: () => (/* binding */ sqlerp),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24457);
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32591);
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9175);
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15958);




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.create();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.dot(a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__.len(tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ 15958:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24457);

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ 56037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(89738);

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(81327);

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(21897);

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(49329);

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(95967);

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(68415);

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(17663);

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ 10989:
/***/ ((module) => {

(function (factory) {
    if (true) {
        // Node/CommonJS
        module.exports = factory();
    } else { var glob; }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));


/***/ }),

/***/ 18642:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ascending)
/* harmony export */ });
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ 97315:
/***/ ((__unused_webpack___webpack_module__, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/array.js
var array = Array.prototype;

var array_slice = array.slice;
var map = array.map;

// EXTERNAL MODULE: ../../../node_modules/d3-array/src/bisect.js
var src_bisect = __webpack_require__(81068);
;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/constant.js
function constant_constant(x) {
  return () => x;
}

// EXTERNAL MODULE: ../../../node_modules/d3-array/src/extent.js
var src_extent = __webpack_require__(80130);
// EXTERNAL MODULE: ../../../node_modules/d3-array/src/identity.js
var src_identity = __webpack_require__(9792);
// EXTERNAL MODULE: ../../../node_modules/d3-array/src/nice.js
var src_nice = __webpack_require__(51963);
// EXTERNAL MODULE: ../../../node_modules/d3-array/src/ticks.js
var src_ticks = __webpack_require__(47598);
// EXTERNAL MODULE: ../../../node_modules/d3-array/src/threshold/sturges.js
var threshold_sturges = __webpack_require__(67049);
;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/bin.js









function bin() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);

    var i,
        n = data.length,
        x,
        step,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds, and nice the
    // default domain accordingly.
    if (!Array.isArray(tz)) {
      const max = x1, tn = +tz;
      if (domain === extent) [x0, x1] = nice(x0, x1, tn);
      tz = ticks(x0, x1, tn);

      // If the domain is aligned with the first tick (which it will by
      // default), then we can use quantization rather than bisection to bin
      // values, which is substantially faster.
      if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);

      // If the last threshold is coincident with the domain’s upper bound, the
      // last bin will be zero-width. If the default domain is used, and this
      // last threshold is coincident with the maximum input value, we can
      // extend the niced upper bound by one tick to ensure uniform bin widths;
      // otherwise, we simply remove the last threshold. Note that we don’t
      // coerce values or the domain to numbers, and thus must be careful to
      // compare order (>=) rather than strict equality (===)!
      if (tz[tz.length - 1] >= x1) {
        if (max >= x1 && domain === extent) {
          const step = tickIncrement(x0, x1, tn);
          if (isFinite(step)) {
            if (step > 0) {
              x1 = (Math.floor(x1 / step) + 1) * step;
            } else if (step < 0) {
              x1 = (Math.ceil(x1 * -step) + 1) / -step;
            }
          }
        } else {
          tz.pop();
        }
      }
    }

    // Remove any thresholds outside the domain.
    // Be careful not to mutate an array owned by the user!
    var m = tz.length, a = 0, b = m;
    while (tz[a] <= x0) ++a;
    while (tz[b - 1] > x1) --b;
    if (a || b < m) tz = tz.slice(a, b), m = b - a;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    if (isFinite(step)) {
      if (step > 0) {
        for (i = 0; i < n; ++i) {
          if ((x = values[i]) != null && x0 <= x && x <= x1) {
            bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
          }
        }
      } else if (step < 0) {
        for (i = 0; i < n; ++i) {
          if ((x = values[i]) != null && x0 <= x && x <= x1) {
            const j = Math.floor((x0 - x) * step);
            bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x = values[i]) != null && x0 <= x && x <= x1) {
          bins[bisect(tz, x, 0, m)].push(data[i]);
        }
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold;
  };

  return histogram;
}


/***/ }),

/***/ 81068:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports bisectRight, bisectLeft, bisectCenter */
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38153);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46503);




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(_ascending_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(_number_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ 38153:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ bisector)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33760);



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A;
    compare2 = (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === _ascending_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A || f === _descending_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}


/***/ }),

/***/ 19743:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports blur, blur2, blurImage */
function blur(values, r) {
  if (!((r = +r) >= 0)) throw new RangeError("invalid r");
  let length = values.length;
  if (!((length = Math.floor(length)) >= 0)) throw new RangeError("invalid length");
  if (!length || !r) return values;
  const blur = blurf(r);
  const temp = values.slice();
  blur(values, temp, 0, length, 1);
  blur(temp, values, 0, length, 1);
  blur(values, temp, 0, length, 1);
  return values;
}

const blur2 = Blur2(blurf);

const blurImage = Blur2(blurfImage);

function Blur2(blur) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let {data: values, width, height} = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || (!rx && !ry)) return data;
    const blurx = rx && blur(rx);
    const blury = ry && blur(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}

function blurh(blur, T, S, w, h) {
  for (let y = 0, n = w * h; y < n;) {
    blur(T, S, y, y += w, 1);
  }
}

function blurv(blur, T, S, w, h) {
  for (let x = 0, n = w * h; x < w; ++x) {
    blur(T, S, x, x + n, w);
  }
}

function blurfImage(radius) {
  const blur = blurf(radius);
  return (T, S, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur(T, S, start + 0, stop + 0, step);
    blur(T, S, start + 1, stop + 1, step);
    blur(T, S, start + 2, stop + 2, step);
    blur(T, S, start + 3, stop + 3, step);
  };
}

// Given a target array T, a source array S, sets each value T[i] to the average
// of {S[i - r], …, S[i], …, S[i + r]}, where r = ⌊radius⌋, start <= i < stop,
// for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between
// S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an
// integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted
// according to r - ⌊radius⌋.
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => { // stop must be aligned!
    if (!((stop -= step) >= start)) return; // inclusive stop
    let sum = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum += S[Math.min(stop, i + s0)];
      T[i] = (sum + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum -= S[Math.max(start, i - s0)];
    }
  };
}

// Like blurf, but optimized for integer radius.
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => { // stop must be aligned!
    if (!((stop -= step) >= start)) return; // inclusive stop
    let sum = radius * S[start];
    const s = step * radius;
    for (let i = start, j = start + s; i < j; i += step) {
      sum += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum += S[Math.min(stop, i + s)];
      T[i] = sum / w;
      sum -= S[Math.max(start, i - s)];
    }
  };
}


/***/ }),

/***/ 5739:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function count(values, valueof) {
  let count = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count;
      }
    }
  }
  return count;
}


/***/ }),

/***/ 67800:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function length(array) {
  return array.length | 0;
}

function empty(length) {
  return !(length > 0);
}

function arrayify(values) {
  return typeof values !== "object" || "length" in values ? values : Array.from(values);
}

function reducer(reduce) {
  return values => reduce(...values);
}

function cross(...values) {
  const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
  values = values.map(arrayify);
  const lengths = values.map(length);
  const j = values.length - 1;
  const index = new Array(j + 1).fill(0);
  const product = [];
  if (j < 0 || lengths.some(empty)) return product;
  while (true) {
    product.push(index.map((j, i) => values[i][j]));
    let i = j;
    while (++index[i] === lengths[i]) {
      if (i === 0) return reduce ? product.map(reduce) : product;
      index[i--] = 0;
    }
  }
}


/***/ }),

/***/ 11472:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function cumsum(values, valueof) {
  var sum = 0, index = 0;
  return Float64Array.from(values, valueof === undefined
    ? v => (sum += +v || 0)
    : v => (sum += +valueof(v, index++, values) || 0));
}

/***/ }),

/***/ 33760:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ descending)
/* harmony export */ });
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}


/***/ }),

/***/ 47803:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _variance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77097);


function deviation(values, valueof) {
  const v = variance(values, valueof);
  return v ? Math.sqrt(v) : v;
}


/***/ }),

/***/ 18949:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var internmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59043);


function difference(values, ...others) {
  values = new InternSet(values);
  for (const other of others) {
    for (const value of other) {
      values.delete(value);
    }
  }
  return values;
}


/***/ }),

/***/ 77050:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var internmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59043);


function disjoint(values, other) {
  const iterator = other[Symbol.iterator](), set = new InternSet();
  for (const v of values) {
    if (set.has(v)) return false;
    let value, done;
    while (({value, done} = iterator.next())) {
      if (done) break;
      if (Object.is(v, value)) return false;
      set.add(value);
    }
  }
  return true;
}


/***/ }),

/***/ 25475:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function every(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  let index = -1;
  for (const value of values) {
    if (!test(value, ++index, values)) {
      return false;
    }
  }
  return true;
}


/***/ }),

/***/ 80130:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}


/***/ }),

/***/ 95388:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function filter(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  const array = [];
  let index = -1;
  for (const value of values) {
    if (test(value, ++index, values)) {
      array.push(value);
    }
  }
  return array;
}


/***/ }),

/***/ 52827:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports Adder, fsum, fcumsum */
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ 40049:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);


function greatest(values, compare = ascending) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? ascending(value, maxValue) > 0
          : ascending(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}


/***/ }),

/***/ 82061:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);
/* harmony import */ var _maxIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64196);



function greatestIndex(values, compare = ascending) {
  if (compare.length === 1) return maxIndex(values, compare);
  let maxValue;
  let max = -1;
  let index = -1;
  for (const value of values) {
    ++index;
    if (max < 0
        ? compare(value, value) === 0
        : compare(value, maxValue) > 0) {
      maxValue = value;
      max = index;
    }
  }
  return max;
}


/***/ }),

/***/ 13723:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, groups, flatGroup, flatRollup, rollup, rollups, index, indexes */
/* harmony import */ var internmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59043);
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9792);



function group(values, ...keys) {
  return nest(values, identity, identity, keys);
}

function groups(values, ...keys) {
  return nest(values, Array.from, identity, keys);
}

function flatten(groups, keys) {
  for (let i = 1, n = keys.length; i < n; ++i) {
    groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
  }
  return groups;
}

function flatGroup(values, ...keys) {
  return flatten(groups(values, ...keys), keys);
}

function flatRollup(values, reduce, ...keys) {
  return flatten(rollups(values, reduce, ...keys), keys);
}

function rollup(values, reduce, ...keys) {
  return nest(values, identity, reduce, keys);
}

function rollups(values, reduce, ...keys) {
  return nest(values, Array.from, reduce, keys);
}

function index(values, ...keys) {
  return nest(values, identity, unique, keys);
}

function indexes(values, ...keys) {
  return nest(values, Array.from, unique, keys);
}

function unique(values) {
  if (values.length !== 1) throw new Error("duplicate key");
  return values[0];
}

function nest(values, map, reduce, keys) {
  return (function regroup(values, i) {
    if (i >= keys.length) return reduce(values);
    const groups = new InternMap();
    const keyof = keys[i++];
    let index = -1;
    for (const value of values) {
      const key = keyof(value, ++index, values);
      const group = groups.get(key);
      if (group) group.push(value);
      else groups.set(key, [value]);
    }
    for (const [key, values] of groups) {
      groups.set(key, regroup(values, i));
    }
    return map(groups);
  })(values, 0);
}


/***/ }),

/***/ 22543:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13723);
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60786);




function groupSort(values, reduce, key) {
  return (reduce.length !== 2
    ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)))
    : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending(ak, bk))))
    .map(([key]) => key);
}


/***/ }),

/***/ 9792:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function identity(x) {
  return x;
}


/***/ }),

/***/ 29351:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var internmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59043);


function intersection(values, ...others) {
  values = new InternSet(values);
  others = others.map(set);
  out: for (const value of values) {
    for (const other of others) {
      if (!other.has(value)) {
        values.delete(value);
        continue out;
      }
    }
  }
  return values;
}

function set(values) {
  return values instanceof InternSet ? values : new InternSet(values);
}


/***/ }),

/***/ 84201:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);


function least(values, compare = ascending) {
  let min;
  let defined = false;
  if (compare.length === 1) {
    let minValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? ascending(value, minValue) < 0
          : ascending(value, value) === 0) {
        min = element;
        minValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, min) < 0
          : compare(value, value) === 0) {
        min = value;
        defined = true;
      }
    }
  }
  return min;
}


/***/ }),

/***/ 55973:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);
/* harmony import */ var _minIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97982);



function leastIndex(values, compare = ascending) {
  if (compare.length === 1) return minIndex(values, compare);
  let minValue;
  let min = -1;
  let index = -1;
  for (const value of values) {
    ++index;
    if (min < 0
        ? compare(value, value) === 0
        : compare(value, minValue) < 0) {
      minValue = value;
      min = index;
    }
  }
  return min;
}


/***/ }),

/***/ 69010:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function map(values, mapper) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
  return Array.from(values, (value, index) => mapper(value, index, values));
}


/***/ }),

/***/ 36426:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ 64196:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}


/***/ }),

/***/ 61515:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function mean(values, valueof) {
  let count = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  }
  if (count) return sum / count;
}


/***/ }),

/***/ 26892:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, medianIndex */
/* harmony import */ var _quantile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49115);


function median(values, valueof) {
  return quantile(values, 0.5, valueof);
}

function medianIndex(values, valueof) {
  return quantileIndex(values, 0.5, valueof);
}


/***/ }),

/***/ 37412:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ 97982:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}


/***/ }),

/***/ 3581:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var internmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59043);


function mode(values, valueof) {
  const counts = new InternMap();
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count] of counts) {
    if (count > modeCount) {
      modeCount = count;
      modeValue = value;
    }
  }
  return modeValue;
}


/***/ }),

/***/ 51963:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _ticks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47598);


function nice(start, stop, count) {
  let prestep;
  while (true) {
    const step = tickIncrement(start, stop, count);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}


/***/ }),

/***/ 46503:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ number)
/* harmony export */ });
/* unused harmony export numbers */
function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ 35457:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, pair */
function pairs(values, pairof = pair) {
  const pairs = [];
  let previous;
  let first = false;
  for (const value of values) {
    if (first) pairs.push(pairof(previous, value));
    previous = value;
    first = true;
  }
  return pairs;
}

function pair(a, b) {
  return [a, b];
}


/***/ }),

/***/ 83254:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function permute(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ 49115:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, quantileSorted, quantileIndex */
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36426);
/* harmony import */ var _maxIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64196);
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57623);
/* harmony import */ var _minIndex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97982);
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43523);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46503);
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(60786);
/* harmony import */ var _greatest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(40049);









function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return min(values);
  if (p >= 1) return max(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),
      value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = number) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function quantileIndex(values, p, valueof = number) {
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, (_, i) => number(valueof(values[i], i, values)));
  if (p <= 0) return minIndex(numbers);
  if (p >= 1) return maxIndex(numbers);
  var numbers,
      index = Uint32Array.from(values, (_, i) => i),
      j = numbers.length - 1,
      i = Math.floor(j * p);
  quickselect(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));
  i = greatest(index.subarray(0, i + 1), (i) => numbers[i]);
  return i >= 0 ? i : -1;
}


/***/ }),

/***/ 43523:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60786);


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = Infinity, compare) {
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));

  if (!(left <= k && k <= right)) return array;

  compare = compare === undefined ? ascendingDefined : compareDefined(compare);

  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ 14029:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ 36820:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60786);



function rank(values, valueof = ascending) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  let V = Array.from(values);
  const R = new Float64Array(V.length);
  if (valueof.length !== 2) V = V.map(valueof), valueof = ascending;
  const compareIndex = (i, j) => valueof(V[i], V[j]);
  let k, r;
  values = Uint32Array.from(V, (_, i) => i);
  // Risky chaining due to Safari 14 https://github.com/d3/d3-array/issues/123
  values.sort(valueof === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
  values.forEach((j, i) => {
      const c = compareIndex(j, k === undefined ? j : k);
      if (c >= 0) {
        if (k === undefined || c > 0) k = j, r = i;
        R[j] = r;
      } else {
        R[j] = NaN;
      }
    });
  return R;
}


/***/ }),

/***/ 91804:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function reduce(values, reducer, value) {
  if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
  const iterator = values[Symbol.iterator]();
  let done, next, index = -1;
  if (arguments.length < 3) {
    ({done, value} = iterator.next());
    if (done) return;
    ++index;
  }
  while (({done, value: next} = iterator.next()), !done) {
    value = reducer(value, next, ++index, values);
  }
  return value;
}


/***/ }),

/***/ 23526:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function reverse(values) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  return Array.from(values).reverse();
}


/***/ }),

/***/ 65591:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _leastIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55973);


function scan(values, compare) {
  const index = leastIndex(values, compare);
  return index < 0 ? undefined : index;
}


/***/ }),

/***/ 96945:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export shuffler */
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (shuffler(Math.random));

function shuffler(random) {
  return function shuffle(array, i0 = 0, i1 = array.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }
    return array;
  };
}


/***/ }),

/***/ 39034:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function some(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  let index = -1;
  for (const value of values) {
    if (test(value, ++index, values)) {
      return true;
    }
  }
  return false;
}


/***/ }),

/***/ 60786:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, compareDefined, ascendingDefined */
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18642);
/* harmony import */ var _permute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83254);



function sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if ((f && f.length !== 2) || F.length > 1) {
    const index = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map(f => values.map(f));
      index.sort((i, j) => {
        for (const f of F) {
          const c = ascendingDefined(f[i], f[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return permute(values, index);
  }
  return values.sort(compareDefined(f));
}

function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}

function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}


/***/ }),

/***/ 59128:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _superset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47051);


function subset(values, other) {
  return superset(other, values);
}


/***/ }),

/***/ 66871:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}


/***/ }),

/***/ 47051:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function superset(values, other) {
  const iterator = values[Symbol.iterator](), set = new Set();
  for (const o of other) {
    const io = intern(o);
    if (set.has(io)) continue;
    let value, done;
    while (({value, done} = iterator.next())) {
      if (done) return false;
      const ivalue = intern(value);
      set.add(ivalue);
      if (Object.is(io, ivalue)) break;
    }
  }
  return true;
}

function intern(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}


/***/ }),

/***/ 48210:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5739);
/* harmony import */ var _quantile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49115);



function thresholdFreedmanDiaconis(values, min, max) {
  const c = count(values), d = quantile(values, 0.75) - quantile(values, 0.25);
  return c && d ? Math.ceil((max - min) / (2 * d * Math.pow(c, -1 / 3))) : 1;
}


/***/ }),

/***/ 95211:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5739);
/* harmony import */ var _deviation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47803);



function thresholdScott(values, min, max) {
  const c = count(values), d = deviation(values);
  return c && d ? Math.ceil((max - min) * Math.cbrt(c) / (3.49 * d)) : 1;
}


/***/ }),

/***/ 67049:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5739);


function thresholdSturges(values) {
  return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
}


/***/ }),

/***/ 47598:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ ticks),
/* harmony export */   lq: () => (/* binding */ tickIncrement),
/* harmony export */   sG: () => (/* binding */ tickStep)
/* harmony export */ });
const e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log10(step)),
      error = step / Math.pow(10, power),
      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}

function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
  }
  return ticks;
}

function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}

function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}


/***/ }),

/***/ 78603:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var internmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59043);


function union(...others) {
  const set = new InternSet();
  for (const other of others) {
    for (const o of other) {
      set.add(o);
    }
  }
  return set;
}


/***/ }),

/***/ 77097:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function variance(values, valueof) {
  let count = 0;
  let delta;
  let mean = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  }
  if (count > 1) return sum / (count - 1);
}


/***/ }),

/***/ 54603:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  yW: () => (/* reexport */ color),
  UB: () => (/* reexport */ cubehelix),
  aq: () => (/* reexport */ hcl),
  KI: () => (/* reexport */ hsl),
  Qh: () => (/* reexport */ rgb)
});

// UNUSED EXPORTS: gray, lab, lch

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/define.js
/* harmony default export */ function src_define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/color.js


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

src_define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

src_define(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

src_define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/math.js
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/lab.js




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

src_define(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

src_define(Hcl, hcl, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/cubehelix.js




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

src_define(Cubehelix, cubehelix, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/index.js





/***/ }),

/***/ 82043:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ genericArray)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1283);
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32204);



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ 43724:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   H: () => (/* binding */ basis)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ 96184:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43724);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__/* .basis */ .H)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ 2169:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ nogamma),
/* harmony export */   lG: () => (/* binding */ hue),
/* harmony export */   uN: () => (/* binding */ gamma)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80136);


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(isNaN(a) ? b : a);
}


/***/ }),

/***/ 80136:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ 34121:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export cubehelixLong */
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54603);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2169);



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .cubehelix */ .UB)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .cubehelix */ .UB)(end)).h),
          s = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.s, end.s),
          l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.l, end.l),
          opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__/* .hue */ .lG));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay);


/***/ }),

/***/ 2728:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}


/***/ }),

/***/ 61847:
/***/ (() => {

"use strict";
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}


/***/ }),

/***/ 69277:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export hclLong */
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54603);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2169);



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .hcl */ .aq)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .hcl */ .aq)(end)).h),
        c = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.c, end.c),
        l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.l, end.l),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__/* .hue */ .lG));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay);


/***/ }),

/***/ 26093:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export hslLong */
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54603);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2169);



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .hsl */ .KI)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .hsl */ .KI)(end)).h),
        s = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.s, end.s),
        l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.l, end.l),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay)(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__/* .hue */ .lG));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay);


/***/ }),

/***/ 73524:
/***/ ((__unused_webpack___webpack_module__, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2169);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}


/***/ }),

/***/ 86617:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54603);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2169);



function lab(start, end) {
  var l = color((start = colorLab(start)).l, (end = colorLab(end)).l),
      a = color(start.a, end.a),
      b = color(start.b, end.b),
      opacity = color(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ 20825:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ 32204:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   p: () => (/* binding */ isNumberArray)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ 34107:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1283);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}


/***/ }),

/***/ 84444:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1283);


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = value;
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ 83441:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports rgbBasis, rgbBasisClosed */
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54603);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43724);
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96184);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2169);





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_3__/* .gamma */ .uN)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .rgb */ .Qh)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .rgb */ .Qh)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay)(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .rgb */ .Qh)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);


/***/ }),

/***/ 66822:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}


/***/ }),

/***/ 33637:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20825);


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ 62911:
/***/ ((__unused_webpack___webpack_module__, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: interpolateTransformCss, interpolateTransformSvg

// EXTERNAL MODULE: ../../../node_modules/d3-interpolate/src/number.js
var number = __webpack_require__(20825);
;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/transform/parse.js


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/transform/index.js



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,number/* default */.A)(xa, xb)}, {i: i - 2, x: (0,number/* default */.A)(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,number/* default */.A)(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,number/* default */.A)(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,number/* default */.A)(xa, xb)}, {i: i - 2, x: (0,number/* default */.A)(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");


/***/ }),

/***/ 1283:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54603);
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83441);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82043);
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2728);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20825);
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34107);
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33637);
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(80136);
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(32204);










/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A
      : t === "string" ? ((c = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__/* .color */ .yW)(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay) : _string_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__/* .color */ .yW ? _rgb_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A
      : (0,_numberArray_js__WEBPACK_IMPORTED_MODULE_8__/* .isNumberArray */ .p)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_2__/* .genericArray */ .$
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A
      : _number_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(a, b);
}


/***/ }),

/***/ 85351:
/***/ (() => {

"use strict";
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ 95583:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  m4: () => (/* reexport */ linear)
});

// UNUSED EXPORTS: scaleBand, scaleDiverging, scaleDivergingLog, scaleDivergingPow, scaleDivergingSqrt, scaleDivergingSymlog, scaleIdentity, scaleImplicit, scaleLog, scaleOrdinal, scalePoint, scalePow, scaleQuantile, scaleQuantize, scaleRadial, scaleSequential, scaleSequentialLog, scaleSequentialPow, scaleSequentialQuantile, scaleSequentialSqrt, scaleSequentialSymlog, scaleSqrt, scaleSymlog, scaleThreshold, scaleTime, scaleUtc, tickFormat

// EXTERNAL MODULE: ../../../node_modules/d3-array/src/index.js + 2 modules
var src = __webpack_require__(75210);
;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/init.js
function init_initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function init_initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/ordinal.js



const implicit = Symbol("implicit");

function ordinal_ordinal() {
  var index = new InternMap(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    let i = index.get(d);
    if (i === undefined) {
      if (unknown !== implicit) return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new InternMap();
    for (const value of _) {
      if (index.has(value)) continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal_ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/band.js




function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// EXTERNAL MODULE: ../../../node_modules/d3-interpolate/src/index.js + 1 modules
var d3_interpolate_src = __webpack_require__(65481);
;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/number.js
function number_number(x) {
  return +x;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/continuous.js





var unit = [0, 1];

function continuous_identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constants(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,src/* bisect */.h1)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function continuous_copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function continuous_transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate_src/* interpolate */.GW,
      transform,
      untransform,
      unknown,
      clamp = continuous_identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== continuous_identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate_src/* interpolateNumber */.Dj)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number_number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate_src/* interpolateRound */.sH, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : continuous_identity, rescale()) : clamp !== continuous_identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous_continuous() {
  return continuous_transformer()(continuous_identity, continuous_identity);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatDecimal.js
/* harmony default export */ function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/exponent.js


/* harmony default export */ function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatGroup.js
/* harmony default export */ function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatSpecifier.js
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier_formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier_formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatTrim.js
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatPrefixAuto.js


var prefixExponent;

/* harmony default export */ function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatRounded.js


/* harmony default export */ function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatTypes.js




/* harmony default export */ const formatTypes = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/identity.js
/* harmony default export */ function src_identity(x) {
  return x;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/locale.js









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function locale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? src_identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? src_identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier_formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier_formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/defaultLocale.js


var defaultLocale_locale;
var defaultLocale_format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  defaultLocale_locale = locale(definition);
  defaultLocale_format = defaultLocale_locale.format;
  formatPrefix = defaultLocale_locale.formatPrefix;
  return defaultLocale_locale;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/precisionFixed.js


/* harmony default export */ function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/precisionPrefix.js


/* harmony default export */ function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/precisionRound.js


/* harmony default export */ function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/index.js







;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/tickFormat.js



function tickFormat(start, stop, count, specifier) {
  var step = (0,src/* tickStep */.sG)(start, stop, count),
      precision;
  specifier = formatSpecifier_formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return defaultLocale_format(specifier);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/linear.js





function linear_linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,src/* ticks */.Zc)(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,src/* tickIncrement */.lq)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous_continuous();

  scale.copy = function() {
    return continuous_copy(scale, linear());
  };

  init_initRange.apply(scale, arguments);

  return linear_linearish(scale);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/identity.js



function identity_identity(domain) {
  var unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity_identity(domain).unknown(unknown);
  };

  domain = arguments.length ? Array.from(domain, number) : [0, 1];

  return linearish(scale);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/nice.js
function nice_nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/log.js






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : x => Math.pow(base, x);
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), x => Math.log(x) / base);
}

function reflect(f) {
  return (x, k) => -f(-x, k);
}

function log_loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = count => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;

    if (r) ([u, v] = [v, u]);

    let i = logs(u);
    let j = logs(v);
    let k;
    let t;
    const n = count == null ? 10 : +count;
    let z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1; k < base; ++k) {
          t = i < 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1; k >= 1; --k) {
          t = i > 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };

  scale.tickFormat = (count, specifier) => {
    if (count == null) count = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count === Infinity) return specifier;
    const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return d => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = () => {
    return domain(nice(domain(), {
      floor: x => pows(Math.floor(logs(x))),
      ceil: x => pows(Math.ceil(logs(x)))
    }));
  };

  return scale;
}

function log() {
  const scale = log_loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/symlog.js




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlog_symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}

function symlog() {
  var scale = symlog_symlogish(transformer());

  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/pow.js




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function pow_powish(transform) {
  var scale = transform(identity, identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(identity, identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return linearish(scale);
}

function pow() {
  var scale = pow_powish(transformer());

  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/radial.js





function square(x) {
  return Math.sign(x) * x * x;
}

function unsquare(x) {
  return Math.sign(x) * Math.sqrt(Math.abs(x));
}

function radial() {
  var squared = continuous(),
      range = [0, 1],
      round = false,
      unknown;

  function scale(x) {
    var y = unsquare(squared(x));
    return isNaN(y) ? unknown : round ? Math.round(y) : y;
  }

  scale.invert = function(y) {
    return squared.invert(square(y));
  };

  scale.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale) : squared.domain();
  };

  scale.range = function(_) {
    return arguments.length ? (squared.range((range = Array.from(_, number)).map(square)), scale) : range.slice();
  };

  scale.rangeRound = function(_) {
    return scale.range(_).round(true);
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, scale) : round;
  };

  scale.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return radial(squared.domain(), range)
        .round(round)
        .clamp(squared.clamp())
        .unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/quantile.js



function quantile_quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile_quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/quantize.js




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(linearish(scale), arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/threshold.js



function threshold_threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold_threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/interval.js
const t0 = new Date, t1 = new Date;

function timeInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = (date) => {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = (date) => {
    const d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = (date, step) => {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = (start, stop, step) => {
    const range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    let previous;
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, (date, step) => {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? (d) => field(d) % step === 0
              : (d) => interval.count(0, d) % step === 0);
    };
  }

  return interval;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/millisecond.js


const millisecond = timeInterval(() => {
  // noop
}, (date, step) => {
  date.setTime(+date + step);
}, (start, end) => {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = (k) => {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k) * k);
  }, (date, step) => {
    date.setTime(+date + step * k);
  }, (start, end) => {
    return (end - start) / k;
  });
};

const milliseconds = millisecond.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/duration.js
const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/second.js



const second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step) => {
  date.setTime(+date + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});

const seconds = second.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/minute.js



const minute_timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getMinutes();
});

const timeMinutes = minute_timeMinute.range;

const minute_utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});

const utcMinutes = minute_utcMinute.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/hour.js



const hour_timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getHours();
});

const timeHours = hour_timeHour.range;

const hour_utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getUTCHours();
});

const utcHours = hour_utcHour.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/day.js



const day_timeDay = timeInterval(
  date => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  date => date.getDate() - 1
);

const timeDays = day_timeDay.range;

const day_utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});

const utcDays = day_utcDay.range;

const unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});

const unixDays = unixDay.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/week.js



function timeWeekday(i) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setDate(date.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);

const timeSundays = timeSunday.range;
const timeMondays = timeMonday.range;
const timeTuesdays = timeTuesday.range;
const timeWednesdays = timeWednesday.range;
const timeThursdays = timeThursday.range;
const timeFridays = timeFriday.range;
const timeSaturdays = timeSaturday.range;

function utcWeekday(i) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}

const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);

const utcSundays = utcSunday.range;
const utcMondays = utcMonday.range;
const utcTuesdays = utcTuesday.range;
const utcWednesdays = utcWednesday.range;
const utcThursdays = utcThursday.range;
const utcFridays = utcFriday.range;
const utcSaturdays = utcSaturday.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/month.js


const month_timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setMonth(date.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});

const timeMonths = month_timeMonth.range;

const month_utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCMonth(date.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});

const utcMonths = month_utcMonth.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/year.js


const year_timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setFullYear(date.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date) => {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year_timeYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

const timeYears = year_timeYear.range;

const year_utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
year_utcYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

const utcYears = year_utcYear.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/ticks.js











function ticker(year, month, week, day, hour, minute) {

  const tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = (0,src/* bisector */.yl)(([,, step]) => step).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every((0,src/* tickStep */.sG)(start / durationYear, stop / durationYear, count));
    if (i === 0) return millisecond.every(Math.max((0,src/* tickStep */.sG)(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }

  return [ticks, tickInterval];
}

const [ticks_utcTicks, ticks_utcTickInterval] = ticker(year_utcYear, month_utcMonth, utcSunday, unixDay, hour_utcHour, minute_utcMinute);
const [ticks_timeTicks, ticks_timeTickInterval] = ticker(year_timeYear, month_timeMonth, timeSunday, day_timeDay, hour_timeHour, minute_timeMinute);



;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/index.js




















;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/locale.js


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = day_utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = day_timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day_timeDay.count(year_timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(timeSunday.count(year_timeYear(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(timeThursday.count(year_timeYear(d), d) + (year_timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(timeMonday.count(year_timeYear(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + day_utcDay.count(year_utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(year_utcYear(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(year_utcYear(d), d) + (year_utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(year_utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/defaultLocale.js


var src_defaultLocale_locale;
var defaultLocale_timeFormat;
var timeParse;
var defaultLocale_utcFormat;
var utcParse;

defaultLocale_defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale_defaultLocale(definition) {
  src_defaultLocale_locale = formatLocale(definition);
  defaultLocale_timeFormat = src_defaultLocale_locale.format;
  timeParse = src_defaultLocale_locale.parse;
  defaultLocale_utcFormat = src_defaultLocale_locale.utcFormat;
  utcParse = src_defaultLocale_locale.utcParse;
  return src_defaultLocale_locale;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/isoFormat.js


var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : defaultLocale_utcFormat(isoSpecifier);

/* harmony default export */ const isoFormat = ((/* unused pure expression or super */ null && (formatIso)));

;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/isoParse.js



function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : utcParse(isoSpecifier);

/* harmony default export */ const isoParse = ((/* unused pure expression or super */ null && (parseIso)));

;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/index.js





;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/time.js






function date(t) {
  return new Date(t);
}

function time_number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function time_calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = continuous(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, time_number)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d, interval)) : scale;
  };

  scale.copy = function() {
    return copy(scale, time_calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return initRange.apply(time_calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/utcTime.js





function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/sequential.js








function sequential_transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = identity,
      clamp = false,
      unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }

  scale.range = range(interpolate);

  scale.rangeRound = range(interpolateRound);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function sequential_copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = linearish(sequential_transformer()(identity));

  scale.copy = function() {
    return sequential_copy(scale, sequential());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = loggish(sequential_transformer()).domain([1, 10]);

  scale.copy = function() {
    return sequential_copy(scale, sequentialLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = symlogish(sequential_transformer());

  scale.copy = function() {
    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = powish(sequential_transformer());

  scale.copy = function() {
    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/sequentialQuantile.js




function sequentialQuantile() {
  var domain = [],
      interpolator = identity;

  function scale(x) {
    if (x != null && !isNaN(x = +x)) return interpolator((bisect(domain, x, 1) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };

  scale.quantiles = function(n) {
    return Array.from({length: n + 1}, (_, i) => quantile(domain, i / n));
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return initInterpolator.apply(scale, arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/diverging.js









function diverging_transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      s = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }

  scale.range = range(interpolate);

  scale.rangeRound = range(interpolateRound);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
    return scale;
  };
}

function diverging() {
  var scale = linearish(diverging_transformer()(identity));

  scale.copy = function() {
    return copy(scale, diverging());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return copy(scale, divergingLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = symlogish(diverging_transformer());

  scale.copy = function() {
    return copy(scale, divergingSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = powish(diverging_transformer());

  scale.copy = function() {
    return copy(scale, divergingPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/index.js



































/***/ }),

/***/ 59043:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports InternMap, InternSet */
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (entries != null) for (const [key, value] of entries) this.set(key, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}

class InternSet extends Set {
  constructor(values, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (values != null) for (const value of values) this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
}

function intern_get({_intern, _key}, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}

function intern_set({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}

function intern_delete({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}

function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}


/***/ })

}]);